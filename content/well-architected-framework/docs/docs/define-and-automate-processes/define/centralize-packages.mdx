---
page_title: Centralize packages and dependencies
description: Centralize artifacts and dependencies with artifact managers to streamline builds, enhance security, and ensure consistent deployments across environments.
# START AUTO GENERATED METADATA, DO NOT EDIT
created_at: 2025-10-16T12:20:33-04:00
last_modified: 2026-02-04T15:37:21-06:00
# END AUTO GENERATED METADATA
---

# Centralize packages and dependencies

An artifact manager is a centralized repository that stores build artifacts, manages package dependencies, and acts as a proxy for package managers. Artifact managers streamline the build process by providing a single source for all dependencies, and increase security through centralized vulnerability scanning. 

Applications rely on dependencies such as external software libraries and packages, to provide functionality without requiring custom development. During the build process, dependency retrieval can become complex when multiple projects query different package sources simultaneously. Artifact managers solve this challenge by centralizing dependency storage and providing caching, versioning, and access control.

## Why centralize packages and dependencies

Centralizing artifacts and dependencies addresses the following operational, security, and reliability challenges:

**Remove build failures from external dependencies:** Projects that retrieve dependencies directly from public repositories fail when those repositories experience outages or when maintainers remove packages. Centralized artifact managers cache dependencies locally, ensuring builds continue even when external sources are unavailable.

**Reduce security vulnerabilities in dependencies:** Teams that pull dependencies directly from external sources without scanning introduce vulnerabilities and malicious packages into applications. Centralized artifact managers can scan all artifacts for Common Vulnerabilities and Exposures (CVEs) before distribution.

**Improve build performance and reliability:** Projects that repeatedly download the same dependencies waste time and bandwidth while creating points of failure during builds. Artifact managers cache common dependencies and serve them locally, significantly reducing build times and eliminating redundant network requests.

## Types of artifact management

Artifact management addresses two distinct needs:

**Package and dependency management:** 
- Package managers such as Artifactory, Nexus, or Azure Artifacts
- Stores application dependencies like npm packages, Maven JARs, and Go modules
- Acts as a proxy cache for public package registries
- Manages build artifacts from CI/CD pipelines

**Machine image management:**
- HCP Packer manages machine image artifacts
- Tracks and versions machine images like AMIs, Docker images, and VM templates
- Manages image promotion across environments like dev → staging → production
- Stores image metadata and software bill of materials (SBOM)

Most organizations need both types of artifact management working together.

## Use an artifact and package manager

An artifact manager, also called an artifact repository or package registry, can store artifacts from the build process and can also manage packages from package managers and act as a proxy for software being built in a developer or CI workflow. Sonatype Nexus Repository and JFrog Artifactory serve as examples of artifact managers that function as proxies for common package managers including npm, Go, Maven, and NuGet.

Manually configuring artifact managers across environments can lead to configuration drift and inconsistencies. You can [define artifact managers as code](/well-architected-framework/define-and-automate-processes/define/as-code/artifact-management) with Terraform to ensure consistent deployment across development, testing, and production environments.

### Streamline and simplify the build process

Artifact managers provide a single repository for all dependencies, which simplifies builds for developers and CI pipelines. The artifact manager downloads common dependencies once and caches them for future builds, which decreases total build time. Cached dependencies also create a local backup when the original source goes offline, which increases availability during builds.

### Facilitate environment promotions

Proper artifact versioning and tracking are important for artifact management. Immutable artifacts ensure the contents of the artifact match exactly what the software bill of materials (SBOM) and metadata specify. A centralized artifact repository with artifact metadata gives you a consistent rollback process with previously known working artifacts in the event of a failed deployment.

After you [build immutable containers](/well-architected-framework/define-and-automate-processes/define/immutable-infrastructure/containers) or [virtual machine images](/well-architected-framework/define-and-automate-processes/define/immutable-infrastructure/virtual-machines) with Packer, HCP Packer manages these machine image artifacts, like AMIs, Docker images, or VM templates, with channels and metadata tracking, including SBOM storage. By defining channels like "development", "staging", and "production", you can create gates that allow only tested and approved images through. Terraform can automatically retrieve the latest artifacts from these channels with HCP Packer data blocks and does not require you to manually update the configuration code.

When Packer builds an image with HCP Packer integration enabled, it automatically registers the artifact metadata with HCP Packer, creating the bucket and channel structure referenced in Terraform configurations.

The following example shows Terraform using HCP Packer channels to retrieve validated machine images:

<CodeBlockConfig filename="packer-channels.tf">

```hcl
terraform {
  required_providers {
    hcp = {
      source  = "hashicorp/hcp"
      version = "~> 0.100"
    }
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

# Retrieve latest production-approved image from HCP Packer
data "hcp_packer_artifact" "web_app" {
  bucket_name  = "web-application"
  channel_name = "production"
  platform     = "aws"
  region       = "us-east-1"
}

# Deploy instance using validated artifact
resource "aws_instance" "web" {
  ami           = data.hcp_packer_artifact.web_app.external_identifier
  instance_type = "t3.micro"

  tags = {
    Name         = "web-server"
    PackerBucket = data.hcp_packer_artifact.web_app.bucket_name
    BuildID      = data.hcp_packer_artifact.web_app.build_id
  }
}

# Output artifact metadata for audit trail
output "deployed_image_info" {
  value = {
    ami_id       = data.hcp_packer_artifact.web_app.external_identifier
    packer_build = data.hcp_packer_artifact.web_app.build_id
    created_at   = data.hcp_packer_artifact.web_app.created_at
  }
}
```

</CodeBlockConfig>

The Terraform configuration retrieves the latest production-approved image from HCP Packer without hard-coding AMI IDs. When your team promotes new images through channels, Terraform automatically uses the latest approved artifact on the next apply.

### Enhance security and governance

Artifact managers scan both internal and external artifacts for Common Vulnerabilities and Exposures (CVEs) before teams promote them or include them in builds.

Store access credentials to your artifact repository securely in a secrets management tool like Vault and limit write-access to CI tools and build processes. Vault can generate dynamic, short-lived credentials for your artifact repository and CI tools to significantly reduce the risk of credential compromise.

Vault's audit logging capabilities track access to artifact repository credentials, providing a comprehensive audit trail for compliance and security investigations. You can implement fine-grained access control policies that determine which teams, services, or individuals can publish or retrieve specific artifacts. Additionally, Vault can manage encryption keys for your artifact repository, enabling encryption at rest to protect your intellectual property and dependencies.

## HashiCorp resources

- Create [immutable containers](/well-architected-framework/define-and-automate-processes/define/immutable-infrastructure/containers) and [immutable virtual machines](/well-architected-framework/define-and-automate-processes/define/immutable-infrastructure/virtual-machines) as artifacts
- Manage [artifact repositories as code](/well-architected-framework/define-and-automate-processes/define/as-code/artifact-management) with Terraform providers
- Implement [automated testing](/well-architected-framework/define-and-automate-processes/automate/testing) for artifacts before storage

Get started with Packer, Terraform, and Vault:

- Get started with [HCP Packer tutorials](/packer/tutorials/hcp-get-started) and read the [HCP Packer documentation](/packer/docs/hcp) for image versioning and channels
- Get started with [Terraform tutorials](/terraform/tutorials) and read the [Terraform documentation](/terraform/docs) for infrastructure as code
- Get started with [Vault tutorials](/vault/tutorials) and read the [Vault documentation](/vault/docs) for secrets management

HCP Packer artifact management:

- Standardize [artifacts across multiple cloud providers](/packer/tutorials/cloud-production/multicloud) for consistent images
- Identify [compromised artifacts](/packer/tutorials/hcp/run-tasks-data-source-image-validation) using automated vulnerability scans
- Enforce [artifact compliance](/packer/tutorials/hcp/run-tasks-resource-image-validation) with policy validation before deployment
- Manage [image channels](/packer/tutorials/hcp-get-started/hcp-artifact-channels) for controlled promotion workflows

## Next steps

In this section of Define your processes, you learned how to centralize packages and dependencies using artifact managers to streamline builds, enhance security, and ensure consistent deployments. You explored how HCP Packer manages machine image artifacts with channels and metadata tracking, and how Terraform retrieves validated artifacts for infrastructure deployments. Centralize packages and dependencies is part of the [Define and automate processes pillar](/well-architected-framework/define-and-automate-processes).

Visit the following documents to continue building your automation strategy:

- Package [applications](/well-architected-framework/define-and-automate-processes/automate/packaging) to create container images and machine images for centralized storage
- Implement [CI/CD](/well-architected-framework/define-and-automate-processes/automate/cicd) to automate artifact builds and deployments
- Use [version control](/well-architected-framework/define-and-automate-processes/define/version-control) to track changes to artifact configurations
- Define [infrastructure as code](/well-architected-framework/define-and-automate-processes/define/as-code/infrastructure) to provision artifact managers consistently