---
page_title: 'Import: strings'
sidebar_current: docs-imports-strings
description: The strings import exposes common string operations.
layout: docs
# START AUTO GENERATED METADATA, DO NOT EDIT
created_at: 2025-09-17T13:35:48-05:00
last_modified: 2025-09-17T13:35:48-05:00
# END AUTO GENERATED METADATA
---

# Import: strings

The strings import exposes common string operations.

### strings.has_prefix(s, prefix)

Returns true if `s` starts with `prefix`.

```sentinel
strings.has_prefix("billing-id", "billing-") // true
strings.has_prefix("bill-id", "billing-")    // false
```

### strings.has_suffix(s, suffix)

Returns true if `s` ends with `suffix`.

```sentinel
strings.has_suffix("billing-id", "id")   // true
strings.has_suffix("billing-name", "id") // false
```

### strings.join(a, sep)

Joins a list with the string supplied by `sep`.

Multi-dimensional lists are supported, and non-string primitive
types will be converted to their string equivalents. Maps and
other complex non-list types are not supported.

```sentinel
strings.join(["foo", "bar", "baz"], ".")   // "foo.bar.baz"
strings.join([["foo", "bar"], "baz"], ".") // "foo.bar.baz"
strings.join(["a", 1, 1.01, true], ",")    // "a,1,1.01,true"
```

### strings.replace(s, old, new, times)

Replace the substring `old` with the substring `new` in the string `s`
by how many times the int parameter `times` is specified.
If the string `s` doesn't the substrings or if `times` is zero,
then the string is returned without any changes applied.

```
strings.replace("foobar", "foo", "bar") // "barbar"
strings.replace("foofoofoobar", "foo", "bar", 1) // "barfoofoobar"
strings.replace("foofoofoobar", "foo", "bar", 2) // "barbarfoobar"
strings.replace("foobar", "test", "bar") // "foobar"
strings.replace("foobar", "foo", "bar", 0) // "foobar"
```

### strings.trim(s, cutset)

Trim the leading and trailing characters in `cutset` from the string `s`.
If the string doesn't have the cutset, then the string is returned
unmodified.

```
strings.trim("iiifoobariii", "i")   // "foobar"
strings.trim("!1!bar foo!!1", "!1") // "bar foo"
```

### strings.trim_left(s, cutset)

Trim the leading characters contained in `cutset` from the string `s`.
If the string doesn't have the cutset, then the string is returned
unmodified.

```sentinel
strings.trim_left("aaaaaaaafoo", "a")   // "foo"
strings.trim_left("!!!bar!!!", "!")     // "bar!!!"
```

### strings.trim_right(s, cutset)

Trim the trailing characters contained in the `cutset` from the
string `s`. If the string doesn't have the cutset, then the string
is returned unmodified.

```sentinel
strings.trim_right("foo_bar...", ".")   // "foo_bar"
strings.trim_right("billing---","-")    // "billing"
```

### strings.trim_space(s)

Trim leading and trailing white space from the string `s`. If the
string doesn't have any surrounding white space, then the string is
returned unmodified.

```sentinel
strings.trim_space("      foo    ") // "foo"
strings.trim_space(" bar foo ")     // "bar foo"
```

### strings.trim_prefix(s, prefix)

Trim the prefix from the string `s`. If the string doesn't have the
prefix, then the string is returned unmodified.

```sentinel
strings.trim_prefix("billing-id", "billing-")   // "id"
strings.trim_prefix("bill-id",    "billing-")   // "bill-id"
```

### strings.trim_suffix(s, suffix)

Trim the suffix from the string `s`. If the string doesn't have the
suffix, then the string is returned unmodified.

```sentinel
strings.trim_suffix("billing-id", "-id")    // "billing"
strings.trim_suffix("bill-id",    "-foo")   // "bill-id"
```

### strings.to_lower(s)

Lowercase the string s.

```sentinel
strings.to_lower("FoO") // "foo"
```

### strings.to_upper(s)

Uppercase the string s.

```sentinel
strings.to_upper("FoO") // "FOO"
```

### strings.split(s, sep)

Split the string 's' via a substring 'sep'. If 'sep' is not contained in
's', the return value will be a single-element list containing only 's'.
As a special-case, if the input is already a list, it will be returned
as-is. This allows calling the split function when not knowing if the input
is already a list or not.

```sentinel
strings.split("foo,bar,baz", ",") // ["foo", "bar", "baz"]
strings.split(["foo", "bar", "baz"], ",") // ["foo", "bar", "baz"]
```
