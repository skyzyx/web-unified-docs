/******/ ;(() => {
	// webpackBootstrap
	/******/ var __webpack_modules__ = {
		/***/ 18541: /***/ (module) => {
			function webpackEmptyAsyncContext(req) {
				// Here Promise.resolve().then() is used instead of new Promise() to prevent
				// uncaught exception popping up in devtools
				return Promise.resolve().then(() => {
					var e = new Error("Cannot find module '" + req + "'")
					e.code = 'MODULE_NOT_FOUND'
					throw e
				})
			}
			webpackEmptyAsyncContext.keys = () => []
			webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext
			webpackEmptyAsyncContext.id = 18541
			module.exports = webpackEmptyAsyncContext

			/***/
		},

		/***/ 44914: /***/ function (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) {
			'use strict'

			var __createBinding =
				(this && this.__createBinding) ||
				(Object.create
					? function (o, m, k, k2) {
							if (k2 === undefined) k2 = k
							var desc = Object.getOwnPropertyDescriptor(m, k)
							if (
								!desc ||
								('get' in desc
									? !m.__esModule
									: desc.writable || desc.configurable)
							) {
								desc = {
									enumerable: true,
									get: function () {
										return m[k]
									},
								}
							}
							Object.defineProperty(o, k2, desc)
						}
					: function (o, m, k, k2) {
							if (k2 === undefined) k2 = k
							o[k2] = m[k]
						})
			var __setModuleDefault =
				(this && this.__setModuleDefault) ||
				(Object.create
					? function (o, v) {
							Object.defineProperty(o, 'default', {
								enumerable: true,
								value: v,
							})
						}
					: function (o, v) {
							o['default'] = v
						})
			var __importStar =
				(this && this.__importStar) ||
				function (mod) {
					if (mod && mod.__esModule) return mod
					var result = {}
					if (mod != null)
						for (var k in mod)
							if (
								k !== 'default' &&
								Object.prototype.hasOwnProperty.call(mod, k)
							)
								__createBinding(result, mod, k)
					__setModuleDefault(result, mod)
					return result
				}
			Object.defineProperty(exports, '__esModule', { value: true })
			exports.issue = exports.issueCommand = void 0
			const os = __importStar(__nccwpck_require__(70857))
			const utils_1 = __nccwpck_require__(30302)
			/**
			 * Commands
			 *
			 * Command Format:
			 *   ::name key=value,key=value::message
			 *
			 * Examples:
			 *   ::warning::This is the message
			 *   ::set-env name=MY_VAR::some value
			 */
			function issueCommand(command, properties, message) {
				const cmd = new Command(command, properties, message)
				process.stdout.write(cmd.toString() + os.EOL)
			}
			exports.issueCommand = issueCommand
			function issue(name, message = '') {
				issueCommand(name, {}, message)
			}
			exports.issue = issue
			const CMD_STRING = '::'
			class Command {
				constructor(command, properties, message) {
					if (!command) {
						command = 'missing.command'
					}
					this.command = command
					this.properties = properties
					this.message = message
				}
				toString() {
					let cmdStr = CMD_STRING + this.command
					if (this.properties && Object.keys(this.properties).length > 0) {
						cmdStr += ' '
						let first = true
						for (const key in this.properties) {
							if (this.properties.hasOwnProperty(key)) {
								const val = this.properties[key]
								if (val) {
									if (first) {
										first = false
									} else {
										cmdStr += ','
									}
									cmdStr += `${key}=${escapeProperty(val)}`
								}
							}
						}
					}
					cmdStr += `${CMD_STRING}${escapeData(this.message)}`
					return cmdStr
				}
			}
			function escapeData(s) {
				return (0, utils_1.toCommandValue)(s)
					.replace(/%/g, '%25')
					.replace(/\r/g, '%0D')
					.replace(/\n/g, '%0A')
			}
			function escapeProperty(s) {
				return (0, utils_1.toCommandValue)(s)
					.replace(/%/g, '%25')
					.replace(/\r/g, '%0D')
					.replace(/\n/g, '%0A')
					.replace(/:/g, '%3A')
					.replace(/,/g, '%2C')
			}
			//# sourceMappingURL=command.js.map

			/***/
		},

		/***/ 37484: /***/ function (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) {
			'use strict'

			var __createBinding =
				(this && this.__createBinding) ||
				(Object.create
					? function (o, m, k, k2) {
							if (k2 === undefined) k2 = k
							var desc = Object.getOwnPropertyDescriptor(m, k)
							if (
								!desc ||
								('get' in desc
									? !m.__esModule
									: desc.writable || desc.configurable)
							) {
								desc = {
									enumerable: true,
									get: function () {
										return m[k]
									},
								}
							}
							Object.defineProperty(o, k2, desc)
						}
					: function (o, m, k, k2) {
							if (k2 === undefined) k2 = k
							o[k2] = m[k]
						})
			var __setModuleDefault =
				(this && this.__setModuleDefault) ||
				(Object.create
					? function (o, v) {
							Object.defineProperty(o, 'default', {
								enumerable: true,
								value: v,
							})
						}
					: function (o, v) {
							o['default'] = v
						})
			var __importStar =
				(this && this.__importStar) ||
				function (mod) {
					if (mod && mod.__esModule) return mod
					var result = {}
					if (mod != null)
						for (var k in mod)
							if (
								k !== 'default' &&
								Object.prototype.hasOwnProperty.call(mod, k)
							)
								__createBinding(result, mod, k)
					__setModuleDefault(result, mod)
					return result
				}
			var __awaiter =
				(this && this.__awaiter) ||
				function (thisArg, _arguments, P, generator) {
					function adopt(value) {
						return value instanceof P
							? value
							: new P(function (resolve) {
									resolve(value)
								})
					}
					return new (P || (P = Promise))(function (resolve, reject) {
						function fulfilled(value) {
							try {
								step(generator.next(value))
							} catch (e) {
								reject(e)
							}
						}
						function rejected(value) {
							try {
								step(generator['throw'](value))
							} catch (e) {
								reject(e)
							}
						}
						function step(result) {
							result.done
								? resolve(result.value)
								: adopt(result.value).then(fulfilled, rejected)
						}
						step(
							(generator = generator.apply(thisArg, _arguments || [])).next(),
						)
					})
				}
			Object.defineProperty(exports, '__esModule', { value: true })
			exports.platform =
				exports.toPlatformPath =
				exports.toWin32Path =
				exports.toPosixPath =
				exports.markdownSummary =
				exports.summary =
				exports.getIDToken =
				exports.getState =
				exports.saveState =
				exports.group =
				exports.endGroup =
				exports.startGroup =
				exports.info =
				exports.notice =
				exports.warning =
				exports.error =
				exports.debug =
				exports.isDebug =
				exports.setFailed =
				exports.setCommandEcho =
				exports.setOutput =
				exports.getBooleanInput =
				exports.getMultilineInput =
				exports.getInput =
				exports.addPath =
				exports.setSecret =
				exports.exportVariable =
				exports.ExitCode =
					void 0
			const command_1 = __nccwpck_require__(44914)
			const file_command_1 = __nccwpck_require__(24753)
			const utils_1 = __nccwpck_require__(30302)
			const os = __importStar(__nccwpck_require__(70857))
			const path = __importStar(__nccwpck_require__(16928))
			const oidc_utils_1 = __nccwpck_require__(35306)
			/**
			 * The code to exit an action
			 */
			var ExitCode
			;(function (ExitCode) {
				/**
				 * A code indicating that the action was successful
				 */
				ExitCode[(ExitCode['Success'] = 0)] = 'Success'
				/**
				 * A code indicating that the action was a failure
				 */
				ExitCode[(ExitCode['Failure'] = 1)] = 'Failure'
			})(ExitCode || (exports.ExitCode = ExitCode = {}))
			//-----------------------------------------------------------------------
			// Variables
			//-----------------------------------------------------------------------
			/**
			 * Sets env variable for this action and future actions in the job
			 * @param name the name of the variable to set
			 * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
			 */
			// eslint-disable-next-line @typescript-eslint/no-explicit-any
			function exportVariable(name, val) {
				const convertedVal = (0, utils_1.toCommandValue)(val)
				process.env[name] = convertedVal
				const filePath = process.env['GITHUB_ENV'] || ''
				if (filePath) {
					return (0, file_command_1.issueFileCommand)(
						'ENV',
						(0, file_command_1.prepareKeyValueMessage)(name, val),
					)
				}
				;(0, command_1.issueCommand)('set-env', { name }, convertedVal)
			}
			exports.exportVariable = exportVariable
			/**
			 * Registers a secret which will get masked from logs
			 * @param secret value of the secret
			 */
			function setSecret(secret) {
				;(0, command_1.issueCommand)('add-mask', {}, secret)
			}
			exports.setSecret = setSecret
			/**
			 * Prepends inputPath to the PATH (for this action and future actions)
			 * @param inputPath
			 */
			function addPath(inputPath) {
				const filePath = process.env['GITHUB_PATH'] || ''
				if (filePath) {
					;(0, file_command_1.issueFileCommand)('PATH', inputPath)
				} else {
					;(0, command_1.issueCommand)('add-path', {}, inputPath)
				}
				process.env['PATH'] =
					`${inputPath}${path.delimiter}${process.env['PATH']}`
			}
			exports.addPath = addPath
			/**
			 * Gets the value of an input.
			 * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
			 * Returns an empty string if the value is not defined.
			 *
			 * @param     name     name of the input to get
			 * @param     options  optional. See InputOptions.
			 * @returns   string
			 */
			function getInput(name, options) {
				const val =
					process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || ''
				if (options && options.required && !val) {
					throw new Error(`Input required and not supplied: ${name}`)
				}
				if (options && options.trimWhitespace === false) {
					return val
				}
				return val.trim()
			}
			exports.getInput = getInput
			/**
			 * Gets the values of an multiline input.  Each value is also trimmed.
			 *
			 * @param     name     name of the input to get
			 * @param     options  optional. See InputOptions.
			 * @returns   string[]
			 *
			 */
			function getMultilineInput(name, options) {
				const inputs = getInput(name, options)
					.split('\n')
					.filter((x) => x !== '')
				if (options && options.trimWhitespace === false) {
					return inputs
				}
				return inputs.map((input) => input.trim())
			}
			exports.getMultilineInput = getMultilineInput
			/**
			 * Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
			 * Support boolean input list: `true | True | TRUE | false | False | FALSE` .
			 * The return value is also in boolean type.
			 * ref: https://yaml.org/spec/1.2/spec.html#id2804923
			 *
			 * @param     name     name of the input to get
			 * @param     options  optional. See InputOptions.
			 * @returns   boolean
			 */
			function getBooleanInput(name, options) {
				const trueValue = ['true', 'True', 'TRUE']
				const falseValue = ['false', 'False', 'FALSE']
				const val = getInput(name, options)
				if (trueValue.includes(val)) return true
				if (falseValue.includes(val)) return false
				throw new TypeError(
					`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\n` +
						`Support boolean input list: \`true | True | TRUE | false | False | FALSE\``,
				)
			}
			exports.getBooleanInput = getBooleanInput
			/**
			 * Sets the value of an output.
			 *
			 * @param     name     name of the output to set
			 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
			 */
			// eslint-disable-next-line @typescript-eslint/no-explicit-any
			function setOutput(name, value) {
				const filePath = process.env['GITHUB_OUTPUT'] || ''
				if (filePath) {
					return (0, file_command_1.issueFileCommand)(
						'OUTPUT',
						(0, file_command_1.prepareKeyValueMessage)(name, value),
					)
				}
				process.stdout.write(os.EOL)
				;(0, command_1.issueCommand)(
					'set-output',
					{ name },
					(0, utils_1.toCommandValue)(value),
				)
			}
			exports.setOutput = setOutput
			/**
			 * Enables or disables the echoing of commands into stdout for the rest of the step.
			 * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
			 *
			 */
			function setCommandEcho(enabled) {
				;(0, command_1.issue)('echo', enabled ? 'on' : 'off')
			}
			exports.setCommandEcho = setCommandEcho
			//-----------------------------------------------------------------------
			// Results
			//-----------------------------------------------------------------------
			/**
			 * Sets the action status to failed.
			 * When the action exits it will be with an exit code of 1
			 * @param message add error issue message
			 */
			function setFailed(message) {
				process.exitCode = ExitCode.Failure
				error(message)
			}
			exports.setFailed = setFailed
			//-----------------------------------------------------------------------
			// Logging Commands
			//-----------------------------------------------------------------------
			/**
			 * Gets whether Actions Step Debug is on or not
			 */
			function isDebug() {
				return process.env['RUNNER_DEBUG'] === '1'
			}
			exports.isDebug = isDebug
			/**
			 * Writes debug message to user log
			 * @param message debug message
			 */
			function debug(message) {
				;(0, command_1.issueCommand)('debug', {}, message)
			}
			exports.debug = debug
			/**
			 * Adds an error issue
			 * @param message error issue message. Errors will be converted to string via toString()
			 * @param properties optional properties to add to the annotation.
			 */
			function error(message, properties = {}) {
				;(0, command_1.issueCommand)(
					'error',
					(0, utils_1.toCommandProperties)(properties),
					message instanceof Error ? message.toString() : message,
				)
			}
			exports.error = error
			/**
			 * Adds a warning issue
			 * @param message warning issue message. Errors will be converted to string via toString()
			 * @param properties optional properties to add to the annotation.
			 */
			function warning(message, properties = {}) {
				;(0, command_1.issueCommand)(
					'warning',
					(0, utils_1.toCommandProperties)(properties),
					message instanceof Error ? message.toString() : message,
				)
			}
			exports.warning = warning
			/**
			 * Adds a notice issue
			 * @param message notice issue message. Errors will be converted to string via toString()
			 * @param properties optional properties to add to the annotation.
			 */
			function notice(message, properties = {}) {
				;(0, command_1.issueCommand)(
					'notice',
					(0, utils_1.toCommandProperties)(properties),
					message instanceof Error ? message.toString() : message,
				)
			}
			exports.notice = notice
			/**
			 * Writes info to log with console.log.
			 * @param message info message
			 */
			function info(message) {
				process.stdout.write(message + os.EOL)
			}
			exports.info = info
			/**
			 * Begin an output group.
			 *
			 * Output until the next `groupEnd` will be foldable in this group
			 *
			 * @param name The name of the output group
			 */
			function startGroup(name) {
				;(0, command_1.issue)('group', name)
			}
			exports.startGroup = startGroup
			/**
			 * End an output group.
			 */
			function endGroup() {
				;(0, command_1.issue)('endgroup')
			}
			exports.endGroup = endGroup
			/**
			 * Wrap an asynchronous function call in a group.
			 *
			 * Returns the same type as the function itself.
			 *
			 * @param name The name of the group
			 * @param fn The function to wrap in the group
			 */
			function group(name, fn) {
				return __awaiter(this, void 0, void 0, function* () {
					startGroup(name)
					let result
					try {
						result = yield fn()
					} finally {
						endGroup()
					}
					return result
				})
			}
			exports.group = group
			//-----------------------------------------------------------------------
			// Wrapper action state
			//-----------------------------------------------------------------------
			/**
			 * Saves state for current action, the state can only be retrieved by this action's post job execution.
			 *
			 * @param     name     name of the state to store
			 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
			 */
			// eslint-disable-next-line @typescript-eslint/no-explicit-any
			function saveState(name, value) {
				const filePath = process.env['GITHUB_STATE'] || ''
				if (filePath) {
					return (0, file_command_1.issueFileCommand)(
						'STATE',
						(0, file_command_1.prepareKeyValueMessage)(name, value),
					)
				}
				;(0, command_1.issueCommand)(
					'save-state',
					{ name },
					(0, utils_1.toCommandValue)(value),
				)
			}
			exports.saveState = saveState
			/**
			 * Gets the value of an state set by this action's main execution.
			 *
			 * @param     name     name of the state to get
			 * @returns   string
			 */
			function getState(name) {
				return process.env[`STATE_${name}`] || ''
			}
			exports.getState = getState
			function getIDToken(aud) {
				return __awaiter(this, void 0, void 0, function* () {
					return yield oidc_utils_1.OidcClient.getIDToken(aud)
				})
			}
			exports.getIDToken = getIDToken
			/**
			 * Summary exports
			 */
			var summary_1 = __nccwpck_require__(71847)
			Object.defineProperty(exports, 'summary', {
				enumerable: true,
				get: function () {
					return summary_1.summary
				},
			})
			/**
			 * @deprecated use core.summary
			 */
			var summary_2 = __nccwpck_require__(71847)
			Object.defineProperty(exports, 'markdownSummary', {
				enumerable: true,
				get: function () {
					return summary_2.markdownSummary
				},
			})
			/**
			 * Path exports
			 */
			var path_utils_1 = __nccwpck_require__(31976)
			Object.defineProperty(exports, 'toPosixPath', {
				enumerable: true,
				get: function () {
					return path_utils_1.toPosixPath
				},
			})
			Object.defineProperty(exports, 'toWin32Path', {
				enumerable: true,
				get: function () {
					return path_utils_1.toWin32Path
				},
			})
			Object.defineProperty(exports, 'toPlatformPath', {
				enumerable: true,
				get: function () {
					return path_utils_1.toPlatformPath
				},
			})
			/**
			 * Platform utilities exports
			 */
			exports.platform = __importStar(__nccwpck_require__(18968))
			//# sourceMappingURL=core.js.map

			/***/
		},

		/***/ 24753: /***/ function (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) {
			'use strict'

			// For internal use, subject to change.
			var __createBinding =
				(this && this.__createBinding) ||
				(Object.create
					? function (o, m, k, k2) {
							if (k2 === undefined) k2 = k
							var desc = Object.getOwnPropertyDescriptor(m, k)
							if (
								!desc ||
								('get' in desc
									? !m.__esModule
									: desc.writable || desc.configurable)
							) {
								desc = {
									enumerable: true,
									get: function () {
										return m[k]
									},
								}
							}
							Object.defineProperty(o, k2, desc)
						}
					: function (o, m, k, k2) {
							if (k2 === undefined) k2 = k
							o[k2] = m[k]
						})
			var __setModuleDefault =
				(this && this.__setModuleDefault) ||
				(Object.create
					? function (o, v) {
							Object.defineProperty(o, 'default', {
								enumerable: true,
								value: v,
							})
						}
					: function (o, v) {
							o['default'] = v
						})
			var __importStar =
				(this && this.__importStar) ||
				function (mod) {
					if (mod && mod.__esModule) return mod
					var result = {}
					if (mod != null)
						for (var k in mod)
							if (
								k !== 'default' &&
								Object.prototype.hasOwnProperty.call(mod, k)
							)
								__createBinding(result, mod, k)
					__setModuleDefault(result, mod)
					return result
				}
			Object.defineProperty(exports, '__esModule', { value: true })
			exports.prepareKeyValueMessage = exports.issueFileCommand = void 0
			// We use any as a valid input type
			/* eslint-disable @typescript-eslint/no-explicit-any */
			const crypto = __importStar(__nccwpck_require__(76982))
			const fs = __importStar(__nccwpck_require__(79896))
			const os = __importStar(__nccwpck_require__(70857))
			const utils_1 = __nccwpck_require__(30302)
			function issueFileCommand(command, message) {
				const filePath = process.env[`GITHUB_${command}`]
				if (!filePath) {
					throw new Error(
						`Unable to find environment variable for file command ${command}`,
					)
				}
				if (!fs.existsSync(filePath)) {
					throw new Error(`Missing file at path: ${filePath}`)
				}
				fs.appendFileSync(
					filePath,
					`${(0, utils_1.toCommandValue)(message)}${os.EOL}`,
					{
						encoding: 'utf8',
					},
				)
			}
			exports.issueFileCommand = issueFileCommand
			function prepareKeyValueMessage(key, value) {
				const delimiter = `ghadelimiter_${crypto.randomUUID()}`
				const convertedValue = (0, utils_1.toCommandValue)(value)
				// These should realistically never happen, but just in case someone finds a
				// way to exploit uuid generation let's not allow keys or values that contain
				// the delimiter.
				if (key.includes(delimiter)) {
					throw new Error(
						`Unexpected input: name should not contain the delimiter "${delimiter}"`,
					)
				}
				if (convertedValue.includes(delimiter)) {
					throw new Error(
						`Unexpected input: value should not contain the delimiter "${delimiter}"`,
					)
				}
				return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`
			}
			exports.prepareKeyValueMessage = prepareKeyValueMessage
			//# sourceMappingURL=file-command.js.map

			/***/
		},

		/***/ 35306: /***/ function (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) {
			'use strict'

			var __awaiter =
				(this && this.__awaiter) ||
				function (thisArg, _arguments, P, generator) {
					function adopt(value) {
						return value instanceof P
							? value
							: new P(function (resolve) {
									resolve(value)
								})
					}
					return new (P || (P = Promise))(function (resolve, reject) {
						function fulfilled(value) {
							try {
								step(generator.next(value))
							} catch (e) {
								reject(e)
							}
						}
						function rejected(value) {
							try {
								step(generator['throw'](value))
							} catch (e) {
								reject(e)
							}
						}
						function step(result) {
							result.done
								? resolve(result.value)
								: adopt(result.value).then(fulfilled, rejected)
						}
						step(
							(generator = generator.apply(thisArg, _arguments || [])).next(),
						)
					})
				}
			Object.defineProperty(exports, '__esModule', { value: true })
			exports.OidcClient = void 0
			const http_client_1 = __nccwpck_require__(54844)
			const auth_1 = __nccwpck_require__(44552)
			const core_1 = __nccwpck_require__(37484)
			class OidcClient {
				static createHttpClient(allowRetry = true, maxRetry = 10) {
					const requestOptions = {
						allowRetries: allowRetry,
						maxRetries: maxRetry,
					}
					return new http_client_1.HttpClient(
						'actions/oidc-client',
						[new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())],
						requestOptions,
					)
				}
				static getRequestToken() {
					const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN']
					if (!token) {
						throw new Error(
							'Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable',
						)
					}
					return token
				}
				static getIDTokenUrl() {
					const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL']
					if (!runtimeUrl) {
						throw new Error(
							'Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable',
						)
					}
					return runtimeUrl
				}
				static getCall(id_token_url) {
					var _a
					return __awaiter(this, void 0, void 0, function* () {
						const httpclient = OidcClient.createHttpClient()
						const res = yield httpclient
							.getJson(id_token_url)
							.catch((error) => {
								throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error.statusCode}\n 
        Error Message: ${error.message}`)
							})
						const id_token =
							(_a = res.result) === null || _a === void 0 ? void 0 : _a.value
						if (!id_token) {
							throw new Error('Response json body do not have ID Token field')
						}
						return id_token
					})
				}
				static getIDToken(audience) {
					return __awaiter(this, void 0, void 0, function* () {
						try {
							// New ID Token is requested from action service
							let id_token_url = OidcClient.getIDTokenUrl()
							if (audience) {
								const encodedAudience = encodeURIComponent(audience)
								id_token_url = `${id_token_url}&audience=${encodedAudience}`
							}
							;(0, core_1.debug)(`ID token url is ${id_token_url}`)
							const id_token = yield OidcClient.getCall(id_token_url)
							;(0, core_1.setSecret)(id_token)
							return id_token
						} catch (error) {
							throw new Error(`Error message: ${error.message}`)
						}
					})
				}
			}
			exports.OidcClient = OidcClient
			//# sourceMappingURL=oidc-utils.js.map

			/***/
		},

		/***/ 31976: /***/ function (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) {
			'use strict'

			var __createBinding =
				(this && this.__createBinding) ||
				(Object.create
					? function (o, m, k, k2) {
							if (k2 === undefined) k2 = k
							var desc = Object.getOwnPropertyDescriptor(m, k)
							if (
								!desc ||
								('get' in desc
									? !m.__esModule
									: desc.writable || desc.configurable)
							) {
								desc = {
									enumerable: true,
									get: function () {
										return m[k]
									},
								}
							}
							Object.defineProperty(o, k2, desc)
						}
					: function (o, m, k, k2) {
							if (k2 === undefined) k2 = k
							o[k2] = m[k]
						})
			var __setModuleDefault =
				(this && this.__setModuleDefault) ||
				(Object.create
					? function (o, v) {
							Object.defineProperty(o, 'default', {
								enumerable: true,
								value: v,
							})
						}
					: function (o, v) {
							o['default'] = v
						})
			var __importStar =
				(this && this.__importStar) ||
				function (mod) {
					if (mod && mod.__esModule) return mod
					var result = {}
					if (mod != null)
						for (var k in mod)
							if (
								k !== 'default' &&
								Object.prototype.hasOwnProperty.call(mod, k)
							)
								__createBinding(result, mod, k)
					__setModuleDefault(result, mod)
					return result
				}
			Object.defineProperty(exports, '__esModule', { value: true })
			exports.toPlatformPath =
				exports.toWin32Path =
				exports.toPosixPath =
					void 0
			const path = __importStar(__nccwpck_require__(16928))
			/**
			 * toPosixPath converts the given path to the posix form. On Windows, \\ will be
			 * replaced with /.
			 *
			 * @param pth. Path to transform.
			 * @return string Posix path.
			 */
			function toPosixPath(pth) {
				return pth.replace(/[\\]/g, '/')
			}
			exports.toPosixPath = toPosixPath
			/**
			 * toWin32Path converts the given path to the win32 form. On Linux, / will be
			 * replaced with \\.
			 *
			 * @param pth. Path to transform.
			 * @return string Win32 path.
			 */
			function toWin32Path(pth) {
				return pth.replace(/[/]/g, '\\')
			}
			exports.toWin32Path = toWin32Path
			/**
			 * toPlatformPath converts the given path to a platform-specific path. It does
			 * this by replacing instances of / and \ with the platform-specific path
			 * separator.
			 *
			 * @param pth The path to platformize.
			 * @return string The platform-specific path.
			 */
			function toPlatformPath(pth) {
				return pth.replace(/[/\\]/g, path.sep)
			}
			exports.toPlatformPath = toPlatformPath
			//# sourceMappingURL=path-utils.js.map

			/***/
		},

		/***/ 18968: /***/ function (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) {
			'use strict'

			var __createBinding =
				(this && this.__createBinding) ||
				(Object.create
					? function (o, m, k, k2) {
							if (k2 === undefined) k2 = k
							var desc = Object.getOwnPropertyDescriptor(m, k)
							if (
								!desc ||
								('get' in desc
									? !m.__esModule
									: desc.writable || desc.configurable)
							) {
								desc = {
									enumerable: true,
									get: function () {
										return m[k]
									},
								}
							}
							Object.defineProperty(o, k2, desc)
						}
					: function (o, m, k, k2) {
							if (k2 === undefined) k2 = k
							o[k2] = m[k]
						})
			var __setModuleDefault =
				(this && this.__setModuleDefault) ||
				(Object.create
					? function (o, v) {
							Object.defineProperty(o, 'default', {
								enumerable: true,
								value: v,
							})
						}
					: function (o, v) {
							o['default'] = v
						})
			var __importStar =
				(this && this.__importStar) ||
				function (mod) {
					if (mod && mod.__esModule) return mod
					var result = {}
					if (mod != null)
						for (var k in mod)
							if (
								k !== 'default' &&
								Object.prototype.hasOwnProperty.call(mod, k)
							)
								__createBinding(result, mod, k)
					__setModuleDefault(result, mod)
					return result
				}
			var __awaiter =
				(this && this.__awaiter) ||
				function (thisArg, _arguments, P, generator) {
					function adopt(value) {
						return value instanceof P
							? value
							: new P(function (resolve) {
									resolve(value)
								})
					}
					return new (P || (P = Promise))(function (resolve, reject) {
						function fulfilled(value) {
							try {
								step(generator.next(value))
							} catch (e) {
								reject(e)
							}
						}
						function rejected(value) {
							try {
								step(generator['throw'](value))
							} catch (e) {
								reject(e)
							}
						}
						function step(result) {
							result.done
								? resolve(result.value)
								: adopt(result.value).then(fulfilled, rejected)
						}
						step(
							(generator = generator.apply(thisArg, _arguments || [])).next(),
						)
					})
				}
			var __importDefault =
				(this && this.__importDefault) ||
				function (mod) {
					return mod && mod.__esModule ? mod : { default: mod }
				}
			Object.defineProperty(exports, '__esModule', { value: true })
			exports.getDetails =
				exports.isLinux =
				exports.isMacOS =
				exports.isWindows =
				exports.arch =
				exports.platform =
					void 0
			const os_1 = __importDefault(__nccwpck_require__(70857))
			const exec = __importStar(__nccwpck_require__(95236))
			const getWindowsInfo = () =>
				__awaiter(void 0, void 0, void 0, function* () {
					const { stdout: version } = yield exec.getExecOutput(
						'powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Version"',
						undefined,
						{
							silent: true,
						},
					)
					const { stdout: name } = yield exec.getExecOutput(
						'powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Caption"',
						undefined,
						{
							silent: true,
						},
					)
					return {
						name: name.trim(),
						version: version.trim(),
					}
				})
			const getMacOsInfo = () =>
				__awaiter(void 0, void 0, void 0, function* () {
					var _a, _b, _c, _d
					const { stdout } = yield exec.getExecOutput('sw_vers', undefined, {
						silent: true,
					})
					const version =
						(_b =
							(_a = stdout.match(/ProductVersion:\s*(.+)/)) === null ||
							_a === void 0
								? void 0
								: _a[1]) !== null && _b !== void 0
							? _b
							: ''
					const name =
						(_d =
							(_c = stdout.match(/ProductName:\s*(.+)/)) === null ||
							_c === void 0
								? void 0
								: _c[1]) !== null && _d !== void 0
							? _d
							: ''
					return {
						name,
						version,
					}
				})
			const getLinuxInfo = () =>
				__awaiter(void 0, void 0, void 0, function* () {
					const { stdout } = yield exec.getExecOutput(
						'lsb_release',
						['-i', '-r', '-s'],
						{
							silent: true,
						},
					)
					const [name, version] = stdout.trim().split('\n')
					return {
						name,
						version,
					}
				})
			exports.platform = os_1.default.platform()
			exports.arch = os_1.default.arch()
			exports.isWindows = exports.platform === 'win32'
			exports.isMacOS = exports.platform === 'darwin'
			exports.isLinux = exports.platform === 'linux'
			function getDetails() {
				return __awaiter(this, void 0, void 0, function* () {
					return Object.assign(
						Object.assign(
							{},
							yield exports.isWindows
								? getWindowsInfo()
								: exports.isMacOS
									? getMacOsInfo()
									: getLinuxInfo(),
						),
						{
							platform: exports.platform,
							arch: exports.arch,
							isWindows: exports.isWindows,
							isMacOS: exports.isMacOS,
							isLinux: exports.isLinux,
						},
					)
				})
			}
			exports.getDetails = getDetails
			//# sourceMappingURL=platform.js.map

			/***/
		},

		/***/ 71847: /***/ function (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) {
			'use strict'

			var __awaiter =
				(this && this.__awaiter) ||
				function (thisArg, _arguments, P, generator) {
					function adopt(value) {
						return value instanceof P
							? value
							: new P(function (resolve) {
									resolve(value)
								})
					}
					return new (P || (P = Promise))(function (resolve, reject) {
						function fulfilled(value) {
							try {
								step(generator.next(value))
							} catch (e) {
								reject(e)
							}
						}
						function rejected(value) {
							try {
								step(generator['throw'](value))
							} catch (e) {
								reject(e)
							}
						}
						function step(result) {
							result.done
								? resolve(result.value)
								: adopt(result.value).then(fulfilled, rejected)
						}
						step(
							(generator = generator.apply(thisArg, _arguments || [])).next(),
						)
					})
				}
			Object.defineProperty(exports, '__esModule', { value: true })
			exports.summary =
				exports.markdownSummary =
				exports.SUMMARY_DOCS_URL =
				exports.SUMMARY_ENV_VAR =
					void 0
			const os_1 = __nccwpck_require__(70857)
			const fs_1 = __nccwpck_require__(79896)
			const { access, appendFile, writeFile } = fs_1.promises
			exports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY'
			exports.SUMMARY_DOCS_URL =
				'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary'
			class Summary {
				constructor() {
					this._buffer = ''
				}
				/**
				 * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
				 * Also checks r/w permissions.
				 *
				 * @returns step summary file path
				 */
				filePath() {
					return __awaiter(this, void 0, void 0, function* () {
						if (this._filePath) {
							return this._filePath
						}
						const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR]
						if (!pathFromEnv) {
							throw new Error(
								`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`,
							)
						}
						try {
							yield access(
								pathFromEnv,
								fs_1.constants.R_OK | fs_1.constants.W_OK,
							)
						} catch (_a) {
							throw new Error(
								`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`,
							)
						}
						this._filePath = pathFromEnv
						return this._filePath
					})
				}
				/**
				 * Wraps content in an HTML tag, adding any HTML attributes
				 *
				 * @param {string} tag HTML tag to wrap
				 * @param {string | null} content content within the tag
				 * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
				 *
				 * @returns {string} content wrapped in HTML element
				 */
				wrap(tag, content, attrs = {}) {
					const htmlAttrs = Object.entries(attrs)
						.map(([key, value]) => ` ${key}="${value}"`)
						.join('')
					if (!content) {
						return `<${tag}${htmlAttrs}>`
					}
					return `<${tag}${htmlAttrs}>${content}</${tag}>`
				}
				/**
				 * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
				 *
				 * @param {SummaryWriteOptions} [options] (optional) options for write operation
				 *
				 * @returns {Promise<Summary>} summary instance
				 */
				write(options) {
					return __awaiter(this, void 0, void 0, function* () {
						const overwrite = !!(options === null || options === void 0
							? void 0
							: options.overwrite)
						const filePath = yield this.filePath()
						const writeFunc = overwrite ? writeFile : appendFile
						yield writeFunc(filePath, this._buffer, { encoding: 'utf8' })
						return this.emptyBuffer()
					})
				}
				/**
				 * Clears the summary buffer and wipes the summary file
				 *
				 * @returns {Summary} summary instance
				 */
				clear() {
					return __awaiter(this, void 0, void 0, function* () {
						return this.emptyBuffer().write({ overwrite: true })
					})
				}
				/**
				 * Returns the current summary buffer as a string
				 *
				 * @returns {string} string of summary buffer
				 */
				stringify() {
					return this._buffer
				}
				/**
				 * If the summary buffer is empty
				 *
				 * @returns {boolen} true if the buffer is empty
				 */
				isEmptyBuffer() {
					return this._buffer.length === 0
				}
				/**
				 * Resets the summary buffer without writing to summary file
				 *
				 * @returns {Summary} summary instance
				 */
				emptyBuffer() {
					this._buffer = ''
					return this
				}
				/**
				 * Adds raw text to the summary buffer
				 *
				 * @param {string} text content to add
				 * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
				 *
				 * @returns {Summary} summary instance
				 */
				addRaw(text, addEOL = false) {
					this._buffer += text
					return addEOL ? this.addEOL() : this
				}
				/**
				 * Adds the operating system-specific end-of-line marker to the buffer
				 *
				 * @returns {Summary} summary instance
				 */
				addEOL() {
					return this.addRaw(os_1.EOL)
				}
				/**
				 * Adds an HTML codeblock to the summary buffer
				 *
				 * @param {string} code content to render within fenced code block
				 * @param {string} lang (optional) language to syntax highlight code
				 *
				 * @returns {Summary} summary instance
				 */
				addCodeBlock(code, lang) {
					const attrs = Object.assign({}, lang && { lang })
					const element = this.wrap('pre', this.wrap('code', code), attrs)
					return this.addRaw(element).addEOL()
				}
				/**
				 * Adds an HTML list to the summary buffer
				 *
				 * @param {string[]} items list of items to render
				 * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
				 *
				 * @returns {Summary} summary instance
				 */
				addList(items, ordered = false) {
					const tag = ordered ? 'ol' : 'ul'
					const listItems = items.map((item) => this.wrap('li', item)).join('')
					const element = this.wrap(tag, listItems)
					return this.addRaw(element).addEOL()
				}
				/**
				 * Adds an HTML table to the summary buffer
				 *
				 * @param {SummaryTableCell[]} rows table rows
				 *
				 * @returns {Summary} summary instance
				 */
				addTable(rows) {
					const tableBody = rows
						.map((row) => {
							const cells = row
								.map((cell) => {
									if (typeof cell === 'string') {
										return this.wrap('td', cell)
									}
									const { header, data, colspan, rowspan } = cell
									const tag = header ? 'th' : 'td'
									const attrs = Object.assign(
										Object.assign({}, colspan && { colspan }),
										rowspan && { rowspan },
									)
									return this.wrap(tag, data, attrs)
								})
								.join('')
							return this.wrap('tr', cells)
						})
						.join('')
					const element = this.wrap('table', tableBody)
					return this.addRaw(element).addEOL()
				}
				/**
				 * Adds a collapsable HTML details element to the summary buffer
				 *
				 * @param {string} label text for the closed state
				 * @param {string} content collapsable content
				 *
				 * @returns {Summary} summary instance
				 */
				addDetails(label, content) {
					const element = this.wrap(
						'details',
						this.wrap('summary', label) + content,
					)
					return this.addRaw(element).addEOL()
				}
				/**
				 * Adds an HTML image tag to the summary buffer
				 *
				 * @param {string} src path to the image you to embed
				 * @param {string} alt text description of the image
				 * @param {SummaryImageOptions} options (optional) addition image attributes
				 *
				 * @returns {Summary} summary instance
				 */
				addImage(src, alt, options) {
					const { width, height } = options || {}
					const attrs = Object.assign(
						Object.assign({}, width && { width }),
						height && { height },
					)
					const element = this.wrap(
						'img',
						null,
						Object.assign({ src, alt }, attrs),
					)
					return this.addRaw(element).addEOL()
				}
				/**
				 * Adds an HTML section heading element
				 *
				 * @param {string} text heading text
				 * @param {number | string} [level=1] (optional) the heading level, default: 1
				 *
				 * @returns {Summary} summary instance
				 */
				addHeading(text, level) {
					const tag = `h${level}`
					const allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)
						? tag
						: 'h1'
					const element = this.wrap(allowedTag, text)
					return this.addRaw(element).addEOL()
				}
				/**
				 * Adds an HTML thematic break (<hr>) to the summary buffer
				 *
				 * @returns {Summary} summary instance
				 */
				addSeparator() {
					const element = this.wrap('hr', null)
					return this.addRaw(element).addEOL()
				}
				/**
				 * Adds an HTML line break (<br>) to the summary buffer
				 *
				 * @returns {Summary} summary instance
				 */
				addBreak() {
					const element = this.wrap('br', null)
					return this.addRaw(element).addEOL()
				}
				/**
				 * Adds an HTML blockquote to the summary buffer
				 *
				 * @param {string} text quote text
				 * @param {string} cite (optional) citation url
				 *
				 * @returns {Summary} summary instance
				 */
				addQuote(text, cite) {
					const attrs = Object.assign({}, cite && { cite })
					const element = this.wrap('blockquote', text, attrs)
					return this.addRaw(element).addEOL()
				}
				/**
				 * Adds an HTML anchor tag to the summary buffer
				 *
				 * @param {string} text link text/content
				 * @param {string} href hyperlink
				 *
				 * @returns {Summary} summary instance
				 */
				addLink(text, href) {
					const element = this.wrap('a', text, { href })
					return this.addRaw(element).addEOL()
				}
			}
			const _summary = new Summary()
			/**
			 * @deprecated use `core.summary`
			 */
			exports.markdownSummary = _summary
			exports.summary = _summary
			//# sourceMappingURL=summary.js.map

			/***/
		},

		/***/ 30302: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			// We use any as a valid input type
			/* eslint-disable @typescript-eslint/no-explicit-any */
			Object.defineProperty(exports, '__esModule', { value: true })
			exports.toCommandProperties = exports.toCommandValue = void 0
			/**
			 * Sanitizes an input into a string so it can be passed into issueCommand safely
			 * @param input input to sanitize into a string
			 */
			function toCommandValue(input) {
				if (input === null || input === undefined) {
					return ''
				} else if (typeof input === 'string' || input instanceof String) {
					return input
				}
				return JSON.stringify(input)
			}
			exports.toCommandValue = toCommandValue
			/**
			 *
			 * @param annotationProperties
			 * @returns The command properties to send with the actual annotation command
			 * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646
			 */
			function toCommandProperties(annotationProperties) {
				if (!Object.keys(annotationProperties).length) {
					return {}
				}
				return {
					title: annotationProperties.title,
					file: annotationProperties.file,
					line: annotationProperties.startLine,
					endLine: annotationProperties.endLine,
					col: annotationProperties.startColumn,
					endColumn: annotationProperties.endColumn,
				}
			}
			exports.toCommandProperties = toCommandProperties
			//# sourceMappingURL=utils.js.map

			/***/
		},

		/***/ 95236: /***/ function (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) {
			'use strict'

			var __createBinding =
				(this && this.__createBinding) ||
				(Object.create
					? function (o, m, k, k2) {
							if (k2 === undefined) k2 = k
							Object.defineProperty(o, k2, {
								enumerable: true,
								get: function () {
									return m[k]
								},
							})
						}
					: function (o, m, k, k2) {
							if (k2 === undefined) k2 = k
							o[k2] = m[k]
						})
			var __setModuleDefault =
				(this && this.__setModuleDefault) ||
				(Object.create
					? function (o, v) {
							Object.defineProperty(o, 'default', {
								enumerable: true,
								value: v,
							})
						}
					: function (o, v) {
							o['default'] = v
						})
			var __importStar =
				(this && this.__importStar) ||
				function (mod) {
					if (mod && mod.__esModule) return mod
					var result = {}
					if (mod != null)
						for (var k in mod)
							if (k !== 'default' && Object.hasOwnProperty.call(mod, k))
								__createBinding(result, mod, k)
					__setModuleDefault(result, mod)
					return result
				}
			var __awaiter =
				(this && this.__awaiter) ||
				function (thisArg, _arguments, P, generator) {
					function adopt(value) {
						return value instanceof P
							? value
							: new P(function (resolve) {
									resolve(value)
								})
					}
					return new (P || (P = Promise))(function (resolve, reject) {
						function fulfilled(value) {
							try {
								step(generator.next(value))
							} catch (e) {
								reject(e)
							}
						}
						function rejected(value) {
							try {
								step(generator['throw'](value))
							} catch (e) {
								reject(e)
							}
						}
						function step(result) {
							result.done
								? resolve(result.value)
								: adopt(result.value).then(fulfilled, rejected)
						}
						step(
							(generator = generator.apply(thisArg, _arguments || [])).next(),
						)
					})
				}
			Object.defineProperty(exports, '__esModule', { value: true })
			exports.getExecOutput = exports.exec = void 0
			const string_decoder_1 = __nccwpck_require__(13193)
			const tr = __importStar(__nccwpck_require__(6665))
			/**
			 * Exec a command.
			 * Output will be streamed to the live console.
			 * Returns promise with return code
			 *
			 * @param     commandLine        command to execute (can include additional args). Must be correctly escaped.
			 * @param     args               optional arguments for tool. Escaping is handled by the lib.
			 * @param     options            optional exec options.  See ExecOptions
			 * @returns   Promise<number>    exit code
			 */
			function exec(commandLine, args, options) {
				return __awaiter(this, void 0, void 0, function* () {
					const commandArgs = tr.argStringToArray(commandLine)
					if (commandArgs.length === 0) {
						throw new Error(`Parameter 'commandLine' cannot be null or empty.`)
					}
					// Path to tool to execute should be first arg
					const toolPath = commandArgs[0]
					args = commandArgs.slice(1).concat(args || [])
					const runner = new tr.ToolRunner(toolPath, args, options)
					return runner.exec()
				})
			}
			exports.exec = exec
			/**
			 * Exec a command and get the output.
			 * Output will be streamed to the live console.
			 * Returns promise with the exit code and collected stdout and stderr
			 *
			 * @param     commandLine           command to execute (can include additional args). Must be correctly escaped.
			 * @param     args                  optional arguments for tool. Escaping is handled by the lib.
			 * @param     options               optional exec options.  See ExecOptions
			 * @returns   Promise<ExecOutput>   exit code, stdout, and stderr
			 */
			function getExecOutput(commandLine, args, options) {
				var _a, _b
				return __awaiter(this, void 0, void 0, function* () {
					let stdout = ''
					let stderr = ''
					//Using string decoder covers the case where a mult-byte character is split
					const stdoutDecoder = new string_decoder_1.StringDecoder('utf8')
					const stderrDecoder = new string_decoder_1.StringDecoder('utf8')
					const originalStdoutListener =
						(_a =
							options === null || options === void 0
								? void 0
								: options.listeners) === null || _a === void 0
							? void 0
							: _a.stdout
					const originalStdErrListener =
						(_b =
							options === null || options === void 0
								? void 0
								: options.listeners) === null || _b === void 0
							? void 0
							: _b.stderr
					const stdErrListener = (data) => {
						stderr += stderrDecoder.write(data)
						if (originalStdErrListener) {
							originalStdErrListener(data)
						}
					}
					const stdOutListener = (data) => {
						stdout += stdoutDecoder.write(data)
						if (originalStdoutListener) {
							originalStdoutListener(data)
						}
					}
					const listeners = Object.assign(
						Object.assign(
							{},
							options === null || options === void 0
								? void 0
								: options.listeners,
						),
						{ stdout: stdOutListener, stderr: stdErrListener },
					)
					const exitCode = yield exec(
						commandLine,
						args,
						Object.assign(Object.assign({}, options), { listeners }),
					)
					//flush any remaining characters
					stdout += stdoutDecoder.end()
					stderr += stderrDecoder.end()
					return {
						exitCode,
						stdout,
						stderr,
					}
				})
			}
			exports.getExecOutput = getExecOutput
			//# sourceMappingURL=exec.js.map

			/***/
		},

		/***/ 6665: /***/ function (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) {
			'use strict'

			var __createBinding =
				(this && this.__createBinding) ||
				(Object.create
					? function (o, m, k, k2) {
							if (k2 === undefined) k2 = k
							Object.defineProperty(o, k2, {
								enumerable: true,
								get: function () {
									return m[k]
								},
							})
						}
					: function (o, m, k, k2) {
							if (k2 === undefined) k2 = k
							o[k2] = m[k]
						})
			var __setModuleDefault =
				(this && this.__setModuleDefault) ||
				(Object.create
					? function (o, v) {
							Object.defineProperty(o, 'default', {
								enumerable: true,
								value: v,
							})
						}
					: function (o, v) {
							o['default'] = v
						})
			var __importStar =
				(this && this.__importStar) ||
				function (mod) {
					if (mod && mod.__esModule) return mod
					var result = {}
					if (mod != null)
						for (var k in mod)
							if (k !== 'default' && Object.hasOwnProperty.call(mod, k))
								__createBinding(result, mod, k)
					__setModuleDefault(result, mod)
					return result
				}
			var __awaiter =
				(this && this.__awaiter) ||
				function (thisArg, _arguments, P, generator) {
					function adopt(value) {
						return value instanceof P
							? value
							: new P(function (resolve) {
									resolve(value)
								})
					}
					return new (P || (P = Promise))(function (resolve, reject) {
						function fulfilled(value) {
							try {
								step(generator.next(value))
							} catch (e) {
								reject(e)
							}
						}
						function rejected(value) {
							try {
								step(generator['throw'](value))
							} catch (e) {
								reject(e)
							}
						}
						function step(result) {
							result.done
								? resolve(result.value)
								: adopt(result.value).then(fulfilled, rejected)
						}
						step(
							(generator = generator.apply(thisArg, _arguments || [])).next(),
						)
					})
				}
			Object.defineProperty(exports, '__esModule', { value: true })
			exports.argStringToArray = exports.ToolRunner = void 0
			const os = __importStar(__nccwpck_require__(70857))
			const events = __importStar(__nccwpck_require__(24434))
			const child = __importStar(__nccwpck_require__(35317))
			const path = __importStar(__nccwpck_require__(16928))
			const io = __importStar(__nccwpck_require__(94994))
			const ioUtil = __importStar(__nccwpck_require__(75207))
			const timers_1 = __nccwpck_require__(53557)
			/* eslint-disable @typescript-eslint/unbound-method */
			const IS_WINDOWS = process.platform === 'win32'
			/*
			 * Class for running command line tools. Handles quoting and arg parsing in a platform agnostic way.
			 */
			class ToolRunner extends events.EventEmitter {
				constructor(toolPath, args, options) {
					super()
					if (!toolPath) {
						throw new Error("Parameter 'toolPath' cannot be null or empty.")
					}
					this.toolPath = toolPath
					this.args = args || []
					this.options = options || {}
				}
				_debug(message) {
					if (this.options.listeners && this.options.listeners.debug) {
						this.options.listeners.debug(message)
					}
				}
				_getCommandString(options, noPrefix) {
					const toolPath = this._getSpawnFileName()
					const args = this._getSpawnArgs(options)
					let cmd = noPrefix ? '' : '[command]' // omit prefix when piped to a second tool
					if (IS_WINDOWS) {
						// Windows + cmd file
						if (this._isCmdFile()) {
							cmd += toolPath
							for (const a of args) {
								cmd += ` ${a}`
							}
						}
						// Windows + verbatim
						else if (options.windowsVerbatimArguments) {
							cmd += `"${toolPath}"`
							for (const a of args) {
								cmd += ` ${a}`
							}
						}
						// Windows (regular)
						else {
							cmd += this._windowsQuoteCmdArg(toolPath)
							for (const a of args) {
								cmd += ` ${this._windowsQuoteCmdArg(a)}`
							}
						}
					} else {
						// OSX/Linux - this can likely be improved with some form of quoting.
						// creating processes on Unix is fundamentally different than Windows.
						// on Unix, execvp() takes an arg array.
						cmd += toolPath
						for (const a of args) {
							cmd += ` ${a}`
						}
					}
					return cmd
				}
				_processLineBuffer(data, strBuffer, onLine) {
					try {
						let s = strBuffer + data.toString()
						let n = s.indexOf(os.EOL)
						while (n > -1) {
							const line = s.substring(0, n)
							onLine(line)
							// the rest of the string ...
							s = s.substring(n + os.EOL.length)
							n = s.indexOf(os.EOL)
						}
						return s
					} catch (err) {
						// streaming lines to console is best effort.  Don't fail a build.
						this._debug(`error processing line. Failed with error ${err}`)
						return ''
					}
				}
				_getSpawnFileName() {
					if (IS_WINDOWS) {
						if (this._isCmdFile()) {
							return process.env['COMSPEC'] || 'cmd.exe'
						}
					}
					return this.toolPath
				}
				_getSpawnArgs(options) {
					if (IS_WINDOWS) {
						if (this._isCmdFile()) {
							let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`
							for (const a of this.args) {
								argline += ' '
								argline += options.windowsVerbatimArguments
									? a
									: this._windowsQuoteCmdArg(a)
							}
							argline += '"'
							return [argline]
						}
					}
					return this.args
				}
				_endsWith(str, end) {
					return str.endsWith(end)
				}
				_isCmdFile() {
					const upperToolPath = this.toolPath.toUpperCase()
					return (
						this._endsWith(upperToolPath, '.CMD') ||
						this._endsWith(upperToolPath, '.BAT')
					)
				}
				_windowsQuoteCmdArg(arg) {
					// for .exe, apply the normal quoting rules that libuv applies
					if (!this._isCmdFile()) {
						return this._uvQuoteCmdArg(arg)
					}
					// otherwise apply quoting rules specific to the cmd.exe command line parser.
					// the libuv rules are generic and are not designed specifically for cmd.exe
					// command line parser.
					//
					// for a detailed description of the cmd.exe command line parser, refer to
					// http://stackoverflow.com/questions/4094699/how-does-the-windows-command-interpreter-cmd-exe-parse-scripts/7970912#7970912
					// need quotes for empty arg
					if (!arg) {
						return '""'
					}
					// determine whether the arg needs to be quoted
					const cmdSpecialChars = [
						' ',
						'\t',
						'&',
						'(',
						')',
						'[',
						']',
						'{',
						'}',
						'^',
						'=',
						';',
						'!',
						"'",
						'+',
						',',
						'`',
						'~',
						'|',
						'<',
						'>',
						'"',
					]
					let needsQuotes = false
					for (const char of arg) {
						if (cmdSpecialChars.some((x) => x === char)) {
							needsQuotes = true
							break
						}
					}
					// short-circuit if quotes not needed
					if (!needsQuotes) {
						return arg
					}
					// the following quoting rules are very similar to the rules that by libuv applies.
					//
					// 1) wrap the string in quotes
					//
					// 2) double-up quotes - i.e. " => ""
					//
					//    this is different from the libuv quoting rules. libuv replaces " with \", which unfortunately
					//    doesn't work well with a cmd.exe command line.
					//
					//    note, replacing " with "" also works well if the arg is passed to a downstream .NET console app.
					//    for example, the command line:
					//          foo.exe "myarg:""my val"""
					//    is parsed by a .NET console app into an arg array:
					//          [ "myarg:\"my val\"" ]
					//    which is the same end result when applying libuv quoting rules. although the actual
					//    command line from libuv quoting rules would look like:
					//          foo.exe "myarg:\"my val\""
					//
					// 3) double-up slashes that precede a quote,
					//    e.g.  hello \world    => "hello \world"
					//          hello\"world    => "hello\\""world"
					//          hello\\"world   => "hello\\\\""world"
					//          hello world\    => "hello world\\"
					//
					//    technically this is not required for a cmd.exe command line, or the batch argument parser.
					//    the reasons for including this as a .cmd quoting rule are:
					//
					//    a) this is optimized for the scenario where the argument is passed from the .cmd file to an
					//       external program. many programs (e.g. .NET console apps) rely on the slash-doubling rule.
					//
					//    b) it's what we've been doing previously (by deferring to node default behavior) and we
					//       haven't heard any complaints about that aspect.
					//
					// note, a weakness of the quoting rules chosen here, is that % is not escaped. in fact, % cannot be
					// escaped when used on the command line directly - even though within a .cmd file % can be escaped
					// by using %%.
					//
					// the saving grace is, on the command line, %var% is left as-is if var is not defined. this contrasts
					// the line parsing rules within a .cmd file, where if var is not defined it is replaced with nothing.
					//
					// one option that was explored was replacing % with ^% - i.e. %var% => ^%var^%. this hack would
					// often work, since it is unlikely that var^ would exist, and the ^ character is removed when the
					// variable is used. the problem, however, is that ^ is not removed when %* is used to pass the args
					// to an external program.
					//
					// an unexplored potential solution for the % escaping problem, is to create a wrapper .cmd file.
					// % can be escaped within a .cmd file.
					let reverse = '"'
					let quoteHit = true
					for (let i = arg.length; i > 0; i--) {
						// walk the string in reverse
						reverse += arg[i - 1]
						if (quoteHit && arg[i - 1] === '\\') {
							reverse += '\\' // double the slash
						} else if (arg[i - 1] === '"') {
							quoteHit = true
							reverse += '"' // double the quote
						} else {
							quoteHit = false
						}
					}
					reverse += '"'
					return reverse.split('').reverse().join('')
				}
				_uvQuoteCmdArg(arg) {
					// Tool runner wraps child_process.spawn() and needs to apply the same quoting as
					// Node in certain cases where the undocumented spawn option windowsVerbatimArguments
					// is used.
					//
					// Since this function is a port of quote_cmd_arg from Node 4.x (technically, lib UV,
					// see https://github.com/nodejs/node/blob/v4.x/deps/uv/src/win/process.c for details),
					// pasting copyright notice from Node within this function:
					//
					//      Copyright Joyent, Inc. and other Node contributors. All rights reserved.
					//
					//      Permission is hereby granted, free of charge, to any person obtaining a copy
					//      of this software and associated documentation files (the "Software"), to
					//      deal in the Software without restriction, including without limitation the
					//      rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
					//      sell copies of the Software, and to permit persons to whom the Software is
					//      furnished to do so, subject to the following conditions:
					//
					//      The above copyright notice and this permission notice shall be included in
					//      all copies or substantial portions of the Software.
					//
					//      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
					//      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
					//      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
					//      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
					//      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
					//      FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
					//      IN THE SOFTWARE.
					if (!arg) {
						// Need double quotation for empty argument
						return '""'
					}
					if (!arg.includes(' ') && !arg.includes('\t') && !arg.includes('"')) {
						// No quotation needed
						return arg
					}
					if (!arg.includes('"') && !arg.includes('\\')) {
						// No embedded double quotes or backslashes, so I can just wrap
						// quote marks around the whole thing.
						return `"${arg}"`
					}
					// Expected input/output:
					//   input : hello"world
					//   output: "hello\"world"
					//   input : hello""world
					//   output: "hello\"\"world"
					//   input : hello\world
					//   output: hello\world
					//   input : hello\\world
					//   output: hello\\world
					//   input : hello\"world
					//   output: "hello\\\"world"
					//   input : hello\\"world
					//   output: "hello\\\\\"world"
					//   input : hello world\
					//   output: "hello world\\" - note the comment in libuv actually reads "hello world\"
					//                             but it appears the comment is wrong, it should be "hello world\\"
					let reverse = '"'
					let quoteHit = true
					for (let i = arg.length; i > 0; i--) {
						// walk the string in reverse
						reverse += arg[i - 1]
						if (quoteHit && arg[i - 1] === '\\') {
							reverse += '\\'
						} else if (arg[i - 1] === '"') {
							quoteHit = true
							reverse += '\\'
						} else {
							quoteHit = false
						}
					}
					reverse += '"'
					return reverse.split('').reverse().join('')
				}
				_cloneExecOptions(options) {
					options = options || {}
					const result = {
						cwd: options.cwd || process.cwd(),
						env: options.env || process.env,
						silent: options.silent || false,
						windowsVerbatimArguments: options.windowsVerbatimArguments || false,
						failOnStdErr: options.failOnStdErr || false,
						ignoreReturnCode: options.ignoreReturnCode || false,
						delay: options.delay || 10000,
					}
					result.outStream = options.outStream || process.stdout
					result.errStream = options.errStream || process.stderr
					return result
				}
				_getSpawnOptions(options, toolPath) {
					options = options || {}
					const result = {}
					result.cwd = options.cwd
					result.env = options.env
					result['windowsVerbatimArguments'] =
						options.windowsVerbatimArguments || this._isCmdFile()
					if (options.windowsVerbatimArguments) {
						result.argv0 = `"${toolPath}"`
					}
					return result
				}
				/**
				 * Exec a tool.
				 * Output will be streamed to the live console.
				 * Returns promise with return code
				 *
				 * @param     tool     path to tool to exec
				 * @param     options  optional exec options.  See ExecOptions
				 * @returns   number
				 */
				exec() {
					return __awaiter(this, void 0, void 0, function* () {
						// root the tool path if it is unrooted and contains relative pathing
						if (
							!ioUtil.isRooted(this.toolPath) &&
							(this.toolPath.includes('/') ||
								(IS_WINDOWS && this.toolPath.includes('\\')))
						) {
							// prefer options.cwd if it is specified, however options.cwd may also need to be rooted
							this.toolPath = path.resolve(
								process.cwd(),
								this.options.cwd || process.cwd(),
								this.toolPath,
							)
						}
						// if the tool is only a file name, then resolve it from the PATH
						// otherwise verify it exists (add extension on Windows if necessary)
						this.toolPath = yield io.which(this.toolPath, true)
						return new Promise((resolve, reject) =>
							__awaiter(this, void 0, void 0, function* () {
								this._debug(`exec tool: ${this.toolPath}`)
								this._debug('arguments:')
								for (const arg of this.args) {
									this._debug(`   ${arg}`)
								}
								const optionsNonNull = this._cloneExecOptions(this.options)
								if (!optionsNonNull.silent && optionsNonNull.outStream) {
									optionsNonNull.outStream.write(
										this._getCommandString(optionsNonNull) + os.EOL,
									)
								}
								const state = new ExecState(optionsNonNull, this.toolPath)
								state.on('debug', (message) => {
									this._debug(message)
								})
								if (
									this.options.cwd &&
									!(yield ioUtil.exists(this.options.cwd))
								) {
									return reject(
										new Error(`The cwd: ${this.options.cwd} does not exist!`),
									)
								}
								const fileName = this._getSpawnFileName()
								const cp = child.spawn(
									fileName,
									this._getSpawnArgs(optionsNonNull),
									this._getSpawnOptions(this.options, fileName),
								)
								let stdbuffer = ''
								if (cp.stdout) {
									cp.stdout.on('data', (data) => {
										if (
											this.options.listeners &&
											this.options.listeners.stdout
										) {
											this.options.listeners.stdout(data)
										}
										if (!optionsNonNull.silent && optionsNonNull.outStream) {
											optionsNonNull.outStream.write(data)
										}
										stdbuffer = this._processLineBuffer(
											data,
											stdbuffer,
											(line) => {
												if (
													this.options.listeners &&
													this.options.listeners.stdline
												) {
													this.options.listeners.stdline(line)
												}
											},
										)
									})
								}
								let errbuffer = ''
								if (cp.stderr) {
									cp.stderr.on('data', (data) => {
										state.processStderr = true
										if (
											this.options.listeners &&
											this.options.listeners.stderr
										) {
											this.options.listeners.stderr(data)
										}
										if (
											!optionsNonNull.silent &&
											optionsNonNull.errStream &&
											optionsNonNull.outStream
										) {
											const s = optionsNonNull.failOnStdErr
												? optionsNonNull.errStream
												: optionsNonNull.outStream
											s.write(data)
										}
										errbuffer = this._processLineBuffer(
											data,
											errbuffer,
											(line) => {
												if (
													this.options.listeners &&
													this.options.listeners.errline
												) {
													this.options.listeners.errline(line)
												}
											},
										)
									})
								}
								cp.on('error', (err) => {
									state.processError = err.message
									state.processExited = true
									state.processClosed = true
									state.CheckComplete()
								})
								cp.on('exit', (code) => {
									state.processExitCode = code
									state.processExited = true
									this._debug(
										`Exit code ${code} received from tool '${this.toolPath}'`,
									)
									state.CheckComplete()
								})
								cp.on('close', (code) => {
									state.processExitCode = code
									state.processExited = true
									state.processClosed = true
									this._debug(
										`STDIO streams have closed for tool '${this.toolPath}'`,
									)
									state.CheckComplete()
								})
								state.on('done', (error, exitCode) => {
									if (stdbuffer.length > 0) {
										this.emit('stdline', stdbuffer)
									}
									if (errbuffer.length > 0) {
										this.emit('errline', errbuffer)
									}
									cp.removeAllListeners()
									if (error) {
										reject(error)
									} else {
										resolve(exitCode)
									}
								})
								if (this.options.input) {
									if (!cp.stdin) {
										throw new Error('child process missing stdin')
									}
									cp.stdin.end(this.options.input)
								}
							}),
						)
					})
				}
			}
			exports.ToolRunner = ToolRunner
			/**
			 * Convert an arg string to an array of args. Handles escaping
			 *
			 * @param    argString   string of arguments
			 * @returns  string[]    array of arguments
			 */
			function argStringToArray(argString) {
				const args = []
				let inQuotes = false
				let escaped = false
				let arg = ''
				function append(c) {
					// we only escape double quotes.
					if (escaped && c !== '"') {
						arg += '\\'
					}
					arg += c
					escaped = false
				}
				for (let i = 0; i < argString.length; i++) {
					const c = argString.charAt(i)
					if (c === '"') {
						if (!escaped) {
							inQuotes = !inQuotes
						} else {
							append(c)
						}
						continue
					}
					if (c === '\\' && escaped) {
						append(c)
						continue
					}
					if (c === '\\' && inQuotes) {
						escaped = true
						continue
					}
					if (c === ' ' && !inQuotes) {
						if (arg.length > 0) {
							args.push(arg)
							arg = ''
						}
						continue
					}
					append(c)
				}
				if (arg.length > 0) {
					args.push(arg.trim())
				}
				return args
			}
			exports.argStringToArray = argStringToArray
			class ExecState extends events.EventEmitter {
				constructor(options, toolPath) {
					super()
					this.processClosed = false // tracks whether the process has exited and stdio is closed
					this.processError = ''
					this.processExitCode = 0
					this.processExited = false // tracks whether the process has exited
					this.processStderr = false // tracks whether stderr was written to
					this.delay = 10000 // 10 seconds
					this.done = false
					this.timeout = null
					if (!toolPath) {
						throw new Error('toolPath must not be empty')
					}
					this.options = options
					this.toolPath = toolPath
					if (options.delay) {
						this.delay = options.delay
					}
				}
				CheckComplete() {
					if (this.done) {
						return
					}
					if (this.processClosed) {
						this._setResult()
					} else if (this.processExited) {
						this.timeout = timers_1.setTimeout(
							ExecState.HandleTimeout,
							this.delay,
							this,
						)
					}
				}
				_debug(message) {
					this.emit('debug', message)
				}
				_setResult() {
					// determine whether there is an error
					let error
					if (this.processExited) {
						if (this.processError) {
							error = new Error(
								`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`,
							)
						} else if (
							this.processExitCode !== 0 &&
							!this.options.ignoreReturnCode
						) {
							error = new Error(
								`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`,
							)
						} else if (this.processStderr && this.options.failOnStdErr) {
							error = new Error(
								`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`,
							)
						}
					}
					// clear the timeout
					if (this.timeout) {
						clearTimeout(this.timeout)
						this.timeout = null
					}
					this.done = true
					this.emit('done', error, this.processExitCode)
				}
				static HandleTimeout(state) {
					if (state.done) {
						return
					}
					if (!state.processClosed && state.processExited) {
						const message = `The STDIO streams did not close within ${
							state.delay / 1000
						} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`
						state._debug(message)
					}
					state._setResult()
				}
			}
			//# sourceMappingURL=toolrunner.js.map

			/***/
		},

		/***/ 44552: /***/ function (__unused_webpack_module, exports) {
			'use strict'

			var __awaiter =
				(this && this.__awaiter) ||
				function (thisArg, _arguments, P, generator) {
					function adopt(value) {
						return value instanceof P
							? value
							: new P(function (resolve) {
									resolve(value)
								})
					}
					return new (P || (P = Promise))(function (resolve, reject) {
						function fulfilled(value) {
							try {
								step(generator.next(value))
							} catch (e) {
								reject(e)
							}
						}
						function rejected(value) {
							try {
								step(generator['throw'](value))
							} catch (e) {
								reject(e)
							}
						}
						function step(result) {
							result.done
								? resolve(result.value)
								: adopt(result.value).then(fulfilled, rejected)
						}
						step(
							(generator = generator.apply(thisArg, _arguments || [])).next(),
						)
					})
				}
			Object.defineProperty(exports, '__esModule', { value: true })
			exports.PersonalAccessTokenCredentialHandler =
				exports.BearerCredentialHandler =
				exports.BasicCredentialHandler =
					void 0
			class BasicCredentialHandler {
				constructor(username, password) {
					this.username = username
					this.password = password
				}
				prepareRequest(options) {
					if (!options.headers) {
						throw Error('The request has no headers')
					}
					options.headers['Authorization'] =
						`Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`
				}
				// This handler cannot handle 401
				canHandleAuthentication() {
					return false
				}
				handleAuthentication() {
					return __awaiter(this, void 0, void 0, function* () {
						throw new Error('not implemented')
					})
				}
			}
			exports.BasicCredentialHandler = BasicCredentialHandler
			class BearerCredentialHandler {
				constructor(token) {
					this.token = token
				}
				// currently implements pre-authorization
				// TODO: support preAuth = false where it hooks on 401
				prepareRequest(options) {
					if (!options.headers) {
						throw Error('The request has no headers')
					}
					options.headers['Authorization'] = `Bearer ${this.token}`
				}
				// This handler cannot handle 401
				canHandleAuthentication() {
					return false
				}
				handleAuthentication() {
					return __awaiter(this, void 0, void 0, function* () {
						throw new Error('not implemented')
					})
				}
			}
			exports.BearerCredentialHandler = BearerCredentialHandler
			class PersonalAccessTokenCredentialHandler {
				constructor(token) {
					this.token = token
				}
				// currently implements pre-authorization
				// TODO: support preAuth = false where it hooks on 401
				prepareRequest(options) {
					if (!options.headers) {
						throw Error('The request has no headers')
					}
					options.headers['Authorization'] =
						`Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`
				}
				// This handler cannot handle 401
				canHandleAuthentication() {
					return false
				}
				handleAuthentication() {
					return __awaiter(this, void 0, void 0, function* () {
						throw new Error('not implemented')
					})
				}
			}
			exports.PersonalAccessTokenCredentialHandler =
				PersonalAccessTokenCredentialHandler
			//# sourceMappingURL=auth.js.map

			/***/
		},

		/***/ 54844: /***/ function (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) {
			'use strict'

			/* eslint-disable @typescript-eslint/no-explicit-any */
			var __createBinding =
				(this && this.__createBinding) ||
				(Object.create
					? function (o, m, k, k2) {
							if (k2 === undefined) k2 = k
							var desc = Object.getOwnPropertyDescriptor(m, k)
							if (
								!desc ||
								('get' in desc
									? !m.__esModule
									: desc.writable || desc.configurable)
							) {
								desc = {
									enumerable: true,
									get: function () {
										return m[k]
									},
								}
							}
							Object.defineProperty(o, k2, desc)
						}
					: function (o, m, k, k2) {
							if (k2 === undefined) k2 = k
							o[k2] = m[k]
						})
			var __setModuleDefault =
				(this && this.__setModuleDefault) ||
				(Object.create
					? function (o, v) {
							Object.defineProperty(o, 'default', {
								enumerable: true,
								value: v,
							})
						}
					: function (o, v) {
							o['default'] = v
						})
			var __importStar =
				(this && this.__importStar) ||
				function (mod) {
					if (mod && mod.__esModule) return mod
					var result = {}
					if (mod != null)
						for (var k in mod)
							if (
								k !== 'default' &&
								Object.prototype.hasOwnProperty.call(mod, k)
							)
								__createBinding(result, mod, k)
					__setModuleDefault(result, mod)
					return result
				}
			var __awaiter =
				(this && this.__awaiter) ||
				function (thisArg, _arguments, P, generator) {
					function adopt(value) {
						return value instanceof P
							? value
							: new P(function (resolve) {
									resolve(value)
								})
					}
					return new (P || (P = Promise))(function (resolve, reject) {
						function fulfilled(value) {
							try {
								step(generator.next(value))
							} catch (e) {
								reject(e)
							}
						}
						function rejected(value) {
							try {
								step(generator['throw'](value))
							} catch (e) {
								reject(e)
							}
						}
						function step(result) {
							result.done
								? resolve(result.value)
								: adopt(result.value).then(fulfilled, rejected)
						}
						step(
							(generator = generator.apply(thisArg, _arguments || [])).next(),
						)
					})
				}
			Object.defineProperty(exports, '__esModule', { value: true })
			exports.HttpClient =
				exports.isHttps =
				exports.HttpClientResponse =
				exports.HttpClientError =
				exports.getProxyUrl =
				exports.MediaTypes =
				exports.Headers =
				exports.HttpCodes =
					void 0
			const http = __importStar(__nccwpck_require__(58611))
			const https = __importStar(__nccwpck_require__(65692))
			const pm = __importStar(__nccwpck_require__(54988))
			const tunnel = __importStar(__nccwpck_require__(20770))
			const undici_1 = __nccwpck_require__(46752)
			var HttpCodes
			;(function (HttpCodes) {
				HttpCodes[(HttpCodes['OK'] = 200)] = 'OK'
				HttpCodes[(HttpCodes['MultipleChoices'] = 300)] = 'MultipleChoices'
				HttpCodes[(HttpCodes['MovedPermanently'] = 301)] = 'MovedPermanently'
				HttpCodes[(HttpCodes['ResourceMoved'] = 302)] = 'ResourceMoved'
				HttpCodes[(HttpCodes['SeeOther'] = 303)] = 'SeeOther'
				HttpCodes[(HttpCodes['NotModified'] = 304)] = 'NotModified'
				HttpCodes[(HttpCodes['UseProxy'] = 305)] = 'UseProxy'
				HttpCodes[(HttpCodes['SwitchProxy'] = 306)] = 'SwitchProxy'
				HttpCodes[(HttpCodes['TemporaryRedirect'] = 307)] = 'TemporaryRedirect'
				HttpCodes[(HttpCodes['PermanentRedirect'] = 308)] = 'PermanentRedirect'
				HttpCodes[(HttpCodes['BadRequest'] = 400)] = 'BadRequest'
				HttpCodes[(HttpCodes['Unauthorized'] = 401)] = 'Unauthorized'
				HttpCodes[(HttpCodes['PaymentRequired'] = 402)] = 'PaymentRequired'
				HttpCodes[(HttpCodes['Forbidden'] = 403)] = 'Forbidden'
				HttpCodes[(HttpCodes['NotFound'] = 404)] = 'NotFound'
				HttpCodes[(HttpCodes['MethodNotAllowed'] = 405)] = 'MethodNotAllowed'
				HttpCodes[(HttpCodes['NotAcceptable'] = 406)] = 'NotAcceptable'
				HttpCodes[(HttpCodes['ProxyAuthenticationRequired'] = 407)] =
					'ProxyAuthenticationRequired'
				HttpCodes[(HttpCodes['RequestTimeout'] = 408)] = 'RequestTimeout'
				HttpCodes[(HttpCodes['Conflict'] = 409)] = 'Conflict'
				HttpCodes[(HttpCodes['Gone'] = 410)] = 'Gone'
				HttpCodes[(HttpCodes['TooManyRequests'] = 429)] = 'TooManyRequests'
				HttpCodes[(HttpCodes['InternalServerError'] = 500)] =
					'InternalServerError'
				HttpCodes[(HttpCodes['NotImplemented'] = 501)] = 'NotImplemented'
				HttpCodes[(HttpCodes['BadGateway'] = 502)] = 'BadGateway'
				HttpCodes[(HttpCodes['ServiceUnavailable'] = 503)] =
					'ServiceUnavailable'
				HttpCodes[(HttpCodes['GatewayTimeout'] = 504)] = 'GatewayTimeout'
			})(HttpCodes || (exports.HttpCodes = HttpCodes = {}))
			var Headers
			;(function (Headers) {
				Headers['Accept'] = 'accept'
				Headers['ContentType'] = 'content-type'
			})(Headers || (exports.Headers = Headers = {}))
			var MediaTypes
			;(function (MediaTypes) {
				MediaTypes['ApplicationJson'] = 'application/json'
			})(MediaTypes || (exports.MediaTypes = MediaTypes = {}))
			/**
			 * Returns the proxy URL, depending upon the supplied url and proxy environment variables.
			 * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
			 */
			function getProxyUrl(serverUrl) {
				const proxyUrl = pm.getProxyUrl(new URL(serverUrl))
				return proxyUrl ? proxyUrl.href : ''
			}
			exports.getProxyUrl = getProxyUrl
			const HttpRedirectCodes = [
				HttpCodes.MovedPermanently,
				HttpCodes.ResourceMoved,
				HttpCodes.SeeOther,
				HttpCodes.TemporaryRedirect,
				HttpCodes.PermanentRedirect,
			]
			const HttpResponseRetryCodes = [
				HttpCodes.BadGateway,
				HttpCodes.ServiceUnavailable,
				HttpCodes.GatewayTimeout,
			]
			const RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD']
			const ExponentialBackoffCeiling = 10
			const ExponentialBackoffTimeSlice = 5
			class HttpClientError extends Error {
				constructor(message, statusCode) {
					super(message)
					this.name = 'HttpClientError'
					this.statusCode = statusCode
					Object.setPrototypeOf(this, HttpClientError.prototype)
				}
			}
			exports.HttpClientError = HttpClientError
			class HttpClientResponse {
				constructor(message) {
					this.message = message
				}
				readBody() {
					return __awaiter(this, void 0, void 0, function* () {
						return new Promise((resolve) =>
							__awaiter(this, void 0, void 0, function* () {
								let output = Buffer.alloc(0)
								this.message.on('data', (chunk) => {
									output = Buffer.concat([output, chunk])
								})
								this.message.on('end', () => {
									resolve(output.toString())
								})
							}),
						)
					})
				}
				readBodyBuffer() {
					return __awaiter(this, void 0, void 0, function* () {
						return new Promise((resolve) =>
							__awaiter(this, void 0, void 0, function* () {
								const chunks = []
								this.message.on('data', (chunk) => {
									chunks.push(chunk)
								})
								this.message.on('end', () => {
									resolve(Buffer.concat(chunks))
								})
							}),
						)
					})
				}
			}
			exports.HttpClientResponse = HttpClientResponse
			function isHttps(requestUrl) {
				const parsedUrl = new URL(requestUrl)
				return parsedUrl.protocol === 'https:'
			}
			exports.isHttps = isHttps
			class HttpClient {
				constructor(userAgent, handlers, requestOptions) {
					this._ignoreSslError = false
					this._allowRedirects = true
					this._allowRedirectDowngrade = false
					this._maxRedirects = 50
					this._allowRetries = false
					this._maxRetries = 1
					this._keepAlive = false
					this._disposed = false
					this.userAgent = userAgent
					this.handlers = handlers || []
					this.requestOptions = requestOptions
					if (requestOptions) {
						if (requestOptions.ignoreSslError != null) {
							this._ignoreSslError = requestOptions.ignoreSslError
						}
						this._socketTimeout = requestOptions.socketTimeout
						if (requestOptions.allowRedirects != null) {
							this._allowRedirects = requestOptions.allowRedirects
						}
						if (requestOptions.allowRedirectDowngrade != null) {
							this._allowRedirectDowngrade =
								requestOptions.allowRedirectDowngrade
						}
						if (requestOptions.maxRedirects != null) {
							this._maxRedirects = Math.max(requestOptions.maxRedirects, 0)
						}
						if (requestOptions.keepAlive != null) {
							this._keepAlive = requestOptions.keepAlive
						}
						if (requestOptions.allowRetries != null) {
							this._allowRetries = requestOptions.allowRetries
						}
						if (requestOptions.maxRetries != null) {
							this._maxRetries = requestOptions.maxRetries
						}
					}
				}
				options(requestUrl, additionalHeaders) {
					return __awaiter(this, void 0, void 0, function* () {
						return this.request(
							'OPTIONS',
							requestUrl,
							null,
							additionalHeaders || {},
						)
					})
				}
				get(requestUrl, additionalHeaders) {
					return __awaiter(this, void 0, void 0, function* () {
						return this.request(
							'GET',
							requestUrl,
							null,
							additionalHeaders || {},
						)
					})
				}
				del(requestUrl, additionalHeaders) {
					return __awaiter(this, void 0, void 0, function* () {
						return this.request(
							'DELETE',
							requestUrl,
							null,
							additionalHeaders || {},
						)
					})
				}
				post(requestUrl, data, additionalHeaders) {
					return __awaiter(this, void 0, void 0, function* () {
						return this.request(
							'POST',
							requestUrl,
							data,
							additionalHeaders || {},
						)
					})
				}
				patch(requestUrl, data, additionalHeaders) {
					return __awaiter(this, void 0, void 0, function* () {
						return this.request(
							'PATCH',
							requestUrl,
							data,
							additionalHeaders || {},
						)
					})
				}
				put(requestUrl, data, additionalHeaders) {
					return __awaiter(this, void 0, void 0, function* () {
						return this.request(
							'PUT',
							requestUrl,
							data,
							additionalHeaders || {},
						)
					})
				}
				head(requestUrl, additionalHeaders) {
					return __awaiter(this, void 0, void 0, function* () {
						return this.request(
							'HEAD',
							requestUrl,
							null,
							additionalHeaders || {},
						)
					})
				}
				sendStream(verb, requestUrl, stream, additionalHeaders) {
					return __awaiter(this, void 0, void 0, function* () {
						return this.request(verb, requestUrl, stream, additionalHeaders)
					})
				}
				/**
				 * Gets a typed object from an endpoint
				 * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
				 */
				getJson(requestUrl, additionalHeaders = {}) {
					return __awaiter(this, void 0, void 0, function* () {
						additionalHeaders[Headers.Accept] =
							this._getExistingOrDefaultHeader(
								additionalHeaders,
								Headers.Accept,
								MediaTypes.ApplicationJson,
							)
						const res = yield this.get(requestUrl, additionalHeaders)
						return this._processResponse(res, this.requestOptions)
					})
				}
				postJson(requestUrl, obj, additionalHeaders = {}) {
					return __awaiter(this, void 0, void 0, function* () {
						const data = JSON.stringify(obj, null, 2)
						additionalHeaders[Headers.Accept] =
							this._getExistingOrDefaultHeader(
								additionalHeaders,
								Headers.Accept,
								MediaTypes.ApplicationJson,
							)
						additionalHeaders[Headers.ContentType] =
							this._getExistingOrDefaultHeader(
								additionalHeaders,
								Headers.ContentType,
								MediaTypes.ApplicationJson,
							)
						const res = yield this.post(requestUrl, data, additionalHeaders)
						return this._processResponse(res, this.requestOptions)
					})
				}
				putJson(requestUrl, obj, additionalHeaders = {}) {
					return __awaiter(this, void 0, void 0, function* () {
						const data = JSON.stringify(obj, null, 2)
						additionalHeaders[Headers.Accept] =
							this._getExistingOrDefaultHeader(
								additionalHeaders,
								Headers.Accept,
								MediaTypes.ApplicationJson,
							)
						additionalHeaders[Headers.ContentType] =
							this._getExistingOrDefaultHeader(
								additionalHeaders,
								Headers.ContentType,
								MediaTypes.ApplicationJson,
							)
						const res = yield this.put(requestUrl, data, additionalHeaders)
						return this._processResponse(res, this.requestOptions)
					})
				}
				patchJson(requestUrl, obj, additionalHeaders = {}) {
					return __awaiter(this, void 0, void 0, function* () {
						const data = JSON.stringify(obj, null, 2)
						additionalHeaders[Headers.Accept] =
							this._getExistingOrDefaultHeader(
								additionalHeaders,
								Headers.Accept,
								MediaTypes.ApplicationJson,
							)
						additionalHeaders[Headers.ContentType] =
							this._getExistingOrDefaultHeader(
								additionalHeaders,
								Headers.ContentType,
								MediaTypes.ApplicationJson,
							)
						const res = yield this.patch(requestUrl, data, additionalHeaders)
						return this._processResponse(res, this.requestOptions)
					})
				}
				/**
				 * Makes a raw http request.
				 * All other methods such as get, post, patch, and request ultimately call this.
				 * Prefer get, del, post and patch
				 */
				request(verb, requestUrl, data, headers) {
					return __awaiter(this, void 0, void 0, function* () {
						if (this._disposed) {
							throw new Error('Client has already been disposed.')
						}
						const parsedUrl = new URL(requestUrl)
						let info = this._prepareRequest(verb, parsedUrl, headers)
						// Only perform retries on reads since writes may not be idempotent.
						const maxTries =
							this._allowRetries && RetryableHttpVerbs.includes(verb)
								? this._maxRetries + 1
								: 1
						let numTries = 0
						let response
						do {
							response = yield this.requestRaw(info, data)
							// Check if it's an authentication challenge
							if (
								response &&
								response.message &&
								response.message.statusCode === HttpCodes.Unauthorized
							) {
								let authenticationHandler
								for (const handler of this.handlers) {
									if (handler.canHandleAuthentication(response)) {
										authenticationHandler = handler
										break
									}
								}
								if (authenticationHandler) {
									return authenticationHandler.handleAuthentication(
										this,
										info,
										data,
									)
								} else {
									// We have received an unauthorized response but have no handlers to handle it.
									// Let the response return to the caller.
									return response
								}
							}
							let redirectsRemaining = this._maxRedirects
							while (
								response.message.statusCode &&
								HttpRedirectCodes.includes(response.message.statusCode) &&
								this._allowRedirects &&
								redirectsRemaining > 0
							) {
								const redirectUrl = response.message.headers['location']
								if (!redirectUrl) {
									// if there's no location to redirect to, we won't
									break
								}
								const parsedRedirectUrl = new URL(redirectUrl)
								if (
									parsedUrl.protocol === 'https:' &&
									parsedUrl.protocol !== parsedRedirectUrl.protocol &&
									!this._allowRedirectDowngrade
								) {
									throw new Error(
										'Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.',
									)
								}
								// we need to finish reading the response before reassigning response
								// which will leak the open socket.
								yield response.readBody()
								// strip authorization header if redirected to a different hostname
								if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
									for (const header in headers) {
										// header names are case insensitive
										if (header.toLowerCase() === 'authorization') {
											delete headers[header]
										}
									}
								}
								// let's make the request with the new redirectUrl
								info = this._prepareRequest(verb, parsedRedirectUrl, headers)
								response = yield this.requestRaw(info, data)
								redirectsRemaining--
							}
							if (
								!response.message.statusCode ||
								!HttpResponseRetryCodes.includes(response.message.statusCode)
							) {
								// If not a retry code, return immediately instead of retrying
								return response
							}
							numTries += 1
							if (numTries < maxTries) {
								yield response.readBody()
								yield this._performExponentialBackoff(numTries)
							}
						} while (numTries < maxTries)
						return response
					})
				}
				/**
				 * Needs to be called if keepAlive is set to true in request options.
				 */
				dispose() {
					if (this._agent) {
						this._agent.destroy()
					}
					this._disposed = true
				}
				/**
				 * Raw request.
				 * @param info
				 * @param data
				 */
				requestRaw(info, data) {
					return __awaiter(this, void 0, void 0, function* () {
						return new Promise((resolve, reject) => {
							function callbackForResult(err, res) {
								if (err) {
									reject(err)
								} else if (!res) {
									// If `err` is not passed, then `res` must be passed.
									reject(new Error('Unknown error'))
								} else {
									resolve(res)
								}
							}
							this.requestRawWithCallback(info, data, callbackForResult)
						})
					})
				}
				/**
				 * Raw request with callback.
				 * @param info
				 * @param data
				 * @param onResult
				 */
				requestRawWithCallback(info, data, onResult) {
					if (typeof data === 'string') {
						if (!info.options.headers) {
							info.options.headers = {}
						}
						info.options.headers['Content-Length'] = Buffer.byteLength(
							data,
							'utf8',
						)
					}
					let callbackCalled = false
					function handleResult(err, res) {
						if (!callbackCalled) {
							callbackCalled = true
							onResult(err, res)
						}
					}
					const req = info.httpModule.request(info.options, (msg) => {
						const res = new HttpClientResponse(msg)
						handleResult(undefined, res)
					})
					let socket
					req.on('socket', (sock) => {
						socket = sock
					})
					// If we ever get disconnected, we want the socket to timeout eventually
					req.setTimeout(this._socketTimeout || 3 * 60000, () => {
						if (socket) {
							socket.end()
						}
						handleResult(new Error(`Request timeout: ${info.options.path}`))
					})
					req.on('error', function (err) {
						// err has statusCode property
						// res should have headers
						handleResult(err)
					})
					if (data && typeof data === 'string') {
						req.write(data, 'utf8')
					}
					if (data && typeof data !== 'string') {
						data.on('close', function () {
							req.end()
						})
						data.pipe(req)
					} else {
						req.end()
					}
				}
				/**
				 * Gets an http agent. This function is useful when you need an http agent that handles
				 * routing through a proxy server - depending upon the url and proxy environment variables.
				 * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
				 */
				getAgent(serverUrl) {
					const parsedUrl = new URL(serverUrl)
					return this._getAgent(parsedUrl)
				}
				getAgentDispatcher(serverUrl) {
					const parsedUrl = new URL(serverUrl)
					const proxyUrl = pm.getProxyUrl(parsedUrl)
					const useProxy = proxyUrl && proxyUrl.hostname
					if (!useProxy) {
						return
					}
					return this._getProxyAgentDispatcher(parsedUrl, proxyUrl)
				}
				_prepareRequest(method, requestUrl, headers) {
					const info = {}
					info.parsedUrl = requestUrl
					const usingSsl = info.parsedUrl.protocol === 'https:'
					info.httpModule = usingSsl ? https : http
					const defaultPort = usingSsl ? 443 : 80
					info.options = {}
					info.options.host = info.parsedUrl.hostname
					info.options.port = info.parsedUrl.port
						? parseInt(info.parsedUrl.port)
						: defaultPort
					info.options.path =
						(info.parsedUrl.pathname || '') + (info.parsedUrl.search || '')
					info.options.method = method
					info.options.headers = this._mergeHeaders(headers)
					if (this.userAgent != null) {
						info.options.headers['user-agent'] = this.userAgent
					}
					info.options.agent = this._getAgent(info.parsedUrl)
					// gives handlers an opportunity to participate
					if (this.handlers) {
						for (const handler of this.handlers) {
							handler.prepareRequest(info.options)
						}
					}
					return info
				}
				_mergeHeaders(headers) {
					if (this.requestOptions && this.requestOptions.headers) {
						return Object.assign(
							{},
							lowercaseKeys(this.requestOptions.headers),
							lowercaseKeys(headers || {}),
						)
					}
					return lowercaseKeys(headers || {})
				}
				_getExistingOrDefaultHeader(additionalHeaders, header, _default) {
					let clientHeader
					if (this.requestOptions && this.requestOptions.headers) {
						clientHeader = lowercaseKeys(this.requestOptions.headers)[header]
					}
					return additionalHeaders[header] || clientHeader || _default
				}
				_getAgent(parsedUrl) {
					let agent
					const proxyUrl = pm.getProxyUrl(parsedUrl)
					const useProxy = proxyUrl && proxyUrl.hostname
					if (this._keepAlive && useProxy) {
						agent = this._proxyAgent
					}
					if (!useProxy) {
						agent = this._agent
					}
					// if agent is already assigned use that agent.
					if (agent) {
						return agent
					}
					const usingSsl = parsedUrl.protocol === 'https:'
					let maxSockets = 100
					if (this.requestOptions) {
						maxSockets =
							this.requestOptions.maxSockets || http.globalAgent.maxSockets
					}
					// This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.
					if (proxyUrl && proxyUrl.hostname) {
						const agentOptions = {
							maxSockets,
							keepAlive: this._keepAlive,
							proxy: Object.assign(
								Object.assign(
									{},
									(proxyUrl.username || proxyUrl.password) && {
										proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`,
									},
								),
								{ host: proxyUrl.hostname, port: proxyUrl.port },
							),
						}
						let tunnelAgent
						const overHttps = proxyUrl.protocol === 'https:'
						if (usingSsl) {
							tunnelAgent = overHttps
								? tunnel.httpsOverHttps
								: tunnel.httpsOverHttp
						} else {
							tunnelAgent = overHttps
								? tunnel.httpOverHttps
								: tunnel.httpOverHttp
						}
						agent = tunnelAgent(agentOptions)
						this._proxyAgent = agent
					}
					// if tunneling agent isn't assigned create a new agent
					if (!agent) {
						const options = { keepAlive: this._keepAlive, maxSockets }
						agent = usingSsl
							? new https.Agent(options)
							: new http.Agent(options)
						this._agent = agent
					}
					if (usingSsl && this._ignoreSslError) {
						// we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
						// http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
						// we have to cast it to any and change it directly
						agent.options = Object.assign(agent.options || {}, {
							rejectUnauthorized: false,
						})
					}
					return agent
				}
				_getProxyAgentDispatcher(parsedUrl, proxyUrl) {
					let proxyAgent
					if (this._keepAlive) {
						proxyAgent = this._proxyAgentDispatcher
					}
					// if agent is already assigned use that agent.
					if (proxyAgent) {
						return proxyAgent
					}
					const usingSsl = parsedUrl.protocol === 'https:'
					proxyAgent = new undici_1.ProxyAgent(
						Object.assign(
							{ uri: proxyUrl.href, pipelining: !this._keepAlive ? 0 : 1 },
							(proxyUrl.username || proxyUrl.password) && {
								token: `Basic ${Buffer.from(`${proxyUrl.username}:${proxyUrl.password}`).toString('base64')}`,
							},
						),
					)
					this._proxyAgentDispatcher = proxyAgent
					if (usingSsl && this._ignoreSslError) {
						// we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
						// http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
						// we have to cast it to any and change it directly
						proxyAgent.options = Object.assign(
							proxyAgent.options.requestTls || {},
							{
								rejectUnauthorized: false,
							},
						)
					}
					return proxyAgent
				}
				_performExponentialBackoff(retryNumber) {
					return __awaiter(this, void 0, void 0, function* () {
						retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber)
						const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber)
						return new Promise((resolve) => setTimeout(() => resolve(), ms))
					})
				}
				_processResponse(res, options) {
					return __awaiter(this, void 0, void 0, function* () {
						return new Promise((resolve, reject) =>
							__awaiter(this, void 0, void 0, function* () {
								const statusCode = res.message.statusCode || 0
								const response = {
									statusCode,
									result: null,
									headers: {},
								}
								// not found leads to null obj returned
								if (statusCode === HttpCodes.NotFound) {
									resolve(response)
								}
								// get the result from the body
								function dateTimeDeserializer(key, value) {
									if (typeof value === 'string') {
										const a = new Date(value)
										if (!isNaN(a.valueOf())) {
											return a
										}
									}
									return value
								}
								let obj
								let contents
								try {
									contents = yield res.readBody()
									if (contents && contents.length > 0) {
										if (options && options.deserializeDates) {
											obj = JSON.parse(contents, dateTimeDeserializer)
										} else {
											obj = JSON.parse(contents)
										}
										response.result = obj
									}
									response.headers = res.message.headers
								} catch (err) {
									// Invalid resource (contents not json);  leaving result obj null
								}
								// note that 3xx redirects are handled by the http layer.
								if (statusCode > 299) {
									let msg
									// if exception/error in body, attempt to get better error
									if (obj && obj.message) {
										msg = obj.message
									} else if (contents && contents.length > 0) {
										// it may be the case that the exception is in the body message as string
										msg = contents
									} else {
										msg = `Failed request: (${statusCode})`
									}
									const err = new HttpClientError(msg, statusCode)
									err.result = response.result
									reject(err)
								} else {
									resolve(response)
								}
							}),
						)
					})
				}
			}
			exports.HttpClient = HttpClient
			const lowercaseKeys = (obj) =>
				Object.keys(obj).reduce(
					(c, k) => ((c[k.toLowerCase()] = obj[k]), c),
					{},
				)
			//# sourceMappingURL=index.js.map

			/***/
		},

		/***/ 54988: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', { value: true })
			exports.checkBypass = exports.getProxyUrl = void 0
			function getProxyUrl(reqUrl) {
				const usingSsl = reqUrl.protocol === 'https:'
				if (checkBypass(reqUrl)) {
					return undefined
				}
				const proxyVar = (() => {
					if (usingSsl) {
						return process.env['https_proxy'] || process.env['HTTPS_PROXY']
					} else {
						return process.env['http_proxy'] || process.env['HTTP_PROXY']
					}
				})()
				if (proxyVar) {
					try {
						return new DecodedURL(proxyVar)
					} catch (_a) {
						if (
							!proxyVar.startsWith('http://') &&
							!proxyVar.startsWith('https://')
						)
							return new DecodedURL(`http://${proxyVar}`)
					}
				} else {
					return undefined
				}
			}
			exports.getProxyUrl = getProxyUrl
			function checkBypass(reqUrl) {
				if (!reqUrl.hostname) {
					return false
				}
				const reqHost = reqUrl.hostname
				if (isLoopbackAddress(reqHost)) {
					return true
				}
				const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || ''
				if (!noProxy) {
					return false
				}
				// Determine the request port
				let reqPort
				if (reqUrl.port) {
					reqPort = Number(reqUrl.port)
				} else if (reqUrl.protocol === 'http:') {
					reqPort = 80
				} else if (reqUrl.protocol === 'https:') {
					reqPort = 443
				}
				// Format the request hostname and hostname with port
				const upperReqHosts = [reqUrl.hostname.toUpperCase()]
				if (typeof reqPort === 'number') {
					upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`)
				}
				// Compare request host against noproxy
				for (const upperNoProxyItem of noProxy
					.split(',')
					.map((x) => x.trim().toUpperCase())
					.filter((x) => x)) {
					if (
						upperNoProxyItem === '*' ||
						upperReqHosts.some(
							(x) =>
								x === upperNoProxyItem ||
								x.endsWith(`.${upperNoProxyItem}`) ||
								(upperNoProxyItem.startsWith('.') &&
									x.endsWith(`${upperNoProxyItem}`)),
						)
					) {
						return true
					}
				}
				return false
			}
			exports.checkBypass = checkBypass
			function isLoopbackAddress(host) {
				const hostLower = host.toLowerCase()
				return (
					hostLower === 'localhost' ||
					hostLower.startsWith('127.') ||
					hostLower.startsWith('[::1]') ||
					hostLower.startsWith('[0:0:0:0:0:0:0:1]')
				)
			}
			class DecodedURL extends URL {
				constructor(url, base) {
					super(url, base)
					this._decodedUsername = decodeURIComponent(super.username)
					this._decodedPassword = decodeURIComponent(super.password)
				}
				get username() {
					return this._decodedUsername
				}
				get password() {
					return this._decodedPassword
				}
			}
			//# sourceMappingURL=proxy.js.map

			/***/
		},

		/***/ 75207: /***/ function (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) {
			'use strict'

			var __createBinding =
				(this && this.__createBinding) ||
				(Object.create
					? function (o, m, k, k2) {
							if (k2 === undefined) k2 = k
							Object.defineProperty(o, k2, {
								enumerable: true,
								get: function () {
									return m[k]
								},
							})
						}
					: function (o, m, k, k2) {
							if (k2 === undefined) k2 = k
							o[k2] = m[k]
						})
			var __setModuleDefault =
				(this && this.__setModuleDefault) ||
				(Object.create
					? function (o, v) {
							Object.defineProperty(o, 'default', {
								enumerable: true,
								value: v,
							})
						}
					: function (o, v) {
							o['default'] = v
						})
			var __importStar =
				(this && this.__importStar) ||
				function (mod) {
					if (mod && mod.__esModule) return mod
					var result = {}
					if (mod != null)
						for (var k in mod)
							if (k !== 'default' && Object.hasOwnProperty.call(mod, k))
								__createBinding(result, mod, k)
					__setModuleDefault(result, mod)
					return result
				}
			var __awaiter =
				(this && this.__awaiter) ||
				function (thisArg, _arguments, P, generator) {
					function adopt(value) {
						return value instanceof P
							? value
							: new P(function (resolve) {
									resolve(value)
								})
					}
					return new (P || (P = Promise))(function (resolve, reject) {
						function fulfilled(value) {
							try {
								step(generator.next(value))
							} catch (e) {
								reject(e)
							}
						}
						function rejected(value) {
							try {
								step(generator['throw'](value))
							} catch (e) {
								reject(e)
							}
						}
						function step(result) {
							result.done
								? resolve(result.value)
								: adopt(result.value).then(fulfilled, rejected)
						}
						step(
							(generator = generator.apply(thisArg, _arguments || [])).next(),
						)
					})
				}
			var _a
			Object.defineProperty(exports, '__esModule', { value: true })
			exports.getCmdPath =
				exports.tryGetExecutablePath =
				exports.isRooted =
				exports.isDirectory =
				exports.exists =
				exports.READONLY =
				exports.UV_FS_O_EXLOCK =
				exports.IS_WINDOWS =
				exports.unlink =
				exports.symlink =
				exports.stat =
				exports.rmdir =
				exports.rm =
				exports.rename =
				exports.readlink =
				exports.readdir =
				exports.open =
				exports.mkdir =
				exports.lstat =
				exports.copyFile =
				exports.chmod =
					void 0
			const fs = __importStar(__nccwpck_require__(79896))
			const path = __importStar(__nccwpck_require__(16928))
			;(_a = fs.promises),
				// export const {open} = 'fs'
				(exports.chmod = _a.chmod),
				(exports.copyFile = _a.copyFile),
				(exports.lstat = _a.lstat),
				(exports.mkdir = _a.mkdir),
				(exports.open = _a.open),
				(exports.readdir = _a.readdir),
				(exports.readlink = _a.readlink),
				(exports.rename = _a.rename),
				(exports.rm = _a.rm),
				(exports.rmdir = _a.rmdir),
				(exports.stat = _a.stat),
				(exports.symlink = _a.symlink),
				(exports.unlink = _a.unlink)
			// export const {open} = 'fs'
			exports.IS_WINDOWS = process.platform === 'win32'
			// See https://github.com/nodejs/node/blob/d0153aee367422d0858105abec186da4dff0a0c5/deps/uv/include/uv/win.h#L691
			exports.UV_FS_O_EXLOCK = 0x10000000
			exports.READONLY = fs.constants.O_RDONLY
			function exists(fsPath) {
				return __awaiter(this, void 0, void 0, function* () {
					try {
						yield exports.stat(fsPath)
					} catch (err) {
						if (err.code === 'ENOENT') {
							return false
						}
						throw err
					}
					return true
				})
			}
			exports.exists = exists
			function isDirectory(fsPath, useStat = false) {
				return __awaiter(this, void 0, void 0, function* () {
					const stats = useStat
						? yield exports.stat(fsPath)
						: yield exports.lstat(fsPath)
					return stats.isDirectory()
				})
			}
			exports.isDirectory = isDirectory
			/**
			 * On OSX/Linux, true if path starts with '/'. On Windows, true for paths like:
			 * \, \hello, \\hello\share, C:, and C:\hello (and corresponding alternate separator cases).
			 */
			function isRooted(p) {
				p = normalizeSeparators(p)
				if (!p) {
					throw new Error('isRooted() parameter "p" cannot be empty')
				}
				if (exports.IS_WINDOWS) {
					return (
						p.startsWith('\\') || /^[A-Z]:/i.test(p) // e.g. \ or \hello or \\hello
					) // e.g. C: or C:\hello
				}
				return p.startsWith('/')
			}
			exports.isRooted = isRooted
			/**
			 * Best effort attempt to determine whether a file exists and is executable.
			 * @param filePath    file path to check
			 * @param extensions  additional file extensions to try
			 * @return if file exists and is executable, returns the file path. otherwise empty string.
			 */
			function tryGetExecutablePath(filePath, extensions) {
				return __awaiter(this, void 0, void 0, function* () {
					let stats = undefined
					try {
						// test file exists
						stats = yield exports.stat(filePath)
					} catch (err) {
						if (err.code !== 'ENOENT') {
							// eslint-disable-next-line no-console
							console.log(
								`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`,
							)
						}
					}
					if (stats && stats.isFile()) {
						if (exports.IS_WINDOWS) {
							// on Windows, test for valid extension
							const upperExt = path.extname(filePath).toUpperCase()
							if (
								extensions.some(
									(validExt) => validExt.toUpperCase() === upperExt,
								)
							) {
								return filePath
							}
						} else {
							if (isUnixExecutable(stats)) {
								return filePath
							}
						}
					}
					// try each extension
					const originalFilePath = filePath
					for (const extension of extensions) {
						filePath = originalFilePath + extension
						stats = undefined
						try {
							stats = yield exports.stat(filePath)
						} catch (err) {
							if (err.code !== 'ENOENT') {
								// eslint-disable-next-line no-console
								console.log(
									`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`,
								)
							}
						}
						if (stats && stats.isFile()) {
							if (exports.IS_WINDOWS) {
								// preserve the case of the actual file (since an extension was appended)
								try {
									const directory = path.dirname(filePath)
									const upperName = path.basename(filePath).toUpperCase()
									for (const actualName of yield exports.readdir(directory)) {
										if (upperName === actualName.toUpperCase()) {
											filePath = path.join(directory, actualName)
											break
										}
									}
								} catch (err) {
									// eslint-disable-next-line no-console
									console.log(
										`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`,
									)
								}
								return filePath
							} else {
								if (isUnixExecutable(stats)) {
									return filePath
								}
							}
						}
					}
					return ''
				})
			}
			exports.tryGetExecutablePath = tryGetExecutablePath
			function normalizeSeparators(p) {
				p = p || ''
				if (exports.IS_WINDOWS) {
					// convert slashes on Windows
					p = p.replace(/\//g, '\\')
					// remove redundant slashes
					return p.replace(/\\\\+/g, '\\')
				}
				// remove redundant slashes
				return p.replace(/\/\/+/g, '/')
			}
			// on Mac/Linux, test the execute bit
			//     R   W  X  R  W X R W X
			//   256 128 64 32 16 8 4 2 1
			function isUnixExecutable(stats) {
				return (
					(stats.mode & 1) > 0 ||
					((stats.mode & 8) > 0 && stats.gid === process.getgid()) ||
					((stats.mode & 64) > 0 && stats.uid === process.getuid())
				)
			}
			// Get the path of cmd.exe in windows
			function getCmdPath() {
				var _a
				return (_a = process.env['COMSPEC']) !== null && _a !== void 0
					? _a
					: `cmd.exe`
			}
			exports.getCmdPath = getCmdPath
			//# sourceMappingURL=io-util.js.map

			/***/
		},

		/***/ 94994: /***/ function (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) {
			'use strict'

			var __createBinding =
				(this && this.__createBinding) ||
				(Object.create
					? function (o, m, k, k2) {
							if (k2 === undefined) k2 = k
							Object.defineProperty(o, k2, {
								enumerable: true,
								get: function () {
									return m[k]
								},
							})
						}
					: function (o, m, k, k2) {
							if (k2 === undefined) k2 = k
							o[k2] = m[k]
						})
			var __setModuleDefault =
				(this && this.__setModuleDefault) ||
				(Object.create
					? function (o, v) {
							Object.defineProperty(o, 'default', {
								enumerable: true,
								value: v,
							})
						}
					: function (o, v) {
							o['default'] = v
						})
			var __importStar =
				(this && this.__importStar) ||
				function (mod) {
					if (mod && mod.__esModule) return mod
					var result = {}
					if (mod != null)
						for (var k in mod)
							if (k !== 'default' && Object.hasOwnProperty.call(mod, k))
								__createBinding(result, mod, k)
					__setModuleDefault(result, mod)
					return result
				}
			var __awaiter =
				(this && this.__awaiter) ||
				function (thisArg, _arguments, P, generator) {
					function adopt(value) {
						return value instanceof P
							? value
							: new P(function (resolve) {
									resolve(value)
								})
					}
					return new (P || (P = Promise))(function (resolve, reject) {
						function fulfilled(value) {
							try {
								step(generator.next(value))
							} catch (e) {
								reject(e)
							}
						}
						function rejected(value) {
							try {
								step(generator['throw'](value))
							} catch (e) {
								reject(e)
							}
						}
						function step(result) {
							result.done
								? resolve(result.value)
								: adopt(result.value).then(fulfilled, rejected)
						}
						step(
							(generator = generator.apply(thisArg, _arguments || [])).next(),
						)
					})
				}
			Object.defineProperty(exports, '__esModule', { value: true })
			exports.findInPath =
				exports.which =
				exports.mkdirP =
				exports.rmRF =
				exports.mv =
				exports.cp =
					void 0
			const assert_1 = __nccwpck_require__(42613)
			const path = __importStar(__nccwpck_require__(16928))
			const ioUtil = __importStar(__nccwpck_require__(75207))
			/**
			 * Copies a file or folder.
			 * Based off of shelljs - https://github.com/shelljs/shelljs/blob/9237f66c52e5daa40458f94f9565e18e8132f5a6/src/cp.js
			 *
			 * @param     source    source path
			 * @param     dest      destination path
			 * @param     options   optional. See CopyOptions.
			 */
			function cp(source, dest, options = {}) {
				return __awaiter(this, void 0, void 0, function* () {
					const { force, recursive, copySourceDirectory } =
						readCopyOptions(options)
					const destStat = (yield ioUtil.exists(dest))
						? yield ioUtil.stat(dest)
						: null
					// Dest is an existing file, but not forcing
					if (destStat && destStat.isFile() && !force) {
						return
					}
					// If dest is an existing directory, should copy inside.
					const newDest =
						destStat && destStat.isDirectory() && copySourceDirectory
							? path.join(dest, path.basename(source))
							: dest
					if (!(yield ioUtil.exists(source))) {
						throw new Error(`no such file or directory: ${source}`)
					}
					const sourceStat = yield ioUtil.stat(source)
					if (sourceStat.isDirectory()) {
						if (!recursive) {
							throw new Error(
								`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`,
							)
						} else {
							yield cpDirRecursive(source, newDest, 0, force)
						}
					} else {
						if (path.relative(source, newDest) === '') {
							// a file cannot be copied to itself
							throw new Error(`'${newDest}' and '${source}' are the same file`)
						}
						yield copyFile(source, newDest, force)
					}
				})
			}
			exports.cp = cp
			/**
			 * Moves a path.
			 *
			 * @param     source    source path
			 * @param     dest      destination path
			 * @param     options   optional. See MoveOptions.
			 */
			function mv(source, dest, options = {}) {
				return __awaiter(this, void 0, void 0, function* () {
					if (yield ioUtil.exists(dest)) {
						let destExists = true
						if (yield ioUtil.isDirectory(dest)) {
							// If dest is directory copy src into dest
							dest = path.join(dest, path.basename(source))
							destExists = yield ioUtil.exists(dest)
						}
						if (destExists) {
							if (options.force == null || options.force) {
								yield rmRF(dest)
							} else {
								throw new Error('Destination already exists')
							}
						}
					}
					yield mkdirP(path.dirname(dest))
					yield ioUtil.rename(source, dest)
				})
			}
			exports.mv = mv
			/**
			 * Remove a path recursively with force
			 *
			 * @param inputPath path to remove
			 */
			function rmRF(inputPath) {
				return __awaiter(this, void 0, void 0, function* () {
					if (ioUtil.IS_WINDOWS) {
						// Check for invalid characters
						// https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file
						if (/[*"<>|]/.test(inputPath)) {
							throw new Error(
								'File path must not contain `*`, `"`, `<`, `>` or `|` on Windows',
							)
						}
					}
					try {
						// note if path does not exist, error is silent
						yield ioUtil.rm(inputPath, {
							force: true,
							maxRetries: 3,
							recursive: true,
							retryDelay: 300,
						})
					} catch (err) {
						throw new Error(`File was unable to be removed ${err}`)
					}
				})
			}
			exports.rmRF = rmRF
			/**
			 * Make a directory.  Creates the full path with folders in between
			 * Will throw if it fails
			 *
			 * @param   fsPath        path to create
			 * @returns Promise<void>
			 */
			function mkdirP(fsPath) {
				return __awaiter(this, void 0, void 0, function* () {
					assert_1.ok(fsPath, 'a path argument must be provided')
					yield ioUtil.mkdir(fsPath, { recursive: true })
				})
			}
			exports.mkdirP = mkdirP
			/**
			 * Returns path of a tool had the tool actually been invoked.  Resolves via paths.
			 * If you check and the tool does not exist, it will throw.
			 *
			 * @param     tool              name of the tool
			 * @param     check             whether to check if tool exists
			 * @returns   Promise<string>   path to tool
			 */
			function which(tool, check) {
				return __awaiter(this, void 0, void 0, function* () {
					if (!tool) {
						throw new Error("parameter 'tool' is required")
					}
					// recursive when check=true
					if (check) {
						const result = yield which(tool, false)
						if (!result) {
							if (ioUtil.IS_WINDOWS) {
								throw new Error(
									`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`,
								)
							} else {
								throw new Error(
									`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`,
								)
							}
						}
						return result
					}
					const matches = yield findInPath(tool)
					if (matches && matches.length > 0) {
						return matches[0]
					}
					return ''
				})
			}
			exports.which = which
			/**
			 * Returns a list of all occurrences of the given tool on the system path.
			 *
			 * @returns   Promise<string[]>  the paths of the tool
			 */
			function findInPath(tool) {
				return __awaiter(this, void 0, void 0, function* () {
					if (!tool) {
						throw new Error("parameter 'tool' is required")
					}
					// build the list of extensions to try
					const extensions = []
					if (ioUtil.IS_WINDOWS && process.env['PATHEXT']) {
						for (const extension of process.env['PATHEXT'].split(
							path.delimiter,
						)) {
							if (extension) {
								extensions.push(extension)
							}
						}
					}
					// if it's rooted, return it if exists. otherwise return empty.
					if (ioUtil.isRooted(tool)) {
						const filePath = yield ioUtil.tryGetExecutablePath(tool, extensions)
						if (filePath) {
							return [filePath]
						}
						return []
					}
					// if any path separators, return empty
					if (tool.includes(path.sep)) {
						return []
					}
					// build the list of directories
					//
					// Note, technically "where" checks the current directory on Windows. From a toolkit perspective,
					// it feels like we should not do this. Checking the current directory seems like more of a use
					// case of a shell, and the which() function exposed by the toolkit should strive for consistency
					// across platforms.
					const directories = []
					if (process.env.PATH) {
						for (const p of process.env.PATH.split(path.delimiter)) {
							if (p) {
								directories.push(p)
							}
						}
					}
					// find all matches
					const matches = []
					for (const directory of directories) {
						const filePath = yield ioUtil.tryGetExecutablePath(
							path.join(directory, tool),
							extensions,
						)
						if (filePath) {
							matches.push(filePath)
						}
					}
					return matches
				})
			}
			exports.findInPath = findInPath
			function readCopyOptions(options) {
				const force = options.force == null ? true : options.force
				const recursive = Boolean(options.recursive)
				const copySourceDirectory =
					options.copySourceDirectory == null
						? true
						: Boolean(options.copySourceDirectory)
				return { force, recursive, copySourceDirectory }
			}
			function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
				return __awaiter(this, void 0, void 0, function* () {
					// Ensure there is not a run away recursive copy
					if (currentDepth >= 255) return
					currentDepth++
					yield mkdirP(destDir)
					const files = yield ioUtil.readdir(sourceDir)
					for (const fileName of files) {
						const srcFile = `${sourceDir}/${fileName}`
						const destFile = `${destDir}/${fileName}`
						const srcFileStat = yield ioUtil.lstat(srcFile)
						if (srcFileStat.isDirectory()) {
							// Recurse
							yield cpDirRecursive(srcFile, destFile, currentDepth, force)
						} else {
							yield copyFile(srcFile, destFile, force)
						}
					}
					// Change the mode for the newly created directory
					yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode)
				})
			}
			// Buffered file copy
			function copyFile(srcFile, destFile, force) {
				return __awaiter(this, void 0, void 0, function* () {
					if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {
						// unlink/re-link it
						try {
							yield ioUtil.lstat(destFile)
							yield ioUtil.unlink(destFile)
						} catch (e) {
							// Try to override file permission
							if (e.code === 'EPERM') {
								yield ioUtil.chmod(destFile, '0666')
								yield ioUtil.unlink(destFile)
							}
							// other errors = it doesn't exist, no work to do
						}
						// Copy over symlink
						const symlinkFull = yield ioUtil.readlink(srcFile)
						yield ioUtil.symlink(
							symlinkFull,
							destFile,
							ioUtil.IS_WINDOWS ? 'junction' : null,
						)
					} else if (!(yield ioUtil.exists(destFile)) || force) {
						yield ioUtil.copyFile(srcFile, destFile)
					}
				})
			}
			//# sourceMappingURL=io.js.map

			/***/
		},

		/***/ 46268: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.makeWeakCache = makeWeakCache
			exports.makeWeakCacheSync = makeWeakCacheSync
			exports.makeStrongCache = makeStrongCache
			exports.makeStrongCacheSync = makeStrongCacheSync
			exports.assertSimpleType = assertSimpleType

			function _gensync() {
				const data = _interopRequireDefault(__nccwpck_require__(9621))

				_gensync = function () {
					return data
				}

				return data
			}

			var _async = __nccwpck_require__(87360)

			var _util = __nccwpck_require__(54493)

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			const synchronize = (gen) => {
				return (0, _gensync().default)(gen).sync
			}

			function* genTrue(data) {
				return true
			}

			function makeWeakCache(handler) {
				return makeCachedFunction(WeakMap, handler)
			}

			function makeWeakCacheSync(handler) {
				return synchronize(makeWeakCache(handler))
			}

			function makeStrongCache(handler) {
				return makeCachedFunction(Map, handler)
			}

			function makeStrongCacheSync(handler) {
				return synchronize(makeStrongCache(handler))
			}

			function makeCachedFunction(CallCache, handler) {
				const callCacheSync = new CallCache()
				const callCacheAsync = new CallCache()
				const futureCache = new CallCache()
				return function* cachedFunction(arg, data) {
					const asyncContext = yield* (0, _async.isAsync)()
					const callCache = asyncContext ? callCacheAsync : callCacheSync
					const cached = yield* getCachedValueOrWait(
						asyncContext,
						callCache,
						futureCache,
						arg,
						data,
					)
					if (cached.valid) return cached.value
					const cache = new CacheConfigurator(data)
					const handlerResult = handler(arg, cache)
					let finishLock
					let value

					if ((0, _util.isIterableIterator)(handlerResult)) {
						const gen = handlerResult
						value = yield* (0, _async.onFirstPause)(gen, () => {
							finishLock = setupAsyncLocks(cache, futureCache, arg)
						})
					} else {
						value = handlerResult
					}

					updateFunctionCache(callCache, cache, arg, value)

					if (finishLock) {
						futureCache.delete(arg)
						finishLock.release(value)
					}

					return value
				}
			}

			function* getCachedValue(cache, arg, data) {
				const cachedValue = cache.get(arg)

				if (cachedValue) {
					for (const { value, valid } of cachedValue) {
						if (yield* valid(data))
							return {
								valid: true,
								value,
							}
					}
				}

				return {
					valid: false,
					value: null,
				}
			}

			function* getCachedValueOrWait(
				asyncContext,
				callCache,
				futureCache,
				arg,
				data,
			) {
				const cached = yield* getCachedValue(callCache, arg, data)

				if (cached.valid) {
					return cached
				}

				if (asyncContext) {
					const cached = yield* getCachedValue(futureCache, arg, data)

					if (cached.valid) {
						const value = yield* (0, _async.waitFor)(cached.value.promise)
						return {
							valid: true,
							value,
						}
					}
				}

				return {
					valid: false,
					value: null,
				}
			}

			function setupAsyncLocks(config, futureCache, arg) {
				const finishLock = new Lock()
				updateFunctionCache(futureCache, config, arg, finishLock)
				return finishLock
			}

			function updateFunctionCache(cache, config, arg, value) {
				if (!config.configured()) config.forever()
				let cachedValue = cache.get(arg)
				config.deactivate()

				switch (config.mode()) {
					case 'forever':
						cachedValue = [
							{
								value,
								valid: genTrue,
							},
						]
						cache.set(arg, cachedValue)
						break

					case 'invalidate':
						cachedValue = [
							{
								value,
								valid: config.validator(),
							},
						]
						cache.set(arg, cachedValue)
						break

					case 'valid':
						if (cachedValue) {
							cachedValue.push({
								value,
								valid: config.validator(),
							})
						} else {
							cachedValue = [
								{
									value,
									valid: config.validator(),
								},
							]
							cache.set(arg, cachedValue)
						}
				}
			}

			class CacheConfigurator {
				constructor(data) {
					this._active = true
					this._never = false
					this._forever = false
					this._invalidate = false
					this._configured = false
					this._pairs = []
					this._data = void 0
					this._data = data
				}

				simple() {
					return makeSimpleConfigurator(this)
				}

				mode() {
					if (this._never) return 'never'
					if (this._forever) return 'forever'
					if (this._invalidate) return 'invalidate'
					return 'valid'
				}

				forever() {
					if (!this._active) {
						throw new Error(
							'Cannot change caching after evaluation has completed.',
						)
					}

					if (this._never) {
						throw new Error('Caching has already been configured with .never()')
					}

					this._forever = true
					this._configured = true
				}

				never() {
					if (!this._active) {
						throw new Error(
							'Cannot change caching after evaluation has completed.',
						)
					}

					if (this._forever) {
						throw new Error(
							'Caching has already been configured with .forever()',
						)
					}

					this._never = true
					this._configured = true
				}

				using(handler) {
					if (!this._active) {
						throw new Error(
							'Cannot change caching after evaluation has completed.',
						)
					}

					if (this._never || this._forever) {
						throw new Error(
							'Caching has already been configured with .never or .forever()',
						)
					}

					this._configured = true
					const key = handler(this._data)
					const fn = (0, _async.maybeAsync)(
						handler,
						`You appear to be using an async cache handler, but Babel has been called synchronously`,
					)

					if ((0, _async.isThenable)(key)) {
						return key.then((key) => {
							this._pairs.push([key, fn])

							return key
						})
					}

					this._pairs.push([key, fn])

					return key
				}

				invalidate(handler) {
					this._invalidate = true
					return this.using(handler)
				}

				validator() {
					const pairs = this._pairs
					return function* (data) {
						for (const [key, fn] of pairs) {
							if (key !== (yield* fn(data))) return false
						}

						return true
					}
				}

				deactivate() {
					this._active = false
				}

				configured() {
					return this._configured
				}
			}

			function makeSimpleConfigurator(cache) {
				function cacheFn(val) {
					if (typeof val === 'boolean') {
						if (val) cache.forever()
						else cache.never()
						return
					}

					return cache.using(() => assertSimpleType(val()))
				}

				cacheFn.forever = () => cache.forever()

				cacheFn.never = () => cache.never()

				cacheFn.using = (cb) => cache.using(() => assertSimpleType(cb()))

				cacheFn.invalidate = (cb) =>
					cache.invalidate(() => assertSimpleType(cb()))

				return cacheFn
			}

			function assertSimpleType(value) {
				if ((0, _async.isThenable)(value)) {
					throw new Error(
						`You appear to be using an async cache handler, ` +
							`which your current version of Babel does not support. ` +
							`We may add support for this in the future, ` +
							`but if you're on the most recent version of @babel/core and still ` +
							`seeing this error, then you'll need to synchronously handle your caching logic.`,
					)
				}

				if (
					value != null &&
					typeof value !== 'string' &&
					typeof value !== 'boolean' &&
					typeof value !== 'number'
				) {
					throw new Error(
						'Cache keys must be either string, boolean, number, null, or undefined.',
					)
				}

				return value
			}

			class Lock {
				constructor() {
					this.released = false
					this.promise = void 0
					this._resolve = void 0
					this.promise = new Promise((resolve) => {
						this._resolve = resolve
					})
				}

				release(value) {
					this.released = true

					this._resolve(value)
				}
			}

			/***/
		},

		/***/ 70835: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.buildPresetChain = buildPresetChain
			exports.buildRootChain = buildRootChain
			exports.buildPresetChainWalker = void 0

			function _path() {
				const data = _interopRequireDefault(__nccwpck_require__(16928))

				_path = function () {
					return data
				}

				return data
			}

			function _debug() {
				const data = _interopRequireDefault(__nccwpck_require__(2830))

				_debug = function () {
					return data
				}

				return data
			}

			var _options = __nccwpck_require__(44743)

			var _patternToRegex = _interopRequireDefault(__nccwpck_require__(79619))

			var _printer = __nccwpck_require__(30333)

			var _files = __nccwpck_require__(37217)

			var _caching = __nccwpck_require__(46268)

			var _configDescriptors = __nccwpck_require__(2420)

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			const debug = (0, _debug().default)('babel:config:config-chain')

			function* buildPresetChain(arg, context) {
				const chain = yield* buildPresetChainWalker(arg, context)
				if (!chain) return null
				return {
					plugins: dedupDescriptors(chain.plugins),
					presets: dedupDescriptors(chain.presets),
					options: chain.options.map((o) => normalizeOptions(o)),
					files: new Set(),
				}
			}

			const buildPresetChainWalker = makeChainWalker({
				root: (preset) => loadPresetDescriptors(preset),
				env: (preset, envName) => loadPresetEnvDescriptors(preset)(envName),
				overrides: (preset, index) =>
					loadPresetOverridesDescriptors(preset)(index),
				overridesEnv: (preset, index, envName) =>
					loadPresetOverridesEnvDescriptors(preset)(index)(envName),
				createLogger: () => () => {},
			})
			exports.buildPresetChainWalker = buildPresetChainWalker
			const loadPresetDescriptors = (0, _caching.makeWeakCacheSync)((preset) =>
				buildRootDescriptors(
					preset,
					preset.alias,
					_configDescriptors.createUncachedDescriptors,
				),
			)
			const loadPresetEnvDescriptors = (0, _caching.makeWeakCacheSync)(
				(preset) =>
					(0, _caching.makeStrongCacheSync)((envName) =>
						buildEnvDescriptors(
							preset,
							preset.alias,
							_configDescriptors.createUncachedDescriptors,
							envName,
						),
					),
			)
			const loadPresetOverridesDescriptors = (0, _caching.makeWeakCacheSync)(
				(preset) =>
					(0, _caching.makeStrongCacheSync)((index) =>
						buildOverrideDescriptors(
							preset,
							preset.alias,
							_configDescriptors.createUncachedDescriptors,
							index,
						),
					),
			)
			const loadPresetOverridesEnvDescriptors = (0, _caching.makeWeakCacheSync)(
				(preset) =>
					(0, _caching.makeStrongCacheSync)((index) =>
						(0, _caching.makeStrongCacheSync)((envName) =>
							buildOverrideEnvDescriptors(
								preset,
								preset.alias,
								_configDescriptors.createUncachedDescriptors,
								index,
								envName,
							),
						),
					),
			)

			function* buildRootChain(opts, context) {
				let configReport, babelRcReport
				const programmaticLogger = new _printer.ConfigPrinter()
				const programmaticChain = yield* loadProgrammaticChain(
					{
						options: opts,
						dirname: context.cwd,
					},
					context,
					undefined,
					programmaticLogger,
				)
				if (!programmaticChain) return null
				const programmaticReport = programmaticLogger.output()
				let configFile

				if (typeof opts.configFile === 'string') {
					configFile = yield* (0, _files.loadConfig)(
						opts.configFile,
						context.cwd,
						context.envName,
						context.caller,
					)
				} else if (opts.configFile !== false) {
					configFile = yield* (0, _files.findRootConfig)(
						context.root,
						context.envName,
						context.caller,
					)
				}

				let { babelrc, babelrcRoots } = opts
				let babelrcRootsDirectory = context.cwd
				const configFileChain = emptyChain()
				const configFileLogger = new _printer.ConfigPrinter()

				if (configFile) {
					const validatedFile = validateConfigFile(configFile)
					const result = yield* loadFileChain(
						validatedFile,
						context,
						undefined,
						configFileLogger,
					)
					if (!result) return null
					configReport = configFileLogger.output()

					if (babelrc === undefined) {
						babelrc = validatedFile.options.babelrc
					}

					if (babelrcRoots === undefined) {
						babelrcRootsDirectory = validatedFile.dirname
						babelrcRoots = validatedFile.options.babelrcRoots
					}

					mergeChain(configFileChain, result)
				}

				const pkgData =
					typeof context.filename === 'string'
						? yield* (0, _files.findPackageData)(context.filename)
						: null
				let ignoreFile, babelrcFile
				let isIgnored = false
				const fileChain = emptyChain()

				if (
					(babelrc === true || babelrc === undefined) &&
					pkgData &&
					babelrcLoadEnabled(
						context,
						pkgData,
						babelrcRoots,
						babelrcRootsDirectory,
					)
				) {
					;({ ignore: ignoreFile, config: babelrcFile } = yield* (0,
					_files.findRelativeConfig)(pkgData, context.envName, context.caller))

					if (ignoreFile) {
						fileChain.files.add(ignoreFile.filepath)
					}

					if (
						ignoreFile &&
						shouldIgnore(context, ignoreFile.ignore, null, ignoreFile.dirname)
					) {
						isIgnored = true
					}

					if (babelrcFile && !isIgnored) {
						const validatedFile = validateBabelrcFile(babelrcFile)
						const babelrcLogger = new _printer.ConfigPrinter()
						const result = yield* loadFileChain(
							validatedFile,
							context,
							undefined,
							babelrcLogger,
						)

						if (!result) {
							isIgnored = true
						} else {
							babelRcReport = babelrcLogger.output()
							mergeChain(fileChain, result)
						}
					}

					if (babelrcFile && isIgnored) {
						fileChain.files.add(babelrcFile.filepath)
					}
				}

				if (context.showConfig) {
					console.log(
						`Babel configs on "${context.filename}" (ascending priority):\n` +
							[configReport, babelRcReport, programmaticReport]
								.filter((x) => !!x)
								.join('\n\n'),
					)
					return null
				}

				const chain = mergeChain(
					mergeChain(mergeChain(emptyChain(), configFileChain), fileChain),
					programmaticChain,
				)
				return {
					plugins: isIgnored ? [] : dedupDescriptors(chain.plugins),
					presets: isIgnored ? [] : dedupDescriptors(chain.presets),
					options: isIgnored
						? []
						: chain.options.map((o) => normalizeOptions(o)),
					fileHandling: isIgnored ? 'ignored' : 'transpile',
					ignore: ignoreFile || undefined,
					babelrc: babelrcFile || undefined,
					config: configFile || undefined,
					files: chain.files,
				}
			}

			function babelrcLoadEnabled(
				context,
				pkgData,
				babelrcRoots,
				babelrcRootsDirectory,
			) {
				if (typeof babelrcRoots === 'boolean') return babelrcRoots
				const absoluteRoot = context.root

				if (babelrcRoots === undefined) {
					return pkgData.directories.indexOf(absoluteRoot) !== -1
				}

				let babelrcPatterns = babelrcRoots
				if (!Array.isArray(babelrcPatterns)) babelrcPatterns = [babelrcPatterns]
				babelrcPatterns = babelrcPatterns.map((pat) => {
					return typeof pat === 'string'
						? _path().default.resolve(babelrcRootsDirectory, pat)
						: pat
				})

				if (
					babelrcPatterns.length === 1 &&
					babelrcPatterns[0] === absoluteRoot
				) {
					return pkgData.directories.indexOf(absoluteRoot) !== -1
				}

				return babelrcPatterns.some((pat) => {
					if (typeof pat === 'string') {
						pat = (0, _patternToRegex.default)(pat, babelrcRootsDirectory)
					}

					return pkgData.directories.some((directory) => {
						return matchPattern(pat, babelrcRootsDirectory, directory, context)
					})
				})
			}

			const validateConfigFile = (0, _caching.makeWeakCacheSync)((file) => ({
				filepath: file.filepath,
				dirname: file.dirname,
				options: (0, _options.validate)('configfile', file.options),
			}))
			const validateBabelrcFile = (0, _caching.makeWeakCacheSync)((file) => ({
				filepath: file.filepath,
				dirname: file.dirname,
				options: (0, _options.validate)('babelrcfile', file.options),
			}))
			const validateExtendFile = (0, _caching.makeWeakCacheSync)((file) => ({
				filepath: file.filepath,
				dirname: file.dirname,
				options: (0, _options.validate)('extendsfile', file.options),
			}))
			const loadProgrammaticChain = makeChainWalker({
				root: (input) =>
					buildRootDescriptors(
						input,
						'base',
						_configDescriptors.createCachedDescriptors,
					),
				env: (input, envName) =>
					buildEnvDescriptors(
						input,
						'base',
						_configDescriptors.createCachedDescriptors,
						envName,
					),
				overrides: (input, index) =>
					buildOverrideDescriptors(
						input,
						'base',
						_configDescriptors.createCachedDescriptors,
						index,
					),
				overridesEnv: (input, index, envName) =>
					buildOverrideEnvDescriptors(
						input,
						'base',
						_configDescriptors.createCachedDescriptors,
						index,
						envName,
					),
				createLogger: (input, context, baseLogger) =>
					buildProgrammaticLogger(input, context, baseLogger),
			})
			const loadFileChainWalker = makeChainWalker({
				root: (file) => loadFileDescriptors(file),
				env: (file, envName) => loadFileEnvDescriptors(file)(envName),
				overrides: (file, index) => loadFileOverridesDescriptors(file)(index),
				overridesEnv: (file, index, envName) =>
					loadFileOverridesEnvDescriptors(file)(index)(envName),
				createLogger: (file, context, baseLogger) =>
					buildFileLogger(file.filepath, context, baseLogger),
			})

			function* loadFileChain(input, context, files, baseLogger) {
				const chain = yield* loadFileChainWalker(
					input,
					context,
					files,
					baseLogger,
				)

				if (chain) {
					chain.files.add(input.filepath)
				}

				return chain
			}

			const loadFileDescriptors = (0, _caching.makeWeakCacheSync)((file) =>
				buildRootDescriptors(
					file,
					file.filepath,
					_configDescriptors.createUncachedDescriptors,
				),
			)
			const loadFileEnvDescriptors = (0, _caching.makeWeakCacheSync)((file) =>
				(0, _caching.makeStrongCacheSync)((envName) =>
					buildEnvDescriptors(
						file,
						file.filepath,
						_configDescriptors.createUncachedDescriptors,
						envName,
					),
				),
			)
			const loadFileOverridesDescriptors = (0, _caching.makeWeakCacheSync)(
				(file) =>
					(0, _caching.makeStrongCacheSync)((index) =>
						buildOverrideDescriptors(
							file,
							file.filepath,
							_configDescriptors.createUncachedDescriptors,
							index,
						),
					),
			)
			const loadFileOverridesEnvDescriptors = (0, _caching.makeWeakCacheSync)(
				(file) =>
					(0, _caching.makeStrongCacheSync)((index) =>
						(0, _caching.makeStrongCacheSync)((envName) =>
							buildOverrideEnvDescriptors(
								file,
								file.filepath,
								_configDescriptors.createUncachedDescriptors,
								index,
								envName,
							),
						),
					),
			)

			function buildFileLogger(filepath, context, baseLogger) {
				if (!baseLogger) {
					return () => {}
				}

				return baseLogger.configure(
					context.showConfig,
					_printer.ChainFormatter.Config,
					{
						filepath,
					},
				)
			}

			function buildRootDescriptors({ dirname, options }, alias, descriptors) {
				return descriptors(dirname, options, alias)
			}

			function buildProgrammaticLogger(_, context, baseLogger) {
				var _context$caller

				if (!baseLogger) {
					return () => {}
				}

				return baseLogger.configure(
					context.showConfig,
					_printer.ChainFormatter.Programmatic,
					{
						callerName:
							(_context$caller = context.caller) == null
								? void 0
								: _context$caller.name,
					},
				)
			}

			function buildEnvDescriptors(
				{ dirname, options },
				alias,
				descriptors,
				envName,
			) {
				const opts = options.env && options.env[envName]
				return opts
					? descriptors(dirname, opts, `${alias}.env["${envName}"]`)
					: null
			}

			function buildOverrideDescriptors(
				{ dirname, options },
				alias,
				descriptors,
				index,
			) {
				const opts = options.overrides && options.overrides[index]
				if (!opts) throw new Error('Assertion failure - missing override')
				return descriptors(dirname, opts, `${alias}.overrides[${index}]`)
			}

			function buildOverrideEnvDescriptors(
				{ dirname, options },
				alias,
				descriptors,
				index,
				envName,
			) {
				const override = options.overrides && options.overrides[index]
				if (!override) throw new Error('Assertion failure - missing override')
				const opts = override.env && override.env[envName]
				return opts
					? descriptors(
							dirname,
							opts,
							`${alias}.overrides[${index}].env["${envName}"]`,
						)
					: null
			}

			function makeChainWalker({
				root,
				env,
				overrides,
				overridesEnv,
				createLogger,
			}) {
				return function* (input, context, files = new Set(), baseLogger) {
					const { dirname } = input
					const flattenedConfigs = []
					const rootOpts = root(input)

					if (configIsApplicable(rootOpts, dirname, context)) {
						flattenedConfigs.push({
							config: rootOpts,
							envName: undefined,
							index: undefined,
						})
						const envOpts = env(input, context.envName)

						if (envOpts && configIsApplicable(envOpts, dirname, context)) {
							flattenedConfigs.push({
								config: envOpts,
								envName: context.envName,
								index: undefined,
							})
						}

						;(rootOpts.options.overrides || []).forEach((_, index) => {
							const overrideOps = overrides(input, index)

							if (configIsApplicable(overrideOps, dirname, context)) {
								flattenedConfigs.push({
									config: overrideOps,
									index,
									envName: undefined,
								})
								const overrideEnvOpts = overridesEnv(
									input,
									index,
									context.envName,
								)

								if (
									overrideEnvOpts &&
									configIsApplicable(overrideEnvOpts, dirname, context)
								) {
									flattenedConfigs.push({
										config: overrideEnvOpts,
										index,
										envName: context.envName,
									})
								}
							}
						})
					}

					if (
						flattenedConfigs.some(
							({
								config: {
									options: { ignore, only },
								},
							}) => shouldIgnore(context, ignore, only, dirname),
						)
					) {
						return null
					}

					const chain = emptyChain()
					const logger = createLogger(input, context, baseLogger)

					for (const { config, index, envName } of flattenedConfigs) {
						if (
							!(yield* mergeExtendsChain(
								chain,
								config.options,
								dirname,
								context,
								files,
								baseLogger,
							))
						) {
							return null
						}

						logger(config, index, envName)
						mergeChainOpts(chain, config)
					}

					return chain
				}
			}

			function* mergeExtendsChain(
				chain,
				opts,
				dirname,
				context,
				files,
				baseLogger,
			) {
				if (opts.extends === undefined) return true
				const file = yield* (0, _files.loadConfig)(
					opts.extends,
					dirname,
					context.envName,
					context.caller,
				)

				if (files.has(file)) {
					throw new Error(
						`Configuration cycle detected loading ${file.filepath}.\n` +
							`File already loaded following the config chain:\n` +
							Array.from(files, (file) => ` - ${file.filepath}`).join('\n'),
					)
				}

				files.add(file)
				const fileChain = yield* loadFileChain(
					validateExtendFile(file),
					context,
					files,
					baseLogger,
				)
				files.delete(file)
				if (!fileChain) return false
				mergeChain(chain, fileChain)
				return true
			}

			function mergeChain(target, source) {
				target.options.push(...source.options)
				target.plugins.push(...source.plugins)
				target.presets.push(...source.presets)

				for (const file of source.files) {
					target.files.add(file)
				}

				return target
			}

			function mergeChainOpts(target, { options, plugins, presets }) {
				target.options.push(options)
				target.plugins.push(...plugins())
				target.presets.push(...presets())
				return target
			}

			function emptyChain() {
				return {
					options: [],
					presets: [],
					plugins: [],
					files: new Set(),
				}
			}

			function normalizeOptions(opts) {
				const options = Object.assign({}, opts)
				delete options.extends
				delete options.env
				delete options.overrides
				delete options.plugins
				delete options.presets
				delete options.passPerPreset
				delete options.ignore
				delete options.only
				delete options.test
				delete options.include
				delete options.exclude

				if (Object.prototype.hasOwnProperty.call(options, 'sourceMap')) {
					options.sourceMaps = options.sourceMap
					delete options.sourceMap
				}

				return options
			}

			function dedupDescriptors(items) {
				const map = new Map()
				const descriptors = []

				for (const item of items) {
					if (typeof item.value === 'function') {
						const fnKey = item.value
						let nameMap = map.get(fnKey)

						if (!nameMap) {
							nameMap = new Map()
							map.set(fnKey, nameMap)
						}

						let desc = nameMap.get(item.name)

						if (!desc) {
							desc = {
								value: item,
							}
							descriptors.push(desc)
							if (!item.ownPass) nameMap.set(item.name, desc)
						} else {
							desc.value = item
						}
					} else {
						descriptors.push({
							value: item,
						})
					}
				}

				return descriptors.reduce((acc, desc) => {
					acc.push(desc.value)
					return acc
				}, [])
			}

			function configIsApplicable({ options }, dirname, context) {
				return (
					(options.test === undefined ||
						configFieldIsApplicable(context, options.test, dirname)) &&
					(options.include === undefined ||
						configFieldIsApplicable(context, options.include, dirname)) &&
					(options.exclude === undefined ||
						!configFieldIsApplicable(context, options.exclude, dirname))
				)
			}

			function configFieldIsApplicable(context, test, dirname) {
				const patterns = Array.isArray(test) ? test : [test]
				return matchesPatterns(context, patterns, dirname)
			}

			function shouldIgnore(context, ignore, only, dirname) {
				if (ignore && matchesPatterns(context, ignore, dirname)) {
					var _context$filename

					const message = `No config is applied to "${(_context$filename = context.filename) != null ? _context$filename : '(unknown)'}" because it matches one of \`ignore: ${JSON.stringify(ignore)}\` from "${dirname}"`
					debug(message)

					if (context.showConfig) {
						console.log(message)
					}

					return true
				}

				if (only && !matchesPatterns(context, only, dirname)) {
					var _context$filename2

					const message = `No config is applied to "${(_context$filename2 = context.filename) != null ? _context$filename2 : '(unknown)'}" because it fails to match one of \`only: ${JSON.stringify(only)}\` from "${dirname}"`
					debug(message)

					if (context.showConfig) {
						console.log(message)
					}

					return true
				}

				return false
			}

			function matchesPatterns(context, patterns, dirname) {
				return patterns.some((pattern) =>
					matchPattern(pattern, dirname, context.filename, context),
				)
			}

			function matchPattern(pattern, dirname, pathToTest, context) {
				if (typeof pattern === 'function') {
					return !!pattern(pathToTest, {
						dirname,
						envName: context.envName,
						caller: context.caller,
					})
				}

				if (typeof pathToTest !== 'string') {
					throw new Error(
						`Configuration contains string/RegExp pattern, but no filename was passed to Babel`,
					)
				}

				if (typeof pattern === 'string') {
					pattern = (0, _patternToRegex.default)(pattern, dirname)
				}

				return pattern.test(pathToTest)
			}

			/***/
		},

		/***/ 2420: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.createCachedDescriptors = createCachedDescriptors
			exports.createUncachedDescriptors = createUncachedDescriptors
			exports.createDescriptor = createDescriptor

			var _files = __nccwpck_require__(37217)

			var _item = __nccwpck_require__(72478)

			var _caching = __nccwpck_require__(46268)

			function isEqualDescriptor(a, b) {
				return (
					a.name === b.name &&
					a.value === b.value &&
					a.options === b.options &&
					a.dirname === b.dirname &&
					a.alias === b.alias &&
					a.ownPass === b.ownPass &&
					(a.file && a.file.request) === (b.file && b.file.request) &&
					(a.file && a.file.resolved) === (b.file && b.file.resolved)
				)
			}

			function createCachedDescriptors(dirname, options, alias) {
				const { plugins, presets, passPerPreset } = options
				return {
					options,
					plugins: plugins
						? () => createCachedPluginDescriptors(plugins, dirname)(alias)
						: () => [],
					presets: presets
						? () =>
								createCachedPresetDescriptors(presets, dirname)(alias)(
									!!passPerPreset,
								)
						: () => [],
				}
			}

			function createUncachedDescriptors(dirname, options, alias) {
				let plugins
				let presets
				return {
					options,
					plugins: () => {
						if (!plugins) {
							plugins = createPluginDescriptors(
								options.plugins || [],
								dirname,
								alias,
							)
						}

						return plugins
					},
					presets: () => {
						if (!presets) {
							presets = createPresetDescriptors(
								options.presets || [],
								dirname,
								alias,
								!!options.passPerPreset,
							)
						}

						return presets
					},
				}
			}

			const PRESET_DESCRIPTOR_CACHE = new WeakMap()
			const createCachedPresetDescriptors = (0, _caching.makeWeakCacheSync)(
				(items, cache) => {
					const dirname = cache.using((dir) => dir)
					return (0, _caching.makeStrongCacheSync)((alias) =>
						(0, _caching.makeStrongCacheSync)((passPerPreset) =>
							createPresetDescriptors(items, dirname, alias, passPerPreset).map(
								(desc) => loadCachedDescriptor(PRESET_DESCRIPTOR_CACHE, desc),
							),
						),
					)
				},
			)
			const PLUGIN_DESCRIPTOR_CACHE = new WeakMap()
			const createCachedPluginDescriptors = (0, _caching.makeWeakCacheSync)(
				(items, cache) => {
					const dirname = cache.using((dir) => dir)
					return (0, _caching.makeStrongCacheSync)((alias) =>
						createPluginDescriptors(items, dirname, alias).map((desc) =>
							loadCachedDescriptor(PLUGIN_DESCRIPTOR_CACHE, desc),
						),
					)
				},
			)
			const DEFAULT_OPTIONS = {}

			function loadCachedDescriptor(cache, desc) {
				const { value, options = DEFAULT_OPTIONS } = desc
				if (options === false) return desc
				let cacheByOptions = cache.get(value)

				if (!cacheByOptions) {
					cacheByOptions = new WeakMap()
					cache.set(value, cacheByOptions)
				}

				let possibilities = cacheByOptions.get(options)

				if (!possibilities) {
					possibilities = []
					cacheByOptions.set(options, possibilities)
				}

				if (possibilities.indexOf(desc) === -1) {
					const matches = possibilities.filter((possibility) =>
						isEqualDescriptor(possibility, desc),
					)

					if (matches.length > 0) {
						return matches[0]
					}

					possibilities.push(desc)
				}

				return desc
			}

			function createPresetDescriptors(items, dirname, alias, passPerPreset) {
				return createDescriptors('preset', items, dirname, alias, passPerPreset)
			}

			function createPluginDescriptors(items, dirname, alias) {
				return createDescriptors('plugin', items, dirname, alias)
			}

			function createDescriptors(type, items, dirname, alias, ownPass) {
				const descriptors = items.map((item, index) =>
					createDescriptor(item, dirname, {
						type,
						alias: `${alias}$${index}`,
						ownPass: !!ownPass,
					}),
				)
				assertNoDuplicates(descriptors)
				return descriptors
			}

			function createDescriptor(pair, dirname, { type, alias, ownPass }) {
				const desc = (0, _item.getItemDescriptor)(pair)

				if (desc) {
					return desc
				}

				let name
				let options
				let value = pair

				if (Array.isArray(value)) {
					if (value.length === 3) {
						;[value, options, name] = value
					} else {
						;[value, options] = value
					}
				}

				let file = undefined
				let filepath = null

				if (typeof value === 'string') {
					if (typeof type !== 'string') {
						throw new Error(
							'To resolve a string-based item, the type of item must be given',
						)
					}

					const resolver =
						type === 'plugin' ? _files.loadPlugin : _files.loadPreset
					const request = value
					;({ filepath, value } = resolver(value, dirname))
					file = {
						request,
						resolved: filepath,
					}
				}

				if (!value) {
					throw new Error(`Unexpected falsy value: ${String(value)}`)
				}

				if (typeof value === 'object' && value.__esModule) {
					if (value.default) {
						value = value.default
					} else {
						throw new Error(
							'Must export a default export when using ES6 modules.',
						)
					}
				}

				if (typeof value !== 'object' && typeof value !== 'function') {
					throw new Error(
						`Unsupported format: ${typeof value}. Expected an object or a function.`,
					)
				}

				if (filepath !== null && typeof value === 'object' && value) {
					throw new Error(
						`Plugin/Preset files are not allowed to export objects, only functions. In ${filepath}`,
					)
				}

				return {
					name,
					alias: filepath || alias,
					value,
					options,
					dirname,
					ownPass,
					file,
				}
			}

			function assertNoDuplicates(items) {
				const map = new Map()

				for (const item of items) {
					if (typeof item.value !== 'function') continue
					let nameMap = map.get(item.value)

					if (!nameMap) {
						nameMap = new Set()
						map.set(item.value, nameMap)
					}

					if (nameMap.has(item.name)) {
						const conflicts = items.filter((i) => i.value === item.value)
						throw new Error(
							[
								`Duplicate plugin/preset detected.`,
								`If you'd like to use two separate instances of a plugin,`,
								`they need separate names, e.g.`,
								``,
								`  plugins: [`,
								`    ['some-plugin', {}],`,
								`    ['some-plugin', {}, 'some unique name'],`,
								`  ]`,
								``,
								`Duplicates detected are:`,
								`${JSON.stringify(conflicts, null, 2)}`,
							].join('\n'),
						)
					}

					nameMap.add(item.name)
				}
			}

			/***/
		},

		/***/ 86199: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.findConfigUpwards = findConfigUpwards
			exports.findRelativeConfig = findRelativeConfig
			exports.findRootConfig = findRootConfig
			exports.loadConfig = loadConfig
			exports.resolveShowConfigPath = resolveShowConfigPath
			exports.ROOT_CONFIG_FILENAMES = void 0

			function _debug() {
				const data = _interopRequireDefault(__nccwpck_require__(2830))

				_debug = function () {
					return data
				}

				return data
			}

			function _path() {
				const data = _interopRequireDefault(__nccwpck_require__(16928))

				_path = function () {
					return data
				}

				return data
			}

			function _json() {
				const data = _interopRequireDefault(__nccwpck_require__(84841))

				_json = function () {
					return data
				}

				return data
			}

			function _gensync() {
				const data = _interopRequireDefault(__nccwpck_require__(9621))

				_gensync = function () {
					return data
				}

				return data
			}

			var _caching = __nccwpck_require__(46268)

			var _configApi = _interopRequireDefault(__nccwpck_require__(33700))

			var _utils = __nccwpck_require__(748)

			var _moduleTypes = _interopRequireDefault(__nccwpck_require__(67465))

			var _patternToRegex = _interopRequireDefault(__nccwpck_require__(79619))

			var fs = _interopRequireWildcard(__nccwpck_require__(10733))

			var _resolve = _interopRequireDefault(__nccwpck_require__(12620))

			function _getRequireWildcardCache() {
				if (typeof WeakMap !== 'function') return null
				var cache = new WeakMap()
				_getRequireWildcardCache = function () {
					return cache
				}
				return cache
			}

			function _interopRequireWildcard(obj) {
				if (obj && obj.__esModule) {
					return obj
				}
				if (
					obj === null ||
					(typeof obj !== 'object' && typeof obj !== 'function')
				) {
					return { default: obj }
				}
				var cache = _getRequireWildcardCache()
				if (cache && cache.has(obj)) {
					return cache.get(obj)
				}
				var newObj = {}
				var hasPropertyDescriptor =
					Object.defineProperty && Object.getOwnPropertyDescriptor
				for (var key in obj) {
					if (Object.prototype.hasOwnProperty.call(obj, key)) {
						var desc = hasPropertyDescriptor
							? Object.getOwnPropertyDescriptor(obj, key)
							: null
						if (desc && (desc.get || desc.set)) {
							Object.defineProperty(newObj, key, desc)
						} else {
							newObj[key] = obj[key]
						}
					}
				}
				newObj.default = obj
				if (cache) {
					cache.set(obj, newObj)
				}
				return newObj
			}

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			const debug = (0, _debug().default)(
				'babel:config:loading:files:configuration',
			)
			const ROOT_CONFIG_FILENAMES = [
				'babel.config.js',
				'babel.config.cjs',
				'babel.config.mjs',
				'babel.config.json',
			]
			exports.ROOT_CONFIG_FILENAMES = ROOT_CONFIG_FILENAMES
			const RELATIVE_CONFIG_FILENAMES = [
				'.babelrc',
				'.babelrc.js',
				'.babelrc.cjs',
				'.babelrc.mjs',
				'.babelrc.json',
			]
			const BABELIGNORE_FILENAME = '.babelignore'

			function* findConfigUpwards(rootDir) {
				let dirname = rootDir

				while (true) {
					for (const filename of ROOT_CONFIG_FILENAMES) {
						if (yield* fs.exists(_path().default.join(dirname, filename))) {
							return dirname
						}
					}

					const nextDir = _path().default.dirname(dirname)

					if (dirname === nextDir) break
					dirname = nextDir
				}

				return null
			}

			function* findRelativeConfig(packageData, envName, caller) {
				let config = null
				let ignore = null

				const dirname = _path().default.dirname(packageData.filepath)

				for (const loc of packageData.directories) {
					if (!config) {
						var _packageData$pkg

						config = yield* loadOneConfig(
							RELATIVE_CONFIG_FILENAMES,
							loc,
							envName,
							caller,
							((_packageData$pkg = packageData.pkg) == null
								? void 0
								: _packageData$pkg.dirname) === loc
								? packageToBabelConfig(packageData.pkg)
								: null,
						)
					}

					if (!ignore) {
						const ignoreLoc = _path().default.join(loc, BABELIGNORE_FILENAME)

						ignore = yield* readIgnoreConfig(ignoreLoc)

						if (ignore) {
							debug('Found ignore %o from %o.', ignore.filepath, dirname)
						}
					}
				}

				return {
					config,
					ignore,
				}
			}

			function findRootConfig(dirname, envName, caller) {
				return loadOneConfig(ROOT_CONFIG_FILENAMES, dirname, envName, caller)
			}

			function* loadOneConfig(
				names,
				dirname,
				envName,
				caller,
				previousConfig = null,
			) {
				const configs = yield* _gensync().default.all(
					names.map((filename) =>
						readConfig(
							_path().default.join(dirname, filename),
							envName,
							caller,
						),
					),
				)
				const config = configs.reduce((previousConfig, config) => {
					if (config && previousConfig) {
						throw new Error(
							`Multiple configuration files found. Please remove one:\n` +
								` - ${_path().default.basename(previousConfig.filepath)}\n` +
								` - ${config.filepath}\n` +
								`from ${dirname}`,
						)
					}

					return config || previousConfig
				}, previousConfig)

				if (config) {
					debug('Found configuration %o from %o.', config.filepath, dirname)
				}

				return config
			}

			function* loadConfig(name, dirname, envName, caller) {
				const filepath = yield* (0, _resolve.default)(name, {
					basedir: dirname,
				})
				const conf = yield* readConfig(filepath, envName, caller)

				if (!conf) {
					throw new Error(
						`Config file ${filepath} contains no configuration data`,
					)
				}

				debug('Loaded config %o from %o.', name, dirname)
				return conf
			}

			function readConfig(filepath, envName, caller) {
				const ext = _path().default.extname(filepath)

				return ext === '.js' || ext === '.cjs' || ext === '.mjs'
					? readConfigJS(filepath, {
							envName,
							caller,
						})
					: readConfigJSON5(filepath)
			}

			const LOADING_CONFIGS = new Set()
			const readConfigJS = (0, _caching.makeStrongCache)(
				function* readConfigJS(filepath, cache) {
					if (!fs.exists.sync(filepath)) {
						cache.forever()
						return null
					}

					if (LOADING_CONFIGS.has(filepath)) {
						cache.never()
						debug('Auto-ignoring usage of config %o.', filepath)
						return {
							filepath,
							dirname: _path().default.dirname(filepath),
							options: {},
						}
					}

					let options

					try {
						LOADING_CONFIGS.add(filepath)
						options = yield* (0, _moduleTypes.default)(
							filepath,
							'You appear to be using a native ECMAScript module configuration ' +
								'file, which is only supported when running Babel asynchronously.',
						)
					} catch (err) {
						err.message = `${filepath}: Error while loading config - ${err.message}`
						throw err
					} finally {
						LOADING_CONFIGS.delete(filepath)
					}

					let assertCache = false

					if (typeof options === 'function') {
						yield* []
						options = options((0, _configApi.default)(cache))
						assertCache = true
					}

					if (
						!options ||
						typeof options !== 'object' ||
						Array.isArray(options)
					) {
						throw new Error(
							`${filepath}: Configuration should be an exported JavaScript object.`,
						)
					}

					if (typeof options.then === 'function') {
						throw new Error(
							`You appear to be using an async configuration, ` +
								`which your current version of Babel does not support. ` +
								`We may add support for this in the future, ` +
								`but if you're on the most recent version of @babel/core and still ` +
								`seeing this error, then you'll need to synchronously return your config.`,
						)
					}

					if (assertCache && !cache.configured()) throwConfigError()
					return {
						filepath,
						dirname: _path().default.dirname(filepath),
						options,
					}
				},
			)
			const packageToBabelConfig = (0, _caching.makeWeakCacheSync)((file) => {
				const babel = file.options['babel']
				if (typeof babel === 'undefined') return null

				if (
					typeof babel !== 'object' ||
					Array.isArray(babel) ||
					babel === null
				) {
					throw new Error(`${file.filepath}: .babel property must be an object`)
				}

				return {
					filepath: file.filepath,
					dirname: file.dirname,
					options: babel,
				}
			})
			const readConfigJSON5 = (0, _utils.makeStaticFileCache)(
				(filepath, content) => {
					let options

					try {
						options = _json().default.parse(content)
					} catch (err) {
						err.message = `${filepath}: Error while parsing config - ${err.message}`
						throw err
					}

					if (!options) throw new Error(`${filepath}: No config detected`)

					if (typeof options !== 'object') {
						throw new Error(
							`${filepath}: Config returned typeof ${typeof options}`,
						)
					}

					if (Array.isArray(options)) {
						throw new Error(
							`${filepath}: Expected config object but found array`,
						)
					}

					return {
						filepath,
						dirname: _path().default.dirname(filepath),
						options,
					}
				},
			)
			const readIgnoreConfig = (0, _utils.makeStaticFileCache)(
				(filepath, content) => {
					const ignoreDir = _path().default.dirname(filepath)

					const ignorePatterns = content
						.split('\n')
						.map((line) => line.replace(/#(.*?)$/, '').trim())
						.filter((line) => !!line)

					for (const pattern of ignorePatterns) {
						if (pattern[0] === '!') {
							throw new Error(`Negation of file paths is not supported.`)
						}
					}

					return {
						filepath,
						dirname: _path().default.dirname(filepath),
						ignore: ignorePatterns.map((pattern) =>
							(0, _patternToRegex.default)(pattern, ignoreDir),
						),
					}
				},
			)

			function* resolveShowConfigPath(dirname) {
				const targetPath = process.env.BABEL_SHOW_CONFIG_FOR

				if (targetPath != null) {
					const absolutePath = _path().default.resolve(dirname, targetPath)

					const stats = yield* fs.stat(absolutePath)

					if (!stats.isFile()) {
						throw new Error(
							`${absolutePath}: BABEL_SHOW_CONFIG_FOR must refer to a regular file, directories are not supported.`,
						)
					}

					return absolutePath
				}

				return null
			}

			function throwConfigError() {
				throw new Error(`\
Caching was left unconfigured. Babel's plugins, presets, and .babelrc.js files can be configured
for various types of caching, using the first param of their handler functions:

module.exports = function(api) {
  // The API exposes the following:

  // Cache the returned value forever and don't call this function again.
  api.cache(true);

  // Don't cache at all. Not recommended because it will be very slow.
  api.cache(false);

  // Cached based on the value of some function. If this function returns a value different from
  // a previously-encountered value, the plugins will re-evaluate.
  var env = api.cache(() => process.env.NODE_ENV);

  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for
  // any possible NODE_ENV value that might come up during plugin execution.
  var isProd = api.cache(() => process.env.NODE_ENV === "production");

  // .cache(fn) will perform a linear search though instances to find the matching plugin based
  // based on previous instantiated plugins. If you want to recreate the plugin and discard the
  // previous instance whenever something changes, you may use:
  var isProd = api.cache.invalidate(() => process.env.NODE_ENV === "production");

  // Note, we also expose the following more-verbose versions of the above examples:
  api.cache.forever(); // api.cache(true)
  api.cache.never();   // api.cache(false)
  api.cache.using(fn); // api.cache(fn)

  // Return the value that will be cached.
  return { };
};`)
			}

			/***/
		},

		/***/ 81028: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'
			var __webpack_unused_export__

			__webpack_unused_export__ = {
				value: true,
			}
			exports.A = import_

			function import_(filepath) {
				return __nccwpck_require__(18541)(filepath)
			}

			/***/
		},

		/***/ 37217: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			Object.defineProperty(exports, 'findPackageData', {
				enumerable: true,
				get: function () {
					return _package.findPackageData
				},
			})
			Object.defineProperty(exports, 'findConfigUpwards', {
				enumerable: true,
				get: function () {
					return _configuration.findConfigUpwards
				},
			})
			Object.defineProperty(exports, 'findRelativeConfig', {
				enumerable: true,
				get: function () {
					return _configuration.findRelativeConfig
				},
			})
			Object.defineProperty(exports, 'findRootConfig', {
				enumerable: true,
				get: function () {
					return _configuration.findRootConfig
				},
			})
			Object.defineProperty(exports, 'loadConfig', {
				enumerable: true,
				get: function () {
					return _configuration.loadConfig
				},
			})
			Object.defineProperty(exports, 'resolveShowConfigPath', {
				enumerable: true,
				get: function () {
					return _configuration.resolveShowConfigPath
				},
			})
			Object.defineProperty(exports, 'ROOT_CONFIG_FILENAMES', {
				enumerable: true,
				get: function () {
					return _configuration.ROOT_CONFIG_FILENAMES
				},
			})
			Object.defineProperty(exports, 'resolvePlugin', {
				enumerable: true,
				get: function () {
					return _plugins.resolvePlugin
				},
			})
			Object.defineProperty(exports, 'resolvePreset', {
				enumerable: true,
				get: function () {
					return _plugins.resolvePreset
				},
			})
			Object.defineProperty(exports, 'loadPlugin', {
				enumerable: true,
				get: function () {
					return _plugins.loadPlugin
				},
			})
			Object.defineProperty(exports, 'loadPreset', {
				enumerable: true,
				get: function () {
					return _plugins.loadPreset
				},
			})

			var _package = __nccwpck_require__(70597)

			var _configuration = __nccwpck_require__(86199)

			var _plugins = __nccwpck_require__(19669)

			;({})

			/***/
		},

		/***/ 67465: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = loadCjsOrMjsDefault

			var _async = __nccwpck_require__(87360)

			function _path() {
				const data = _interopRequireDefault(__nccwpck_require__(16928))

				_path = function () {
					return data
				}

				return data
			}

			function _url() {
				const data = __nccwpck_require__(87016)

				_url = function () {
					return data
				}

				return data
			}

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			function asyncGeneratorStep(
				gen,
				resolve,
				reject,
				_next,
				_throw,
				key,
				arg,
			) {
				try {
					var info = gen[key](arg)
					var value = info.value
				} catch (error) {
					reject(error)
					return
				}
				if (info.done) {
					resolve(value)
				} else {
					Promise.resolve(value).then(_next, _throw)
				}
			}

			function _asyncToGenerator(fn) {
				return function () {
					var self = this,
						args = arguments
					return new Promise(function (resolve, reject) {
						var gen = fn.apply(self, args)
						function _next(value) {
							asyncGeneratorStep(
								gen,
								resolve,
								reject,
								_next,
								_throw,
								'next',
								value,
							)
						}
						function _throw(err) {
							asyncGeneratorStep(
								gen,
								resolve,
								reject,
								_next,
								_throw,
								'throw',
								err,
							)
						}
						_next(undefined)
					})
				}
			}

			let import_

			try {
				import_ = __nccwpck_require__(81028) /* ["default"] */.A
			} catch (_unused) {}

			function* loadCjsOrMjsDefault(filepath, asyncError) {
				switch (guessJSModuleType(filepath)) {
					case 'cjs':
						return loadCjsDefault(filepath)

					case 'unknown':
						try {
							return loadCjsDefault(filepath)
						} catch (e) {
							if (e.code !== 'ERR_REQUIRE_ESM') throw e
						}

					case 'mjs':
						if (yield* (0, _async.isAsync)()) {
							return yield* (0, _async.waitFor)(loadMjsDefault(filepath))
						}

						throw new Error(asyncError)
				}
			}

			function guessJSModuleType(filename) {
				switch (_path().default.extname(filename)) {
					case '.cjs':
						return 'cjs'

					case '.mjs':
						return 'mjs'

					default:
						return 'unknown'
				}
			}

			function loadCjsDefault(filepath) {
				const module = require(filepath)

				return (module == null ? void 0 : module.__esModule)
					? module.default || undefined
					: module
			}

			function loadMjsDefault(_x) {
				return _loadMjsDefault.apply(this, arguments)
			}

			function _loadMjsDefault() {
				_loadMjsDefault = _asyncToGenerator(function* (filepath) {
					if (!import_) {
						throw new Error(
							"Internal error: Native ECMAScript modules aren't supported" +
								' by this platform.\n',
						)
					}

					const module = yield import_((0, _url().pathToFileURL)(filepath))
					return module.default
				})
				return _loadMjsDefault.apply(this, arguments)
			}

			/***/
		},

		/***/ 70597: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.findPackageData = findPackageData

			function _path() {
				const data = _interopRequireDefault(__nccwpck_require__(16928))

				_path = function () {
					return data
				}

				return data
			}

			var _utils = __nccwpck_require__(748)

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			const PACKAGE_FILENAME = 'package.json'

			function* findPackageData(filepath) {
				let pkg = null
				const directories = []
				let isPackage = true

				let dirname = _path().default.dirname(filepath)

				while (!pkg && _path().default.basename(dirname) !== 'node_modules') {
					directories.push(dirname)
					pkg = yield* readConfigPackage(
						_path().default.join(dirname, PACKAGE_FILENAME),
					)

					const nextLoc = _path().default.dirname(dirname)

					if (dirname === nextLoc) {
						isPackage = false
						break
					}

					dirname = nextLoc
				}

				return {
					filepath,
					directories,
					pkg,
					isPackage,
				}
			}

			const readConfigPackage = (0, _utils.makeStaticFileCache)(
				(filepath, content) => {
					let options

					try {
						options = JSON.parse(content)
					} catch (err) {
						err.message = `${filepath}: Error while parsing JSON - ${err.message}`
						throw err
					}

					if (!options) throw new Error(`${filepath}: No config detected`)

					if (typeof options !== 'object') {
						throw new Error(
							`${filepath}: Config returned typeof ${typeof options}`,
						)
					}

					if (Array.isArray(options)) {
						throw new Error(
							`${filepath}: Expected config object but found array`,
						)
					}

					return {
						filepath,
						dirname: _path().default.dirname(filepath),
						options,
					}
				},
			)

			/***/
		},

		/***/ 19669: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.resolvePlugin = resolvePlugin
			exports.resolvePreset = resolvePreset
			exports.loadPlugin = loadPlugin
			exports.loadPreset = loadPreset

			function _debug() {
				const data = _interopRequireDefault(__nccwpck_require__(2830))

				_debug = function () {
					return data
				}

				return data
			}

			function _resolve() {
				const data = _interopRequireDefault(__nccwpck_require__(92312))

				_resolve = function () {
					return data
				}

				return data
			}

			function _path() {
				const data = _interopRequireDefault(__nccwpck_require__(16928))

				_path = function () {
					return data
				}

				return data
			}

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			const debug = (0, _debug().default)('babel:config:loading:files:plugins')
			const EXACT_RE = /^module:/
			const BABEL_PLUGIN_PREFIX_RE = /^(?!@|module:|[^/]+\/|babel-plugin-)/
			const BABEL_PRESET_PREFIX_RE = /^(?!@|module:|[^/]+\/|babel-preset-)/
			const BABEL_PLUGIN_ORG_RE = /^(@babel\/)(?!plugin-|[^/]+\/)/
			const BABEL_PRESET_ORG_RE = /^(@babel\/)(?!preset-|[^/]+\/)/
			const OTHER_PLUGIN_ORG_RE =
				/^(@(?!babel\/)[^/]+\/)(?![^/]*babel-plugin(?:-|\/|$)|[^/]+\/)/
			const OTHER_PRESET_ORG_RE =
				/^(@(?!babel\/)[^/]+\/)(?![^/]*babel-preset(?:-|\/|$)|[^/]+\/)/
			const OTHER_ORG_DEFAULT_RE = /^(@(?!babel$)[^/]+)$/

			function resolvePlugin(name, dirname) {
				return resolveStandardizedName('plugin', name, dirname)
			}

			function resolvePreset(name, dirname) {
				return resolveStandardizedName('preset', name, dirname)
			}

			function loadPlugin(name, dirname) {
				const filepath = resolvePlugin(name, dirname)

				if (!filepath) {
					throw new Error(`Plugin ${name} not found relative to ${dirname}`)
				}

				const value = requireModule('plugin', filepath)
				debug('Loaded plugin %o from %o.', name, dirname)
				return {
					filepath,
					value,
				}
			}

			function loadPreset(name, dirname) {
				const filepath = resolvePreset(name, dirname)

				if (!filepath) {
					throw new Error(`Preset ${name} not found relative to ${dirname}`)
				}

				const value = requireModule('preset', filepath)
				debug('Loaded preset %o from %o.', name, dirname)
				return {
					filepath,
					value,
				}
			}

			function standardizeName(type, name) {
				if (_path().default.isAbsolute(name)) return name
				const isPreset = type === 'preset'
				return name
					.replace(
						isPreset ? BABEL_PRESET_PREFIX_RE : BABEL_PLUGIN_PREFIX_RE,
						`babel-${type}-`,
					)
					.replace(
						isPreset ? BABEL_PRESET_ORG_RE : BABEL_PLUGIN_ORG_RE,
						`$1${type}-`,
					)
					.replace(
						isPreset ? OTHER_PRESET_ORG_RE : OTHER_PLUGIN_ORG_RE,
						`$1babel-${type}-`,
					)
					.replace(OTHER_ORG_DEFAULT_RE, `$1/babel-${type}`)
					.replace(EXACT_RE, '')
			}

			function resolveStandardizedName(type, name, dirname = process.cwd()) {
				const standardizedName = standardizeName(type, name)

				try {
					return _resolve().default.sync(standardizedName, {
						basedir: dirname,
					})
				} catch (e) {
					if (e.code !== 'MODULE_NOT_FOUND') throw e

					if (standardizedName !== name) {
						let resolvedOriginal = false

						try {
							_resolve().default.sync(name, {
								basedir: dirname,
							})

							resolvedOriginal = true
						} catch (_unused) {}

						if (resolvedOriginal) {
							e.message += `\n- If you want to resolve "${name}", use "module:${name}"`
						}
					}

					let resolvedBabel = false

					try {
						_resolve().default.sync(standardizeName(type, '@babel/' + name), {
							basedir: dirname,
						})

						resolvedBabel = true
					} catch (_unused2) {}

					if (resolvedBabel) {
						e.message += `\n- Did you mean "@babel/${name}"?`
					}

					let resolvedOppositeType = false
					const oppositeType = type === 'preset' ? 'plugin' : 'preset'

					try {
						_resolve().default.sync(standardizeName(oppositeType, name), {
							basedir: dirname,
						})

						resolvedOppositeType = true
					} catch (_unused3) {}

					if (resolvedOppositeType) {
						e.message += `\n- Did you accidentally pass a ${oppositeType} as a ${type}?`
					}

					throw e
				}
			}

			const LOADING_MODULES = new Set()

			function requireModule(type, name) {
				if (LOADING_MODULES.has(name)) {
					throw new Error(
						`Reentrant ${type} detected trying to load "${name}". This module is not ignored ` +
							'and is trying to load itself while compiling itself, leading to a dependency cycle. ' +
							'We recommend adding it to your "ignore" list in your babelrc, or to a .babelignore.',
					)
				}

				try {
					LOADING_MODULES.add(name)
					return require(name)
				} finally {
					LOADING_MODULES.delete(name)
				}
			}

			/***/
		},

		/***/ 748: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.makeStaticFileCache = makeStaticFileCache

			var _caching = __nccwpck_require__(46268)

			var fs = _interopRequireWildcard(__nccwpck_require__(10733))

			function _fs2() {
				const data = _interopRequireDefault(__nccwpck_require__(79896))

				_fs2 = function () {
					return data
				}

				return data
			}

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			function _getRequireWildcardCache() {
				if (typeof WeakMap !== 'function') return null
				var cache = new WeakMap()
				_getRequireWildcardCache = function () {
					return cache
				}
				return cache
			}

			function _interopRequireWildcard(obj) {
				if (obj && obj.__esModule) {
					return obj
				}
				if (
					obj === null ||
					(typeof obj !== 'object' && typeof obj !== 'function')
				) {
					return { default: obj }
				}
				var cache = _getRequireWildcardCache()
				if (cache && cache.has(obj)) {
					return cache.get(obj)
				}
				var newObj = {}
				var hasPropertyDescriptor =
					Object.defineProperty && Object.getOwnPropertyDescriptor
				for (var key in obj) {
					if (Object.prototype.hasOwnProperty.call(obj, key)) {
						var desc = hasPropertyDescriptor
							? Object.getOwnPropertyDescriptor(obj, key)
							: null
						if (desc && (desc.get || desc.set)) {
							Object.defineProperty(newObj, key, desc)
						} else {
							newObj[key] = obj[key]
						}
					}
				}
				newObj.default = obj
				if (cache) {
					cache.set(obj, newObj)
				}
				return newObj
			}

			function makeStaticFileCache(fn) {
				return (0, _caching.makeStrongCache)(function* (filepath, cache) {
					const cached = cache.invalidate(() => fileMtime(filepath))

					if (cached === null) {
						return null
					}

					return fn(filepath, yield* fs.readFile(filepath, 'utf8'))
				})
			}

			function fileMtime(filepath) {
				try {
					return +_fs2().default.statSync(filepath).mtime
				} catch (e) {
					if (e.code !== 'ENOENT' && e.code !== 'ENOTDIR') throw e
				}

				return null
			}

			/***/
		},

		/***/ 74396: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = void 0

			function _gensync() {
				const data = _interopRequireDefault(__nccwpck_require__(9621))

				_gensync = function () {
					return data
				}

				return data
			}

			var _async = __nccwpck_require__(87360)

			var _util = __nccwpck_require__(54493)

			var context = _interopRequireWildcard(__nccwpck_require__(85414))

			var _plugin = _interopRequireDefault(__nccwpck_require__(68618))

			var _item = __nccwpck_require__(72478)

			var _configChain = __nccwpck_require__(70835)

			function _traverse() {
				const data = _interopRequireDefault(__nccwpck_require__(50148))

				_traverse = function () {
					return data
				}

				return data
			}

			var _caching = __nccwpck_require__(46268)

			var _options = __nccwpck_require__(44743)

			var _plugins = __nccwpck_require__(22449)

			var _configApi = _interopRequireDefault(__nccwpck_require__(33700))

			var _partial = _interopRequireDefault(__nccwpck_require__(71700))

			function _getRequireWildcardCache() {
				if (typeof WeakMap !== 'function') return null
				var cache = new WeakMap()
				_getRequireWildcardCache = function () {
					return cache
				}
				return cache
			}

			function _interopRequireWildcard(obj) {
				if (obj && obj.__esModule) {
					return obj
				}
				if (
					obj === null ||
					(typeof obj !== 'object' && typeof obj !== 'function')
				) {
					return { default: obj }
				}
				var cache = _getRequireWildcardCache()
				if (cache && cache.has(obj)) {
					return cache.get(obj)
				}
				var newObj = {}
				var hasPropertyDescriptor =
					Object.defineProperty && Object.getOwnPropertyDescriptor
				for (var key in obj) {
					if (Object.prototype.hasOwnProperty.call(obj, key)) {
						var desc = hasPropertyDescriptor
							? Object.getOwnPropertyDescriptor(obj, key)
							: null
						if (desc && (desc.get || desc.set)) {
							Object.defineProperty(newObj, key, desc)
						} else {
							newObj[key] = obj[key]
						}
					}
				}
				newObj.default = obj
				if (cache) {
					cache.set(obj, newObj)
				}
				return newObj
			}

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			var _default = (0, _gensync().default)(
				function* loadFullConfig(inputOpts) {
					const result = yield* (0, _partial.default)(inputOpts)

					if (!result) {
						return null
					}

					const { options, context, fileHandling } = result

					if (fileHandling === 'ignored') {
						return null
					}

					const optionDefaults = {}
					const { plugins, presets } = options

					if (!plugins || !presets) {
						throw new Error('Assertion failure - plugins and presets exist')
					}

					const toDescriptor = (item) => {
						const desc = (0, _item.getItemDescriptor)(item)

						if (!desc) {
							throw new Error('Assertion failure - must be config item')
						}

						return desc
					}

					const presetsDescriptors = presets.map(toDescriptor)
					const initialPluginsDescriptors = plugins.map(toDescriptor)
					const pluginDescriptorsByPass = [[]]
					const passes = []
					const ignored = yield* enhanceError(
						context,
						function* recursePresetDescriptors(
							rawPresets,
							pluginDescriptorsPass,
						) {
							const presets = []

							for (let i = 0; i < rawPresets.length; i++) {
								const descriptor = rawPresets[i]

								if (descriptor.options !== false) {
									try {
										if (descriptor.ownPass) {
											presets.push({
												preset: yield* loadPresetDescriptor(
													descriptor,
													context,
												),
												pass: [],
											})
										} else {
											presets.unshift({
												preset: yield* loadPresetDescriptor(
													descriptor,
													context,
												),
												pass: pluginDescriptorsPass,
											})
										}
									} catch (e) {
										if (e.code === 'BABEL_UNKNOWN_OPTION') {
											;(0, _options.checkNoUnwrappedItemOptionPairs)(
												rawPresets,
												i,
												'preset',
												e,
											)
										}

										throw e
									}
								}
							}

							if (presets.length > 0) {
								pluginDescriptorsByPass.splice(
									1,
									0,
									...presets
										.map((o) => o.pass)
										.filter((p) => p !== pluginDescriptorsPass),
								)

								for (const { preset, pass } of presets) {
									if (!preset) return true
									pass.push(...preset.plugins)
									const ignored = yield* recursePresetDescriptors(
										preset.presets,
										pass,
									)
									if (ignored) return true
									preset.options.forEach((opts) => {
										;(0, _util.mergeOptions)(optionDefaults, opts)
									})
								}
							}
						},
					)(presetsDescriptors, pluginDescriptorsByPass[0])
					if (ignored) return null
					const opts = optionDefaults
					;(0, _util.mergeOptions)(opts, options)
					yield* enhanceError(context, function* loadPluginDescriptors() {
						pluginDescriptorsByPass[0].unshift(...initialPluginsDescriptors)

						for (const descs of pluginDescriptorsByPass) {
							const pass = []
							passes.push(pass)

							for (let i = 0; i < descs.length; i++) {
								const descriptor = descs[i]

								if (descriptor.options !== false) {
									try {
										pass.push(yield* loadPluginDescriptor(descriptor, context))
									} catch (e) {
										if (e.code === 'BABEL_UNKNOWN_PLUGIN_PROPERTY') {
											;(0, _options.checkNoUnwrappedItemOptionPairs)(
												descs,
												i,
												'plugin',
												e,
											)
										}

										throw e
									}
								}
							}
						}
					})()
					opts.plugins = passes[0]
					opts.presets = passes
						.slice(1)
						.filter((plugins) => plugins.length > 0)
						.map((plugins) => ({
							plugins,
						}))
					opts.passPerPreset = opts.presets.length > 0
					return {
						options: opts,
						passes: passes,
					}
				},
			)

			exports['default'] = _default

			function enhanceError(context, fn) {
				return function* (arg1, arg2) {
					try {
						return yield* fn(arg1, arg2)
					} catch (e) {
						if (!/^\[BABEL\]/.test(e.message)) {
							e.message = `[BABEL] ${context.filename || 'unknown'}: ${e.message}`
						}

						throw e
					}
				}
			}

			const loadDescriptor = (0, _caching.makeWeakCache)(function* (
				{ value, options, dirname, alias },
				cache,
			) {
				if (options === false) throw new Error('Assertion failure')
				options = options || {}
				let item = value

				if (typeof value === 'function') {
					const api = Object.assign({}, context, (0, _configApi.default)(cache))

					try {
						item = value(api, options, dirname)
					} catch (e) {
						if (alias) {
							e.message += ` (While processing: ${JSON.stringify(alias)})`
						}

						throw e
					}
				}

				if (!item || typeof item !== 'object') {
					throw new Error('Plugin/Preset did not return an object.')
				}

				if (typeof item.then === 'function') {
					yield* []
					throw new Error(
						`You appear to be using an async plugin, ` +
							`which your current version of Babel does not support. ` +
							`If you're using a published plugin, ` +
							`you may need to upgrade your @babel/core version.`,
					)
				}

				return {
					value: item,
					options,
					dirname,
					alias,
				}
			})

			function* loadPluginDescriptor(descriptor, context) {
				if (descriptor.value instanceof _plugin.default) {
					if (descriptor.options) {
						throw new Error(
							'Passed options to an existing Plugin instance will not work.',
						)
					}

					return descriptor.value
				}

				return yield* instantiatePlugin(
					yield* loadDescriptor(descriptor, context),
					context,
				)
			}

			const instantiatePlugin = (0, _caching.makeWeakCache)(function* (
				{ value, options, dirname, alias },
				cache,
			) {
				const pluginObj = (0, _plugins.validatePluginObject)(value)
				const plugin = Object.assign({}, pluginObj)

				if (plugin.visitor) {
					plugin.visitor = _traverse().default.explode(
						Object.assign({}, plugin.visitor),
					)
				}

				if (plugin.inherits) {
					const inheritsDescriptor = {
						name: undefined,
						alias: `${alias}$inherits`,
						value: plugin.inherits,
						options,
						dirname,
					}
					const inherits = yield* (0, _async.forwardAsync)(
						loadPluginDescriptor,
						(run) => {
							return cache.invalidate((data) => run(inheritsDescriptor, data))
						},
					)
					plugin.pre = chain(inherits.pre, plugin.pre)
					plugin.post = chain(inherits.post, plugin.post)
					plugin.manipulateOptions = chain(
						inherits.manipulateOptions,
						plugin.manipulateOptions,
					)
					plugin.visitor = _traverse().default.visitors.merge([
						inherits.visitor || {},
						plugin.visitor || {},
					])
				}

				return new _plugin.default(plugin, options, alias)
			})

			const validateIfOptionNeedsFilename = (options, descriptor) => {
				if (options.test || options.include || options.exclude) {
					const formattedPresetName = descriptor.name
						? `"${descriptor.name}"`
						: '/* your preset */'
					throw new Error(
						[
							`Preset ${formattedPresetName} requires a filename to be set when babel is called directly,`,
							`\`\`\``,
							`babel.transform(code, { filename: 'file.ts', presets: [${formattedPresetName}] });`,
							`\`\`\``,
							`See https://babeljs.io/docs/en/options#filename for more information.`,
						].join('\n'),
					)
				}
			}

			const validatePreset = (preset, context, descriptor) => {
				if (!context.filename) {
					const { options } = preset
					validateIfOptionNeedsFilename(options, descriptor)

					if (options.overrides) {
						options.overrides.forEach((overrideOptions) =>
							validateIfOptionNeedsFilename(overrideOptions, descriptor),
						)
					}
				}
			}

			function* loadPresetDescriptor(descriptor, context) {
				const preset = instantiatePreset(
					yield* loadDescriptor(descriptor, context),
				)
				validatePreset(preset, context, descriptor)
				return yield* (0, _configChain.buildPresetChain)(preset, context)
			}

			const instantiatePreset = (0, _caching.makeWeakCacheSync)(
				({ value, dirname, alias }) => {
					return {
						options: (0, _options.validate)('preset', value),
						alias,
						dirname,
					}
				},
			)

			function chain(a, b) {
				const fns = [a, b].filter(Boolean)
				if (fns.length <= 1) return fns[0]
				return function (...args) {
					for (const fn of fns) {
						fn.apply(this, args)
					}
				}
			}

			/***/
		},

		/***/ 33700: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = makeAPI

			function _semver() {
				const data = _interopRequireDefault(__nccwpck_require__(39318))

				_semver = function () {
					return data
				}

				return data
			}

			var _ = __nccwpck_require__(85414)

			var _caching = __nccwpck_require__(46268)

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			function makeAPI(cache) {
				const env = (value) =>
					cache.using((data) => {
						if (typeof value === 'undefined') return data.envName

						if (typeof value === 'function') {
							return (0, _caching.assertSimpleType)(value(data.envName))
						}

						if (!Array.isArray(value)) value = [value]
						return value.some((entry) => {
							if (typeof entry !== 'string') {
								throw new Error('Unexpected non-string value')
							}

							return entry === data.envName
						})
					})

				const caller = (cb) =>
					cache.using((data) => (0, _caching.assertSimpleType)(cb(data.caller)))

				return {
					version: _.version,
					cache: cache.simple(),
					env,
					async: () => false,
					caller,
					assertVersion,
				}
			}

			function assertVersion(range) {
				if (typeof range === 'number') {
					if (!Number.isInteger(range)) {
						throw new Error('Expected string or integer value.')
					}

					range = `^${range}.0.0-0`
				}

				if (typeof range !== 'string') {
					throw new Error('Expected string or integer value.')
				}

				if (_semver().default.satisfies(_.version, range)) return
				const limit = Error.stackTraceLimit

				if (typeof limit === 'number' && limit < 25) {
					Error.stackTraceLimit = 25
				}

				const err = new Error(
					`Requires Babel "${range}", but was loaded with "${_.version}". ` +
						`If you are sure you have a compatible version of @babel/core, ` +
						`it is likely that something in your build process is loading the ` +
						`wrong version. Inspect the stack trace of this error to look for ` +
						`the first entry that doesn't mention "@babel/core" or "babel-core" ` +
						`to see what is calling Babel.`,
				)

				if (typeof limit === 'number') {
					Error.stackTraceLimit = limit
				}

				throw Object.assign(err, {
					code: 'BABEL_VERSION_UNSUPPORTED',
					version: _.version,
					range,
				})
			}

			/***/
		},

		/***/ 3110: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.getEnv = getEnv

			function getEnv(defaultValue = 'development') {
				return process.env.BABEL_ENV || process.env.NODE_ENV || defaultValue
			}

			/***/
		},

		/***/ 73677: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			Object.defineProperty(exports, 'default', {
				enumerable: true,
				get: function () {
					return _full.default
				},
			})
			exports.loadOptionsAsync =
				exports.loadOptionsSync =
				exports.loadOptions =
				exports.loadPartialConfigAsync =
				exports.loadPartialConfigSync =
				exports.loadPartialConfig =
					void 0

			function _gensync() {
				const data = _interopRequireDefault(__nccwpck_require__(9621))

				_gensync = function () {
					return data
				}

				return data
			}

			var _full = _interopRequireDefault(__nccwpck_require__(74396))

			var _partial = __nccwpck_require__(71700)

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			const loadOptionsRunner = (0, _gensync().default)(function* (opts) {
				var _config$options

				const config = yield* (0, _full.default)(opts)
				return (_config$options = config == null ? void 0 : config.options) !=
					null
					? _config$options
					: null
			})

			const maybeErrback = (runner) => (opts, callback) => {
				if (callback === undefined && typeof opts === 'function') {
					callback = opts
					opts = undefined
				}

				return callback ? runner.errback(opts, callback) : runner.sync(opts)
			}

			const loadPartialConfig = maybeErrback(_partial.loadPartialConfig)
			exports.loadPartialConfig = loadPartialConfig
			const loadPartialConfigSync = _partial.loadPartialConfig.sync
			exports.loadPartialConfigSync = loadPartialConfigSync
			const loadPartialConfigAsync = _partial.loadPartialConfig.async
			exports.loadPartialConfigAsync = loadPartialConfigAsync
			const loadOptions = maybeErrback(loadOptionsRunner)
			exports.loadOptions = loadOptions
			const loadOptionsSync = loadOptionsRunner.sync
			exports.loadOptionsSync = loadOptionsSync
			const loadOptionsAsync = loadOptionsRunner.async
			exports.loadOptionsAsync = loadOptionsAsync

			/***/
		},

		/***/ 72478: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.createItemFromDescriptor = createItemFromDescriptor
			exports.createConfigItem = createConfigItem
			exports.getItemDescriptor = getItemDescriptor

			function _path() {
				const data = _interopRequireDefault(__nccwpck_require__(16928))

				_path = function () {
					return data
				}

				return data
			}

			var _configDescriptors = __nccwpck_require__(2420)

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			function createItemFromDescriptor(desc) {
				return new ConfigItem(desc)
			}

			function createConfigItem(value, { dirname = '.', type } = {}) {
				const descriptor = (0, _configDescriptors.createDescriptor)(
					value,
					_path().default.resolve(dirname),
					{
						type,
						alias: 'programmatic item',
					},
				)
				return createItemFromDescriptor(descriptor)
			}

			function getItemDescriptor(item) {
				if (item == null ? void 0 : item[CONFIG_ITEM_BRAND]) {
					return item._descriptor
				}

				return undefined
			}

			const CONFIG_ITEM_BRAND = Symbol.for('@babel/core@7 - ConfigItem')

			class ConfigItem {
				constructor(descriptor) {
					this._descriptor = void 0
					this[CONFIG_ITEM_BRAND] = true
					this.value = void 0
					this.options = void 0
					this.dirname = void 0
					this.name = void 0
					this.file = void 0
					this._descriptor = descriptor
					Object.defineProperty(this, '_descriptor', {
						enumerable: false,
					})
					Object.defineProperty(this, CONFIG_ITEM_BRAND, {
						enumerable: false,
					})
					this.value = this._descriptor.value
					this.options = this._descriptor.options
					this.dirname = this._descriptor.dirname
					this.name = this._descriptor.name
					this.file = this._descriptor.file
						? {
								request: this._descriptor.file.request,
								resolved: this._descriptor.file.resolved,
							}
						: undefined
					Object.freeze(this)
				}
			}

			Object.freeze(ConfigItem.prototype)

			/***/
		},

		/***/ 71700: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = loadPrivatePartialConfig
			exports.loadPartialConfig = void 0

			function _path() {
				const data = _interopRequireDefault(__nccwpck_require__(16928))

				_path = function () {
					return data
				}

				return data
			}

			function _gensync() {
				const data = _interopRequireDefault(__nccwpck_require__(9621))

				_gensync = function () {
					return data
				}

				return data
			}

			var _plugin = _interopRequireDefault(__nccwpck_require__(68618))

			var _util = __nccwpck_require__(54493)

			var _item = __nccwpck_require__(72478)

			var _configChain = __nccwpck_require__(70835)

			var _environment = __nccwpck_require__(3110)

			var _options = __nccwpck_require__(44743)

			var _files = __nccwpck_require__(37217)

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			function _objectWithoutPropertiesLoose(source, excluded) {
				if (source == null) return {}
				var target = {}
				var sourceKeys = Object.keys(source)
				var key, i
				for (i = 0; i < sourceKeys.length; i++) {
					key = sourceKeys[i]
					if (excluded.indexOf(key) >= 0) continue
					target[key] = source[key]
				}
				return target
			}

			function* resolveRootMode(rootDir, rootMode) {
				switch (rootMode) {
					case 'root':
						return rootDir

					case 'upward-optional': {
						const upwardRootDir = yield* (0, _files.findConfigUpwards)(rootDir)
						return upwardRootDir === null ? rootDir : upwardRootDir
					}

					case 'upward': {
						const upwardRootDir = yield* (0, _files.findConfigUpwards)(rootDir)
						if (upwardRootDir !== null) return upwardRootDir
						throw Object.assign(
							new Error(
								`Babel was run with rootMode:"upward" but a root could not ` +
									`be found when searching upward from "${rootDir}".\n` +
									`One of the following config files must be in the directory tree: ` +
									`"${_files.ROOT_CONFIG_FILENAMES.join(', ')}".`,
							),
							{
								code: 'BABEL_ROOT_NOT_FOUND',
								dirname: rootDir,
							},
						)
					}

					default:
						throw new Error(`Assertion failure - unknown rootMode value.`)
				}
			}

			function* loadPrivatePartialConfig(inputOpts) {
				if (
					inputOpts != null &&
					(typeof inputOpts !== 'object' || Array.isArray(inputOpts))
				) {
					throw new Error('Babel options must be an object, null, or undefined')
				}

				const args = inputOpts
					? (0, _options.validate)('arguments', inputOpts)
					: {}
				const {
					envName = (0, _environment.getEnv)(),
					cwd = '.',
					root: rootDir = '.',
					rootMode = 'root',
					caller,
					cloneInputAst = true,
				} = args

				const absoluteCwd = _path().default.resolve(cwd)

				const absoluteRootDir = yield* resolveRootMode(
					_path().default.resolve(absoluteCwd, rootDir),
					rootMode,
				)
				const filename =
					typeof args.filename === 'string'
						? _path().default.resolve(cwd, args.filename)
						: undefined
				const showConfigPath = yield* (0, _files.resolveShowConfigPath)(
					absoluteCwd,
				)
				const context = {
					filename,
					cwd: absoluteCwd,
					root: absoluteRootDir,
					envName,
					caller,
					showConfig: showConfigPath === filename,
				}
				const configChain = yield* (0, _configChain.buildRootChain)(
					args,
					context,
				)
				if (!configChain) return null
				const options = {}
				configChain.options.forEach((opts) => {
					;(0, _util.mergeOptions)(options, opts)
				})
				options.cloneInputAst = cloneInputAst
				options.babelrc = false
				options.configFile = false
				options.passPerPreset = false
				options.envName = context.envName
				options.cwd = context.cwd
				options.root = context.root
				options.filename =
					typeof context.filename === 'string' ? context.filename : undefined
				options.plugins = configChain.plugins.map((descriptor) =>
					(0, _item.createItemFromDescriptor)(descriptor),
				)
				options.presets = configChain.presets.map((descriptor) =>
					(0, _item.createItemFromDescriptor)(descriptor),
				)
				return {
					options,
					context,
					fileHandling: configChain.fileHandling,
					ignore: configChain.ignore,
					babelrc: configChain.babelrc,
					config: configChain.config,
					files: configChain.files,
				}
			}

			const loadPartialConfig = (0, _gensync().default)(function* (opts) {
				let showIgnoredFiles = false

				if (typeof opts === 'object' && opts !== null && !Array.isArray(opts)) {
					var _opts = opts
					;({ showIgnoredFiles } = _opts)
					opts = _objectWithoutPropertiesLoose(_opts, ['showIgnoredFiles'])
					_opts
				}

				const result = yield* loadPrivatePartialConfig(opts)
				if (!result) return null
				const { options, babelrc, ignore, config, fileHandling, files } = result

				if (fileHandling === 'ignored' && !showIgnoredFiles) {
					return null
				}

				;(options.plugins || []).forEach((item) => {
					if (item.value instanceof _plugin.default) {
						throw new Error(
							'Passing cached plugin instances is not supported in ' +
								'babel.loadPartialConfig()',
						)
					}
				})
				return new PartialConfig(
					options,
					babelrc ? babelrc.filepath : undefined,
					ignore ? ignore.filepath : undefined,
					config ? config.filepath : undefined,
					fileHandling,
					files,
				)
			})
			exports.loadPartialConfig = loadPartialConfig

			class PartialConfig {
				constructor(options, babelrc, ignore, config, fileHandling, files) {
					this.options = void 0
					this.babelrc = void 0
					this.babelignore = void 0
					this.config = void 0
					this.fileHandling = void 0
					this.files = void 0
					this.options = options
					this.babelignore = ignore
					this.babelrc = babelrc
					this.config = config
					this.fileHandling = fileHandling
					this.files = files
					Object.freeze(this)
				}

				hasFilesystemConfig() {
					return this.babelrc !== undefined || this.config !== undefined
				}
			}

			Object.freeze(PartialConfig.prototype)

			/***/
		},

		/***/ 79619: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = pathToPattern

			function _path() {
				const data = _interopRequireDefault(__nccwpck_require__(16928))

				_path = function () {
					return data
				}

				return data
			}

			function _escapeRegExp() {
				const data = _interopRequireDefault(__nccwpck_require__(66195))

				_escapeRegExp = function () {
					return data
				}

				return data
			}

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			const sep = `\\${_path().default.sep}`
			const endSep = `(?:${sep}|$)`
			const substitution = `[^${sep}]+`
			const starPat = `(?:${substitution}${sep})`
			const starPatLast = `(?:${substitution}${endSep})`
			const starStarPat = `${starPat}*?`
			const starStarPatLast = `${starPat}*?${starPatLast}?`

			function pathToPattern(pattern, dirname) {
				const parts = _path()
					.default.resolve(dirname, pattern)
					.split(_path().default.sep)

				return new RegExp(
					[
						'^',
						...parts.map((part, i) => {
							const last = i === parts.length - 1
							if (part === '**') return last ? starStarPatLast : starStarPat
							if (part === '*') return last ? starPatLast : starPat

							if (part.indexOf('*.') === 0) {
								return (
									substitution +
									(0, _escapeRegExp().default)(part.slice(1)) +
									(last ? endSep : sep)
								)
							}

							return (0, _escapeRegExp().default)(part) + (last ? endSep : sep)
						}),
					].join(''),
				)
			}

			/***/
		},

		/***/ 68618: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = void 0

			class Plugin {
				constructor(plugin, options, key) {
					this.key = void 0
					this.manipulateOptions = void 0
					this.post = void 0
					this.pre = void 0
					this.visitor = void 0
					this.parserOverride = void 0
					this.generatorOverride = void 0
					this.options = void 0
					this.key = plugin.name || key
					this.manipulateOptions = plugin.manipulateOptions
					this.post = plugin.post
					this.pre = plugin.pre
					this.visitor = plugin.visitor || {}
					this.parserOverride = plugin.parserOverride
					this.generatorOverride = plugin.generatorOverride
					this.options = options
				}
			}

			exports['default'] = Plugin

			/***/
		},

		/***/ 30333: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.ConfigPrinter = exports.ChainFormatter = void 0
			const ChainFormatter = {
				Programmatic: 0,
				Config: 1,
			}
			exports.ChainFormatter = ChainFormatter
			const Formatter = {
				title(type, callerName, filepath) {
					let title = ''

					if (type === ChainFormatter.Programmatic) {
						title = 'programmatic options'

						if (callerName) {
							title += ' from ' + callerName
						}
					} else {
						title = 'config ' + filepath
					}

					return title
				},

				loc(index, envName) {
					let loc = ''

					if (index != null) {
						loc += `.overrides[${index}]`
					}

					if (envName != null) {
						loc += `.env["${envName}"]`
					}

					return loc
				},

				optionsAndDescriptors(opt) {
					const content = Object.assign({}, opt.options)
					delete content.overrides
					delete content.env
					const pluginDescriptors = [...opt.plugins()]

					if (pluginDescriptors.length) {
						content.plugins = pluginDescriptors.map((d) =>
							descriptorToConfig(d),
						)
					}

					const presetDescriptors = [...opt.presets()]

					if (presetDescriptors.length) {
						content.presets = [...presetDescriptors].map((d) =>
							descriptorToConfig(d),
						)
					}

					return JSON.stringify(content, undefined, 2)
				},
			}

			function descriptorToConfig(d) {
				var _d$file

				let name = (_d$file = d.file) == null ? void 0 : _d$file.request

				if (name == null) {
					if (typeof d.value === 'object') {
						name = d.value
					} else if (typeof d.value === 'function') {
						name = `[Function: ${d.value.toString().substr(0, 50)} ... ]`
					}
				}

				if (name == null) {
					name = '[Unknown]'
				}

				if (d.options === undefined) {
					return name
				} else if (d.name == null) {
					return [name, d.options]
				} else {
					return [name, d.options, d.name]
				}
			}

			class ConfigPrinter {
				constructor() {
					this._stack = []
				}

				configure(enabled, type, { callerName, filepath }) {
					if (!enabled) return () => {}
					return (content, index, envName) => {
						this._stack.push({
							type,
							callerName,
							filepath,
							content,
							index,
							envName,
						})
					}
				}

				static format(config) {
					let title = Formatter.title(
						config.type,
						config.callerName,
						config.filepath,
					)
					const loc = Formatter.loc(config.index, config.envName)
					if (loc) title += ` ${loc}`
					const content = Formatter.optionsAndDescriptors(config.content)
					return `${title}\n${content}`
				}

				output() {
					if (this._stack.length === 0) return ''
					return this._stack.map((s) => ConfigPrinter.format(s)).join('\n\n')
				}
			}

			exports.ConfigPrinter = ConfigPrinter

			/***/
		},

		/***/ 54493: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.mergeOptions = mergeOptions
			exports.isIterableIterator = isIterableIterator

			function mergeOptions(target, source) {
				for (const k of Object.keys(source)) {
					if (k === 'parserOpts' && source.parserOpts) {
						const parserOpts = source.parserOpts
						const targetObj = (target.parserOpts = target.parserOpts || {})
						mergeDefaultFields(targetObj, parserOpts)
					} else if (k === 'generatorOpts' && source.generatorOpts) {
						const generatorOpts = source.generatorOpts
						const targetObj = (target.generatorOpts =
							target.generatorOpts || {})
						mergeDefaultFields(targetObj, generatorOpts)
					} else {
						const val = source[k]
						if (val !== undefined) target[k] = val
					}
				}
			}

			function mergeDefaultFields(target, source) {
				for (const k of Object.keys(source)) {
					const val = source[k]
					if (val !== undefined) target[k] = val
				}
			}

			function isIterableIterator(value) {
				return (
					!!value &&
					typeof value.next === 'function' &&
					typeof value[Symbol.iterator] === 'function'
				)
			}

			/***/
		},

		/***/ 28: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.msg = msg
			exports.access = access
			exports.assertRootMode = assertRootMode
			exports.assertSourceMaps = assertSourceMaps
			exports.assertCompact = assertCompact
			exports.assertSourceType = assertSourceType
			exports.assertCallerMetadata = assertCallerMetadata
			exports.assertInputSourceMap = assertInputSourceMap
			exports.assertString = assertString
			exports.assertFunction = assertFunction
			exports.assertBoolean = assertBoolean
			exports.assertObject = assertObject
			exports.assertArray = assertArray
			exports.assertIgnoreList = assertIgnoreList
			exports.assertConfigApplicableTest = assertConfigApplicableTest
			exports.assertConfigFileSearch = assertConfigFileSearch
			exports.assertBabelrcSearch = assertBabelrcSearch
			exports.assertPluginList = assertPluginList

			function msg(loc) {
				switch (loc.type) {
					case 'root':
						return ``

					case 'env':
						return `${msg(loc.parent)}.env["${loc.name}"]`

					case 'overrides':
						return `${msg(loc.parent)}.overrides[${loc.index}]`

					case 'option':
						return `${msg(loc.parent)}.${loc.name}`

					case 'access':
						return `${msg(loc.parent)}[${JSON.stringify(loc.name)}]`

					default:
						throw new Error(`Assertion failure: Unknown type ${loc.type}`)
				}
			}

			function access(loc, name) {
				return {
					type: 'access',
					name,
					parent: loc,
				}
			}

			function assertRootMode(loc, value) {
				if (
					value !== undefined &&
					value !== 'root' &&
					value !== 'upward' &&
					value !== 'upward-optional'
				) {
					throw new Error(
						`${msg(loc)} must be a "root", "upward", "upward-optional" or undefined`,
					)
				}

				return value
			}

			function assertSourceMaps(loc, value) {
				if (
					value !== undefined &&
					typeof value !== 'boolean' &&
					value !== 'inline' &&
					value !== 'both'
				) {
					throw new Error(
						`${msg(loc)} must be a boolean, "inline", "both", or undefined`,
					)
				}

				return value
			}

			function assertCompact(loc, value) {
				if (
					value !== undefined &&
					typeof value !== 'boolean' &&
					value !== 'auto'
				) {
					throw new Error(`${msg(loc)} must be a boolean, "auto", or undefined`)
				}

				return value
			}

			function assertSourceType(loc, value) {
				if (
					value !== undefined &&
					value !== 'module' &&
					value !== 'script' &&
					value !== 'unambiguous'
				) {
					throw new Error(
						`${msg(loc)} must be "module", "script", "unambiguous", or undefined`,
					)
				}

				return value
			}

			function assertCallerMetadata(loc, value) {
				const obj = assertObject(loc, value)

				if (obj) {
					if (typeof obj['name'] !== 'string') {
						throw new Error(
							`${msg(loc)} set but does not contain "name" property string`,
						)
					}

					for (const prop of Object.keys(obj)) {
						const propLoc = access(loc, prop)
						const value = obj[prop]

						if (
							value != null &&
							typeof value !== 'boolean' &&
							typeof value !== 'string' &&
							typeof value !== 'number'
						) {
							throw new Error(
								`${msg(propLoc)} must be null, undefined, a boolean, a string, or a number.`,
							)
						}
					}
				}

				return value
			}

			function assertInputSourceMap(loc, value) {
				if (
					value !== undefined &&
					typeof value !== 'boolean' &&
					(typeof value !== 'object' || !value)
				) {
					throw new Error(`${msg(loc)} must be a boolean, object, or undefined`)
				}

				return value
			}

			function assertString(loc, value) {
				if (value !== undefined && typeof value !== 'string') {
					throw new Error(`${msg(loc)} must be a string, or undefined`)
				}

				return value
			}

			function assertFunction(loc, value) {
				if (value !== undefined && typeof value !== 'function') {
					throw new Error(`${msg(loc)} must be a function, or undefined`)
				}

				return value
			}

			function assertBoolean(loc, value) {
				if (value !== undefined && typeof value !== 'boolean') {
					throw new Error(`${msg(loc)} must be a boolean, or undefined`)
				}

				return value
			}

			function assertObject(loc, value) {
				if (
					value !== undefined &&
					(typeof value !== 'object' || Array.isArray(value) || !value)
				) {
					throw new Error(`${msg(loc)} must be an object, or undefined`)
				}

				return value
			}

			function assertArray(loc, value) {
				if (value != null && !Array.isArray(value)) {
					throw new Error(`${msg(loc)} must be an array, or undefined`)
				}

				return value
			}

			function assertIgnoreList(loc, value) {
				const arr = assertArray(loc, value)

				if (arr) {
					arr.forEach((item, i) => assertIgnoreItem(access(loc, i), item))
				}

				return arr
			}

			function assertIgnoreItem(loc, value) {
				if (
					typeof value !== 'string' &&
					typeof value !== 'function' &&
					!(value instanceof RegExp)
				) {
					throw new Error(
						`${msg(loc)} must be an array of string/Function/RegExp values, or undefined`,
					)
				}

				return value
			}

			function assertConfigApplicableTest(loc, value) {
				if (value === undefined) return value

				if (Array.isArray(value)) {
					value.forEach((item, i) => {
						if (!checkValidTest(item)) {
							throw new Error(
								`${msg(access(loc, i))} must be a string/Function/RegExp.`,
							)
						}
					})
				} else if (!checkValidTest(value)) {
					throw new Error(
						`${msg(loc)} must be a string/Function/RegExp, or an array of those`,
					)
				}

				return value
			}

			function checkValidTest(value) {
				return (
					typeof value === 'string' ||
					typeof value === 'function' ||
					value instanceof RegExp
				)
			}

			function assertConfigFileSearch(loc, value) {
				if (
					value !== undefined &&
					typeof value !== 'boolean' &&
					typeof value !== 'string'
				) {
					throw new Error(
						`${msg(loc)} must be a undefined, a boolean, a string, ` +
							`got ${JSON.stringify(value)}`,
					)
				}

				return value
			}

			function assertBabelrcSearch(loc, value) {
				if (value === undefined || typeof value === 'boolean') return value

				if (Array.isArray(value)) {
					value.forEach((item, i) => {
						if (!checkValidTest(item)) {
							throw new Error(
								`${msg(access(loc, i))} must be a string/Function/RegExp.`,
							)
						}
					})
				} else if (!checkValidTest(value)) {
					throw new Error(
						`${msg(loc)} must be a undefined, a boolean, a string/Function/RegExp ` +
							`or an array of those, got ${JSON.stringify(value)}`,
					)
				}

				return value
			}

			function assertPluginList(loc, value) {
				const arr = assertArray(loc, value)

				if (arr) {
					arr.forEach((item, i) => assertPluginItem(access(loc, i), item))
				}

				return arr
			}

			function assertPluginItem(loc, value) {
				if (Array.isArray(value)) {
					if (value.length === 0) {
						throw new Error(`${msg(loc)} must include an object`)
					}

					if (value.length > 3) {
						throw new Error(
							`${msg(loc)} may only be a two-tuple or three-tuple`,
						)
					}

					assertPluginTarget(access(loc, 0), value[0])

					if (value.length > 1) {
						const opts = value[1]

						if (
							opts !== undefined &&
							opts !== false &&
							(typeof opts !== 'object' || Array.isArray(opts) || opts === null)
						) {
							throw new Error(
								`${msg(access(loc, 1))} must be an object, false, or undefined`,
							)
						}
					}

					if (value.length === 3) {
						const name = value[2]

						if (name !== undefined && typeof name !== 'string') {
							throw new Error(
								`${msg(access(loc, 2))} must be a string, or undefined`,
							)
						}
					}
				} else {
					assertPluginTarget(loc, value)
				}

				return value
			}

			function assertPluginTarget(loc, value) {
				if (
					(typeof value !== 'object' || !value) &&
					typeof value !== 'string' &&
					typeof value !== 'function'
				) {
					throw new Error(`${msg(loc)} must be a string, object, function`)
				}

				return value
			}

			/***/
		},

		/***/ 44743: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.validate = validate
			exports.checkNoUnwrappedItemOptionPairs = checkNoUnwrappedItemOptionPairs

			var _plugin = _interopRequireDefault(__nccwpck_require__(68618))

			var _removed = _interopRequireDefault(__nccwpck_require__(87269))

			var _optionAssertions = __nccwpck_require__(28)

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			const ROOT_VALIDATORS = {
				cwd: _optionAssertions.assertString,
				root: _optionAssertions.assertString,
				rootMode: _optionAssertions.assertRootMode,
				configFile: _optionAssertions.assertConfigFileSearch,
				caller: _optionAssertions.assertCallerMetadata,
				filename: _optionAssertions.assertString,
				filenameRelative: _optionAssertions.assertString,
				code: _optionAssertions.assertBoolean,
				ast: _optionAssertions.assertBoolean,
				cloneInputAst: _optionAssertions.assertBoolean,
				envName: _optionAssertions.assertString,
			}
			const BABELRC_VALIDATORS = {
				babelrc: _optionAssertions.assertBoolean,
				babelrcRoots: _optionAssertions.assertBabelrcSearch,
			}
			const NONPRESET_VALIDATORS = {
				extends: _optionAssertions.assertString,
				ignore: _optionAssertions.assertIgnoreList,
				only: _optionAssertions.assertIgnoreList,
			}
			const COMMON_VALIDATORS = {
				inputSourceMap: _optionAssertions.assertInputSourceMap,
				presets: _optionAssertions.assertPluginList,
				plugins: _optionAssertions.assertPluginList,
				passPerPreset: _optionAssertions.assertBoolean,
				env: assertEnvSet,
				overrides: assertOverridesList,
				test: _optionAssertions.assertConfigApplicableTest,
				include: _optionAssertions.assertConfigApplicableTest,
				exclude: _optionAssertions.assertConfigApplicableTest,
				retainLines: _optionAssertions.assertBoolean,
				comments: _optionAssertions.assertBoolean,
				shouldPrintComment: _optionAssertions.assertFunction,
				compact: _optionAssertions.assertCompact,
				minified: _optionAssertions.assertBoolean,
				auxiliaryCommentBefore: _optionAssertions.assertString,
				auxiliaryCommentAfter: _optionAssertions.assertString,
				sourceType: _optionAssertions.assertSourceType,
				wrapPluginVisitorMethod: _optionAssertions.assertFunction,
				highlightCode: _optionAssertions.assertBoolean,
				sourceMaps: _optionAssertions.assertSourceMaps,
				sourceMap: _optionAssertions.assertSourceMaps,
				sourceFileName: _optionAssertions.assertString,
				sourceRoot: _optionAssertions.assertString,
				getModuleId: _optionAssertions.assertFunction,
				moduleRoot: _optionAssertions.assertString,
				moduleIds: _optionAssertions.assertBoolean,
				moduleId: _optionAssertions.assertString,
				parserOpts: _optionAssertions.assertObject,
				generatorOpts: _optionAssertions.assertObject,
			}

			function getSource(loc) {
				return loc.type === 'root' ? loc.source : getSource(loc.parent)
			}

			function validate(type, opts) {
				return validateNested(
					{
						type: 'root',
						source: type,
					},
					opts,
				)
			}

			function validateNested(loc, opts) {
				const type = getSource(loc)
				assertNoDuplicateSourcemap(opts)
				Object.keys(opts).forEach((key) => {
					const optLoc = {
						type: 'option',
						name: key,
						parent: loc,
					}

					if (type === 'preset' && NONPRESET_VALIDATORS[key]) {
						throw new Error(
							`${(0, _optionAssertions.msg)(optLoc)} is not allowed in preset options`,
						)
					}

					if (type !== 'arguments' && ROOT_VALIDATORS[key]) {
						throw new Error(
							`${(0, _optionAssertions.msg)(optLoc)} is only allowed in root programmatic options`,
						)
					}

					if (
						type !== 'arguments' &&
						type !== 'configfile' &&
						BABELRC_VALIDATORS[key]
					) {
						if (type === 'babelrcfile' || type === 'extendsfile') {
							throw new Error(
								`${(0, _optionAssertions.msg)(optLoc)} is not allowed in .babelrc or "extends"ed files, only in root programmatic options, ` +
									`or babel.config.js/config file options`,
							)
						}

						throw new Error(
							`${(0, _optionAssertions.msg)(optLoc)} is only allowed in root programmatic options, or babel.config.js/config file options`,
						)
					}

					const validator =
						COMMON_VALIDATORS[key] ||
						NONPRESET_VALIDATORS[key] ||
						BABELRC_VALIDATORS[key] ||
						ROOT_VALIDATORS[key] ||
						throwUnknownError
					validator(optLoc, opts[key])
				})
				return opts
			}

			function throwUnknownError(loc) {
				const key = loc.name

				if (_removed.default[key]) {
					const { message, version = 5 } = _removed.default[key]
					throw new Error(
						`Using removed Babel ${version} option: ${(0, _optionAssertions.msg)(loc)} - ${message}`,
					)
				} else {
					const unknownOptErr = new Error(
						`Unknown option: ${(0, _optionAssertions.msg)(loc)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.`,
					)
					unknownOptErr.code = 'BABEL_UNKNOWN_OPTION'
					throw unknownOptErr
				}
			}

			function has(obj, key) {
				return Object.prototype.hasOwnProperty.call(obj, key)
			}

			function assertNoDuplicateSourcemap(opts) {
				if (has(opts, 'sourceMap') && has(opts, 'sourceMaps')) {
					throw new Error(
						'.sourceMap is an alias for .sourceMaps, cannot use both',
					)
				}
			}

			function assertEnvSet(loc, value) {
				if (loc.parent.type === 'env') {
					throw new Error(
						`${(0, _optionAssertions.msg)(loc)} is not allowed inside of another .env block`,
					)
				}

				const parent = loc.parent
				const obj = (0, _optionAssertions.assertObject)(loc, value)

				if (obj) {
					for (const envName of Object.keys(obj)) {
						const env = (0, _optionAssertions.assertObject)(
							(0, _optionAssertions.access)(loc, envName),
							obj[envName],
						)
						if (!env) continue
						const envLoc = {
							type: 'env',
							name: envName,
							parent,
						}
						validateNested(envLoc, env)
					}
				}

				return obj
			}

			function assertOverridesList(loc, value) {
				if (loc.parent.type === 'env') {
					throw new Error(
						`${(0, _optionAssertions.msg)(loc)} is not allowed inside an .env block`,
					)
				}

				if (loc.parent.type === 'overrides') {
					throw new Error(
						`${(0, _optionAssertions.msg)(loc)} is not allowed inside an .overrides block`,
					)
				}

				const parent = loc.parent
				const arr = (0, _optionAssertions.assertArray)(loc, value)

				if (arr) {
					for (const [index, item] of arr.entries()) {
						const objLoc = (0, _optionAssertions.access)(loc, index)
						const env = (0, _optionAssertions.assertObject)(objLoc, item)
						if (!env)
							throw new Error(
								`${(0, _optionAssertions.msg)(objLoc)} must be an object`,
							)
						const overridesLoc = {
							type: 'overrides',
							index,
							parent,
						}
						validateNested(overridesLoc, env)
					}
				}

				return arr
			}

			function checkNoUnwrappedItemOptionPairs(items, index, type, e) {
				if (index === 0) return
				const lastItem = items[index - 1]
				const thisItem = items[index]

				if (
					lastItem.file &&
					lastItem.options === undefined &&
					typeof thisItem.value === 'object'
				) {
					e.message +=
						`\n- Maybe you meant to use\n` +
						`"${type}": [\n  ["${lastItem.file.request}", ${JSON.stringify(thisItem.value, undefined, 2)}]\n]\n` +
						`To be a valid ${type}, its name and options should be wrapped in a pair of brackets`
				}
			}

			/***/
		},

		/***/ 22449: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.validatePluginObject = validatePluginObject

			var _optionAssertions = __nccwpck_require__(28)

			const VALIDATORS = {
				name: _optionAssertions.assertString,
				manipulateOptions: _optionAssertions.assertFunction,
				pre: _optionAssertions.assertFunction,
				post: _optionAssertions.assertFunction,
				inherits: _optionAssertions.assertFunction,
				visitor: assertVisitorMap,
				parserOverride: _optionAssertions.assertFunction,
				generatorOverride: _optionAssertions.assertFunction,
			}

			function assertVisitorMap(loc, value) {
				const obj = (0, _optionAssertions.assertObject)(loc, value)

				if (obj) {
					Object.keys(obj).forEach((prop) =>
						assertVisitorHandler(prop, obj[prop]),
					)

					if (obj.enter || obj.exit) {
						throw new Error(
							`${(0, _optionAssertions.msg)(loc)} cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.`,
						)
					}
				}

				return obj
			}

			function assertVisitorHandler(key, value) {
				if (value && typeof value === 'object') {
					Object.keys(value).forEach((handler) => {
						if (handler !== 'enter' && handler !== 'exit') {
							throw new Error(
								`.visitor["${key}"] may only have .enter and/or .exit handlers.`,
							)
						}
					})
				} else if (typeof value !== 'function') {
					throw new Error(`.visitor["${key}"] must be a function`)
				}

				return value
			}

			function validatePluginObject(obj) {
				const rootPath = {
					type: 'root',
					source: 'plugin',
				}
				Object.keys(obj).forEach((key) => {
					const validator = VALIDATORS[key]

					if (validator) {
						const optLoc = {
							type: 'option',
							name: key,
							parent: rootPath,
						}
						validator(optLoc, obj[key])
					} else {
						const invalidPluginPropertyError = new Error(
							`.${key} is not a valid Plugin property`,
						)
						invalidPluginPropertyError.code = 'BABEL_UNKNOWN_PLUGIN_PROPERTY'
						throw invalidPluginPropertyError
					}
				})
				return obj
			}

			/***/
		},

		/***/ 87269: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = void 0
			var _default = {
				auxiliaryComment: {
					message: 'Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`',
				},
				blacklist: {
					message:
						'Put the specific transforms you want in the `plugins` option',
				},
				breakConfig: {
					message: 'This is not a necessary option in Babel 6',
				},
				experimental: {
					message:
						'Put the specific transforms you want in the `plugins` option',
				},
				externalHelpers: {
					message:
						'Use the `external-helpers` plugin instead. ' +
						'Check out http://babeljs.io/docs/plugins/external-helpers/',
				},
				extra: {
					message: '',
				},
				jsxPragma: {
					message:
						'use the `pragma` option in the `react-jsx` plugin. ' +
						'Check out http://babeljs.io/docs/plugins/transform-react-jsx/',
				},
				loose: {
					message:
						'Specify the `loose` option for the relevant plugin you are using ' +
						'or use a preset that sets the option.',
				},
				metadataUsedHelpers: {
					message: 'Not required anymore as this is enabled by default',
				},
				modules: {
					message:
						'Use the corresponding module transform plugin in the `plugins` option. ' +
						'Check out http://babeljs.io/docs/plugins/#modules',
				},
				nonStandard: {
					message:
						'Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. ' +
						'Also check out the react preset http://babeljs.io/docs/plugins/preset-react/',
				},
				optional: {
					message:
						'Put the specific transforms you want in the `plugins` option',
				},
				sourceMapName: {
					message:
						'The `sourceMapName` option has been removed because it makes more sense for the ' +
						'tooling that calls Babel to assign `map.file` themselves.',
				},
				stage: {
					message:
						'Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets',
				},
				whitelist: {
					message:
						'Put the specific transforms you want in the `plugins` option',
				},
				resolveModuleSource: {
					version: 6,
					message:
						"Use `babel-plugin-module-resolver@3`'s 'resolvePath' options",
				},
				metadata: {
					version: 6,
					message:
						'Generated plugin metadata is always included in the output result',
				},
				sourceMapTarget: {
					version: 6,
					message:
						'The `sourceMapTarget` option has been removed because it makes more sense for the tooling ' +
						'that calls Babel to assign `map.file` themselves.',
				},
			}
			exports['default'] = _default

			/***/
		},

		/***/ 87360: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.maybeAsync = maybeAsync
			exports.forwardAsync = forwardAsync
			exports.isThenable = isThenable
			exports.waitFor = exports.onFirstPause = exports.isAsync = void 0

			function _gensync() {
				const data = _interopRequireDefault(__nccwpck_require__(9621))

				_gensync = function () {
					return data
				}

				return data
			}

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			const id = (x) => x

			const runGenerator = (0, _gensync().default)(function* (item) {
				return yield* item
			})
			const isAsync = (0, _gensync().default)({
				sync: () => false,
				errback: (cb) => cb(null, true),
			})
			exports.isAsync = isAsync

			function maybeAsync(fn, message) {
				return (0, _gensync().default)({
					sync(...args) {
						const result = fn.apply(this, args)
						if (isThenable(result)) throw new Error(message)
						return result
					},

					async(...args) {
						return Promise.resolve(fn.apply(this, args))
					},
				})
			}

			const withKind = (0, _gensync().default)({
				sync: (cb) => cb('sync'),
				async: (cb) => cb('async'),
			})

			function forwardAsync(action, cb) {
				const g = (0, _gensync().default)(action)
				return withKind((kind) => {
					const adapted = g[kind]
					return cb(adapted)
				})
			}

			const onFirstPause = (0, _gensync().default)({
				name: 'onFirstPause',
				arity: 2,
				sync: function (item) {
					return runGenerator.sync(item)
				},
				errback: function (item, firstPause, cb) {
					let completed = false
					runGenerator.errback(item, (err, value) => {
						completed = true
						cb(err, value)
					})

					if (!completed) {
						firstPause()
					}
				},
			})
			exports.onFirstPause = onFirstPause
			const waitFor = (0, _gensync().default)({
				sync: id,
				async: id,
			})
			exports.waitFor = waitFor

			function isThenable(val) {
				return (
					!!val &&
					(typeof val === 'object' || typeof val === 'function') &&
					!!val.then &&
					typeof val.then === 'function'
				)
			}

			/***/
		},

		/***/ 10733: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.stat = exports.exists = exports.readFile = void 0

			function _fs() {
				const data = _interopRequireDefault(__nccwpck_require__(79896))

				_fs = function () {
					return data
				}

				return data
			}

			function _gensync() {
				const data = _interopRequireDefault(__nccwpck_require__(9621))

				_gensync = function () {
					return data
				}

				return data
			}

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			const readFile = (0, _gensync().default)({
				sync: _fs().default.readFileSync,
				errback: _fs().default.readFile,
			})
			exports.readFile = readFile
			const exists = (0, _gensync().default)({
				sync(path) {
					try {
						_fs().default.accessSync(path)

						return true
					} catch (_unused) {
						return false
					}
				},

				errback: (path, cb) =>
					_fs().default.access(path, undefined, (err) => cb(null, !err)),
			})
			exports.exists = exists
			const stat = (0, _gensync().default)({
				sync: _fs().default.statSync,
				errback: _fs().default.stat,
			})
			exports.stat = stat

			/***/
		},

		/***/ 12620: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = void 0

			function _resolve() {
				const data = _interopRequireDefault(__nccwpck_require__(92312))

				_resolve = function () {
					return data
				}

				return data
			}

			function _gensync() {
				const data = _interopRequireDefault(__nccwpck_require__(9621))

				_gensync = function () {
					return data
				}

				return data
			}

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			var _default = (0, _gensync().default)({
				sync: _resolve().default.sync,
				errback: _resolve().default,
			})

			exports['default'] = _default

			/***/
		},

		/***/ 85414: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.Plugin = Plugin
			Object.defineProperty(exports, 'File', {
				enumerable: true,
				get: function () {
					return _file.default
				},
			})
			Object.defineProperty(exports, 'buildExternalHelpers', {
				enumerable: true,
				get: function () {
					return _buildExternalHelpers.default
				},
			})
			Object.defineProperty(exports, 'resolvePlugin', {
				enumerable: true,
				get: function () {
					return _files.resolvePlugin
				},
			})
			Object.defineProperty(exports, 'resolvePreset', {
				enumerable: true,
				get: function () {
					return _files.resolvePreset
				},
			})
			Object.defineProperty(exports, 'version', {
				enumerable: true,
				get: function () {
					return _package.version
				},
			})
			Object.defineProperty(exports, 'getEnv', {
				enumerable: true,
				get: function () {
					return _environment.getEnv
				},
			})
			Object.defineProperty(exports, 'tokTypes', {
				enumerable: true,
				get: function () {
					return _parser().tokTypes
				},
			})
			Object.defineProperty(exports, 'traverse', {
				enumerable: true,
				get: function () {
					return _traverse().default
				},
			})
			Object.defineProperty(exports, 'template', {
				enumerable: true,
				get: function () {
					return _template().default
				},
			})
			Object.defineProperty(exports, 'createConfigItem', {
				enumerable: true,
				get: function () {
					return _item.createConfigItem
				},
			})
			Object.defineProperty(exports, 'loadPartialConfig', {
				enumerable: true,
				get: function () {
					return _config.loadPartialConfig
				},
			})
			Object.defineProperty(exports, 'loadPartialConfigSync', {
				enumerable: true,
				get: function () {
					return _config.loadPartialConfigSync
				},
			})
			Object.defineProperty(exports, 'loadPartialConfigAsync', {
				enumerable: true,
				get: function () {
					return _config.loadPartialConfigAsync
				},
			})
			Object.defineProperty(exports, 'loadOptions', {
				enumerable: true,
				get: function () {
					return _config.loadOptions
				},
			})
			Object.defineProperty(exports, 'loadOptionsSync', {
				enumerable: true,
				get: function () {
					return _config.loadOptionsSync
				},
			})
			Object.defineProperty(exports, 'loadOptionsAsync', {
				enumerable: true,
				get: function () {
					return _config.loadOptionsAsync
				},
			})
			Object.defineProperty(exports, 'transform', {
				enumerable: true,
				get: function () {
					return _transform.transform
				},
			})
			Object.defineProperty(exports, 'transformSync', {
				enumerable: true,
				get: function () {
					return _transform.transformSync
				},
			})
			Object.defineProperty(exports, 'transformAsync', {
				enumerable: true,
				get: function () {
					return _transform.transformAsync
				},
			})
			Object.defineProperty(exports, 'transformFile', {
				enumerable: true,
				get: function () {
					return _transformFile.transformFile
				},
			})
			Object.defineProperty(exports, 'transformFileSync', {
				enumerable: true,
				get: function () {
					return _transformFile.transformFileSync
				},
			})
			Object.defineProperty(exports, 'transformFileAsync', {
				enumerable: true,
				get: function () {
					return _transformFile.transformFileAsync
				},
			})
			Object.defineProperty(exports, 'transformFromAst', {
				enumerable: true,
				get: function () {
					return _transformAst.transformFromAst
				},
			})
			Object.defineProperty(exports, 'transformFromAstSync', {
				enumerable: true,
				get: function () {
					return _transformAst.transformFromAstSync
				},
			})
			Object.defineProperty(exports, 'transformFromAstAsync', {
				enumerable: true,
				get: function () {
					return _transformAst.transformFromAstAsync
				},
			})
			Object.defineProperty(exports, 'parse', {
				enumerable: true,
				get: function () {
					return _parse.parse
				},
			})
			Object.defineProperty(exports, 'parseSync', {
				enumerable: true,
				get: function () {
					return _parse.parseSync
				},
			})
			Object.defineProperty(exports, 'parseAsync', {
				enumerable: true,
				get: function () {
					return _parse.parseAsync
				},
			})
			exports.types =
				exports.OptionManager =
				exports.DEFAULT_EXTENSIONS =
					void 0

			var _file = _interopRequireDefault(__nccwpck_require__(12211))

			var _buildExternalHelpers = _interopRequireDefault(
				__nccwpck_require__(60316),
			)

			var _files = __nccwpck_require__(37217)

			var _package = __nccwpck_require__(29602)

			var _environment = __nccwpck_require__(3110)

			function _types() {
				const data = _interopRequireWildcard(__nccwpck_require__(16535))

				_types = function () {
					return data
				}

				return data
			}

			Object.defineProperty(exports, 'types', {
				enumerable: true,
				get: function () {
					return _types()
				},
			})

			function _parser() {
				const data = __nccwpck_require__(5429)

				_parser = function () {
					return data
				}

				return data
			}

			function _traverse() {
				const data = _interopRequireDefault(__nccwpck_require__(50148))

				_traverse = function () {
					return data
				}

				return data
			}

			function _template() {
				const data = _interopRequireDefault(__nccwpck_require__(19648))

				_template = function () {
					return data
				}

				return data
			}

			var _item = __nccwpck_require__(72478)

			var _config = __nccwpck_require__(73677)

			var _transform = __nccwpck_require__(46442)

			var _transformFile = __nccwpck_require__(39037)

			var _transformAst = __nccwpck_require__(98239)

			var _parse = __nccwpck_require__(35973)

			function _getRequireWildcardCache() {
				if (typeof WeakMap !== 'function') return null
				var cache = new WeakMap()
				_getRequireWildcardCache = function () {
					return cache
				}
				return cache
			}

			function _interopRequireWildcard(obj) {
				if (obj && obj.__esModule) {
					return obj
				}
				if (
					obj === null ||
					(typeof obj !== 'object' && typeof obj !== 'function')
				) {
					return { default: obj }
				}
				var cache = _getRequireWildcardCache()
				if (cache && cache.has(obj)) {
					return cache.get(obj)
				}
				var newObj = {}
				var hasPropertyDescriptor =
					Object.defineProperty && Object.getOwnPropertyDescriptor
				for (var key in obj) {
					if (Object.prototype.hasOwnProperty.call(obj, key)) {
						var desc = hasPropertyDescriptor
							? Object.getOwnPropertyDescriptor(obj, key)
							: null
						if (desc && (desc.get || desc.set)) {
							Object.defineProperty(newObj, key, desc)
						} else {
							newObj[key] = obj[key]
						}
					}
				}
				newObj.default = obj
				if (cache) {
					cache.set(obj, newObj)
				}
				return newObj
			}

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			const DEFAULT_EXTENSIONS = Object.freeze([
				'.js',
				'.jsx',
				'.es6',
				'.es',
				'.mjs',
			])
			exports.DEFAULT_EXTENSIONS = DEFAULT_EXTENSIONS

			class OptionManager {
				init(opts) {
					return (0, _config.loadOptions)(opts)
				}
			}

			exports.OptionManager = OptionManager

			function Plugin(alias) {
				throw new Error(
					`The (${alias}) Babel 5 plugin is being run with an unsupported Babel version.`,
				)
			}

			/***/
		},

		/***/ 35973: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.parseAsync = exports.parseSync = exports.parse = void 0

			function _gensync() {
				const data = _interopRequireDefault(__nccwpck_require__(9621))

				_gensync = function () {
					return data
				}

				return data
			}

			var _config = _interopRequireDefault(__nccwpck_require__(73677))

			var _parser = _interopRequireDefault(__nccwpck_require__(99904))

			var _normalizeOpts = _interopRequireDefault(__nccwpck_require__(74944))

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			const parseRunner = (0, _gensync().default)(function* parse(code, opts) {
				const config = yield* (0, _config.default)(opts)

				if (config === null) {
					return null
				}

				return yield* (0, _parser.default)(
					config.passes,
					(0, _normalizeOpts.default)(config),
					code,
				)
			})

			const parse = function parse(code, opts, callback) {
				if (typeof opts === 'function') {
					callback = opts
					opts = undefined
				}

				if (callback === undefined) return parseRunner.sync(code, opts)
				parseRunner.errback(code, opts, callback)
			}

			exports.parse = parse
			const parseSync = parseRunner.sync
			exports.parseSync = parseSync
			const parseAsync = parseRunner.async
			exports.parseAsync = parseAsync

			/***/
		},

		/***/ 99904: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = parser

			function _parser() {
				const data = __nccwpck_require__(5429)

				_parser = function () {
					return data
				}

				return data
			}

			function _codeFrame() {
				const data = __nccwpck_require__(90147)

				_codeFrame = function () {
					return data
				}

				return data
			}

			var _missingPluginHelper = _interopRequireDefault(
				__nccwpck_require__(3498),
			)

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			function* parser(
				pluginPasses,
				{ parserOpts, highlightCode = true, filename = 'unknown' },
				code,
			) {
				try {
					const results = []

					for (const plugins of pluginPasses) {
						for (const plugin of plugins) {
							const { parserOverride } = plugin

							if (parserOverride) {
								const ast = parserOverride(code, parserOpts, _parser().parse)
								if (ast !== undefined) results.push(ast)
							}
						}
					}

					if (results.length === 0) {
						return (0, _parser().parse)(code, parserOpts)
					} else if (results.length === 1) {
						yield* []

						if (typeof results[0].then === 'function') {
							throw new Error(
								`You appear to be using an async parser plugin, ` +
									`which your current version of Babel does not support. ` +
									`If you're using a published plugin, you may need to upgrade ` +
									`your @babel/core version.`,
							)
						}

						return results[0]
					}

					throw new Error('More than one plugin attempted to override parsing.')
				} catch (err) {
					if (err.code === 'BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED') {
						err.message +=
							"\nConsider renaming the file to '.mjs', or setting sourceType:module " +
							'or sourceType:unambiguous in your Babel config for this file.'
					}

					const { loc, missingPlugin } = err

					if (loc) {
						const codeFrame = (0, _codeFrame().codeFrameColumns)(
							code,
							{
								start: {
									line: loc.line,
									column: loc.column + 1,
								},
							},
							{
								highlightCode,
							},
						)

						if (missingPlugin) {
							err.message =
								`${filename}: ` +
								(0, _missingPluginHelper.default)(
									missingPlugin[0],
									loc,
									codeFrame,
								)
						} else {
							err.message = `${filename}: ${err.message}\n\n` + codeFrame
						}

						err.code = 'BABEL_PARSE_ERROR'
					}

					throw err
				}
			}

			/***/
		},

		/***/ 3498: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = generateMissingPluginMessage
			const pluginNameMap = {
				classProperties: {
					syntax: {
						name: '@babel/plugin-syntax-class-properties',
						url: 'https://git.io/vb4yQ',
					},
					transform: {
						name: '@babel/plugin-proposal-class-properties',
						url: 'https://git.io/vb4SL',
					},
				},
				classPrivateProperties: {
					syntax: {
						name: '@babel/plugin-syntax-class-properties',
						url: 'https://git.io/vb4yQ',
					},
					transform: {
						name: '@babel/plugin-proposal-class-properties',
						url: 'https://git.io/vb4SL',
					},
				},
				classPrivateMethods: {
					syntax: {
						name: '@babel/plugin-syntax-class-properties',
						url: 'https://git.io/vb4yQ',
					},
					transform: {
						name: '@babel/plugin-proposal-private-methods',
						url: 'https://git.io/JvpRG',
					},
				},
				classStaticBlock: {
					syntax: {
						name: '@babel/plugin-syntax-class-static-block',
						url: 'https://git.io/JTLB6',
					},
					transform: {
						name: '@babel/plugin-proposal-class-static-block',
						url: 'https://git.io/JTLBP',
					},
				},
				decimal: {
					syntax: {
						name: '@babel/plugin-syntax-decimal',
						url: 'https://git.io/JfKOH',
					},
				},
				decorators: {
					syntax: {
						name: '@babel/plugin-syntax-decorators',
						url: 'https://git.io/vb4y9',
					},
					transform: {
						name: '@babel/plugin-proposal-decorators',
						url: 'https://git.io/vb4ST',
					},
				},
				doExpressions: {
					syntax: {
						name: '@babel/plugin-syntax-do-expressions',
						url: 'https://git.io/vb4yh',
					},
					transform: {
						name: '@babel/plugin-proposal-do-expressions',
						url: 'https://git.io/vb4S3',
					},
				},
				dynamicImport: {
					syntax: {
						name: '@babel/plugin-syntax-dynamic-import',
						url: 'https://git.io/vb4Sv',
					},
				},
				exportDefaultFrom: {
					syntax: {
						name: '@babel/plugin-syntax-export-default-from',
						url: 'https://git.io/vb4SO',
					},
					transform: {
						name: '@babel/plugin-proposal-export-default-from',
						url: 'https://git.io/vb4yH',
					},
				},
				exportNamespaceFrom: {
					syntax: {
						name: '@babel/plugin-syntax-export-namespace-from',
						url: 'https://git.io/vb4Sf',
					},
					transform: {
						name: '@babel/plugin-proposal-export-namespace-from',
						url: 'https://git.io/vb4SG',
					},
				},
				flow: {
					syntax: {
						name: '@babel/plugin-syntax-flow',
						url: 'https://git.io/vb4yb',
					},
					transform: {
						name: '@babel/preset-flow',
						url: 'https://git.io/JfeDn',
					},
				},
				functionBind: {
					syntax: {
						name: '@babel/plugin-syntax-function-bind',
						url: 'https://git.io/vb4y7',
					},
					transform: {
						name: '@babel/plugin-proposal-function-bind',
						url: 'https://git.io/vb4St',
					},
				},
				functionSent: {
					syntax: {
						name: '@babel/plugin-syntax-function-sent',
						url: 'https://git.io/vb4yN',
					},
					transform: {
						name: '@babel/plugin-proposal-function-sent',
						url: 'https://git.io/vb4SZ',
					},
				},
				importMeta: {
					syntax: {
						name: '@babel/plugin-syntax-import-meta',
						url: 'https://git.io/vbKK6',
					},
				},
				jsx: {
					syntax: {
						name: '@babel/plugin-syntax-jsx',
						url: 'https://git.io/vb4yA',
					},
					transform: {
						name: '@babel/preset-react',
						url: 'https://git.io/JfeDR',
					},
				},
				importAssertions: {
					syntax: {
						name: '@babel/plugin-syntax-import-assertions',
						url: 'https://git.io/JUbkv',
					},
				},
				moduleStringNames: {
					syntax: {
						name: '@babel/plugin-syntax-module-string-names',
						url: 'https://git.io/JTL8G',
					},
				},
				numericSeparator: {
					syntax: {
						name: '@babel/plugin-syntax-numeric-separator',
						url: 'https://git.io/vb4Sq',
					},
					transform: {
						name: '@babel/plugin-proposal-numeric-separator',
						url: 'https://git.io/vb4yS',
					},
				},
				optionalChaining: {
					syntax: {
						name: '@babel/plugin-syntax-optional-chaining',
						url: 'https://git.io/vb4Sc',
					},
					transform: {
						name: '@babel/plugin-proposal-optional-chaining',
						url: 'https://git.io/vb4Sk',
					},
				},
				pipelineOperator: {
					syntax: {
						name: '@babel/plugin-syntax-pipeline-operator',
						url: 'https://git.io/vb4yj',
					},
					transform: {
						name: '@babel/plugin-proposal-pipeline-operator',
						url: 'https://git.io/vb4SU',
					},
				},
				privateIn: {
					syntax: {
						name: '@babel/plugin-syntax-private-property-in-object',
						url: 'https://git.io/JfK3q',
					},
					transform: {
						name: '@babel/plugin-proposal-private-property-in-object',
						url: 'https://git.io/JfK3O',
					},
				},
				recordAndTuple: {
					syntax: {
						name: '@babel/plugin-syntax-record-and-tuple',
						url: 'https://git.io/JvKp3',
					},
				},
				throwExpressions: {
					syntax: {
						name: '@babel/plugin-syntax-throw-expressions',
						url: 'https://git.io/vb4SJ',
					},
					transform: {
						name: '@babel/plugin-proposal-throw-expressions',
						url: 'https://git.io/vb4yF',
					},
				},
				typescript: {
					syntax: {
						name: '@babel/plugin-syntax-typescript',
						url: 'https://git.io/vb4SC',
					},
					transform: {
						name: '@babel/preset-typescript',
						url: 'https://git.io/JfeDz',
					},
				},
				asyncGenerators: {
					syntax: {
						name: '@babel/plugin-syntax-async-generators',
						url: 'https://git.io/vb4SY',
					},
					transform: {
						name: '@babel/plugin-proposal-async-generator-functions',
						url: 'https://git.io/vb4yp',
					},
				},
				logicalAssignment: {
					syntax: {
						name: '@babel/plugin-syntax-logical-assignment-operators',
						url: 'https://git.io/vAlBp',
					},
					transform: {
						name: '@babel/plugin-proposal-logical-assignment-operators',
						url: 'https://git.io/vAlRe',
					},
				},
				nullishCoalescingOperator: {
					syntax: {
						name: '@babel/plugin-syntax-nullish-coalescing-operator',
						url: 'https://git.io/vb4yx',
					},
					transform: {
						name: '@babel/plugin-proposal-nullish-coalescing-operator',
						url: 'https://git.io/vb4Se',
					},
				},
				objectRestSpread: {
					syntax: {
						name: '@babel/plugin-syntax-object-rest-spread',
						url: 'https://git.io/vb4y5',
					},
					transform: {
						name: '@babel/plugin-proposal-object-rest-spread',
						url: 'https://git.io/vb4Ss',
					},
				},
				optionalCatchBinding: {
					syntax: {
						name: '@babel/plugin-syntax-optional-catch-binding',
						url: 'https://git.io/vb4Sn',
					},
					transform: {
						name: '@babel/plugin-proposal-optional-catch-binding',
						url: 'https://git.io/vb4SI',
					},
				},
			}
			pluginNameMap.privateIn.syntax = pluginNameMap.privateIn.transform

			const getNameURLCombination = ({ name, url }) => `${name} (${url})`

			function generateMissingPluginMessage(missingPluginName, loc, codeFrame) {
				let helpMessage =
					`Support for the experimental syntax '${missingPluginName}' isn't currently enabled ` +
					`(${loc.line}:${loc.column + 1}):\n\n` +
					codeFrame
				const pluginInfo = pluginNameMap[missingPluginName]

				if (pluginInfo) {
					const { syntax: syntaxPlugin, transform: transformPlugin } =
						pluginInfo

					if (syntaxPlugin) {
						const syntaxPluginInfo = getNameURLCombination(syntaxPlugin)

						if (transformPlugin) {
							const transformPluginInfo = getNameURLCombination(transformPlugin)
							const sectionType = transformPlugin.name.startsWith(
								'@babel/plugin',
							)
								? 'plugins'
								: 'presets'
							helpMessage += `\n\nAdd ${transformPluginInfo} to the '${sectionType}' section of your Babel config to enable transformation.
If you want to leave it as-is, add ${syntaxPluginInfo} to the 'plugins' section to enable parsing.`
						} else {
							helpMessage +=
								`\n\nAdd ${syntaxPluginInfo} to the 'plugins' section of your Babel config ` +
								`to enable parsing.`
						}
					}
				}

				return helpMessage
			}

			/***/
		},

		/***/ 60316: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = _default

			function helpers() {
				const data = _interopRequireWildcard(__nccwpck_require__(71475))

				helpers = function () {
					return data
				}

				return data
			}

			function _generator() {
				const data = _interopRequireDefault(__nccwpck_require__(12123))

				_generator = function () {
					return data
				}

				return data
			}

			function _template() {
				const data = _interopRequireDefault(__nccwpck_require__(19648))

				_template = function () {
					return data
				}

				return data
			}

			function t() {
				const data = _interopRequireWildcard(__nccwpck_require__(16535))

				t = function () {
					return data
				}

				return data
			}

			var _file = _interopRequireDefault(__nccwpck_require__(12211))

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			function _getRequireWildcardCache() {
				if (typeof WeakMap !== 'function') return null
				var cache = new WeakMap()
				_getRequireWildcardCache = function () {
					return cache
				}
				return cache
			}

			function _interopRequireWildcard(obj) {
				if (obj && obj.__esModule) {
					return obj
				}
				if (
					obj === null ||
					(typeof obj !== 'object' && typeof obj !== 'function')
				) {
					return { default: obj }
				}
				var cache = _getRequireWildcardCache()
				if (cache && cache.has(obj)) {
					return cache.get(obj)
				}
				var newObj = {}
				var hasPropertyDescriptor =
					Object.defineProperty && Object.getOwnPropertyDescriptor
				for (var key in obj) {
					if (Object.prototype.hasOwnProperty.call(obj, key)) {
						var desc = hasPropertyDescriptor
							? Object.getOwnPropertyDescriptor(obj, key)
							: null
						if (desc && (desc.get || desc.set)) {
							Object.defineProperty(newObj, key, desc)
						} else {
							newObj[key] = obj[key]
						}
					}
				}
				newObj.default = obj
				if (cache) {
					cache.set(obj, newObj)
				}
				return newObj
			}

			const buildUmdWrapper = (replacements) =>
				(0, _template().default)`
    (function (root, factory) {
      if (typeof define === "function" && define.amd) {
        define(AMD_ARGUMENTS, factory);
      } else if (typeof exports === "object") {
        factory(COMMON_ARGUMENTS);
      } else {
        factory(BROWSER_ARGUMENTS);
      }
    })(UMD_ROOT, function (FACTORY_PARAMETERS) {
      FACTORY_BODY
    });
  `(replacements)

			function buildGlobal(allowlist) {
				const namespace = t().identifier('babelHelpers')
				const body = []
				const container = t().functionExpression(
					null,
					[t().identifier('global')],
					t().blockStatement(body),
				)
				const tree = t().program([
					t().expressionStatement(
						t().callExpression(container, [
							t().conditionalExpression(
								t().binaryExpression(
									'===',
									t().unaryExpression('typeof', t().identifier('global')),
									t().stringLiteral('undefined'),
								),
								t().identifier('self'),
								t().identifier('global'),
							),
						]),
					),
				])
				body.push(
					t().variableDeclaration('var', [
						t().variableDeclarator(
							namespace,
							t().assignmentExpression(
								'=',
								t().memberExpression(t().identifier('global'), namespace),
								t().objectExpression([]),
							),
						),
					]),
				)
				buildHelpers(body, namespace, allowlist)
				return tree
			}

			function buildModule(allowlist) {
				const body = []
				const refs = buildHelpers(body, null, allowlist)
				body.unshift(
					t().exportNamedDeclaration(
						null,
						Object.keys(refs).map((name) => {
							return t().exportSpecifier(
								t().cloneNode(refs[name]),
								t().identifier(name),
							)
						}),
					),
				)
				return t().program(body, [], 'module')
			}

			function buildUmd(allowlist) {
				const namespace = t().identifier('babelHelpers')
				const body = []
				body.push(
					t().variableDeclaration('var', [
						t().variableDeclarator(namespace, t().identifier('global')),
					]),
				)
				buildHelpers(body, namespace, allowlist)
				return t().program([
					buildUmdWrapper({
						FACTORY_PARAMETERS: t().identifier('global'),
						BROWSER_ARGUMENTS: t().assignmentExpression(
							'=',
							t().memberExpression(t().identifier('root'), namespace),
							t().objectExpression([]),
						),
						COMMON_ARGUMENTS: t().identifier('exports'),
						AMD_ARGUMENTS: t().arrayExpression([t().stringLiteral('exports')]),
						FACTORY_BODY: body,
						UMD_ROOT: t().identifier('this'),
					}),
				])
			}

			function buildVar(allowlist) {
				const namespace = t().identifier('babelHelpers')
				const body = []
				body.push(
					t().variableDeclaration('var', [
						t().variableDeclarator(namespace, t().objectExpression([])),
					]),
				)
				const tree = t().program(body)
				buildHelpers(body, namespace, allowlist)
				body.push(t().expressionStatement(namespace))
				return tree
			}

			function buildHelpers(body, namespace, allowlist) {
				const getHelperReference = (name) => {
					return namespace
						? t().memberExpression(namespace, t().identifier(name))
						: t().identifier(`_${name}`)
				}

				const refs = {}
				helpers().list.forEach(function (name) {
					if (allowlist && allowlist.indexOf(name) < 0) return
					const ref = (refs[name] = getHelperReference(name))
					helpers().ensure(name, _file.default)
					const { nodes } = helpers().get(name, getHelperReference, ref)
					body.push(...nodes)
				})
				return refs
			}

			function _default(allowlist, outputType = 'global') {
				let tree
				const build = {
					global: buildGlobal,
					module: buildModule,
					umd: buildUmd,
					var: buildVar,
				}[outputType]

				if (build) {
					tree = build(allowlist)
				} else {
					throw new Error(`Unsupported output type ${outputType}`)
				}

				return (0, _generator().default)(tree).code
			}

			/***/
		},

		/***/ 98239: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.transformFromAstAsync =
				exports.transformFromAstSync =
				exports.transformFromAst =
					void 0

			function _gensync() {
				const data = _interopRequireDefault(__nccwpck_require__(9621))

				_gensync = function () {
					return data
				}

				return data
			}

			var _config = _interopRequireDefault(__nccwpck_require__(73677))

			var _transformation = __nccwpck_require__(16486)

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			const transformFromAstRunner = (0, _gensync().default)(
				function* (ast, code, opts) {
					const config = yield* (0, _config.default)(opts)
					if (config === null) return null
					if (!ast) throw new Error('No AST given')
					return yield* (0, _transformation.run)(config, code, ast)
				},
			)

			const transformFromAst = function transformFromAst(
				ast,
				code,
				opts,
				callback,
			) {
				if (typeof opts === 'function') {
					callback = opts
					opts = undefined
				}

				if (callback === undefined) {
					return transformFromAstRunner.sync(ast, code, opts)
				}

				transformFromAstRunner.errback(ast, code, opts, callback)
			}

			exports.transformFromAst = transformFromAst
			const transformFromAstSync = transformFromAstRunner.sync
			exports.transformFromAstSync = transformFromAstSync
			const transformFromAstAsync = transformFromAstRunner.async
			exports.transformFromAstAsync = transformFromAstAsync

			/***/
		},

		/***/ 39037: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.transformFileAsync =
				exports.transformFileSync =
				exports.transformFile =
					void 0

			function _gensync() {
				const data = _interopRequireDefault(__nccwpck_require__(9621))

				_gensync = function () {
					return data
				}

				return data
			}

			var _config = _interopRequireDefault(__nccwpck_require__(73677))

			var _transformation = __nccwpck_require__(16486)

			var fs = _interopRequireWildcard(__nccwpck_require__(10733))

			function _getRequireWildcardCache() {
				if (typeof WeakMap !== 'function') return null
				var cache = new WeakMap()
				_getRequireWildcardCache = function () {
					return cache
				}
				return cache
			}

			function _interopRequireWildcard(obj) {
				if (obj && obj.__esModule) {
					return obj
				}
				if (
					obj === null ||
					(typeof obj !== 'object' && typeof obj !== 'function')
				) {
					return { default: obj }
				}
				var cache = _getRequireWildcardCache()
				if (cache && cache.has(obj)) {
					return cache.get(obj)
				}
				var newObj = {}
				var hasPropertyDescriptor =
					Object.defineProperty && Object.getOwnPropertyDescriptor
				for (var key in obj) {
					if (Object.prototype.hasOwnProperty.call(obj, key)) {
						var desc = hasPropertyDescriptor
							? Object.getOwnPropertyDescriptor(obj, key)
							: null
						if (desc && (desc.get || desc.set)) {
							Object.defineProperty(newObj, key, desc)
						} else {
							newObj[key] = obj[key]
						}
					}
				}
				newObj.default = obj
				if (cache) {
					cache.set(obj, newObj)
				}
				return newObj
			}

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			;({})
			const transformFileRunner = (0, _gensync().default)(
				function* (filename, opts) {
					const options = Object.assign({}, opts, {
						filename,
					})
					const config = yield* (0, _config.default)(options)
					if (config === null) return null
					const code = yield* fs.readFile(filename, 'utf8')
					return yield* (0, _transformation.run)(config, code)
				},
			)
			const transformFile = transformFileRunner.errback
			exports.transformFile = transformFile
			const transformFileSync = transformFileRunner.sync
			exports.transformFileSync = transformFileSync
			const transformFileAsync = transformFileRunner.async
			exports.transformFileAsync = transformFileAsync

			/***/
		},

		/***/ 46442: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.transformAsync =
				exports.transformSync =
				exports.transform =
					void 0

			function _gensync() {
				const data = _interopRequireDefault(__nccwpck_require__(9621))

				_gensync = function () {
					return data
				}

				return data
			}

			var _config = _interopRequireDefault(__nccwpck_require__(73677))

			var _transformation = __nccwpck_require__(16486)

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			const transformRunner = (0, _gensync().default)(
				function* transform(code, opts) {
					const config = yield* (0, _config.default)(opts)
					if (config === null) return null
					return yield* (0, _transformation.run)(config, code)
				},
			)

			const transform = function transform(code, opts, callback) {
				if (typeof opts === 'function') {
					callback = opts
					opts = undefined
				}

				if (callback === undefined) return transformRunner.sync(code, opts)
				transformRunner.errback(code, opts, callback)
			}

			exports.transform = transform
			const transformSync = transformRunner.sync
			exports.transformSync = transformSync
			const transformAsync = transformRunner.async
			exports.transformAsync = transformAsync

			/***/
		},

		/***/ 28925: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = loadBlockHoistPlugin

			function _sortBy() {
				const data = _interopRequireDefault(__nccwpck_require__(94604))

				_sortBy = function () {
					return data
				}

				return data
			}

			var _config = _interopRequireDefault(__nccwpck_require__(73677))

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			let LOADED_PLUGIN

			function loadBlockHoistPlugin() {
				if (!LOADED_PLUGIN) {
					const config = _config.default.sync({
						babelrc: false,
						configFile: false,
						plugins: [blockHoistPlugin],
					})

					LOADED_PLUGIN = config ? config.passes[0][0] : undefined
					if (!LOADED_PLUGIN) throw new Error('Assertion failure')
				}

				return LOADED_PLUGIN
			}

			const blockHoistPlugin = {
				name: 'internal.blockHoist',
				visitor: {
					Block: {
						exit({ node }) {
							let hasChange = false

							for (let i = 0; i < node.body.length; i++) {
								const bodyNode = node.body[i]

								if (
									(bodyNode == null ? void 0 : bodyNode._blockHoist) != null
								) {
									hasChange = true
									break
								}
							}

							if (!hasChange) return
							node.body = (0, _sortBy().default)(
								node.body,
								function (bodyNode) {
									let priority =
										bodyNode == null ? void 0 : bodyNode._blockHoist
									if (priority == null) priority = 1
									if (priority === true) priority = 2
									return -1 * priority
								},
							)
						},
					},
				},
			}

			/***/
		},

		/***/ 12211: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = void 0

			function helpers() {
				const data = _interopRequireWildcard(__nccwpck_require__(71475))

				helpers = function () {
					return data
				}

				return data
			}

			function _traverse() {
				const data = _interopRequireWildcard(__nccwpck_require__(50148))

				_traverse = function () {
					return data
				}

				return data
			}

			function _codeFrame() {
				const data = __nccwpck_require__(90147)

				_codeFrame = function () {
					return data
				}

				return data
			}

			function t() {
				const data = _interopRequireWildcard(__nccwpck_require__(16535))

				t = function () {
					return data
				}

				return data
			}

			function _helperModuleTransforms() {
				const data = __nccwpck_require__(3665)

				_helperModuleTransforms = function () {
					return data
				}

				return data
			}

			function _semver() {
				const data = _interopRequireDefault(__nccwpck_require__(39318))

				_semver = function () {
					return data
				}

				return data
			}

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			function _getRequireWildcardCache() {
				if (typeof WeakMap !== 'function') return null
				var cache = new WeakMap()
				_getRequireWildcardCache = function () {
					return cache
				}
				return cache
			}

			function _interopRequireWildcard(obj) {
				if (obj && obj.__esModule) {
					return obj
				}
				if (
					obj === null ||
					(typeof obj !== 'object' && typeof obj !== 'function')
				) {
					return { default: obj }
				}
				var cache = _getRequireWildcardCache()
				if (cache && cache.has(obj)) {
					return cache.get(obj)
				}
				var newObj = {}
				var hasPropertyDescriptor =
					Object.defineProperty && Object.getOwnPropertyDescriptor
				for (var key in obj) {
					if (Object.prototype.hasOwnProperty.call(obj, key)) {
						var desc = hasPropertyDescriptor
							? Object.getOwnPropertyDescriptor(obj, key)
							: null
						if (desc && (desc.get || desc.set)) {
							Object.defineProperty(newObj, key, desc)
						} else {
							newObj[key] = obj[key]
						}
					}
				}
				newObj.default = obj
				if (cache) {
					cache.set(obj, newObj)
				}
				return newObj
			}

			const errorVisitor = {
				enter(path, state) {
					const loc = path.node.loc

					if (loc) {
						state.loc = loc
						path.stop()
					}
				},
			}

			class File {
				constructor(options, { code, ast, inputMap }) {
					this._map = new Map()
					this.opts = void 0
					this.declarations = {}
					this.path = null
					this.ast = {}
					this.scope = void 0
					this.metadata = {}
					this.code = ''
					this.inputMap = null
					this.hub = {
						file: this,
						getCode: () => this.code,
						getScope: () => this.scope,
						addHelper: this.addHelper.bind(this),
						buildError: this.buildCodeFrameError.bind(this),
					}
					this.opts = options
					this.code = code
					this.ast = ast
					this.inputMap = inputMap
					this.path = _traverse()
						.NodePath.get({
							hub: this.hub,
							parentPath: null,
							parent: this.ast,
							container: this.ast,
							key: 'program',
						})
						.setContext()
					this.scope = this.path.scope
				}

				get shebang() {
					const { interpreter } = this.path.node
					return interpreter ? interpreter.value : ''
				}

				set shebang(value) {
					if (value) {
						this.path
							.get('interpreter')
							.replaceWith(t().interpreterDirective(value))
					} else {
						this.path.get('interpreter').remove()
					}
				}

				set(key, val) {
					if (key === 'helpersNamespace') {
						throw new Error(
							"Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility." +
								'If you are using @babel/plugin-external-helpers you will need to use a newer ' +
								'version than the one you currently have installed. ' +
								"If you have your own implementation, you'll want to explore using 'helperGenerator' " +
								"alongside 'file.availableHelper()'.",
						)
					}

					this._map.set(key, val)
				}

				get(key) {
					return this._map.get(key)
				}

				has(key) {
					return this._map.has(key)
				}

				getModuleName() {
					return (0, _helperModuleTransforms().getModuleName)(
						this.opts,
						this.opts,
					)
				}

				addImport() {
					throw new Error(
						"This API has been removed. If you're looking for this " +
							'functionality in Babel 7, you should import the ' +
							"'@babel/helper-module-imports' module and use the functions exposed " +
							" from that module, such as 'addNamed' or 'addDefault'.",
					)
				}

				availableHelper(name, versionRange) {
					let minVersion

					try {
						minVersion = helpers().minVersion(name)
					} catch (err) {
						if (err.code !== 'BABEL_HELPER_UNKNOWN') throw err
						return false
					}

					if (typeof versionRange !== 'string') return true
					if (_semver().default.valid(versionRange))
						versionRange = `^${versionRange}`
					return (
						!_semver().default.intersects(`<${minVersion}`, versionRange) &&
						!_semver().default.intersects(`>=8.0.0`, versionRange)
					)
				}

				addHelper(name) {
					const declar = this.declarations[name]
					if (declar) return t().cloneNode(declar)
					const generator = this.get('helperGenerator')

					if (generator) {
						const res = generator(name)
						if (res) return res
					}

					helpers().ensure(name, File)
					const uid = (this.declarations[name] =
						this.scope.generateUidIdentifier(name))
					const dependencies = {}

					for (const dep of helpers().getDependencies(name)) {
						dependencies[dep] = this.addHelper(dep)
					}

					const { nodes, globals } = helpers().get(
						name,
						(dep) => dependencies[dep],
						uid,
						Object.keys(this.scope.getAllBindings()),
					)
					globals.forEach((name) => {
						if (this.path.scope.hasBinding(name, true)) {
							this.path.scope.rename(name)
						}
					})
					nodes.forEach((node) => {
						node._compact = true
					})
					this.path.unshiftContainer('body', nodes)
					this.path.get('body').forEach((path) => {
						if (nodes.indexOf(path.node) === -1) return
						if (path.isVariableDeclaration())
							this.scope.registerDeclaration(path)
					})
					return uid
				}

				addTemplateObject() {
					throw new Error(
						'This function has been moved into the template literal transform itself.',
					)
				}

				buildCodeFrameError(node, msg, Error = SyntaxError) {
					let loc = node && (node.loc || node._loc)

					if (!loc && node) {
						const state = {
							loc: null,
						}
						;(0, _traverse().default)(node, errorVisitor, this.scope, state)
						loc = state.loc
						let txt =
							'This is an error on an internal node. Probably an internal error.'
						if (loc) txt += ' Location has been estimated.'
						msg += ` (${txt})`
					}

					if (loc) {
						const { highlightCode = true } = this.opts
						msg +=
							'\n' +
							(0, _codeFrame().codeFrameColumns)(
								this.code,
								{
									start: {
										line: loc.start.line,
										column: loc.start.column + 1,
									},
									end:
										loc.end && loc.start.line === loc.end.line
											? {
													line: loc.end.line,
													column: loc.end.column + 1,
												}
											: undefined,
								},
								{
									highlightCode,
								},
							)
					}

					return new Error(msg)
				}
			}

			exports['default'] = File

			/***/
		},

		/***/ 48358: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = generateCode

			function _convertSourceMap() {
				const data = _interopRequireDefault(__nccwpck_require__(25288))

				_convertSourceMap = function () {
					return data
				}

				return data
			}

			function _generator() {
				const data = _interopRequireDefault(__nccwpck_require__(12123))

				_generator = function () {
					return data
				}

				return data
			}

			var _mergeMap = _interopRequireDefault(__nccwpck_require__(5890))

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			function generateCode(pluginPasses, file) {
				const { opts, ast, code, inputMap } = file
				const results = []

				for (const plugins of pluginPasses) {
					for (const plugin of plugins) {
						const { generatorOverride } = plugin

						if (generatorOverride) {
							const result = generatorOverride(
								ast,
								opts.generatorOpts,
								code,
								_generator().default,
							)
							if (result !== undefined) results.push(result)
						}
					}
				}

				let result

				if (results.length === 0) {
					result = (0, _generator().default)(ast, opts.generatorOpts, code)
				} else if (results.length === 1) {
					result = results[0]

					if (typeof result.then === 'function') {
						throw new Error(
							`You appear to be using an async codegen plugin, ` +
								`which your current version of Babel does not support. ` +
								`If you're using a published plugin, ` +
								`you may need to upgrade your @babel/core version.`,
						)
					}
				} else {
					throw new Error('More than one plugin attempted to override codegen.')
				}

				let { code: outputCode, map: outputMap } = result

				if (outputMap && inputMap) {
					outputMap = (0, _mergeMap.default)(inputMap.toObject(), outputMap)
				}

				if (opts.sourceMaps === 'inline' || opts.sourceMaps === 'both') {
					outputCode +=
						'\n' + _convertSourceMap().default.fromObject(outputMap).toComment()
				}

				if (opts.sourceMaps === 'inline') {
					outputMap = null
				}

				return {
					outputCode,
					outputMap,
				}
			}

			/***/
		},

		/***/ 5890: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = mergeSourceMap

			function _sourceMap() {
				const data = _interopRequireDefault(__nccwpck_require__(62618))

				_sourceMap = function () {
					return data
				}

				return data
			}

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			function mergeSourceMap(inputMap, map) {
				const input = buildMappingData(inputMap)
				const output = buildMappingData(map)
				const mergedGenerator = new (_sourceMap().default.SourceMapGenerator)()

				for (const { source } of input.sources) {
					if (typeof source.content === 'string') {
						mergedGenerator.setSourceContent(source.path, source.content)
					}
				}

				if (output.sources.length === 1) {
					const defaultSource = output.sources[0]
					const insertedMappings = new Map()
					eachInputGeneratedRange(input, (generated, original, source) => {
						eachOverlappingGeneratedOutputRange(
							defaultSource,
							generated,
							(item) => {
								const key = makeMappingKey(item)
								if (insertedMappings.has(key)) return
								insertedMappings.set(key, item)
								mergedGenerator.addMapping({
									source: source.path,
									original: {
										line: original.line,
										column: original.columnStart,
									},
									generated: {
										line: item.line,
										column: item.columnStart,
									},
									name: original.name,
								})
							},
						)
					})

					for (const item of insertedMappings.values()) {
						if (item.columnEnd === Infinity) {
							continue
						}

						const clearItem = {
							line: item.line,
							columnStart: item.columnEnd,
						}
						const key = makeMappingKey(clearItem)

						if (insertedMappings.has(key)) {
							continue
						}

						mergedGenerator.addMapping({
							generated: {
								line: clearItem.line,
								column: clearItem.columnStart,
							},
						})
					}
				}

				const result = mergedGenerator.toJSON()

				if (typeof input.sourceRoot === 'string') {
					result.sourceRoot = input.sourceRoot
				}

				return result
			}

			function makeMappingKey(item) {
				return `${item.line}/${item.columnStart}`
			}

			function eachOverlappingGeneratedOutputRange(
				outputFile,
				inputGeneratedRange,
				callback,
			) {
				const overlappingOriginal = filterApplicableOriginalRanges(
					outputFile,
					inputGeneratedRange,
				)

				for (const { generated } of overlappingOriginal) {
					for (const item of generated) {
						callback(item)
					}
				}
			}

			function filterApplicableOriginalRanges(
				{ mappings },
				{ line, columnStart, columnEnd },
			) {
				return filterSortedArray(mappings, ({ original: outOriginal }) => {
					if (line > outOriginal.line) return -1
					if (line < outOriginal.line) return 1
					if (columnStart >= outOriginal.columnEnd) return -1
					if (columnEnd <= outOriginal.columnStart) return 1
					return 0
				})
			}

			function eachInputGeneratedRange(map, callback) {
				for (const { source, mappings } of map.sources) {
					for (const { original, generated } of mappings) {
						for (const item of generated) {
							callback(item, original, source)
						}
					}
				}
			}

			function buildMappingData(map) {
				const consumer = new (_sourceMap().default.SourceMapConsumer)(
					Object.assign({}, map, {
						sourceRoot: null,
					}),
				)
				const sources = new Map()
				const mappings = new Map()
				let last = null
				consumer.computeColumnSpans()
				consumer.eachMapping(
					(m) => {
						if (m.originalLine === null) return
						let source = sources.get(m.source)

						if (!source) {
							source = {
								path: m.source,
								content: consumer.sourceContentFor(m.source, true),
							}
							sources.set(m.source, source)
						}

						let sourceData = mappings.get(source)

						if (!sourceData) {
							sourceData = {
								source,
								mappings: [],
							}
							mappings.set(source, sourceData)
						}

						const obj = {
							line: m.originalLine,
							columnStart: m.originalColumn,
							columnEnd: Infinity,
							name: m.name,
						}

						if (
							last &&
							last.source === source &&
							last.mapping.line === m.originalLine
						) {
							last.mapping.columnEnd = m.originalColumn
						}

						last = {
							source,
							mapping: obj,
						}
						sourceData.mappings.push({
							original: obj,
							generated: consumer
								.allGeneratedPositionsFor({
									source: m.source,
									line: m.originalLine,
									column: m.originalColumn,
								})
								.map((item) => ({
									line: item.line,
									columnStart: item.column,
									columnEnd: item.lastColumn + 1,
								})),
						})
					},
					null,
					_sourceMap().default.SourceMapConsumer.ORIGINAL_ORDER,
				)
				return {
					file: map.file,
					sourceRoot: map.sourceRoot,
					sources: Array.from(mappings.values()),
				}
			}

			function findInsertionLocation(array, callback) {
				let left = 0
				let right = array.length

				while (left < right) {
					const mid = Math.floor((left + right) / 2)
					const item = array[mid]
					const result = callback(item)

					if (result === 0) {
						left = mid
						break
					}

					if (result >= 0) {
						right = mid
					} else {
						left = mid + 1
					}
				}

				let i = left

				if (i < array.length) {
					while (i >= 0 && callback(array[i]) >= 0) {
						i--
					}

					return i + 1
				}

				return i
			}

			function filterSortedArray(array, callback) {
				const start = findInsertionLocation(array, callback)
				const results = []

				for (let i = start; i < array.length && callback(array[i]) === 0; i++) {
					results.push(array[i])
				}

				return results
			}

			/***/
		},

		/***/ 16486: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.run = run

			function _traverse() {
				const data = _interopRequireDefault(__nccwpck_require__(50148))

				_traverse = function () {
					return data
				}

				return data
			}

			var _pluginPass = _interopRequireDefault(__nccwpck_require__(20937))

			var _blockHoistPlugin = _interopRequireDefault(__nccwpck_require__(28925))

			var _normalizeOpts = _interopRequireDefault(__nccwpck_require__(74944))

			var _normalizeFile = _interopRequireDefault(__nccwpck_require__(99168))

			var _generate = _interopRequireDefault(__nccwpck_require__(48358))

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			function* run(config, code, ast) {
				const file = yield* (0, _normalizeFile.default)(
					config.passes,
					(0, _normalizeOpts.default)(config),
					code,
					ast,
				)
				const opts = file.opts

				try {
					yield* transformFile(file, config.passes)
				} catch (e) {
					var _opts$filename

					e.message = `${(_opts$filename = opts.filename) != null ? _opts$filename : 'unknown'}: ${e.message}`

					if (!e.code) {
						e.code = 'BABEL_TRANSFORM_ERROR'
					}

					throw e
				}

				let outputCode, outputMap

				try {
					if (opts.code !== false) {
						;({ outputCode, outputMap } = (0, _generate.default)(
							config.passes,
							file,
						))
					}
				} catch (e) {
					var _opts$filename2

					e.message = `${(_opts$filename2 = opts.filename) != null ? _opts$filename2 : 'unknown'}: ${e.message}`

					if (!e.code) {
						e.code = 'BABEL_GENERATE_ERROR'
					}

					throw e
				}

				return {
					metadata: file.metadata,
					options: opts,
					ast: opts.ast === true ? file.ast : null,
					code: outputCode === undefined ? null : outputCode,
					map: outputMap === undefined ? null : outputMap,
					sourceType: file.ast.program.sourceType,
				}
			}

			function* transformFile(file, pluginPasses) {
				for (const pluginPairs of pluginPasses) {
					const passPairs = []
					const passes = []
					const visitors = []

					for (const plugin of pluginPairs.concat([
						(0, _blockHoistPlugin.default)(),
					])) {
						const pass = new _pluginPass.default(
							file,
							plugin.key,
							plugin.options,
						)
						passPairs.push([plugin, pass])
						passes.push(pass)
						visitors.push(plugin.visitor)
					}

					for (const [plugin, pass] of passPairs) {
						const fn = plugin.pre

						if (fn) {
							const result = fn.call(pass, file)
							yield* []

							if (isThenable(result)) {
								throw new Error(
									`You appear to be using an plugin with an async .pre, ` +
										`which your current version of Babel does not support. ` +
										`If you're using a published plugin, you may need to upgrade ` +
										`your @babel/core version.`,
								)
							}
						}
					}

					const visitor = _traverse().default.visitors.merge(
						visitors,
						passes,
						file.opts.wrapPluginVisitorMethod,
					)

					;(0, _traverse().default)(file.ast, visitor, file.scope)

					for (const [plugin, pass] of passPairs) {
						const fn = plugin.post

						if (fn) {
							const result = fn.call(pass, file)
							yield* []

							if (isThenable(result)) {
								throw new Error(
									`You appear to be using an plugin with an async .post, ` +
										`which your current version of Babel does not support. ` +
										`If you're using a published plugin, you may need to upgrade ` +
										`your @babel/core version.`,
								)
							}
						}
					}
				}
			}

			function isThenable(val) {
				return (
					!!val &&
					(typeof val === 'object' || typeof val === 'function') &&
					!!val.then &&
					typeof val.then === 'function'
				)
			}

			/***/
		},

		/***/ 99168: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = normalizeFile

			function _fs() {
				const data = _interopRequireDefault(__nccwpck_require__(79896))

				_fs = function () {
					return data
				}

				return data
			}

			function _path() {
				const data = _interopRequireDefault(__nccwpck_require__(16928))

				_path = function () {
					return data
				}

				return data
			}

			function _debug() {
				const data = _interopRequireDefault(__nccwpck_require__(2830))

				_debug = function () {
					return data
				}

				return data
			}

			function _cloneDeep() {
				const data = _interopRequireDefault(__nccwpck_require__(80542))

				_cloneDeep = function () {
					return data
				}

				return data
			}

			function t() {
				const data = _interopRequireWildcard(__nccwpck_require__(16535))

				t = function () {
					return data
				}

				return data
			}

			function _convertSourceMap() {
				const data = _interopRequireDefault(__nccwpck_require__(25288))

				_convertSourceMap = function () {
					return data
				}

				return data
			}

			var _file = _interopRequireDefault(__nccwpck_require__(12211))

			var _parser = _interopRequireDefault(__nccwpck_require__(99904))

			function _getRequireWildcardCache() {
				if (typeof WeakMap !== 'function') return null
				var cache = new WeakMap()
				_getRequireWildcardCache = function () {
					return cache
				}
				return cache
			}

			function _interopRequireWildcard(obj) {
				if (obj && obj.__esModule) {
					return obj
				}
				if (
					obj === null ||
					(typeof obj !== 'object' && typeof obj !== 'function')
				) {
					return { default: obj }
				}
				var cache = _getRequireWildcardCache()
				if (cache && cache.has(obj)) {
					return cache.get(obj)
				}
				var newObj = {}
				var hasPropertyDescriptor =
					Object.defineProperty && Object.getOwnPropertyDescriptor
				for (var key in obj) {
					if (Object.prototype.hasOwnProperty.call(obj, key)) {
						var desc = hasPropertyDescriptor
							? Object.getOwnPropertyDescriptor(obj, key)
							: null
						if (desc && (desc.get || desc.set)) {
							Object.defineProperty(newObj, key, desc)
						} else {
							newObj[key] = obj[key]
						}
					}
				}
				newObj.default = obj
				if (cache) {
					cache.set(obj, newObj)
				}
				return newObj
			}

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			const debug = (0, _debug().default)('babel:transform:file')
			const LARGE_INPUT_SOURCEMAP_THRESHOLD = 1000000

			function* normalizeFile(pluginPasses, options, code, ast) {
				code = `${code || ''}`

				if (ast) {
					if (ast.type === 'Program') {
						ast = t().file(ast, [], [])
					} else if (ast.type !== 'File') {
						throw new Error('AST root must be a Program or File node')
					}

					const { cloneInputAst } = options

					if (cloneInputAst) {
						ast = (0, _cloneDeep().default)(ast)
					}
				} else {
					ast = yield* (0, _parser.default)(pluginPasses, options, code)
				}

				let inputMap = null

				if (options.inputSourceMap !== false) {
					if (typeof options.inputSourceMap === 'object') {
						inputMap = _convertSourceMap().default.fromObject(
							options.inputSourceMap,
						)
					}

					if (!inputMap) {
						const lastComment = extractComments(INLINE_SOURCEMAP_REGEX, ast)

						if (lastComment) {
							try {
								inputMap = _convertSourceMap().default.fromComment(lastComment)
							} catch (err) {
								debug('discarding unknown inline input sourcemap', err)
							}
						}
					}

					if (!inputMap) {
						const lastComment = extractComments(EXTERNAL_SOURCEMAP_REGEX, ast)

						if (typeof options.filename === 'string' && lastComment) {
							try {
								const match = EXTERNAL_SOURCEMAP_REGEX.exec(lastComment)

								const inputMapContent = _fs().default.readFileSync(
									_path().default.resolve(
										_path().default.dirname(options.filename),
										match[1],
									),
								)

								if (inputMapContent.length > LARGE_INPUT_SOURCEMAP_THRESHOLD) {
									debug('skip merging input map > 1 MB')
								} else {
									inputMap =
										_convertSourceMap().default.fromJSON(inputMapContent)
								}
							} catch (err) {
								debug('discarding unknown file input sourcemap', err)
							}
						} else if (lastComment) {
							debug('discarding un-loadable file input sourcemap')
						}
					}
				}

				return new _file.default(options, {
					code,
					ast,
					inputMap,
				})
			}

			const INLINE_SOURCEMAP_REGEX =
				/^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/
			const EXTERNAL_SOURCEMAP_REGEX =
				/^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/

			function extractCommentsFromList(regex, comments, lastComment) {
				if (comments) {
					comments = comments.filter(({ value }) => {
						if (regex.test(value)) {
							lastComment = value
							return false
						}

						return true
					})
				}

				return [comments, lastComment]
			}

			function extractComments(regex, ast) {
				let lastComment = null
				t().traverseFast(ast, (node) => {
					;[node.leadingComments, lastComment] = extractCommentsFromList(
						regex,
						node.leadingComments,
						lastComment,
					)
					;[node.innerComments, lastComment] = extractCommentsFromList(
						regex,
						node.innerComments,
						lastComment,
					)
					;[node.trailingComments, lastComment] = extractCommentsFromList(
						regex,
						node.trailingComments,
						lastComment,
					)
				})
				return lastComment
			}

			/***/
		},

		/***/ 74944: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = normalizeOptions

			function _path() {
				const data = _interopRequireDefault(__nccwpck_require__(16928))

				_path = function () {
					return data
				}

				return data
			}

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			function normalizeOptions(config) {
				const {
					filename,
					cwd,
					filenameRelative = typeof filename === 'string'
						? _path().default.relative(cwd, filename)
						: 'unknown',
					sourceType = 'module',
					inputSourceMap,
					sourceMaps = !!inputSourceMap,
					moduleRoot,
					sourceRoot = moduleRoot,
					sourceFileName = _path().default.basename(filenameRelative),
					comments = true,
					compact = 'auto',
				} = config.options
				const opts = config.options
				const options = Object.assign({}, opts, {
					parserOpts: Object.assign(
						{
							sourceType:
								_path().default.extname(filenameRelative) === '.mjs'
									? 'module'
									: sourceType,
							sourceFileName: filename,
							plugins: [],
						},
						opts.parserOpts,
					),
					generatorOpts: Object.assign(
						{
							filename,
							auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
							auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
							retainLines: opts.retainLines,
							comments,
							shouldPrintComment: opts.shouldPrintComment,
							compact,
							minified: opts.minified,
							sourceMaps,
							sourceRoot,
							sourceFileName,
						},
						opts.generatorOpts,
					),
				})

				for (const plugins of config.passes) {
					for (const plugin of plugins) {
						if (plugin.manipulateOptions) {
							plugin.manipulateOptions(options, options.parserOpts)
						}
					}
				}

				return options
			}

			/***/
		},

		/***/ 20937: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = void 0

			class PluginPass {
				constructor(file, key, options) {
					this._map = new Map()
					this.key = void 0
					this.file = void 0
					this.opts = void 0
					this.cwd = void 0
					this.filename = void 0
					this.key = key
					this.file = file
					this.opts = options || {}
					this.cwd = file.opts.cwd
					this.filename = file.opts.filename
				}

				set(key, val) {
					this._map.set(key, val)
				}

				get(key) {
					return this._map.get(key)
				}

				availableHelper(name, versionRange) {
					return this.file.availableHelper(name, versionRange)
				}

				addHelper(name) {
					return this.file.addHelper(name)
				}

				addImport() {
					return this.file.addImport()
				}

				getModuleName() {
					return this.file.getModuleName()
				}

				buildCodeFrameError(node, msg, Error) {
					return this.file.buildCodeFrameError(node, msg, Error)
				}
			}

			exports['default'] = PluginPass

			/***/
		},

		/***/ 25683: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.declare = declare

			function declare(builder) {
				return (api, options, dirname) => {
					if (!api.assertVersion) {
						api = Object.assign(copyApiObject(api), {
							assertVersion(range) {
								throwVersionError(range, api.version)
							},
						})
					}

					return builder(api, options || {}, dirname)
				}
			}

			function copyApiObject(api) {
				let proto = null

				if (typeof api.version === 'string' && /^7\./.test(api.version)) {
					proto = Object.getPrototypeOf(api)

					if (
						proto &&
						(!has(proto, 'version') ||
							!has(proto, 'transform') ||
							!has(proto, 'template') ||
							!has(proto, 'types'))
					) {
						proto = null
					}
				}

				return Object.assign({}, proto, api)
			}

			function has(obj, key) {
				return Object.prototype.hasOwnProperty.call(obj, key)
			}

			function throwVersionError(range, version) {
				if (typeof range === 'number') {
					if (!Number.isInteger(range)) {
						throw new Error('Expected string or integer value.')
					}

					range = `^${range}.0.0-0`
				}

				if (typeof range !== 'string') {
					throw new Error('Expected string or integer value.')
				}

				const limit = Error.stackTraceLimit

				if (typeof limit === 'number' && limit < 25) {
					Error.stackTraceLimit = 25
				}

				let err

				if (version.slice(0, 2) === '7.') {
					err = new Error(
						`Requires Babel "^7.0.0-beta.41", but was loaded with "${version}". ` +
							`You'll need to update your @babel/core version.`,
					)
				} else {
					err = new Error(
						`Requires Babel "${range}", but was loaded with "${version}". ` +
							`If you are sure you have a compatible version of @babel/core, ` +
							`it is likely that something in your build process is loading the ` +
							`wrong version. Inspect the stack trace of this error to look for ` +
							`the first entry that doesn't mention "@babel/core" or "babel-core" ` +
							`to see what is calling Babel.`,
					)
				}

				if (typeof limit === 'number') {
					Error.stackTraceLimit = limit
				}

				throw Object.assign(err, {
					code: 'BABEL_VERSION_UNSUPPORTED',
					version,
					range,
				})
			}

			/***/
		},

		/***/ 16186: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = void 0

			var _helperPluginUtils = __nccwpck_require__(25683)

			var _pluginSyntaxObjectRestSpread = _interopRequireDefault(
				__nccwpck_require__(55165),
			)

			var _core = __nccwpck_require__(85414)

			var _pluginTransformParameters = __nccwpck_require__(32519)

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj }
			}

			const ZERO_REFS = (() => {
				const node = _core.types.identifier('a')

				const property = _core.types.objectProperty(
					_core.types.identifier('key'),
					node,
				)

				const pattern = _core.types.objectPattern([property])

				return _core.types.isReferenced(node, property, pattern) ? 1 : 0
			})()

			var _default = (0, _helperPluginUtils.declare)((api, opts) => {
				api.assertVersion(7)
				const { useBuiltIns = false, loose = false } = opts

				if (typeof loose !== 'boolean') {
					throw new Error('.loose must be a boolean, or undefined')
				}

				function getExtendsHelper(file) {
					return useBuiltIns
						? _core.types.memberExpression(
								_core.types.identifier('Object'),
								_core.types.identifier('assign'),
							)
						: file.addHelper('extends')
				}

				function hasRestElement(path) {
					let foundRestElement = false
					visitRestElements(path, (restElement) => {
						foundRestElement = true
						restElement.stop()
					})
					return foundRestElement
				}

				function hasObjectPatternRestElement(path) {
					let foundRestElement = false
					visitRestElements(path, (restElement) => {
						if (restElement.parentPath.isObjectPattern()) {
							foundRestElement = true
							restElement.stop()
						}
					})
					return foundRestElement
				}

				function visitRestElements(path, visitor) {
					path.traverse({
						Expression(path) {
							const parentType = path.parent.type

							if (
								(parentType === 'AssignmentPattern' && path.key === 'right') ||
								(parentType === 'ObjectProperty' &&
									path.parent.computed &&
									path.key === 'key')
							) {
								path.skip()
							}
						},

						RestElement: visitor,
					})
				}

				function hasSpread(node) {
					for (const prop of node.properties) {
						if (_core.types.isSpreadElement(prop)) {
							return true
						}
					}

					return false
				}

				function extractNormalizedKeys(path) {
					const props = path.node.properties
					const keys = []
					let allLiteral = true

					for (const prop of props) {
						if (_core.types.isIdentifier(prop.key) && !prop.computed) {
							keys.push(_core.types.stringLiteral(prop.key.name))
						} else if (_core.types.isTemplateLiteral(prop.key)) {
							keys.push(_core.types.cloneNode(prop.key))
						} else if (_core.types.isLiteral(prop.key)) {
							keys.push(_core.types.stringLiteral(String(prop.key.value)))
						} else {
							keys.push(_core.types.cloneNode(prop.key))
							allLiteral = false
						}
					}

					return {
						keys,
						allLiteral,
					}
				}

				function replaceImpureComputedKeys(properties, scope) {
					const impureComputedPropertyDeclarators = []

					for (const propPath of properties) {
						const key = propPath.get('key')

						if (propPath.node.computed && !key.isPure()) {
							const name = scope.generateUidBasedOnNode(key.node)

							const declarator = _core.types.variableDeclarator(
								_core.types.identifier(name),
								key.node,
							)

							impureComputedPropertyDeclarators.push(declarator)
							key.replaceWith(_core.types.identifier(name))
						}
					}

					return impureComputedPropertyDeclarators
				}

				function removeUnusedExcludedKeys(path) {
					const bindings = path.getOuterBindingIdentifierPaths()
					Object.keys(bindings).forEach((bindingName) => {
						const bindingParentPath = bindings[bindingName].parentPath

						if (
							path.scope.getBinding(bindingName).references > ZERO_REFS ||
							!bindingParentPath.isObjectProperty()
						) {
							return
						}

						bindingParentPath.remove()
					})
				}

				function createObjectSpread(path, file, objRef) {
					const props = path.get('properties')
					const last = props[props.length - 1]

					_core.types.assertRestElement(last.node)

					const restElement = _core.types.cloneNode(last.node)

					last.remove()
					const impureComputedPropertyDeclarators = replaceImpureComputedKeys(
						path.get('properties'),
						path.scope,
					)
					const { keys, allLiteral } = extractNormalizedKeys(path)

					if (keys.length === 0) {
						return [
							impureComputedPropertyDeclarators,
							restElement.argument,
							_core.types.callExpression(getExtendsHelper(file), [
								_core.types.objectExpression([]),
								_core.types.cloneNode(objRef),
							]),
						]
					}

					let keyExpression

					if (!allLiteral) {
						keyExpression = _core.types.callExpression(
							_core.types.memberExpression(
								_core.types.arrayExpression(keys),
								_core.types.identifier('map'),
							),
							[file.addHelper('toPropertyKey')],
						)
					} else {
						keyExpression = _core.types.arrayExpression(keys)
					}

					return [
						impureComputedPropertyDeclarators,
						restElement.argument,
						_core.types.callExpression(
							file.addHelper(`objectWithoutProperties${loose ? 'Loose' : ''}`),
							[_core.types.cloneNode(objRef), keyExpression],
						),
					]
				}

				function replaceRestElement(parentPath, paramPath, container) {
					if (paramPath.isAssignmentPattern()) {
						replaceRestElement(parentPath, paramPath.get('left'), container)
						return
					}

					if (paramPath.isArrayPattern() && hasRestElement(paramPath)) {
						const elements = paramPath.get('elements')

						for (let i = 0; i < elements.length; i++) {
							replaceRestElement(parentPath, elements[i], container)
						}
					}

					if (paramPath.isObjectPattern() && hasRestElement(paramPath)) {
						const uid = parentPath.scope.generateUidIdentifier('ref')

						const declar = _core.types.variableDeclaration('let', [
							_core.types.variableDeclarator(paramPath.node, uid),
						])

						if (container) {
							container.push(declar)
						} else {
							parentPath.ensureBlock()
							parentPath.get('body').unshiftContainer('body', declar)
						}

						paramPath.replaceWith(_core.types.cloneNode(uid))
					}
				}

				return {
					name: 'proposal-object-rest-spread',
					inherits: _pluginSyntaxObjectRestSpread.default,
					visitor: {
						Function(path) {
							const params = path.get('params')
							const paramsWithRestElement = new Set()
							const idsInRestParams = new Set()

							for (let i = 0; i < params.length; ++i) {
								const param = params[i]

								if (hasRestElement(param)) {
									paramsWithRestElement.add(i)

									for (const name of Object.keys(
										param.getBindingIdentifiers(),
									)) {
										idsInRestParams.add(name)
									}
								}
							}

							let idInRest = false

							const IdentifierHandler = function (path, functionScope) {
								const name = path.node.name

								if (
									path.scope.getBinding(name) ===
										functionScope.getBinding(name) &&
									idsInRestParams.has(name)
								) {
									idInRest = true
									path.stop()
								}
							}

							let i

							for (i = 0; i < params.length && !idInRest; ++i) {
								const param = params[i]

								if (!paramsWithRestElement.has(i)) {
									if (
										param.isReferencedIdentifier() ||
										param.isBindingIdentifier()
									) {
										IdentifierHandler(path, path.scope)
									} else {
										param.traverse(
											{
												'Scope|TypeAnnotation|TSTypeAnnotation': (path) =>
													path.skip(),
												'ReferencedIdentifier|BindingIdentifier':
													IdentifierHandler,
											},
											path.scope,
										)
									}
								}
							}

							if (!idInRest) {
								for (let i = 0; i < params.length; ++i) {
									const param = params[i]

									if (paramsWithRestElement.has(i)) {
										replaceRestElement(param.parentPath, param)
									}
								}
							} else {
								const shouldTransformParam = (idx) =>
									idx >= i - 1 || paramsWithRestElement.has(idx)

								;(0, _pluginTransformParameters.convertFunctionParams)(
									path,
									loose,
									shouldTransformParam,
									replaceRestElement,
								)
							}
						},

						VariableDeclarator(path, file) {
							if (!path.get('id').isObjectPattern()) {
								return
							}

							let insertionPath = path
							const originalPath = path
							visitRestElements(path.get('id'), (path) => {
								if (!path.parentPath.isObjectPattern()) {
									return
								}

								if (
									originalPath.node.id.properties.length > 1 &&
									!_core.types.isIdentifier(originalPath.node.init)
								) {
									const initRef = path.scope.generateUidIdentifierBasedOnNode(
										originalPath.node.init,
										'ref',
									)
									originalPath.insertBefore(
										_core.types.variableDeclarator(
											initRef,
											originalPath.node.init,
										),
									)
									originalPath.replaceWith(
										_core.types.variableDeclarator(
											originalPath.node.id,
											_core.types.cloneNode(initRef),
										),
									)
									return
								}

								let ref = originalPath.node.init
								const refPropertyPath = []
								let kind
								path.findParent((path) => {
									if (path.isObjectProperty()) {
										refPropertyPath.unshift(path)
									} else if (path.isVariableDeclarator()) {
										kind = path.parentPath.node.kind
										return true
									}
								})
								const impureObjRefComputedDeclarators =
									replaceImpureComputedKeys(refPropertyPath, path.scope)
								refPropertyPath.forEach((prop) => {
									const { node } = prop
									ref = _core.types.memberExpression(
										ref,
										_core.types.cloneNode(node.key),
										node.computed || _core.types.isLiteral(node.key),
									)
								})
								const objectPatternPath = path.findParent((path) =>
									path.isObjectPattern(),
								)
								const [
									impureComputedPropertyDeclarators,
									argument,
									callExpression,
								] = createObjectSpread(objectPatternPath, file, ref)

								if (loose) {
									removeUnusedExcludedKeys(objectPatternPath)
								}

								_core.types.assertIdentifier(argument)

								insertionPath.insertBefore(impureComputedPropertyDeclarators)
								insertionPath.insertBefore(impureObjRefComputedDeclarators)
								insertionPath.insertAfter(
									_core.types.variableDeclarator(argument, callExpression),
								)
								insertionPath = insertionPath.getSibling(insertionPath.key + 1)
								path.scope.registerBinding(kind, insertionPath)

								if (objectPatternPath.node.properties.length === 0) {
									objectPatternPath
										.findParent(
											(path) =>
												path.isObjectProperty() || path.isVariableDeclarator(),
										)
										.remove()
								}
							})
						},

						ExportNamedDeclaration(path) {
							const declaration = path.get('declaration')
							if (!declaration.isVariableDeclaration()) return
							const hasRest = declaration
								.get('declarations')
								.some((path) => hasObjectPatternRestElement(path.get('id')))
							if (!hasRest) return
							const specifiers = []

							for (const name of Object.keys(
								path.getOuterBindingIdentifiers(path),
							)) {
								specifiers.push(
									_core.types.exportSpecifier(
										_core.types.identifier(name),
										_core.types.identifier(name),
									),
								)
							}

							path.replaceWith(declaration.node)
							path.insertAfter(
								_core.types.exportNamedDeclaration(null, specifiers),
							)
						},

						CatchClause(path) {
							const paramPath = path.get('param')
							replaceRestElement(paramPath.parentPath, paramPath)
						},

						AssignmentExpression(path, file) {
							const leftPath = path.get('left')

							if (leftPath.isObjectPattern() && hasRestElement(leftPath)) {
								const nodes = []
								const refName = path.scope.generateUidBasedOnNode(
									path.node.right,
									'ref',
								)
								nodes.push(
									_core.types.variableDeclaration('var', [
										_core.types.variableDeclarator(
											_core.types.identifier(refName),
											path.node.right,
										),
									]),
								)
								const [
									impureComputedPropertyDeclarators,
									argument,
									callExpression,
								] = createObjectSpread(
									leftPath,
									file,
									_core.types.identifier(refName),
								)

								if (impureComputedPropertyDeclarators.length > 0) {
									nodes.push(
										_core.types.variableDeclaration(
											'var',
											impureComputedPropertyDeclarators,
										),
									)
								}

								const nodeWithoutSpread = _core.types.cloneNode(path.node)

								nodeWithoutSpread.right = _core.types.identifier(refName)
								nodes.push(_core.types.expressionStatement(nodeWithoutSpread))
								nodes.push(
									_core.types.toStatement(
										_core.types.assignmentExpression(
											'=',
											argument,
											callExpression,
										),
									),
								)
								nodes.push(
									_core.types.expressionStatement(
										_core.types.identifier(refName),
									),
								)
								path.replaceWithMultiple(nodes)
							}
						},

						ForXStatement(path) {
							const { node, scope } = path
							const leftPath = path.get('left')
							const left = node.left

							if (!hasObjectPatternRestElement(leftPath)) {
								return
							}

							if (!_core.types.isVariableDeclaration(left)) {
								const temp = scope.generateUidIdentifier('ref')
								node.left = _core.types.variableDeclaration('var', [
									_core.types.variableDeclarator(temp),
								])
								path.ensureBlock()

								if (node.body.body.length === 0 && path.isCompletionRecord()) {
									node.body.body.unshift(
										_core.types.expressionStatement(scope.buildUndefinedNode()),
									)
								}

								node.body.body.unshift(
									_core.types.expressionStatement(
										_core.types.assignmentExpression(
											'=',
											left,
											_core.types.cloneNode(temp),
										),
									),
								)
							} else {
								const pattern = left.declarations[0].id
								const key = scope.generateUidIdentifier('ref')
								node.left = _core.types.variableDeclaration(left.kind, [
									_core.types.variableDeclarator(key, null),
								])
								path.ensureBlock()
								node.body.body.unshift(
									_core.types.variableDeclaration(node.left.kind, [
										_core.types.variableDeclarator(
											pattern,
											_core.types.cloneNode(key),
										),
									]),
								)
							}
						},

						ArrayPattern(path) {
							const objectPatterns = []
							visitRestElements(path, (path) => {
								if (!path.parentPath.isObjectPattern()) {
									return
								}

								const objectPattern = path.parentPath
								const uid = path.scope.generateUidIdentifier('ref')
								objectPatterns.push(
									_core.types.variableDeclarator(objectPattern.node, uid),
								)
								objectPattern.replaceWith(_core.types.cloneNode(uid))
								path.skip()
							})

							if (objectPatterns.length > 0) {
								const statementPath = path.getStatementParent()
								statementPath.insertAfter(
									_core.types.variableDeclaration(
										statementPath.node.kind || 'var',
										objectPatterns,
									),
								)
							}
						},

						ObjectExpression(path, file) {
							if (!hasSpread(path.node)) return
							let helper

							if (loose) {
								helper = getExtendsHelper(file)
							} else {
								try {
									helper = file.addHelper('objectSpread2')
								} catch (_unused) {
									this.file.declarations['objectSpread2'] = null
									helper = file.addHelper('objectSpread')
								}
							}

							let exp = null
							let props = []

							function make() {
								const hadProps = props.length > 0

								const obj = _core.types.objectExpression(props)

								props = []

								if (!exp) {
									exp = _core.types.callExpression(helper, [obj])
									return
								}

								if (loose) {
									if (hadProps) {
										exp.arguments.push(obj)
									}

									return
								}

								exp = _core.types.callExpression(
									_core.types.cloneNode(helper),
									[
										exp,
										...(hadProps
											? [_core.types.objectExpression([]), obj]
											: []),
									],
								)
							}

							for (const prop of path.node.properties) {
								if (_core.types.isSpreadElement(prop)) {
									make()
									exp.arguments.push(prop.argument)
								} else {
									props.push(prop)
								}
							}

							if (props.length) make()
							path.replaceWith(exp)
						},
					},
				}
			})

			exports['default'] = _default

			/***/
		},

		/***/ 47358: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = void 0

			var _helperPluginUtils = __nccwpck_require__(25683)

			var _default = (0, _helperPluginUtils.declare)((api) => {
				api.assertVersion(7)
				return {
					name: 'syntax-jsx',

					manipulateOptions(opts, parserOpts) {
						if (
							parserOpts.plugins.some(
								(p) => (Array.isArray(p) ? p[0] : p) === 'typescript',
							)
						) {
							return
						}

						parserOpts.plugins.push('jsx')
					},
				}
			})

			exports['default'] = _default

			/***/
		},

		/***/ 55165: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = void 0

			var _helperPluginUtils = __nccwpck_require__(25683)

			var _default = (0, _helperPluginUtils.declare)((api) => {
				api.assertVersion(7)
				return {
					name: 'syntax-object-rest-spread',

					manipulateOptions(opts, parserOpts) {
						parserOpts.plugins.push('objectRestSpread')
					},
				}
			})

			exports['default'] = _default

			/***/
		},

		/***/ 36153: /***/ function (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) {
			;(function (global, factory) {
				true
					? factory(
							exports,
							__nccwpck_require__(83199),
							__nccwpck_require__(69551),
							__nccwpck_require__(99535),
						)
					: 0
			})(this, function (exports, setArray, sourcemapCodec, traceMapping) {
				'use strict'

				const COLUMN = 0
				const SOURCES_INDEX = 1
				const SOURCE_LINE = 2
				const SOURCE_COLUMN = 3
				const NAMES_INDEX = 4

				const NO_NAME = -1
				/**
				 * Provides the state to generate a sourcemap.
				 */
				class GenMapping {
					constructor({ file, sourceRoot } = {}) {
						this._names = new setArray.SetArray()
						this._sources = new setArray.SetArray()
						this._sourcesContent = []
						this._mappings = []
						this.file = file
						this.sourceRoot = sourceRoot
						this._ignoreList = new setArray.SetArray()
					}
				}
				/**
				 * Typescript doesn't allow friend access to private fields, so this just casts the map into a type
				 * with public access modifiers.
				 */
				function cast(map) {
					return map
				}
				function addSegment(
					map,
					genLine,
					genColumn,
					source,
					sourceLine,
					sourceColumn,
					name,
					content,
				) {
					return addSegmentInternal(
						false,
						map,
						genLine,
						genColumn,
						source,
						sourceLine,
						sourceColumn,
						name,
						content,
					)
				}
				function addMapping(map, mapping) {
					return addMappingInternal(false, map, mapping)
				}
				/**
				 * Same as `addSegment`, but will only add the segment if it generates useful information in the
				 * resulting map. This only works correctly if segments are added **in order**, meaning you should
				 * not add a segment with a lower generated line/column than one that came before.
				 */
				const maybeAddSegment = (
					map,
					genLine,
					genColumn,
					source,
					sourceLine,
					sourceColumn,
					name,
					content,
				) => {
					return addSegmentInternal(
						true,
						map,
						genLine,
						genColumn,
						source,
						sourceLine,
						sourceColumn,
						name,
						content,
					)
				}
				/**
				 * Same as `addMapping`, but will only add the mapping if it generates useful information in the
				 * resulting map. This only works correctly if mappings are added **in order**, meaning you should
				 * not add a mapping with a lower generated line/column than one that came before.
				 */
				const maybeAddMapping = (map, mapping) => {
					return addMappingInternal(true, map, mapping)
				}
				/**
				 * Adds/removes the content of the source file to the source map.
				 */
				function setSourceContent(map, source, content) {
					const { _sources: sources, _sourcesContent: sourcesContent } =
						cast(map)
					const index = setArray.put(sources, source)
					sourcesContent[index] = content
				}
				function setIgnore(map, source, ignore = true) {
					const {
						_sources: sources,
						_sourcesContent: sourcesContent,
						_ignoreList: ignoreList,
					} = cast(map)
					const index = setArray.put(sources, source)
					if (index === sourcesContent.length) sourcesContent[index] = null
					if (ignore) setArray.put(ignoreList, index)
					else setArray.remove(ignoreList, index)
				}
				/**
				 * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects
				 * a sourcemap, or to JSON.stringify.
				 */
				function toDecodedMap(map) {
					const {
						_mappings: mappings,
						_sources: sources,
						_sourcesContent: sourcesContent,
						_names: names,
						_ignoreList: ignoreList,
					} = cast(map)
					removeEmptyFinalLines(mappings)
					return {
						version: 3,
						file: map.file || undefined,
						names: names.array,
						sourceRoot: map.sourceRoot || undefined,
						sources: sources.array,
						sourcesContent,
						mappings,
						ignoreList: ignoreList.array,
					}
				}
				/**
				 * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects
				 * a sourcemap, or to JSON.stringify.
				 */
				function toEncodedMap(map) {
					const decoded = toDecodedMap(map)
					return Object.assign(Object.assign({}, decoded), {
						mappings: sourcemapCodec.encode(decoded.mappings),
					})
				}
				/**
				 * Constructs a new GenMapping, using the already present mappings of the input.
				 */
				function fromMap(input) {
					const map = new traceMapping.TraceMap(input)
					const gen = new GenMapping({
						file: map.file,
						sourceRoot: map.sourceRoot,
					})
					putAll(cast(gen)._names, map.names)
					putAll(cast(gen)._sources, map.sources)
					cast(gen)._sourcesContent =
						map.sourcesContent || map.sources.map(() => null)
					cast(gen)._mappings = traceMapping.decodedMappings(map)
					if (map.ignoreList) putAll(cast(gen)._ignoreList, map.ignoreList)
					return gen
				}
				/**
				 * Returns an array of high-level mapping objects for every recorded segment, which could then be
				 * passed to the `source-map` library.
				 */
				function allMappings(map) {
					const out = []
					const {
						_mappings: mappings,
						_sources: sources,
						_names: names,
					} = cast(map)
					for (let i = 0; i < mappings.length; i++) {
						const line = mappings[i]
						for (let j = 0; j < line.length; j++) {
							const seg = line[j]
							const generated = { line: i + 1, column: seg[COLUMN] }
							let source = undefined
							let original = undefined
							let name = undefined
							if (seg.length !== 1) {
								source = sources.array[seg[SOURCES_INDEX]]
								original = {
									line: seg[SOURCE_LINE] + 1,
									column: seg[SOURCE_COLUMN],
								}
								if (seg.length === 5) name = names.array[seg[NAMES_INDEX]]
							}
							out.push({ generated, source, original, name })
						}
					}
					return out
				}
				// This split declaration is only so that terser can elminiate the static initialization block.
				function addSegmentInternal(
					skipable,
					map,
					genLine,
					genColumn,
					source,
					sourceLine,
					sourceColumn,
					name,
					content,
				) {
					const {
						_mappings: mappings,
						_sources: sources,
						_sourcesContent: sourcesContent,
						_names: names,
					} = cast(map)
					const line = getLine(mappings, genLine)
					const index = getColumnIndex(line, genColumn)
					if (!source) {
						if (skipable && skipSourceless(line, index)) return
						return insert(line, index, [genColumn])
					}
					const sourcesIndex = setArray.put(sources, source)
					const namesIndex = name ? setArray.put(names, name) : NO_NAME
					if (sourcesIndex === sourcesContent.length)
						sourcesContent[sourcesIndex] =
							content !== null && content !== void 0 ? content : null
					if (
						skipable &&
						skipSource(
							line,
							index,
							sourcesIndex,
							sourceLine,
							sourceColumn,
							namesIndex,
						)
					) {
						return
					}
					return insert(
						line,
						index,
						name
							? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]
							: [genColumn, sourcesIndex, sourceLine, sourceColumn],
					)
				}
				function getLine(mappings, index) {
					for (let i = mappings.length; i <= index; i++) {
						mappings[i] = []
					}
					return mappings[index]
				}
				function getColumnIndex(line, genColumn) {
					let index = line.length
					for (let i = index - 1; i >= 0; index = i--) {
						const current = line[i]
						if (genColumn >= current[COLUMN]) break
					}
					return index
				}
				function insert(array, index, value) {
					for (let i = array.length; i > index; i--) {
						array[i] = array[i - 1]
					}
					array[index] = value
				}
				function removeEmptyFinalLines(mappings) {
					const { length } = mappings
					let len = length
					for (let i = len - 1; i >= 0; len = i, i--) {
						if (mappings[i].length > 0) break
					}
					if (len < length) mappings.length = len
				}
				function putAll(setarr, array) {
					for (let i = 0; i < array.length; i++) setArray.put(setarr, array[i])
				}
				function skipSourceless(line, index) {
					// The start of a line is already sourceless, so adding a sourceless segment to the beginning
					// doesn't generate any useful information.
					if (index === 0) return true
					const prev = line[index - 1]
					// If the previous segment is also sourceless, then adding another sourceless segment doesn't
					// genrate any new information. Else, this segment will end the source/named segment and point to
					// a sourceless position, which is useful.
					return prev.length === 1
				}
				function skipSource(
					line,
					index,
					sourcesIndex,
					sourceLine,
					sourceColumn,
					namesIndex,
				) {
					// A source/named segment at the start of a line gives position at that genColumn
					if (index === 0) return false
					const prev = line[index - 1]
					// If the previous segment is sourceless, then we're transitioning to a source.
					if (prev.length === 1) return false
					// If the previous segment maps to the exact same source position, then this segment doesn't
					// provide any new position information.
					return (
						sourcesIndex === prev[SOURCES_INDEX] &&
						sourceLine === prev[SOURCE_LINE] &&
						sourceColumn === prev[SOURCE_COLUMN] &&
						namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME)
					)
				}
				function addMappingInternal(skipable, map, mapping) {
					const { generated, source, original, name, content } = mapping
					if (!source) {
						return addSegmentInternal(
							skipable,
							map,
							generated.line - 1,
							generated.column,
							null,
							null,
							null,
							null,
							null,
						)
					}
					return addSegmentInternal(
						skipable,
						map,
						generated.line - 1,
						generated.column,
						source,
						original.line - 1,
						original.column,
						name,
						content,
					)
				}

				exports.GenMapping = GenMapping
				exports.addMapping = addMapping
				exports.addSegment = addSegment
				exports.allMappings = allMappings
				exports.fromMap = fromMap
				exports.maybeAddMapping = maybeAddMapping
				exports.maybeAddSegment = maybeAddSegment
				exports.setIgnore = setIgnore
				exports.setSourceContent = setSourceContent
				exports.toDecodedMap = toDecodedMap
				exports.toEncodedMap = toEncodedMap

				Object.defineProperty(exports, '__esModule', { value: true })
			})
			//# sourceMappingURL=gen-mapping.umd.js.map

			/***/
		},

		/***/ 59445: /***/ function (module) {
			;(function (global, factory) {
				true ? (module.exports = factory()) : 0
			})(this, function () {
				'use strict'

				// Matches the scheme of a URL, eg "http://"
				const schemeRegex = /^[\w+.-]+:\/\//
				/**
				 * Matches the parts of a URL:
				 * 1. Scheme, including ":", guaranteed.
				 * 2. User/password, including "@", optional.
				 * 3. Host, guaranteed.
				 * 4. Port, including ":", optional.
				 * 5. Path, including "/", optional.
				 * 6. Query, including "?", optional.
				 * 7. Hash, including "#", optional.
				 */
				const urlRegex =
					/^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/
				/**
				 * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start
				 * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).
				 *
				 * 1. Host, optional.
				 * 2. Path, which may include "/", guaranteed.
				 * 3. Query, including "?", optional.
				 * 4. Hash, including "#", optional.
				 */
				const fileRegex =
					/^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i
				function isAbsoluteUrl(input) {
					return schemeRegex.test(input)
				}
				function isSchemeRelativeUrl(input) {
					return input.startsWith('//')
				}
				function isAbsolutePath(input) {
					return input.startsWith('/')
				}
				function isFileUrl(input) {
					return input.startsWith('file:')
				}
				function isRelative(input) {
					return /^[.?#]/.test(input)
				}
				function parseAbsoluteUrl(input) {
					const match = urlRegex.exec(input)
					return makeUrl(
						match[1],
						match[2] || '',
						match[3],
						match[4] || '',
						match[5] || '/',
						match[6] || '',
						match[7] || '',
					)
				}
				function parseFileUrl(input) {
					const match = fileRegex.exec(input)
					const path = match[2]
					return makeUrl(
						'file:',
						'',
						match[1] || '',
						'',
						isAbsolutePath(path) ? path : '/' + path,
						match[3] || '',
						match[4] || '',
					)
				}
				function makeUrl(scheme, user, host, port, path, query, hash) {
					return {
						scheme,
						user,
						host,
						port,
						path,
						query,
						hash,
						type: 7 /* Absolute */,
					}
				}
				function parseUrl(input) {
					if (isSchemeRelativeUrl(input)) {
						const url = parseAbsoluteUrl('http:' + input)
						url.scheme = ''
						url.type = 6 /* SchemeRelative */
						return url
					}
					if (isAbsolutePath(input)) {
						const url = parseAbsoluteUrl('http://foo.com' + input)
						url.scheme = ''
						url.host = ''
						url.type = 5 /* AbsolutePath */
						return url
					}
					if (isFileUrl(input)) return parseFileUrl(input)
					if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input)
					const url = parseAbsoluteUrl('http://foo.com/' + input)
					url.scheme = ''
					url.host = ''
					url.type = input
						? input.startsWith('?')
							? 3 /* Query */
							: input.startsWith('#')
								? 2 /* Hash */
								: 4 /* RelativePath */
						: 1 /* Empty */
					return url
				}
				function stripPathFilename(path) {
					// If a path ends with a parent directory "..", then it's a relative path with excess parent
					// paths. It's not a file, so we can't strip it.
					if (path.endsWith('/..')) return path
					const index = path.lastIndexOf('/')
					return path.slice(0, index + 1)
				}
				function mergePaths(url, base) {
					normalizePath(base, base.type)
					// If the path is just a "/", then it was an empty path to begin with (remember, we're a relative
					// path).
					if (url.path === '/') {
						url.path = base.path
					} else {
						// Resolution happens relative to the base path's directory, not the file.
						url.path = stripPathFilename(base.path) + url.path
					}
				}
				/**
				 * The path can have empty directories "//", unneeded parents "foo/..", or current directory
				 * "foo/.". We need to normalize to a standard representation.
				 */
				function normalizePath(url, type) {
					const rel = type <= 4 /* RelativePath */
					const pieces = url.path.split('/')
					// We need to preserve the first piece always, so that we output a leading slash. The item at
					// pieces[0] is an empty string.
					let pointer = 1
					// Positive is the number of real directories we've output, used for popping a parent directory.
					// Eg, "foo/bar/.." will have a positive 2, and we can decrement to be left with just "foo".
					let positive = 0
					// We need to keep a trailing slash if we encounter an empty directory (eg, splitting "foo/" will
					// generate `["foo", ""]` pieces). And, if we pop a parent directory. But once we encounter a
					// real directory, we won't need to append, unless the other conditions happen again.
					let addTrailingSlash = false
					for (let i = 1; i < pieces.length; i++) {
						const piece = pieces[i]
						// An empty directory, could be a trailing slash, or just a double "//" in the path.
						if (!piece) {
							addTrailingSlash = true
							continue
						}
						// If we encounter a real directory, then we don't need to append anymore.
						addTrailingSlash = false
						// A current directory, which we can always drop.
						if (piece === '.') continue
						// A parent directory, we need to see if there are any real directories we can pop. Else, we
						// have an excess of parents, and we'll need to keep the "..".
						if (piece === '..') {
							if (positive) {
								addTrailingSlash = true
								positive--
								pointer--
							} else if (rel) {
								// If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute
								// URL, protocol relative URL, or an absolute path, we don't need to keep excess.
								pieces[pointer++] = piece
							}
							continue
						}
						// We've encountered a real directory. Move it to the next insertion pointer, which accounts for
						// any popped or dropped directories.
						pieces[pointer++] = piece
						positive++
					}
					let path = ''
					for (let i = 1; i < pointer; i++) {
						path += '/' + pieces[i]
					}
					if (!path || (addTrailingSlash && !path.endsWith('/..'))) {
						path += '/'
					}
					url.path = path
				}
				/**
				 * Attempts to resolve `input` URL/path relative to `base`.
				 */
				function resolve(input, base) {
					if (!input && !base) return ''
					const url = parseUrl(input)
					let inputType = url.type
					if (base && inputType !== 7 /* Absolute */) {
						const baseUrl = parseUrl(base)
						const baseType = baseUrl.type
						switch (inputType) {
							case 1 /* Empty */:
								url.hash = baseUrl.hash
							// fall through
							case 2 /* Hash */:
								url.query = baseUrl.query
							// fall through
							case 3 /* Query */:
							case 4 /* RelativePath */:
								mergePaths(url, baseUrl)
							// fall through
							case 5 /* AbsolutePath */:
								// The host, user, and port are joined, you can't copy one without the others.
								url.user = baseUrl.user
								url.host = baseUrl.host
								url.port = baseUrl.port
							// fall through
							case 6 /* SchemeRelative */:
								// The input doesn't have a schema at least, so we need to copy at least that over.
								url.scheme = baseUrl.scheme
						}
						if (baseType > inputType) inputType = baseType
					}
					normalizePath(url, inputType)
					const queryHash = url.query + url.hash
					switch (inputType) {
						// This is impossible, because of the empty checks at the start of the function.
						// case UrlType.Empty:
						case 2 /* Hash */:
						case 3 /* Query */:
							return queryHash
						case 4 /* RelativePath */: {
							// The first char is always a "/", and we need it to be relative.
							const path = url.path.slice(1)
							if (!path) return queryHash || '.'
							if (isRelative(base || input) && !isRelative(path)) {
								// If base started with a leading ".", or there is no base and input started with a ".",
								// then we need to ensure that the relative path starts with a ".". We don't know if
								// relative starts with a "..", though, so check before prepending.
								return './' + path + queryHash
							}
							return path + queryHash
						}
						case 5 /* AbsolutePath */:
							return url.path + queryHash
						default:
							return (
								url.scheme +
								'//' +
								url.user +
								url.host +
								url.port +
								url.path +
								queryHash
							)
					}
				}

				return resolve
			})
			//# sourceMappingURL=resolve-uri.umd.js.map

			/***/
		},

		/***/ 83199: /***/ function (__unused_webpack_module, exports) {
			;(function (global, factory) {
				true ? factory(exports) : 0
			})(this, function (exports) {
				'use strict'

				/**
				 * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the
				 * index of the `key` in the backing array.
				 *
				 * This is designed to allow synchronizing a second array with the contents of the backing array,
				 * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,
				 * and there are never duplicates.
				 */
				class SetArray {
					constructor() {
						this._indexes = { __proto__: null }
						this.array = []
					}
				}
				/**
				 * Typescript doesn't allow friend access to private fields, so this just casts the set into a type
				 * with public access modifiers.
				 */
				function cast(set) {
					return set
				}
				/**
				 * Gets the index associated with `key` in the backing array, if it is already present.
				 */
				function get(setarr, key) {
					return cast(setarr)._indexes[key]
				}
				/**
				 * Puts `key` into the backing array, if it is not already present. Returns
				 * the index of the `key` in the backing array.
				 */
				function put(setarr, key) {
					// The key may or may not be present. If it is present, it's a number.
					const index = get(setarr, key)
					if (index !== undefined) return index
					const { array, _indexes: indexes } = cast(setarr)
					const length = array.push(key)
					return (indexes[key] = length - 1)
				}
				/**
				 * Pops the last added item out of the SetArray.
				 */
				function pop(setarr) {
					const { array, _indexes: indexes } = cast(setarr)
					if (array.length === 0) return
					const last = array.pop()
					indexes[last] = undefined
				}
				/**
				 * Removes the key, if it exists in the set.
				 */
				function remove(setarr, key) {
					const index = get(setarr, key)
					if (index === undefined) return
					const { array, _indexes: indexes } = cast(setarr)
					for (let i = index + 1; i < array.length; i++) {
						const k = array[i]
						array[i - 1] = k
						indexes[k]--
					}
					indexes[key] = undefined
					array.pop()
				}

				exports.SetArray = SetArray
				exports.get = get
				exports.pop = pop
				exports.put = put
				exports.remove = remove

				Object.defineProperty(exports, '__esModule', { value: true })
			})
			//# sourceMappingURL=set-array.umd.js.map

			/***/
		},

		/***/ 69551: /***/ function (__unused_webpack_module, exports) {
			;(function (global, factory) {
				true ? factory(exports) : 0
			})(this, function (exports) {
				'use strict'

				const comma = ','.charCodeAt(0)
				const semicolon = ';'.charCodeAt(0)
				const chars =
					'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
				const intToChar = new Uint8Array(64) // 64 possible chars.
				const charToInt = new Uint8Array(128) // z is 122 in ASCII
				for (let i = 0; i < chars.length; i++) {
					const c = chars.charCodeAt(i)
					intToChar[i] = c
					charToInt[c] = i
				}
				function decodeInteger(reader, relative) {
					let value = 0
					let shift = 0
					let integer = 0
					do {
						const c = reader.next()
						integer = charToInt[c]
						value |= (integer & 31) << shift
						shift += 5
					} while (integer & 32)
					const shouldNegate = value & 1
					value >>>= 1
					if (shouldNegate) {
						value = -0x80000000 | -value
					}
					return relative + value
				}
				function encodeInteger(builder, num, relative) {
					let delta = num - relative
					delta = delta < 0 ? (-delta << 1) | 1 : delta << 1
					do {
						let clamped = delta & 0b011111
						delta >>>= 5
						if (delta > 0) clamped |= 0b100000
						builder.write(intToChar[clamped])
					} while (delta > 0)
					return num
				}
				function hasMoreVlq(reader, max) {
					if (reader.pos >= max) return false
					return reader.peek() !== comma
				}

				const bufLength = 1024 * 16
				// Provide a fallback for older environments.
				const td =
					typeof TextDecoder !== 'undefined'
						? /* #__PURE__ */ new TextDecoder()
						: typeof Buffer !== 'undefined'
							? {
									decode(buf) {
										const out = Buffer.from(
											buf.buffer,
											buf.byteOffset,
											buf.byteLength,
										)
										return out.toString()
									},
								}
							: {
									decode(buf) {
										let out = ''
										for (let i = 0; i < buf.length; i++) {
											out += String.fromCharCode(buf[i])
										}
										return out
									},
								}
				class StringWriter {
					constructor() {
						this.pos = 0
						this.out = ''
						this.buffer = new Uint8Array(bufLength)
					}
					write(v) {
						const { buffer } = this
						buffer[this.pos++] = v
						if (this.pos === bufLength) {
							this.out += td.decode(buffer)
							this.pos = 0
						}
					}
					flush() {
						const { buffer, out, pos } = this
						return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out
					}
				}
				class StringReader {
					constructor(buffer) {
						this.pos = 0
						this.buffer = buffer
					}
					next() {
						return this.buffer.charCodeAt(this.pos++)
					}
					peek() {
						return this.buffer.charCodeAt(this.pos)
					}
					indexOf(char) {
						const { buffer, pos } = this
						const idx = buffer.indexOf(char, pos)
						return idx === -1 ? buffer.length : idx
					}
				}

				const EMPTY = []
				function decodeOriginalScopes(input) {
					const { length } = input
					const reader = new StringReader(input)
					const scopes = []
					const stack = []
					let line = 0
					for (; reader.pos < length; reader.pos++) {
						line = decodeInteger(reader, line)
						const column = decodeInteger(reader, 0)
						if (!hasMoreVlq(reader, length)) {
							const last = stack.pop()
							last[2] = line
							last[3] = column
							continue
						}
						const kind = decodeInteger(reader, 0)
						const fields = decodeInteger(reader, 0)
						const hasName = fields & 0b0001
						const scope = hasName
							? [line, column, 0, 0, kind, decodeInteger(reader, 0)]
							: [line, column, 0, 0, kind]
						let vars = EMPTY
						if (hasMoreVlq(reader, length)) {
							vars = []
							do {
								const varsIndex = decodeInteger(reader, 0)
								vars.push(varsIndex)
							} while (hasMoreVlq(reader, length))
						}
						scope.vars = vars
						scopes.push(scope)
						stack.push(scope)
					}
					return scopes
				}
				function encodeOriginalScopes(scopes) {
					const writer = new StringWriter()
					for (let i = 0; i < scopes.length; ) {
						i = _encodeOriginalScopes(scopes, i, writer, [0])
					}
					return writer.flush()
				}
				function _encodeOriginalScopes(scopes, index, writer, state) {
					const scope = scopes[index]
					const {
						0: startLine,
						1: startColumn,
						2: endLine,
						3: endColumn,
						4: kind,
						vars,
					} = scope
					if (index > 0) writer.write(comma)
					state[0] = encodeInteger(writer, startLine, state[0])
					encodeInteger(writer, startColumn, 0)
					encodeInteger(writer, kind, 0)
					const fields = scope.length === 6 ? 0b0001 : 0
					encodeInteger(writer, fields, 0)
					if (scope.length === 6) encodeInteger(writer, scope[5], 0)
					for (const v of vars) {
						encodeInteger(writer, v, 0)
					}
					for (index++; index < scopes.length; ) {
						const next = scopes[index]
						const { 0: l, 1: c } = next
						if (l > endLine || (l === endLine && c >= endColumn)) {
							break
						}
						index = _encodeOriginalScopes(scopes, index, writer, state)
					}
					writer.write(comma)
					state[0] = encodeInteger(writer, endLine, state[0])
					encodeInteger(writer, endColumn, 0)
					return index
				}
				function decodeGeneratedRanges(input) {
					const { length } = input
					const reader = new StringReader(input)
					const ranges = []
					const stack = []
					let genLine = 0
					let definitionSourcesIndex = 0
					let definitionScopeIndex = 0
					let callsiteSourcesIndex = 0
					let callsiteLine = 0
					let callsiteColumn = 0
					let bindingLine = 0
					let bindingColumn = 0
					do {
						const semi = reader.indexOf(';')
						let genColumn = 0
						for (; reader.pos < semi; reader.pos++) {
							genColumn = decodeInteger(reader, genColumn)
							if (!hasMoreVlq(reader, semi)) {
								const last = stack.pop()
								last[2] = genLine
								last[3] = genColumn
								continue
							}
							const fields = decodeInteger(reader, 0)
							const hasDefinition = fields & 0b0001
							const hasCallsite = fields & 0b0010
							const hasScope = fields & 0b0100
							let callsite = null
							let bindings = EMPTY
							let range
							if (hasDefinition) {
								const defSourcesIndex = decodeInteger(
									reader,
									definitionSourcesIndex,
								)
								definitionScopeIndex = decodeInteger(
									reader,
									definitionSourcesIndex === defSourcesIndex
										? definitionScopeIndex
										: 0,
								)
								definitionSourcesIndex = defSourcesIndex
								range = [
									genLine,
									genColumn,
									0,
									0,
									defSourcesIndex,
									definitionScopeIndex,
								]
							} else {
								range = [genLine, genColumn, 0, 0]
							}
							range.isScope = !!hasScope
							if (hasCallsite) {
								const prevCsi = callsiteSourcesIndex
								const prevLine = callsiteLine
								callsiteSourcesIndex = decodeInteger(
									reader,
									callsiteSourcesIndex,
								)
								const sameSource = prevCsi === callsiteSourcesIndex
								callsiteLine = decodeInteger(
									reader,
									sameSource ? callsiteLine : 0,
								)
								callsiteColumn = decodeInteger(
									reader,
									sameSource && prevLine === callsiteLine ? callsiteColumn : 0,
								)
								callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn]
							}
							range.callsite = callsite
							if (hasMoreVlq(reader, semi)) {
								bindings = []
								do {
									bindingLine = genLine
									bindingColumn = genColumn
									const expressionsCount = decodeInteger(reader, 0)
									let expressionRanges
									if (expressionsCount < -1) {
										expressionRanges = [[decodeInteger(reader, 0)]]
										for (let i = -1; i > expressionsCount; i--) {
											const prevBl = bindingLine
											bindingLine = decodeInteger(reader, bindingLine)
											bindingColumn = decodeInteger(
												reader,
												bindingLine === prevBl ? bindingColumn : 0,
											)
											const expression = decodeInteger(reader, 0)
											expressionRanges.push([
												expression,
												bindingLine,
												bindingColumn,
											])
										}
									} else {
										expressionRanges = [[expressionsCount]]
									}
									bindings.push(expressionRanges)
								} while (hasMoreVlq(reader, semi))
							}
							range.bindings = bindings
							ranges.push(range)
							stack.push(range)
						}
						genLine++
						reader.pos = semi + 1
					} while (reader.pos < length)
					return ranges
				}
				function encodeGeneratedRanges(ranges) {
					if (ranges.length === 0) return ''
					const writer = new StringWriter()
					for (let i = 0; i < ranges.length; ) {
						i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0])
					}
					return writer.flush()
				}
				function _encodeGeneratedRanges(ranges, index, writer, state) {
					const range = ranges[index]
					const {
						0: startLine,
						1: startColumn,
						2: endLine,
						3: endColumn,
						isScope,
						callsite,
						bindings,
					} = range
					if (state[0] < startLine) {
						catchupLine(writer, state[0], startLine)
						state[0] = startLine
						state[1] = 0
					} else if (index > 0) {
						writer.write(comma)
					}
					state[1] = encodeInteger(writer, range[1], state[1])
					const fields =
						(range.length === 6 ? 0b0001 : 0) |
						(callsite ? 0b0010 : 0) |
						(isScope ? 0b0100 : 0)
					encodeInteger(writer, fields, 0)
					if (range.length === 6) {
						const { 4: sourcesIndex, 5: scopesIndex } = range
						if (sourcesIndex !== state[2]) {
							state[3] = 0
						}
						state[2] = encodeInteger(writer, sourcesIndex, state[2])
						state[3] = encodeInteger(writer, scopesIndex, state[3])
					}
					if (callsite) {
						const {
							0: sourcesIndex,
							1: callLine,
							2: callColumn,
						} = range.callsite
						if (sourcesIndex !== state[4]) {
							state[5] = 0
							state[6] = 0
						} else if (callLine !== state[5]) {
							state[6] = 0
						}
						state[4] = encodeInteger(writer, sourcesIndex, state[4])
						state[5] = encodeInteger(writer, callLine, state[5])
						state[6] = encodeInteger(writer, callColumn, state[6])
					}
					if (bindings) {
						for (const binding of bindings) {
							if (binding.length > 1) encodeInteger(writer, -binding.length, 0)
							const expression = binding[0][0]
							encodeInteger(writer, expression, 0)
							let bindingStartLine = startLine
							let bindingStartColumn = startColumn
							for (let i = 1; i < binding.length; i++) {
								const expRange = binding[i]
								bindingStartLine = encodeInteger(
									writer,
									expRange[1],
									bindingStartLine,
								)
								bindingStartColumn = encodeInteger(
									writer,
									expRange[2],
									bindingStartColumn,
								)
								encodeInteger(writer, expRange[0], 0)
							}
						}
					}
					for (index++; index < ranges.length; ) {
						const next = ranges[index]
						const { 0: l, 1: c } = next
						if (l > endLine || (l === endLine && c >= endColumn)) {
							break
						}
						index = _encodeGeneratedRanges(ranges, index, writer, state)
					}
					if (state[0] < endLine) {
						catchupLine(writer, state[0], endLine)
						state[0] = endLine
						state[1] = 0
					} else {
						writer.write(comma)
					}
					state[1] = encodeInteger(writer, endColumn, state[1])
					return index
				}
				function catchupLine(writer, lastLine, line) {
					do {
						writer.write(semicolon)
					} while (++lastLine < line)
				}

				function decode(mappings) {
					const { length } = mappings
					const reader = new StringReader(mappings)
					const decoded = []
					let genColumn = 0
					let sourcesIndex = 0
					let sourceLine = 0
					let sourceColumn = 0
					let namesIndex = 0
					do {
						const semi = reader.indexOf(';')
						const line = []
						let sorted = true
						let lastCol = 0
						genColumn = 0
						while (reader.pos < semi) {
							let seg
							genColumn = decodeInteger(reader, genColumn)
							if (genColumn < lastCol) sorted = false
							lastCol = genColumn
							if (hasMoreVlq(reader, semi)) {
								sourcesIndex = decodeInteger(reader, sourcesIndex)
								sourceLine = decodeInteger(reader, sourceLine)
								sourceColumn = decodeInteger(reader, sourceColumn)
								if (hasMoreVlq(reader, semi)) {
									namesIndex = decodeInteger(reader, namesIndex)
									seg = [
										genColumn,
										sourcesIndex,
										sourceLine,
										sourceColumn,
										namesIndex,
									]
								} else {
									seg = [genColumn, sourcesIndex, sourceLine, sourceColumn]
								}
							} else {
								seg = [genColumn]
							}
							line.push(seg)
							reader.pos++
						}
						if (!sorted) sort(line)
						decoded.push(line)
						reader.pos = semi + 1
					} while (reader.pos <= length)
					return decoded
				}
				function sort(line) {
					line.sort(sortComparator)
				}
				function sortComparator(a, b) {
					return a[0] - b[0]
				}
				function encode(decoded) {
					const writer = new StringWriter()
					let sourcesIndex = 0
					let sourceLine = 0
					let sourceColumn = 0
					let namesIndex = 0
					for (let i = 0; i < decoded.length; i++) {
						const line = decoded[i]
						if (i > 0) writer.write(semicolon)
						if (line.length === 0) continue
						let genColumn = 0
						for (let j = 0; j < line.length; j++) {
							const segment = line[j]
							if (j > 0) writer.write(comma)
							genColumn = encodeInteger(writer, segment[0], genColumn)
							if (segment.length === 1) continue
							sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex)
							sourceLine = encodeInteger(writer, segment[2], sourceLine)
							sourceColumn = encodeInteger(writer, segment[3], sourceColumn)
							if (segment.length === 4) continue
							namesIndex = encodeInteger(writer, segment[4], namesIndex)
						}
					}
					return writer.flush()
				}

				exports.decode = decode
				exports.decodeGeneratedRanges = decodeGeneratedRanges
				exports.decodeOriginalScopes = decodeOriginalScopes
				exports.encode = encode
				exports.encodeGeneratedRanges = encodeGeneratedRanges
				exports.encodeOriginalScopes = encodeOriginalScopes

				Object.defineProperty(exports, '__esModule', { value: true })
			})
			//# sourceMappingURL=sourcemap-codec.umd.js.map

			/***/
		},

		/***/ 99535: /***/ function (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) {
			;(function (global, factory) {
				true
					? factory(
							exports,
							__nccwpck_require__(69551),
							__nccwpck_require__(59445),
						)
					: 0
			})(this, function (exports, sourcemapCodec, resolveUri) {
				'use strict'

				function resolve(input, base) {
					// The base is always treated as a directory, if it's not empty.
					// https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327
					// https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401
					if (base && !base.endsWith('/')) base += '/'
					return resolveUri(input, base)
				}

				/**
				 * Removes everything after the last "/", but leaves the slash.
				 */
				function stripFilename(path) {
					if (!path) return ''
					const index = path.lastIndexOf('/')
					return path.slice(0, index + 1)
				}

				const COLUMN = 0
				const SOURCES_INDEX = 1
				const SOURCE_LINE = 2
				const SOURCE_COLUMN = 3
				const NAMES_INDEX = 4
				const REV_GENERATED_LINE = 1
				const REV_GENERATED_COLUMN = 2

				function maybeSort(mappings, owned) {
					const unsortedIndex = nextUnsortedSegmentLine(mappings, 0)
					if (unsortedIndex === mappings.length) return mappings
					// If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If
					// not, we do not want to modify the consumer's input array.
					if (!owned) mappings = mappings.slice()
					for (
						let i = unsortedIndex;
						i < mappings.length;
						i = nextUnsortedSegmentLine(mappings, i + 1)
					) {
						mappings[i] = sortSegments(mappings[i], owned)
					}
					return mappings
				}
				function nextUnsortedSegmentLine(mappings, start) {
					for (let i = start; i < mappings.length; i++) {
						if (!isSorted(mappings[i])) return i
					}
					return mappings.length
				}
				function isSorted(line) {
					for (let j = 1; j < line.length; j++) {
						if (line[j][COLUMN] < line[j - 1][COLUMN]) {
							return false
						}
					}
					return true
				}
				function sortSegments(line, owned) {
					if (!owned) line = line.slice()
					return line.sort(sortComparator)
				}
				function sortComparator(a, b) {
					return a[COLUMN] - b[COLUMN]
				}

				let found = false
				/**
				 * A binary search implementation that returns the index if a match is found.
				 * If no match is found, then the left-index (the index associated with the item that comes just
				 * before the desired index) is returned. To maintain proper sort order, a splice would happen at
				 * the next index:
				 *
				 * ```js
				 * const array = [1, 3];
				 * const needle = 2;
				 * const index = binarySearch(array, needle, (item, needle) => item - needle);
				 *
				 * assert.equal(index, 0);
				 * array.splice(index + 1, 0, needle);
				 * assert.deepEqual(array, [1, 2, 3]);
				 * ```
				 */
				function binarySearch(haystack, needle, low, high) {
					while (low <= high) {
						const mid = low + ((high - low) >> 1)
						const cmp = haystack[mid][COLUMN] - needle
						if (cmp === 0) {
							found = true
							return mid
						}
						if (cmp < 0) {
							low = mid + 1
						} else {
							high = mid - 1
						}
					}
					found = false
					return low - 1
				}
				function upperBound(haystack, needle, index) {
					for (let i = index + 1; i < haystack.length; index = i++) {
						if (haystack[i][COLUMN] !== needle) break
					}
					return index
				}
				function lowerBound(haystack, needle, index) {
					for (let i = index - 1; i >= 0; index = i--) {
						if (haystack[i][COLUMN] !== needle) break
					}
					return index
				}
				function memoizedState() {
					return {
						lastKey: -1,
						lastNeedle: -1,
						lastIndex: -1,
					}
				}
				/**
				 * This overly complicated beast is just to record the last tested line/column and the resulting
				 * index, allowing us to skip a few tests if mappings are monotonically increasing.
				 */
				function memoizedBinarySearch(haystack, needle, state, key) {
					const { lastKey, lastNeedle, lastIndex } = state
					let low = 0
					let high = haystack.length - 1
					if (key === lastKey) {
						if (needle === lastNeedle) {
							found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle
							return lastIndex
						}
						if (needle >= lastNeedle) {
							// lastIndex may be -1 if the previous needle was not found.
							low = lastIndex === -1 ? 0 : lastIndex
						} else {
							high = lastIndex
						}
					}
					state.lastKey = key
					state.lastNeedle = needle
					return (state.lastIndex = binarySearch(haystack, needle, low, high))
				}

				// Rebuilds the original source files, with mappings that are ordered by source line/column instead
				// of generated line/column.
				function buildBySources(decoded, memos) {
					const sources = memos.map(buildNullArray)
					for (let i = 0; i < decoded.length; i++) {
						const line = decoded[i]
						for (let j = 0; j < line.length; j++) {
							const seg = line[j]
							if (seg.length === 1) continue
							const sourceIndex = seg[SOURCES_INDEX]
							const sourceLine = seg[SOURCE_LINE]
							const sourceColumn = seg[SOURCE_COLUMN]
							const originalSource = sources[sourceIndex]
							const originalLine =
								originalSource[sourceLine] || (originalSource[sourceLine] = [])
							const memo = memos[sourceIndex]
							// The binary search either found a match, or it found the left-index just before where the
							// segment should go. Either way, we want to insert after that. And there may be multiple
							// generated segments associated with an original location, so there may need to move several
							// indexes before we find where we need to insert.
							let index = upperBound(
								originalLine,
								sourceColumn,
								memoizedBinarySearch(
									originalLine,
									sourceColumn,
									memo,
									sourceLine,
								),
							)
							memo.lastIndex = ++index
							insert(originalLine, index, [sourceColumn, i, seg[COLUMN]])
						}
					}
					return sources
				}
				function insert(array, index, value) {
					for (let i = array.length; i > index; i--) {
						array[i] = array[i - 1]
					}
					array[index] = value
				}
				// Null arrays allow us to use ordered index keys without actually allocating contiguous memory like
				// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.
				// Numeric properties on objects are magically sorted in ascending order by the engine regardless of
				// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending
				// order when iterating with for-in.
				function buildNullArray() {
					return { __proto__: null }
				}

				const AnyMap = function (map, mapUrl) {
					const parsed = parse(map)
					if (!('sections' in parsed)) {
						return new TraceMap(parsed, mapUrl)
					}
					const mappings = []
					const sources = []
					const sourcesContent = []
					const names = []
					const ignoreList = []
					recurse(
						parsed,
						mapUrl,
						mappings,
						sources,
						sourcesContent,
						names,
						ignoreList,
						0,
						0,
						Infinity,
						Infinity,
					)
					const joined = {
						version: 3,
						file: parsed.file,
						names,
						sources,
						sourcesContent,
						mappings,
						ignoreList,
					}
					return presortedDecodedMap(joined)
				}
				function parse(map) {
					return typeof map === 'string' ? JSON.parse(map) : map
				}
				function recurse(
					input,
					mapUrl,
					mappings,
					sources,
					sourcesContent,
					names,
					ignoreList,
					lineOffset,
					columnOffset,
					stopLine,
					stopColumn,
				) {
					const { sections } = input
					for (let i = 0; i < sections.length; i++) {
						const { map, offset } = sections[i]
						let sl = stopLine
						let sc = stopColumn
						if (i + 1 < sections.length) {
							const nextOffset = sections[i + 1].offset
							sl = Math.min(stopLine, lineOffset + nextOffset.line)
							if (sl === stopLine) {
								sc = Math.min(stopColumn, columnOffset + nextOffset.column)
							} else if (sl < stopLine) {
								sc = columnOffset + nextOffset.column
							}
						}
						addSection(
							map,
							mapUrl,
							mappings,
							sources,
							sourcesContent,
							names,
							ignoreList,
							lineOffset + offset.line,
							columnOffset + offset.column,
							sl,
							sc,
						)
					}
				}
				function addSection(
					input,
					mapUrl,
					mappings,
					sources,
					sourcesContent,
					names,
					ignoreList,
					lineOffset,
					columnOffset,
					stopLine,
					stopColumn,
				) {
					const parsed = parse(input)
					if ('sections' in parsed) return recurse(...arguments)
					const map = new TraceMap(parsed, mapUrl)
					const sourcesOffset = sources.length
					const namesOffset = names.length
					const decoded = decodedMappings(map)
					const {
						resolvedSources,
						sourcesContent: contents,
						ignoreList: ignores,
					} = map
					append(sources, resolvedSources)
					append(names, map.names)
					if (contents) append(sourcesContent, contents)
					else
						for (let i = 0; i < resolvedSources.length; i++)
							sourcesContent.push(null)
					if (ignores)
						for (let i = 0; i < ignores.length; i++)
							ignoreList.push(ignores[i] + sourcesOffset)
					for (let i = 0; i < decoded.length; i++) {
						const lineI = lineOffset + i
						// We can only add so many lines before we step into the range that the next section's map
						// controls. When we get to the last line, then we'll start checking the segments to see if
						// they've crossed into the column range. But it may not have any columns that overstep, so we
						// still need to check that we don't overstep lines, too.
						if (lineI > stopLine) return
						// The out line may already exist in mappings (if we're continuing the line started by a
						// previous section). Or, we may have jumped ahead several lines to start this section.
						const out = getLine(mappings, lineI)
						// On the 0th loop, the section's column offset shifts us forward. On all other lines (since the
						// map can be multiple lines), it doesn't.
						const cOffset = i === 0 ? columnOffset : 0
						const line = decoded[i]
						for (let j = 0; j < line.length; j++) {
							const seg = line[j]
							const column = cOffset + seg[COLUMN]
							// If this segment steps into the column range that the next section's map controls, we need
							// to stop early.
							if (lineI === stopLine && column >= stopColumn) return
							if (seg.length === 1) {
								out.push([column])
								continue
							}
							const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX]
							const sourceLine = seg[SOURCE_LINE]
							const sourceColumn = seg[SOURCE_COLUMN]
							out.push(
								seg.length === 4
									? [column, sourcesIndex, sourceLine, sourceColumn]
									: [
											column,
											sourcesIndex,
											sourceLine,
											sourceColumn,
											namesOffset + seg[NAMES_INDEX],
										],
							)
						}
					}
				}
				function append(arr, other) {
					for (let i = 0; i < other.length; i++) arr.push(other[i])
				}
				function getLine(arr, index) {
					for (let i = arr.length; i <= index; i++) arr[i] = []
					return arr[index]
				}

				const LINE_GTR_ZERO =
					'`line` must be greater than 0 (lines start at line 1)'
				const COL_GTR_EQ_ZERO =
					'`column` must be greater than or equal to 0 (columns start at column 0)'
				const LEAST_UPPER_BOUND = -1
				const GREATEST_LOWER_BOUND = 1
				class TraceMap {
					constructor(map, mapUrl) {
						const isString = typeof map === 'string'
						if (!isString && map._decodedMemo) return map
						const parsed = isString ? JSON.parse(map) : map
						const {
							version,
							file,
							names,
							sourceRoot,
							sources,
							sourcesContent,
						} = parsed
						this.version = version
						this.file = file
						this.names = names || []
						this.sourceRoot = sourceRoot
						this.sources = sources
						this.sourcesContent = sourcesContent
						this.ignoreList =
							parsed.ignoreList || parsed.x_google_ignoreList || undefined
						const from = resolve(sourceRoot || '', stripFilename(mapUrl))
						this.resolvedSources = sources.map((s) => resolve(s || '', from))
						const { mappings } = parsed
						if (typeof mappings === 'string') {
							this._encoded = mappings
							this._decoded = undefined
						} else {
							this._encoded = undefined
							this._decoded = maybeSort(mappings, isString)
						}
						this._decodedMemo = memoizedState()
						this._bySources = undefined
						this._bySourceMemos = undefined
					}
				}
				/**
				 * Typescript doesn't allow friend access to private fields, so this just casts the map into a type
				 * with public access modifiers.
				 */
				function cast(map) {
					return map
				}
				/**
				 * Returns the encoded (VLQ string) form of the SourceMap's mappings field.
				 */
				function encodedMappings(map) {
					var _a
					var _b
					return (_a = (_b = cast(map))._encoded) !== null && _a !== void 0
						? _a
						: (_b._encoded = sourcemapCodec.encode(cast(map)._decoded))
				}
				/**
				 * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.
				 */
				function decodedMappings(map) {
					var _a
					return (
						(_a = cast(map))._decoded ||
						(_a._decoded = sourcemapCodec.decode(cast(map)._encoded))
					)
				}
				/**
				 * A low-level API to find the segment associated with a generated line/column (think, from a
				 * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.
				 */
				function traceSegment(map, line, column) {
					const decoded = decodedMappings(map)
					// It's common for parent source maps to have pointers to lines that have no
					// mapping (like a "//# sourceMappingURL=") at the end of the child file.
					if (line >= decoded.length) return null
					const segments = decoded[line]
					const index = traceSegmentInternal(
						segments,
						cast(map)._decodedMemo,
						line,
						column,
						GREATEST_LOWER_BOUND,
					)
					return index === -1 ? null : segments[index]
				}
				/**
				 * A higher-level API to find the source/line/column associated with a generated line/column
				 * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in
				 * `source-map` library.
				 */
				function originalPositionFor(map, needle) {
					let { line, column, bias } = needle
					line--
					if (line < 0) throw new Error(LINE_GTR_ZERO)
					if (column < 0) throw new Error(COL_GTR_EQ_ZERO)
					const decoded = decodedMappings(map)
					// It's common for parent source maps to have pointers to lines that have no
					// mapping (like a "//# sourceMappingURL=") at the end of the child file.
					if (line >= decoded.length) return OMapping(null, null, null, null)
					const segments = decoded[line]
					const index = traceSegmentInternal(
						segments,
						cast(map)._decodedMemo,
						line,
						column,
						bias || GREATEST_LOWER_BOUND,
					)
					if (index === -1) return OMapping(null, null, null, null)
					const segment = segments[index]
					if (segment.length === 1) return OMapping(null, null, null, null)
					const { names, resolvedSources } = map
					return OMapping(
						resolvedSources[segment[SOURCES_INDEX]],
						segment[SOURCE_LINE] + 1,
						segment[SOURCE_COLUMN],
						segment.length === 5 ? names[segment[NAMES_INDEX]] : null,
					)
				}
				/**
				 * Finds the generated line/column position of the provided source/line/column source position.
				 */
				function generatedPositionFor(map, needle) {
					const { source, line, column, bias } = needle
					return generatedPosition(
						map,
						source,
						line,
						column,
						bias || GREATEST_LOWER_BOUND,
						false,
					)
				}
				/**
				 * Finds all generated line/column positions of the provided source/line/column source position.
				 */
				function allGeneratedPositionsFor(map, needle) {
					const { source, line, column, bias } = needle
					// SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.
					return generatedPosition(
						map,
						source,
						line,
						column,
						bias || LEAST_UPPER_BOUND,
						true,
					)
				}
				/**
				 * Iterates each mapping in generated position order.
				 */
				function eachMapping(map, cb) {
					const decoded = decodedMappings(map)
					const { names, resolvedSources } = map
					for (let i = 0; i < decoded.length; i++) {
						const line = decoded[i]
						for (let j = 0; j < line.length; j++) {
							const seg = line[j]
							const generatedLine = i + 1
							const generatedColumn = seg[0]
							let source = null
							let originalLine = null
							let originalColumn = null
							let name = null
							if (seg.length !== 1) {
								source = resolvedSources[seg[1]]
								originalLine = seg[2] + 1
								originalColumn = seg[3]
							}
							if (seg.length === 5) name = names[seg[4]]
							cb({
								generatedLine,
								generatedColumn,
								source,
								originalLine,
								originalColumn,
								name,
							})
						}
					}
				}
				function sourceIndex(map, source) {
					const { sources, resolvedSources } = map
					let index = sources.indexOf(source)
					if (index === -1) index = resolvedSources.indexOf(source)
					return index
				}
				/**
				 * Retrieves the source content for a particular source, if its found. Returns null if not.
				 */
				function sourceContentFor(map, source) {
					const { sourcesContent } = map
					if (sourcesContent == null) return null
					const index = sourceIndex(map, source)
					return index === -1 ? null : sourcesContent[index]
				}
				/**
				 * Determines if the source is marked to ignore by the source map.
				 */
				function isIgnored(map, source) {
					const { ignoreList } = map
					if (ignoreList == null) return false
					const index = sourceIndex(map, source)
					return index === -1 ? false : ignoreList.includes(index)
				}
				/**
				 * A helper that skips sorting of the input map's mappings array, which can be expensive for larger
				 * maps.
				 */
				function presortedDecodedMap(map, mapUrl) {
					const tracer = new TraceMap(clone(map, []), mapUrl)
					cast(tracer)._decoded = map.mappings
					return tracer
				}
				/**
				 * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects
				 * a sourcemap, or to JSON.stringify.
				 */
				function decodedMap(map) {
					return clone(map, decodedMappings(map))
				}
				/**
				 * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects
				 * a sourcemap, or to JSON.stringify.
				 */
				function encodedMap(map) {
					return clone(map, encodedMappings(map))
				}
				function clone(map, mappings) {
					return {
						version: map.version,
						file: map.file,
						names: map.names,
						sourceRoot: map.sourceRoot,
						sources: map.sources,
						sourcesContent: map.sourcesContent,
						mappings,
						ignoreList: map.ignoreList || map.x_google_ignoreList,
					}
				}
				function OMapping(source, line, column, name) {
					return { source, line, column, name }
				}
				function GMapping(line, column) {
					return { line, column }
				}
				function traceSegmentInternal(segments, memo, line, column, bias) {
					let index = memoizedBinarySearch(segments, column, memo, line)
					if (found) {
						index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(
							segments,
							column,
							index,
						)
					} else if (bias === LEAST_UPPER_BOUND) index++
					if (index === -1 || index === segments.length) return -1
					return index
				}
				function sliceGeneratedPositions(segments, memo, line, column, bias) {
					let min = traceSegmentInternal(
						segments,
						memo,
						line,
						column,
						GREATEST_LOWER_BOUND,
					)
					// We ignored the bias when tracing the segment so that we're guarnateed to find the first (in
					// insertion order) segment that matched. Even if we did respect the bias when tracing, we would
					// still need to call `lowerBound()` to find the first segment, which is slower than just looking
					// for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the
					// binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to
					// match LEAST_UPPER_BOUND.
					if (!found && bias === LEAST_UPPER_BOUND) min++
					if (min === -1 || min === segments.length) return []
					// We may have found the segment that started at an earlier column. If this is the case, then we
					// need to slice all generated segments that match _that_ column, because all such segments span
					// to our desired column.
					const matchedColumn = found ? column : segments[min][COLUMN]
					// The binary search is not guaranteed to find the lower bound when a match wasn't found.
					if (!found) min = lowerBound(segments, matchedColumn, min)
					const max = upperBound(segments, matchedColumn, min)
					const result = []
					for (; min <= max; min++) {
						const segment = segments[min]
						result.push(
							GMapping(
								segment[REV_GENERATED_LINE] + 1,
								segment[REV_GENERATED_COLUMN],
							),
						)
					}
					return result
				}
				function generatedPosition(map, source, line, column, bias, all) {
					var _a
					line--
					if (line < 0) throw new Error(LINE_GTR_ZERO)
					if (column < 0) throw new Error(COL_GTR_EQ_ZERO)
					const { sources, resolvedSources } = map
					let sourceIndex = sources.indexOf(source)
					if (sourceIndex === -1) sourceIndex = resolvedSources.indexOf(source)
					if (sourceIndex === -1) return all ? [] : GMapping(null, null)
					const generated =
						(_a = cast(map))._bySources ||
						(_a._bySources = buildBySources(
							decodedMappings(map),
							(cast(map)._bySourceMemos = sources.map(memoizedState)),
						))
					const segments = generated[sourceIndex][line]
					if (segments == null) return all ? [] : GMapping(null, null)
					const memo = cast(map)._bySourceMemos[sourceIndex]
					if (all)
						return sliceGeneratedPositions(segments, memo, line, column, bias)
					const index = traceSegmentInternal(segments, memo, line, column, bias)
					if (index === -1) return GMapping(null, null)
					const segment = segments[index]
					return GMapping(
						segment[REV_GENERATED_LINE] + 1,
						segment[REV_GENERATED_COLUMN],
					)
				}

				exports.AnyMap = AnyMap
				exports.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND
				exports.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND
				exports.TraceMap = TraceMap
				exports.allGeneratedPositionsFor = allGeneratedPositionsFor
				exports.decodedMap = decodedMap
				exports.decodedMappings = decodedMappings
				exports.eachMapping = eachMapping
				exports.encodedMap = encodedMap
				exports.encodedMappings = encodedMappings
				exports.generatedPositionFor = generatedPositionFor
				exports.isIgnored = isIgnored
				exports.originalPositionFor = originalPositionFor
				exports.presortedDecodedMap = presortedDecodedMap
				exports.sourceContentFor = sourceContentFor
				exports.traceSegment = traceSegment
			})
			//# sourceMappingURL=trace-mapping.umd.js.map

			/***/
		},

		/***/ 73654: /***/ (module) => {
			const IMPORT_REGEX = /^import\s/
			const EXPORT_REGEX = /^export\s/
			const EXPORT_DEFAULT_REGEX = /^export default\s/
			const STARTS_WITH_CAPITAL_LETTER_REGEX = /^[A-Z]/
			const EMPTY_NEWLINE = '\n\n'
			const COMMENT_OPEN = '<!--'
			const COMMENT_CLOSE = '-->'

			const isImport = (text) => IMPORT_REGEX.test(text)
			const isExport = (text) => EXPORT_REGEX.test(text)
			const isExportDefault = (text) => EXPORT_DEFAULT_REGEX.test(text)
			const isImportOrExport = (text) => isImport(text) || isExport(text)

			const isComment = (str) =>
				str.startsWith(COMMENT_OPEN) && str.endsWith(COMMENT_CLOSE)

			const getCommentContents = (str) =>
				str.slice(COMMENT_OPEN.length, -COMMENT_CLOSE.length)

			const startsWithCapitalLetter = (str) =>
				STARTS_WITH_CAPITAL_LETTER_REGEX.test(str)

			const paramCase = (string) =>
				string
					.replace(/([a-z0-9])([A-Z])/g, '$1-$2')
					.replace(/([a-z])([0-9])/g, '$1-$2')
					.toLowerCase()

			const toTemplateLiteral = (text) => {
				const escaped = text
					.replace(/\\(?!\$)/g, '\\\\') // Escape all "\" to avoid unwanted escaping in text nodes
					// and ignore "\$" since it's already escaped and is common
					// with prettier https://github.com/mdx-js/mdx/issues/606
					.replace(/`/g, '\\`') // Escape "`"" since
					.replace(/(\\\$)/g, '\\$1') // Escape \$ so render it as it is
					.replace(/(\\\$)(\{)/g, '\\$1\\$2') // Escape \${} so render it as it is
					.replace(/\$\{/g, '\\${') // Escape ${} in text so that it doesn't eval

				return '{`' + escaped + '`}'
			}

			module.exports.EMPTY_NEWLINE = EMPTY_NEWLINE
			module.exports.isImport = isImport
			module.exports.isExport = isExport
			module.exports.isExportDefault = isExportDefault
			module.exports.isImportOrExport = isImportOrExport
			module.exports.startsWithCapitalLetter = startsWithCapitalLetter
			module.exports.isComment = isComment
			module.exports.getCommentContents = getCommentContents
			module.exports.paramCase = paramCase
			module.exports.toTemplateLiteral = toTemplateLiteral

			/***/
		},

		/***/ 83076: /***/ (module) => {
			'use strict'

			module.exports = ccount

			function ccount(source, character) {
				var value = String(source)
				var count = 0
				var index

				if (typeof character !== 'string') {
					throw new Error('Expected character')
				}

				index = value.indexOf(character)

				while (index !== -1) {
					count++
					index = value.indexOf(character, index + character.length)
				}

				return count
			}

			/***/
		},

		/***/ 37352: /***/ (module) => {
			'use strict'

			module.exports = collapse

			// `collapse(' \t\nbar \nbaz\t') // ' bar baz '`
			function collapse(value) {
				return String(value).replace(/\s+/g, ' ')
			}

			/***/
		},

		/***/ 25288: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var fs = __nccwpck_require__(79896)
			var path = __nccwpck_require__(16928)

			Object.defineProperty(exports, 'commentRegex', {
				get: function getCommentRegex() {
					return /^\s*\/(?:\/|\*)[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/gm
				},
			})

			Object.defineProperty(exports, 'mapFileCommentRegex', {
				get: function getMapFileCommentRegex() {
					// Matches sourceMappingURL in either // or /* comment styles.
					return /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"`]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/gm
				},
			})

			var decodeBase64
			if (typeof Buffer !== 'undefined') {
				if (typeof Buffer.from === 'function') {
					decodeBase64 = decodeBase64WithBufferFrom
				} else {
					decodeBase64 = decodeBase64WithNewBuffer
				}
			} else {
				decodeBase64 = decodeBase64WithAtob
			}

			function decodeBase64WithBufferFrom(base64) {
				return Buffer.from(base64, 'base64').toString()
			}

			function decodeBase64WithNewBuffer(base64) {
				if (typeof value === 'number') {
					throw new TypeError('The value to decode must not be of type number.')
				}
				return new Buffer(base64, 'base64').toString()
			}

			function decodeBase64WithAtob(base64) {
				return decodeURIComponent(escape(atob(base64)))
			}

			function stripComment(sm) {
				return sm.split(',').pop()
			}

			function readFromFileMap(sm, dir) {
				// NOTE: this will only work on the server since it attempts to read the map file

				var r = exports.mapFileCommentRegex.exec(sm)

				// for some odd reason //# .. captures in 1 and /* .. */ in 2
				var filename = r[1] || r[2]
				var filepath = path.resolve(dir, filename)

				try {
					return fs.readFileSync(filepath, 'utf8')
				} catch (e) {
					throw new Error(
						'An error occurred while trying to read the map file at ' +
							filepath +
							'\n' +
							e,
					)
				}
			}

			function Converter(sm, opts) {
				opts = opts || {}

				if (opts.isFileComment) sm = readFromFileMap(sm, opts.commentFileDir)
				if (opts.hasComment) sm = stripComment(sm)
				if (opts.isEncoded) sm = decodeBase64(sm)
				if (opts.isJSON || opts.isEncoded) sm = JSON.parse(sm)

				this.sourcemap = sm
			}

			Converter.prototype.toJSON = function (space) {
				return JSON.stringify(this.sourcemap, null, space)
			}

			if (typeof Buffer !== 'undefined') {
				if (typeof Buffer.from === 'function') {
					Converter.prototype.toBase64 = encodeBase64WithBufferFrom
				} else {
					Converter.prototype.toBase64 = encodeBase64WithNewBuffer
				}
			} else {
				Converter.prototype.toBase64 = encodeBase64WithBtoa
			}

			function encodeBase64WithBufferFrom() {
				var json = this.toJSON()
				return Buffer.from(json, 'utf8').toString('base64')
			}

			function encodeBase64WithNewBuffer() {
				var json = this.toJSON()
				if (typeof json === 'number') {
					throw new TypeError('The json to encode must not be of type number.')
				}
				return new Buffer(json, 'utf8').toString('base64')
			}

			function encodeBase64WithBtoa() {
				var json = this.toJSON()
				return btoa(unescape(encodeURIComponent(json)))
			}

			Converter.prototype.toComment = function (options) {
				var base64 = this.toBase64()
				var data =
					'sourceMappingURL=data:application/json;charset=utf-8;base64,' +
					base64
				return options && options.multiline
					? '/*# ' + data + ' */'
					: '//# ' + data
			}

			// returns copy instead of original
			Converter.prototype.toObject = function () {
				return JSON.parse(this.toJSON())
			}

			Converter.prototype.addProperty = function (key, value) {
				if (this.sourcemap.hasOwnProperty(key))
					throw new Error(
						'property "' +
							key +
							'" already exists on the sourcemap, use set property instead',
					)
				return this.setProperty(key, value)
			}

			Converter.prototype.setProperty = function (key, value) {
				this.sourcemap[key] = value
				return this
			}

			Converter.prototype.getProperty = function (key) {
				return this.sourcemap[key]
			}

			exports.fromObject = function (obj) {
				return new Converter(obj)
			}

			exports.fromJSON = function (json) {
				return new Converter(json, { isJSON: true })
			}

			exports.fromBase64 = function (base64) {
				return new Converter(base64, { isEncoded: true })
			}

			exports.fromComment = function (comment) {
				comment = comment.replace(/^\/\*/g, '//').replace(/\*\/$/g, '')

				return new Converter(comment, { isEncoded: true, hasComment: true })
			}

			exports.fromMapFileComment = function (comment, dir) {
				return new Converter(comment, {
					commentFileDir: dir,
					isFileComment: true,
					isJSON: true,
				})
			}

			// Finds last sourcemap comment in file or returns null if none was found
			exports.fromSource = function (content) {
				var m = content.match(exports.commentRegex)
				return m ? exports.fromComment(m.pop()) : null
			}

			// Finds last sourcemap comment in file or returns null if none was found
			exports.fromMapFileSource = function (content, dir) {
				var m = content.match(exports.mapFileCommentRegex)
				return m ? exports.fromMapFileComment(m.pop(), dir) : null
			}

			exports.removeComments = function (src) {
				return src.replace(exports.commentRegex, '')
			}

			exports.removeMapFileComments = function (src) {
				return src.replace(exports.mapFileCommentRegex, '')
			}

			exports.generateMapFileComment = function (file, options) {
				var data = 'sourceMappingURL=' + file
				return options && options.multiline
					? '/*# ' + data + ' */'
					: '//# ' + data
			}

			/***/
		},

		/***/ 6110: /***/ (module, exports, __nccwpck_require__) => {
			/* eslint-env browser */

			/**
			 * This is the web browser implementation of `debug()`.
			 */

			exports.formatArgs = formatArgs
			exports.save = save
			exports.load = load
			exports.useColors = useColors
			exports.storage = localstorage()
			exports.destroy = (() => {
				let warned = false

				return () => {
					if (!warned) {
						warned = true
						console.warn(
							'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.',
						)
					}
				}
			})()

			/**
			 * Colors.
			 */

			exports.colors = [
				'#0000CC',
				'#0000FF',
				'#0033CC',
				'#0033FF',
				'#0066CC',
				'#0066FF',
				'#0099CC',
				'#0099FF',
				'#00CC00',
				'#00CC33',
				'#00CC66',
				'#00CC99',
				'#00CCCC',
				'#00CCFF',
				'#3300CC',
				'#3300FF',
				'#3333CC',
				'#3333FF',
				'#3366CC',
				'#3366FF',
				'#3399CC',
				'#3399FF',
				'#33CC00',
				'#33CC33',
				'#33CC66',
				'#33CC99',
				'#33CCCC',
				'#33CCFF',
				'#6600CC',
				'#6600FF',
				'#6633CC',
				'#6633FF',
				'#66CC00',
				'#66CC33',
				'#9900CC',
				'#9900FF',
				'#9933CC',
				'#9933FF',
				'#99CC00',
				'#99CC33',
				'#CC0000',
				'#CC0033',
				'#CC0066',
				'#CC0099',
				'#CC00CC',
				'#CC00FF',
				'#CC3300',
				'#CC3333',
				'#CC3366',
				'#CC3399',
				'#CC33CC',
				'#CC33FF',
				'#CC6600',
				'#CC6633',
				'#CC9900',
				'#CC9933',
				'#CCCC00',
				'#CCCC33',
				'#FF0000',
				'#FF0033',
				'#FF0066',
				'#FF0099',
				'#FF00CC',
				'#FF00FF',
				'#FF3300',
				'#FF3333',
				'#FF3366',
				'#FF3399',
				'#FF33CC',
				'#FF33FF',
				'#FF6600',
				'#FF6633',
				'#FF9900',
				'#FF9933',
				'#FFCC00',
				'#FFCC33',
			]

			/**
			 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
			 * and the Firebug extension (any Firefox version) are known
			 * to support "%c" CSS customizations.
			 *
			 * TODO: add a `localStorage` variable to explicitly enable/disable colors
			 */

			// eslint-disable-next-line complexity
			function useColors() {
				// NB: In an Electron preload script, document will be defined but not fully
				// initialized. Since we know we're in Chrome, we'll just detect this case
				// explicitly
				if (
					typeof window !== 'undefined' &&
					window.process &&
					(window.process.type === 'renderer' || window.process.__nwjs)
				) {
					return true
				}

				// Internet Explorer and Edge do not support colors.
				if (
					typeof navigator !== 'undefined' &&
					navigator.userAgent &&
					navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
				) {
					return false
				}

				let m

				// Is webkit? http://stackoverflow.com/a/16459606/376773
				// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
				// eslint-disable-next-line no-return-assign
				return (
					(typeof document !== 'undefined' &&
						document.documentElement &&
						document.documentElement.style &&
						document.documentElement.style.WebkitAppearance) ||
					// Is firebug? http://stackoverflow.com/a/398120/376773
					(typeof window !== 'undefined' &&
						window.console &&
						(window.console.firebug ||
							(window.console.exception && window.console.table))) ||
					// Is firefox >= v31?
					// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
					(typeof navigator !== 'undefined' &&
						navigator.userAgent &&
						(m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) &&
						parseInt(m[1], 10) >= 31) ||
					// Double check webkit in userAgent just in case we are in a worker
					(typeof navigator !== 'undefined' &&
						navigator.userAgent &&
						navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
				)
			}

			/**
			 * Colorize log arguments if enabled.
			 *
			 * @api public
			 */

			function formatArgs(args) {
				args[0] =
					(this.useColors ? '%c' : '') +
					this.namespace +
					(this.useColors ? ' %c' : ' ') +
					args[0] +
					(this.useColors ? '%c ' : ' ') +
					'+' +
					module.exports.humanize(this.diff)

				if (!this.useColors) {
					return
				}

				const c = 'color: ' + this.color
				args.splice(1, 0, c, 'color: inherit')

				// The final "%c" is somewhat tricky, because there could be other
				// arguments passed either before or after the %c, so we need to
				// figure out the correct index to insert the CSS into
				let index = 0
				let lastC = 0
				args[0].replace(/%[a-zA-Z%]/g, (match) => {
					if (match === '%%') {
						return
					}
					index++
					if (match === '%c') {
						// We only are interested in the *last* %c
						// (the user may have provided their own)
						lastC = index
					}
				})

				args.splice(lastC, 0, c)
			}

			/**
			 * Invokes `console.debug()` when available.
			 * No-op when `console.debug` is not a "function".
			 * If `console.debug` is not available, falls back
			 * to `console.log`.
			 *
			 * @api public
			 */
			exports.log = console.debug || console.log || (() => {})

			/**
			 * Save `namespaces`.
			 *
			 * @param {String} namespaces
			 * @api private
			 */
			function save(namespaces) {
				try {
					if (namespaces) {
						exports.storage.setItem('debug', namespaces)
					} else {
						exports.storage.removeItem('debug')
					}
				} catch (error) {
					// Swallow
					// XXX (@Qix-) should we be logging these?
				}
			}

			/**
			 * Load `namespaces`.
			 *
			 * @return {String} returns the previously persisted debug modes
			 * @api private
			 */
			function load() {
				let r
				try {
					r =
						exports.storage.getItem('debug') || exports.storage.getItem('DEBUG')
				} catch (error) {
					// Swallow
					// XXX (@Qix-) should we be logging these?
				}

				// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
				if (!r && typeof process !== 'undefined' && 'env' in process) {
					r = process.env.DEBUG
				}

				return r
			}

			/**
			 * Localstorage attempts to return the localstorage.
			 *
			 * This is necessary because safari throws
			 * when a user disables cookies/localstorage
			 * and you attempt to access it.
			 *
			 * @return {LocalStorage}
			 * @api private
			 */

			function localstorage() {
				try {
					// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
					// The Browser also has localStorage in the global context.
					return localStorage
				} catch (error) {
					// Swallow
					// XXX (@Qix-) should we be logging these?
				}
			}

			module.exports = __nccwpck_require__(40897)(exports)

			const { formatters } = module.exports

			/**
			 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
			 */

			formatters.j = function (v) {
				try {
					return JSON.stringify(v)
				} catch (error) {
					return '[UnexpectedJSONParseError]: ' + error.message
				}
			}

			/***/
		},

		/***/ 40897: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			/**
			 * This is the common logic for both the Node.js and web browser
			 * implementations of `debug()`.
			 */

			function setup(env) {
				createDebug.debug = createDebug
				createDebug.default = createDebug
				createDebug.coerce = coerce
				createDebug.disable = disable
				createDebug.enable = enable
				createDebug.enabled = enabled
				createDebug.humanize = __nccwpck_require__(70744)
				createDebug.destroy = destroy

				Object.keys(env).forEach((key) => {
					createDebug[key] = env[key]
				})

				/**
				 * The currently active debug mode names, and names to skip.
				 */

				createDebug.names = []
				createDebug.skips = []

				/**
				 * Map of special "%n" handling functions, for the debug "format" argument.
				 *
				 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
				 */
				createDebug.formatters = {}

				/**
				 * Selects a color for a debug namespace
				 * @param {String} namespace The namespace string for the debug instance to be colored
				 * @return {Number|String} An ANSI color code for the given namespace
				 * @api private
				 */
				function selectColor(namespace) {
					let hash = 0

					for (let i = 0; i < namespace.length; i++) {
						hash = (hash << 5) - hash + namespace.charCodeAt(i)
						hash |= 0 // Convert to 32bit integer
					}

					return createDebug.colors[Math.abs(hash) % createDebug.colors.length]
				}
				createDebug.selectColor = selectColor

				/**
				 * Create a debugger with the given `namespace`.
				 *
				 * @param {String} namespace
				 * @return {Function}
				 * @api public
				 */
				function createDebug(namespace) {
					let prevTime
					let enableOverride = null
					let namespacesCache
					let enabledCache

					function debug(...args) {
						// Disabled?
						if (!debug.enabled) {
							return
						}

						const self = debug

						// Set `diff` timestamp
						const curr = Number(new Date())
						const ms = curr - (prevTime || curr)
						self.diff = ms
						self.prev = prevTime
						self.curr = curr
						prevTime = curr

						args[0] = createDebug.coerce(args[0])

						if (typeof args[0] !== 'string') {
							// Anything else let's inspect with %O
							args.unshift('%O')
						}

						// Apply any `formatters` transformations
						let index = 0
						args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
							// If we encounter an escaped % then don't increase the array index
							if (match === '%%') {
								return '%'
							}
							index++
							const formatter = createDebug.formatters[format]
							if (typeof formatter === 'function') {
								const val = args[index]
								match = formatter.call(self, val)

								// Now we need to remove `args[index]` since it's inlined in the `format`
								args.splice(index, 1)
								index--
							}
							return match
						})

						// Apply env-specific formatting (colors, etc.)
						createDebug.formatArgs.call(self, args)

						const logFn = self.log || createDebug.log
						logFn.apply(self, args)
					}

					debug.namespace = namespace
					debug.useColors = createDebug.useColors()
					debug.color = createDebug.selectColor(namespace)
					debug.extend = extend
					debug.destroy = createDebug.destroy // XXX Temporary. Will be removed in the next major release.

					Object.defineProperty(debug, 'enabled', {
						enumerable: true,
						configurable: false,
						get: () => {
							if (enableOverride !== null) {
								return enableOverride
							}
							if (namespacesCache !== createDebug.namespaces) {
								namespacesCache = createDebug.namespaces
								enabledCache = createDebug.enabled(namespace)
							}

							return enabledCache
						},
						set: (v) => {
							enableOverride = v
						},
					})

					// Env-specific initialization logic for debug instances
					if (typeof createDebug.init === 'function') {
						createDebug.init(debug)
					}

					return debug
				}

				function extend(namespace, delimiter) {
					const newDebug = createDebug(
						this.namespace +
							(typeof delimiter === 'undefined' ? ':' : delimiter) +
							namespace,
					)
					newDebug.log = this.log
					return newDebug
				}

				/**
				 * Enables a debug mode by namespaces. This can include modes
				 * separated by a colon and wildcards.
				 *
				 * @param {String} namespaces
				 * @api public
				 */
				function enable(namespaces) {
					createDebug.save(namespaces)
					createDebug.namespaces = namespaces

					createDebug.names = []
					createDebug.skips = []

					const split = (typeof namespaces === 'string' ? namespaces : '')
						.trim()
						.replace(/\s+/g, ',')
						.split(',')
						.filter(Boolean)

					for (const ns of split) {
						if (ns[0] === '-') {
							createDebug.skips.push(ns.slice(1))
						} else {
							createDebug.names.push(ns)
						}
					}
				}

				/**
				 * Checks if the given string matches a namespace template, honoring
				 * asterisks as wildcards.
				 *
				 * @param {String} search
				 * @param {String} template
				 * @return {Boolean}
				 */
				function matchesTemplate(search, template) {
					let searchIndex = 0
					let templateIndex = 0
					let starIndex = -1
					let matchIndex = 0

					while (searchIndex < search.length) {
						if (
							templateIndex < template.length &&
							(template[templateIndex] === search[searchIndex] ||
								template[templateIndex] === '*')
						) {
							// Match character or proceed with wildcard
							if (template[templateIndex] === '*') {
								starIndex = templateIndex
								matchIndex = searchIndex
								templateIndex++ // Skip the '*'
							} else {
								searchIndex++
								templateIndex++
							}
						} else if (starIndex !== -1) {
							// eslint-disable-line no-negated-condition
							// Backtrack to the last '*' and try to match more characters
							templateIndex = starIndex + 1
							matchIndex++
							searchIndex = matchIndex
						} else {
							return false // No match
						}
					}

					// Handle trailing '*' in template
					while (
						templateIndex < template.length &&
						template[templateIndex] === '*'
					) {
						templateIndex++
					}

					return templateIndex === template.length
				}

				/**
				 * Disable debug output.
				 *
				 * @return {String} namespaces
				 * @api public
				 */
				function disable() {
					const namespaces = [
						...createDebug.names,
						...createDebug.skips.map((namespace) => '-' + namespace),
					].join(',')
					createDebug.enable('')
					return namespaces
				}

				/**
				 * Returns true if the given mode name is enabled, false otherwise.
				 *
				 * @param {String} name
				 * @return {Boolean}
				 * @api public
				 */
				function enabled(name) {
					for (const skip of createDebug.skips) {
						if (matchesTemplate(name, skip)) {
							return false
						}
					}

					for (const ns of createDebug.names) {
						if (matchesTemplate(name, ns)) {
							return true
						}
					}

					return false
				}

				/**
				 * Coerce `val`.
				 *
				 * @param {Mixed} val
				 * @return {Mixed}
				 * @api private
				 */
				function coerce(val) {
					if (val instanceof Error) {
						return val.stack || val.message
					}
					return val
				}

				/**
				 * XXX DO NOT USE. This is a temporary stub function.
				 * XXX It WILL be removed in the next major release.
				 */
				function destroy() {
					console.warn(
						'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.',
					)
				}

				createDebug.enable(createDebug.load())

				return createDebug
			}

			module.exports = setup

			/***/
		},

		/***/ 2830: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			/**
			 * Detect Electron renderer / nwjs process, which is node, but we should
			 * treat as a browser.
			 */

			if (
				typeof process === 'undefined' ||
				process.type === 'renderer' ||
				process.browser === true ||
				process.__nwjs
			) {
				module.exports = __nccwpck_require__(6110)
			} else {
				module.exports = __nccwpck_require__(95108)
			}

			/***/
		},

		/***/ 95108: /***/ (module, exports, __nccwpck_require__) => {
			/**
			 * Module dependencies.
			 */

			const tty = __nccwpck_require__(52018)
			const util = __nccwpck_require__(39023)

			/**
			 * This is the Node.js implementation of `debug()`.
			 */

			exports.init = init
			exports.log = log
			exports.formatArgs = formatArgs
			exports.save = save
			exports.load = load
			exports.useColors = useColors
			exports.destroy = util.deprecate(
				() => {},
				'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.',
			)

			/**
			 * Colors.
			 */

			exports.colors = [6, 2, 3, 4, 5, 1]

			try {
				// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
				// eslint-disable-next-line import/no-extraneous-dependencies
				const supportsColor = __nccwpck_require__(21450)

				if (
					supportsColor &&
					(supportsColor.stderr || supportsColor).level >= 2
				) {
					exports.colors = [
						20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62,
						63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112,
						113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165,
						166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196,
						197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209,
						214, 215, 220, 221,
					]
				}
			} catch (error) {
				// Swallow - we only care if `supports-color` is available; it doesn't have to be.
			}

			/**
			 * Build up the default `inspectOpts` object from the environment variables.
			 *
			 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
			 */

			exports.inspectOpts = Object.keys(process.env)
				.filter((key) => {
					return /^debug_/i.test(key)
				})
				.reduce((obj, key) => {
					// Camel-case
					const prop = key
						.substring(6)
						.toLowerCase()
						.replace(/_([a-z])/g, (_, k) => {
							return k.toUpperCase()
						})

					// Coerce string value into JS value
					let val = process.env[key]
					if (/^(yes|on|true|enabled)$/i.test(val)) {
						val = true
					} else if (/^(no|off|false|disabled)$/i.test(val)) {
						val = false
					} else if (val === 'null') {
						val = null
					} else {
						val = Number(val)
					}

					obj[prop] = val
					return obj
				}, {})

			/**
			 * Is stdout a TTY? Colored output is enabled when `true`.
			 */

			function useColors() {
				return 'colors' in exports.inspectOpts
					? Boolean(exports.inspectOpts.colors)
					: tty.isatty(process.stderr.fd)
			}

			/**
			 * Adds ANSI color escape codes if enabled.
			 *
			 * @api public
			 */

			function formatArgs(args) {
				const { namespace: name, useColors } = this

				if (useColors) {
					const c = this.color
					const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c)
					const prefix = `  ${colorCode};1m${name} \u001B[0m`

					args[0] = prefix + args[0].split('\n').join('\n' + prefix)
					args.push(
						colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m',
					)
				} else {
					args[0] = getDate() + name + ' ' + args[0]
				}
			}

			function getDate() {
				if (exports.inspectOpts.hideDate) {
					return ''
				}
				return new Date().toISOString() + ' '
			}

			/**
			 * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
			 */

			function log(...args) {
				return process.stderr.write(
					util.formatWithOptions(exports.inspectOpts, ...args) + '\n',
				)
			}

			/**
			 * Save `namespaces`.
			 *
			 * @param {String} namespaces
			 * @api private
			 */
			function save(namespaces) {
				if (namespaces) {
					process.env.DEBUG = namespaces
				} else {
					// If you set a process.env field to null or undefined, it gets cast to the
					// string 'null' or 'undefined'. Just delete instead.
					delete process.env.DEBUG
				}
			}

			/**
			 * Load `namespaces`.
			 *
			 * @return {String} returns the previously persisted debug modes
			 * @api private
			 */

			function load() {
				return process.env.DEBUG
			}

			/**
			 * Init logic for `debug` instances.
			 *
			 * Create a new `inspectOpts` object in case `useColors` is set
			 * differently for a particular `debug` instance.
			 */

			function init(debug) {
				debug.inspectOpts = {}

				const keys = Object.keys(exports.inspectOpts)
				for (let i = 0; i < keys.length; i++) {
					debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]]
				}
			}

			module.exports = __nccwpck_require__(40897)(exports)

			const { formatters } = module.exports

			/**
			 * Map %o to `util.inspect()`, all on a single line.
			 */

			formatters.o = function (v) {
				this.inspectOpts.colors = this.useColors
				return util
					.inspect(v, this.inspectOpts)
					.split('\n')
					.map((str) => str.trim())
					.join(' ')
			}

			/**
			 * Map %O to `util.inspect()`, allowing multiple lines if needed.
			 */

			formatters.O = function (v) {
				this.inspectOpts.colors = this.useColors
				return util.inspect(v, this.inspectOpts)
			}

			/***/
		},

		/***/ 48905: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var isObject = __nccwpck_require__(36403)

			module.exports = function extend(o /*, objects*/) {
				if (!isObject(o)) {
					o = {}
				}

				var len = arguments.length
				for (var i = 1; i < len; i++) {
					var obj = arguments[i]

					if (isObject(obj)) {
						assign(o, obj)
					}
				}
				return o
			}

			function assign(a, b) {
				for (var key in b) {
					if (hasOwn(b, key)) {
						a[key] = b[key]
					}
				}
			}

			/**
			 * Returns true if the given `key` is an own property of `obj`.
			 */

			function hasOwn(obj, key) {
				return Object.prototype.hasOwnProperty.call(obj, key)
			}

			/***/
		},

		/***/ 23860: /***/ (module) => {
			'use strict'

			var hasOwn = Object.prototype.hasOwnProperty
			var toStr = Object.prototype.toString
			var defineProperty = Object.defineProperty
			var gOPD = Object.getOwnPropertyDescriptor

			var isArray = function isArray(arr) {
				if (typeof Array.isArray === 'function') {
					return Array.isArray(arr)
				}

				return toStr.call(arr) === '[object Array]'
			}

			var isPlainObject = function isPlainObject(obj) {
				if (!obj || toStr.call(obj) !== '[object Object]') {
					return false
				}

				var hasOwnConstructor = hasOwn.call(obj, 'constructor')
				var hasIsPrototypeOf =
					obj.constructor &&
					obj.constructor.prototype &&
					hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')
				// Not own constructor property must be Object
				if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
					return false
				}

				// Own properties are enumerated firstly, so to speed up,
				// if last one is own, then all properties are own.
				var key
				for (key in obj) {
					/**/
				}

				return typeof key === 'undefined' || hasOwn.call(obj, key)
			}

			// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
			var setProperty = function setProperty(target, options) {
				if (defineProperty && options.name === '__proto__') {
					defineProperty(target, options.name, {
						enumerable: true,
						configurable: true,
						value: options.newValue,
						writable: true,
					})
				} else {
					target[options.name] = options.newValue
				}
			}

			// Return undefined instead of __proto__ if '__proto__' is not an own property
			var getProperty = function getProperty(obj, name) {
				if (name === '__proto__') {
					if (!hasOwn.call(obj, name)) {
						return void 0
					} else if (gOPD) {
						// In early versions of node, obj['__proto__'] is buggy when obj has
						// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
						return gOPD(obj, name).value
					}
				}

				return obj[name]
			}

			module.exports = function extend() {
				var options, name, src, copy, copyIsArray, clone
				var target = arguments[0]
				var i = 1
				var length = arguments.length
				var deep = false

				// Handle a deep copy situation
				if (typeof target === 'boolean') {
					deep = target
					target = arguments[1] || {}
					// skip the boolean and the target
					i = 2
				}
				if (
					target == null ||
					(typeof target !== 'object' && typeof target !== 'function')
				) {
					target = {}
				}

				for (; i < length; ++i) {
					options = arguments[i]
					// Only deal with non-null/undefined values
					if (options != null) {
						// Extend the base object
						for (name in options) {
							src = getProperty(target, name)
							copy = getProperty(options, name)

							// Prevent never-ending loop
							if (target !== copy) {
								// Recurse if we're merging plain objects or arrays
								if (
									deep &&
									copy &&
									(isPlainObject(copy) || (copyIsArray = isArray(copy)))
								) {
									if (copyIsArray) {
										copyIsArray = false
										clone = src && isArray(src) ? src : []
									} else {
										clone = src && isPlainObject(src) ? src : {}
									}

									// Never move original objects, clone them
									setProperty(target, {
										name: name,
										newValue: extend(deep, clone, copy),
									})

									// Don't bring in undefined values
								} else if (typeof copy !== 'undefined') {
									setProperty(target, { name: name, newValue: copy })
								}
							}
						}
					}
				}

				// Return the modified object
				return target
			}

			/***/
		},

		/***/ 99808: /***/ (module) => {
			'use strict'

			/* eslint no-invalid-this: 1 */

			var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible '
			var toStr = Object.prototype.toString
			var max = Math.max
			var funcType = '[object Function]'

			var concatty = function concatty(a, b) {
				var arr = []

				for (var i = 0; i < a.length; i += 1) {
					arr[i] = a[i]
				}
				for (var j = 0; j < b.length; j += 1) {
					arr[j + a.length] = b[j]
				}

				return arr
			}

			var slicy = function slicy(arrLike, offset) {
				var arr = []
				for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
					arr[j] = arrLike[i]
				}
				return arr
			}

			var joiny = function (arr, joiner) {
				var str = ''
				for (var i = 0; i < arr.length; i += 1) {
					str += arr[i]
					if (i + 1 < arr.length) {
						str += joiner
					}
				}
				return str
			}

			module.exports = function bind(that) {
				var target = this
				if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
					throw new TypeError(ERROR_MESSAGE + target)
				}
				var args = slicy(arguments, 1)

				var bound
				var binder = function () {
					if (this instanceof bound) {
						var result = target.apply(this, concatty(args, arguments))
						if (Object(result) === result) {
							return result
						}
						return this
					}
					return target.apply(that, concatty(args, arguments))
				}

				var boundLength = max(0, target.length - args.length)
				var boundArgs = []
				for (var i = 0; i < boundLength; i++) {
					boundArgs[i] = '$' + i
				}

				bound = Function(
					'binder',
					'return function (' +
						joiny(boundArgs, ',') +
						'){ return binder.apply(this,arguments); }',
				)(binder)

				if (target.prototype) {
					var Empty = function Empty() {}
					Empty.prototype = target.prototype
					bound.prototype = new Empty()
					Empty.prototype = null
				}

				return bound
			}

			/***/
		},

		/***/ 37564: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var implementation = __nccwpck_require__(99808)

			module.exports = Function.prototype.bind || implementation

			/***/
		},

		/***/ 9621: /***/ (module) => {
			'use strict'

			// These use the global symbol registry so that multiple copies of this
			// library can work together in case they are not deduped.
			const GENSYNC_START = Symbol.for('gensync:v1:start')
			const GENSYNC_SUSPEND = Symbol.for('gensync:v1:suspend')

			const GENSYNC_EXPECTED_START = 'GENSYNC_EXPECTED_START'
			const GENSYNC_EXPECTED_SUSPEND = 'GENSYNC_EXPECTED_SUSPEND'
			const GENSYNC_OPTIONS_ERROR = 'GENSYNC_OPTIONS_ERROR'
			const GENSYNC_RACE_NONEMPTY = 'GENSYNC_RACE_NONEMPTY'
			const GENSYNC_ERRBACK_NO_CALLBACK = 'GENSYNC_ERRBACK_NO_CALLBACK'

			module.exports = Object.assign(
				function gensync(optsOrFn) {
					let genFn = optsOrFn
					if (typeof optsOrFn !== 'function') {
						genFn = newGenerator(optsOrFn)
					} else {
						genFn = wrapGenerator(optsOrFn)
					}

					return Object.assign(genFn, makeFunctionAPI(genFn))
				},
				{
					all: buildOperation({
						name: 'all',
						arity: 1,
						sync: function (args) {
							const items = Array.from(args[0])
							return items.map((item) => evaluateSync(item))
						},
						async: function (args, resolve, reject) {
							const items = Array.from(args[0])

							if (items.length === 0) {
								Promise.resolve().then(() => resolve([]))
								return
							}

							let count = 0
							const results = items.map(() => undefined)
							items.forEach((item, i) => {
								evaluateAsync(
									item,
									(val) => {
										results[i] = val
										count += 1

										if (count === results.length) resolve(results)
									},
									reject,
								)
							})
						},
					}),
					race: buildOperation({
						name: 'race',
						arity: 1,
						sync: function (args) {
							const items = Array.from(args[0])
							if (items.length === 0) {
								throw makeError(
									'Must race at least 1 item',
									GENSYNC_RACE_NONEMPTY,
								)
							}

							return evaluateSync(items[0])
						},
						async: function (args, resolve, reject) {
							const items = Array.from(args[0])
							if (items.length === 0) {
								throw makeError(
									'Must race at least 1 item',
									GENSYNC_RACE_NONEMPTY,
								)
							}

							for (const item of items) {
								evaluateAsync(item, resolve, reject)
							}
						},
					}),
				},
			)

			/**
			 * Given a generator function, return the standard API object that executes
			 * the generator and calls the callbacks.
			 */
			function makeFunctionAPI(genFn) {
				const fns = {
					sync: function (...args) {
						return evaluateSync(genFn.apply(this, args))
					},
					async: function (...args) {
						return new Promise((resolve, reject) => {
							evaluateAsync(genFn.apply(this, args), resolve, reject)
						})
					},
					errback: function (...args) {
						const cb = args.pop()
						if (typeof cb !== 'function') {
							throw makeError(
								'Asynchronous function called without callback',
								GENSYNC_ERRBACK_NO_CALLBACK,
							)
						}

						let gen
						try {
							gen = genFn.apply(this, args)
						} catch (err) {
							cb(err)
							return
						}

						evaluateAsync(
							gen,
							(val) => cb(undefined, val),
							(err) => cb(err),
						)
					},
				}
				return fns
			}

			function assertTypeof(type, name, value, allowUndefined) {
				if (
					typeof value === type ||
					(allowUndefined && typeof value === 'undefined')
				) {
					return
				}

				let msg
				if (allowUndefined) {
					msg = `Expected opts.${name} to be either a ${type}, or undefined.`
				} else {
					msg = `Expected opts.${name} to be a ${type}.`
				}

				throw makeError(msg, GENSYNC_OPTIONS_ERROR)
			}
			function makeError(msg, code) {
				return Object.assign(new Error(msg), { code })
			}

			/**
			 * Given an options object, return a new generator that dispatches the
			 * correct handler based on sync or async execution.
			 */
			function newGenerator({ name, arity, sync, async, errback }) {
				assertTypeof('string', 'name', name, true /* allowUndefined */)
				assertTypeof('number', 'arity', arity, true /* allowUndefined */)
				assertTypeof('function', 'sync', sync)
				assertTypeof('function', 'async', async, true /* allowUndefined */)
				assertTypeof('function', 'errback', errback, true /* allowUndefined */)
				if (async && errback) {
					throw makeError(
						'Expected one of either opts.async or opts.errback, but got _both_.',
						GENSYNC_OPTIONS_ERROR,
					)
				}

				if (typeof name !== 'string') {
					let fnName
					if (errback && errback.name && errback.name !== 'errback') {
						fnName = errback.name
					}
					if (async && async.name && async.name !== 'async') {
						fnName = async.name.replace(/Async$/, '')
					}
					if (sync && sync.name && sync.name !== 'sync') {
						fnName = sync.name.replace(/Sync$/, '')
					}

					if (typeof fnName === 'string') {
						name = fnName
					}
				}

				if (typeof arity !== 'number') {
					arity = sync.length
				}

				return buildOperation({
					name,
					arity,
					sync: function (args) {
						return sync.apply(this, args)
					},
					async: function (args, resolve, reject) {
						if (async) {
							async.apply(this, args).then(resolve, reject)
						} else if (errback) {
							errback.call(this, ...args, (err, value) => {
								if (err == null) resolve(value)
								else reject(err)
							})
						} else {
							resolve(sync.apply(this, args))
						}
					},
				})
			}

			function wrapGenerator(genFn) {
				return setFunctionMetadata(
					genFn.name,
					genFn.length,
					function (...args) {
						return genFn.apply(this, args)
					},
				)
			}

			function buildOperation({ name, arity, sync, async }) {
				return setFunctionMetadata(name, arity, function* (...args) {
					const resume = yield GENSYNC_START
					if (!resume) {
						// Break the tail call to avoid a bug in V8 v6.X with --harmony enabled.
						const res = sync.call(this, args)
						return res
					}

					let result
					try {
						async.call(
							this,
							args,
							(value) => {
								if (result) return

								result = { value }
								resume()
							},
							(err) => {
								if (result) return

								result = { err }
								resume()
							},
						)
					} catch (err) {
						result = { err }
						resume()
					}

					// Suspend until the callbacks run. Will resume synchronously if the
					// callback was already called.
					yield GENSYNC_SUSPEND

					if (result.hasOwnProperty('err')) {
						throw result.err
					}

					return result.value
				})
			}

			function evaluateSync(gen) {
				let value
				while (!({ value } = gen.next()).done) {
					assertStart(value, gen)
				}
				return value
			}

			function evaluateAsync(gen, resolve, reject) {
				;(function step() {
					try {
						let value
						while (!({ value } = gen.next()).done) {
							assertStart(value, gen)

							// If this throws, it is considered to have broken the contract
							// established for async handlers. If these handlers are called
							// synchronously, it is also considered bad behavior.
							let sync = true
							let didSyncResume = false
							const out = gen.next(() => {
								if (sync) {
									didSyncResume = true
								} else {
									step()
								}
							})
							sync = false

							assertSuspend(out, gen)

							if (!didSyncResume) {
								// Callback wasn't called synchronously, so break out of the loop
								// and let it call 'step' later.
								return
							}
						}

						return resolve(value)
					} catch (err) {
						return reject(err)
					}
				})()
			}

			function assertStart(value, gen) {
				if (value === GENSYNC_START) return

				throwError(
					gen,
					makeError(
						`Got unexpected yielded value in gensync generator: ${JSON.stringify(
							value,
						)}. Did you perhaps mean to use 'yield*' instead of 'yield'?`,
						GENSYNC_EXPECTED_START,
					),
				)
			}
			function assertSuspend({ value, done }, gen) {
				if (!done && value === GENSYNC_SUSPEND) return

				throwError(
					gen,
					makeError(
						done
							? 'Unexpected generator completion. If you get this, it is probably a gensync bug.'
							: `Expected GENSYNC_SUSPEND, got ${JSON.stringify(
									value,
								)}. If you get this, it is probably a gensync bug.`,
						GENSYNC_EXPECTED_SUSPEND,
					),
				)
			}

			function throwError(gen, err) {
				// Call `.throw` so that users can step in a debugger to easily see which
				// 'yield' passed an unexpected value. If the `.throw` call didn't throw
				// back to the generator, we explicitly do it to stop the error
				// from being swallowed by user code try/catches.
				if (gen.throw) gen.throw(err)
				throw err
			}

			function isIterable(value) {
				return (
					!!value &&
					(typeof value === 'object' || typeof value === 'function') &&
					!value[Symbol.iterator]
				)
			}

			function setFunctionMetadata(name, arity, fn) {
				if (typeof name === 'string') {
					// This should always work on the supported Node versions, but for the
					// sake of users that are compiling to older versions, we check for
					// configurability so we don't throw.
					const nameDesc = Object.getOwnPropertyDescriptor(fn, 'name')
					if (!nameDesc || nameDesc.configurable) {
						Object.defineProperty(
							fn,
							'name',
							Object.assign(nameDesc || {}, {
								configurable: true,
								value: name,
							}),
						)
					}
				}

				if (typeof arity === 'number') {
					const lengthDesc = Object.getOwnPropertyDescriptor(fn, 'length')
					if (!lengthDesc || lengthDesc.configurable) {
						Object.defineProperty(
							fn,
							'length',
							Object.assign(lengthDesc || {}, {
								configurable: true,
								value: arity,
							}),
						)
					}
				}

				return fn
			}

			/***/
		},

		/***/ 21384: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			module.exports = __nccwpck_require__(14652)

			/***/
		},

		/***/ 73964: /***/ (module) => {
			'use strict'

			module.exports = clone

			var getPrototypeOf =
				Object.getPrototypeOf ||
				function (obj) {
					return obj.__proto__
				}

			function clone(obj) {
				if (obj === null || typeof obj !== 'object') return obj

				if (obj instanceof Object) var copy = { __proto__: getPrototypeOf(obj) }
				else var copy = Object.create(null)

				Object.getOwnPropertyNames(obj).forEach(function (key) {
					Object.defineProperty(
						copy,
						key,
						Object.getOwnPropertyDescriptor(obj, key),
					)
				})

				return copy
			}

			/***/
		},

		/***/ 35744: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var fs = __nccwpck_require__(79896)
			var polyfills = __nccwpck_require__(83501)
			var legacy = __nccwpck_require__(12270)
			var clone = __nccwpck_require__(73964)

			var util = __nccwpck_require__(39023)

			/* istanbul ignore next - node 0.x polyfill */
			var gracefulQueue
			var previousSymbol

			/* istanbul ignore else - node 0.x polyfill */
			if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
				gracefulQueue = Symbol.for('graceful-fs.queue')
				// This is used in testing by future versions
				previousSymbol = Symbol.for('graceful-fs.previous')
			} else {
				gracefulQueue = '___graceful-fs.queue'
				previousSymbol = '___graceful-fs.previous'
			}

			function noop() {}

			function publishQueue(context, queue) {
				Object.defineProperty(context, gracefulQueue, {
					get: function () {
						return queue
					},
				})
			}

			var debug = noop
			if (util.debuglog) debug = util.debuglog('gfs4')
			else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
				debug = function () {
					var m = util.format.apply(util, arguments)
					m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ')
					console.error(m)
				}

			// Once time initialization
			if (!fs[gracefulQueue]) {
				// This queue can be shared by multiple loaded instances
				var queue = global[gracefulQueue] || []
				publishQueue(fs, queue)

				// Patch fs.close/closeSync to shared queue version, because we need
				// to retry() whenever a close happens *anywhere* in the program.
				// This is essential when multiple graceful-fs instances are
				// in play at the same time.
				fs.close = (function (fs$close) {
					function close(fd, cb) {
						return fs$close.call(fs, fd, function (err) {
							// This function uses the graceful-fs shared queue
							if (!err) {
								resetQueue()
							}

							if (typeof cb === 'function') cb.apply(this, arguments)
						})
					}

					Object.defineProperty(close, previousSymbol, {
						value: fs$close,
					})
					return close
				})(fs.close)

				fs.closeSync = (function (fs$closeSync) {
					function closeSync(fd) {
						// This function uses the graceful-fs shared queue
						fs$closeSync.apply(fs, arguments)
						resetQueue()
					}

					Object.defineProperty(closeSync, previousSymbol, {
						value: fs$closeSync,
					})
					return closeSync
				})(fs.closeSync)

				if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
					process.on('exit', function () {
						debug(fs[gracefulQueue])
						__nccwpck_require__(42613).equal(fs[gracefulQueue].length, 0)
					})
				}
			}

			if (!global[gracefulQueue]) {
				publishQueue(global, fs[gracefulQueue])
			}

			module.exports = patch(clone(fs))
			if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
				module.exports = patch(fs)
				fs.__patched = true
			}

			function patch(fs) {
				// Everything that references the open() function needs to be in here
				polyfills(fs)
				fs.gracefulify = patch

				fs.createReadStream = createReadStream
				fs.createWriteStream = createWriteStream
				var fs$readFile = fs.readFile
				fs.readFile = readFile
				function readFile(path, options, cb) {
					if (typeof options === 'function') (cb = options), (options = null)

					return go$readFile(path, options, cb)

					function go$readFile(path, options, cb, startTime) {
						return fs$readFile(path, options, function (err) {
							if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
								enqueue([
									go$readFile,
									[path, options, cb],
									err,
									startTime || Date.now(),
									Date.now(),
								])
							else {
								if (typeof cb === 'function') cb.apply(this, arguments)
							}
						})
					}
				}

				var fs$writeFile = fs.writeFile
				fs.writeFile = writeFile
				function writeFile(path, data, options, cb) {
					if (typeof options === 'function') (cb = options), (options = null)

					return go$writeFile(path, data, options, cb)

					function go$writeFile(path, data, options, cb, startTime) {
						return fs$writeFile(path, data, options, function (err) {
							if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
								enqueue([
									go$writeFile,
									[path, data, options, cb],
									err,
									startTime || Date.now(),
									Date.now(),
								])
							else {
								if (typeof cb === 'function') cb.apply(this, arguments)
							}
						})
					}
				}

				var fs$appendFile = fs.appendFile
				if (fs$appendFile) fs.appendFile = appendFile
				function appendFile(path, data, options, cb) {
					if (typeof options === 'function') (cb = options), (options = null)

					return go$appendFile(path, data, options, cb)

					function go$appendFile(path, data, options, cb, startTime) {
						return fs$appendFile(path, data, options, function (err) {
							if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
								enqueue([
									go$appendFile,
									[path, data, options, cb],
									err,
									startTime || Date.now(),
									Date.now(),
								])
							else {
								if (typeof cb === 'function') cb.apply(this, arguments)
							}
						})
					}
				}

				var fs$copyFile = fs.copyFile
				if (fs$copyFile) fs.copyFile = copyFile
				function copyFile(src, dest, flags, cb) {
					if (typeof flags === 'function') {
						cb = flags
						flags = 0
					}
					return go$copyFile(src, dest, flags, cb)

					function go$copyFile(src, dest, flags, cb, startTime) {
						return fs$copyFile(src, dest, flags, function (err) {
							if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
								enqueue([
									go$copyFile,
									[src, dest, flags, cb],
									err,
									startTime || Date.now(),
									Date.now(),
								])
							else {
								if (typeof cb === 'function') cb.apply(this, arguments)
							}
						})
					}
				}

				var fs$readdir = fs.readdir
				fs.readdir = readdir
				var noReaddirOptionVersions = /^v[0-5]\./
				function readdir(path, options, cb) {
					if (typeof options === 'function') (cb = options), (options = null)

					var go$readdir = noReaddirOptionVersions.test(process.version)
						? function go$readdir(path, options, cb, startTime) {
								return fs$readdir(
									path,
									fs$readdirCallback(path, options, cb, startTime),
								)
							}
						: function go$readdir(path, options, cb, startTime) {
								return fs$readdir(
									path,
									options,
									fs$readdirCallback(path, options, cb, startTime),
								)
							}

					return go$readdir(path, options, cb)

					function fs$readdirCallback(path, options, cb, startTime) {
						return function (err, files) {
							if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
								enqueue([
									go$readdir,
									[path, options, cb],
									err,
									startTime || Date.now(),
									Date.now(),
								])
							else {
								if (files && files.sort) files.sort()

								if (typeof cb === 'function') cb.call(this, err, files)
							}
						}
					}
				}

				if (process.version.substr(0, 4) === 'v0.8') {
					var legStreams = legacy(fs)
					ReadStream = legStreams.ReadStream
					WriteStream = legStreams.WriteStream
				}

				var fs$ReadStream = fs.ReadStream
				if (fs$ReadStream) {
					ReadStream.prototype = Object.create(fs$ReadStream.prototype)
					ReadStream.prototype.open = ReadStream$open
				}

				var fs$WriteStream = fs.WriteStream
				if (fs$WriteStream) {
					WriteStream.prototype = Object.create(fs$WriteStream.prototype)
					WriteStream.prototype.open = WriteStream$open
				}

				Object.defineProperty(fs, 'ReadStream', {
					get: function () {
						return ReadStream
					},
					set: function (val) {
						ReadStream = val
					},
					enumerable: true,
					configurable: true,
				})
				Object.defineProperty(fs, 'WriteStream', {
					get: function () {
						return WriteStream
					},
					set: function (val) {
						WriteStream = val
					},
					enumerable: true,
					configurable: true,
				})

				// legacy names
				var FileReadStream = ReadStream
				Object.defineProperty(fs, 'FileReadStream', {
					get: function () {
						return FileReadStream
					},
					set: function (val) {
						FileReadStream = val
					},
					enumerable: true,
					configurable: true,
				})
				var FileWriteStream = WriteStream
				Object.defineProperty(fs, 'FileWriteStream', {
					get: function () {
						return FileWriteStream
					},
					set: function (val) {
						FileWriteStream = val
					},
					enumerable: true,
					configurable: true,
				})

				function ReadStream(path, options) {
					if (this instanceof ReadStream)
						return fs$ReadStream.apply(this, arguments), this
					else
						return ReadStream.apply(
							Object.create(ReadStream.prototype),
							arguments,
						)
				}

				function ReadStream$open() {
					var that = this
					open(that.path, that.flags, that.mode, function (err, fd) {
						if (err) {
							if (that.autoClose) that.destroy()

							that.emit('error', err)
						} else {
							that.fd = fd
							that.emit('open', fd)
							that.read()
						}
					})
				}

				function WriteStream(path, options) {
					if (this instanceof WriteStream)
						return fs$WriteStream.apply(this, arguments), this
					else
						return WriteStream.apply(
							Object.create(WriteStream.prototype),
							arguments,
						)
				}

				function WriteStream$open() {
					var that = this
					open(that.path, that.flags, that.mode, function (err, fd) {
						if (err) {
							that.destroy()
							that.emit('error', err)
						} else {
							that.fd = fd
							that.emit('open', fd)
						}
					})
				}

				function createReadStream(path, options) {
					return new fs.ReadStream(path, options)
				}

				function createWriteStream(path, options) {
					return new fs.WriteStream(path, options)
				}

				var fs$open = fs.open
				fs.open = open
				function open(path, flags, mode, cb) {
					if (typeof mode === 'function') (cb = mode), (mode = null)

					return go$open(path, flags, mode, cb)

					function go$open(path, flags, mode, cb, startTime) {
						return fs$open(path, flags, mode, function (err, fd) {
							if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
								enqueue([
									go$open,
									[path, flags, mode, cb],
									err,
									startTime || Date.now(),
									Date.now(),
								])
							else {
								if (typeof cb === 'function') cb.apply(this, arguments)
							}
						})
					}
				}

				return fs
			}

			function enqueue(elem) {
				debug('ENQUEUE', elem[0].name, elem[1])
				fs[gracefulQueue].push(elem)
				retry()
			}

			// keep track of the timeout between retry() calls
			var retryTimer

			// reset the startTime and lastTime to now
			// this resets the start of the 60 second overall timeout as well as the
			// delay between attempts so that we'll retry these jobs sooner
			function resetQueue() {
				var now = Date.now()
				for (var i = 0; i < fs[gracefulQueue].length; ++i) {
					// entries that are only a length of 2 are from an older version, don't
					// bother modifying those since they'll be retried anyway.
					if (fs[gracefulQueue][i].length > 2) {
						fs[gracefulQueue][i][3] = now // startTime
						fs[gracefulQueue][i][4] = now // lastTime
					}
				}
				// call retry to make sure we're actively processing the queue
				retry()
			}

			function retry() {
				// clear the timer and remove it to help prevent unintended concurrency
				clearTimeout(retryTimer)
				retryTimer = undefined

				if (fs[gracefulQueue].length === 0) return

				var elem = fs[gracefulQueue].shift()
				var fn = elem[0]
				var args = elem[1]
				// these items may be unset if they were added by an older graceful-fs
				var err = elem[2]
				var startTime = elem[3]
				var lastTime = elem[4]

				// if we don't have a startTime we have no way of knowing if we've waited
				// long enough, so go ahead and retry this item now
				if (startTime === undefined) {
					debug('RETRY', fn.name, args)
					fn.apply(null, args)
				} else if (Date.now() - startTime >= 60000) {
					// it's been more than 60 seconds total, bail now
					debug('TIMEOUT', fn.name, args)
					var cb = args.pop()
					if (typeof cb === 'function') cb.call(null, err)
				} else {
					// the amount of time between the last attempt and right now
					var sinceAttempt = Date.now() - lastTime
					// the amount of time between when we first tried, and when we last tried
					// rounded up to at least 1
					var sinceStart = Math.max(lastTime - startTime, 1)
					// backoff. wait longer than the total time we've been retrying, but only
					// up to a maximum of 100ms
					var desiredDelay = Math.min(sinceStart * 1.2, 100)
					// it's been long enough since the last retry, do it again
					if (sinceAttempt >= desiredDelay) {
						debug('RETRY', fn.name, args)
						fn.apply(null, args.concat([startTime]))
					} else {
						// if we can't do this job yet, push it to the end of the queue
						// and let the next iteration check again
						fs[gracefulQueue].push(elem)
					}
				}

				// schedule our next run if one isn't already scheduled
				if (retryTimer === undefined) {
					retryTimer = setTimeout(retry, 0)
				}
			}

			/***/
		},

		/***/ 12270: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var Stream = __nccwpck_require__(2203).Stream

			module.exports = legacy

			function legacy(fs) {
				return {
					ReadStream: ReadStream,
					WriteStream: WriteStream,
				}

				function ReadStream(path, options) {
					if (!(this instanceof ReadStream))
						return new ReadStream(path, options)

					Stream.call(this)

					var self = this

					this.path = path
					this.fd = null
					this.readable = true
					this.paused = false

					this.flags = 'r'
					this.mode = 438 /*=0666*/
					this.bufferSize = 64 * 1024

					options = options || {}

					// Mixin options into this
					var keys = Object.keys(options)
					for (var index = 0, length = keys.length; index < length; index++) {
						var key = keys[index]
						this[key] = options[key]
					}

					if (this.encoding) this.setEncoding(this.encoding)

					if (this.start !== undefined) {
						if ('number' !== typeof this.start) {
							throw TypeError('start must be a Number')
						}
						if (this.end === undefined) {
							this.end = Infinity
						} else if ('number' !== typeof this.end) {
							throw TypeError('end must be a Number')
						}

						if (this.start > this.end) {
							throw new Error('start must be <= end')
						}

						this.pos = this.start
					}

					if (this.fd !== null) {
						process.nextTick(function () {
							self._read()
						})
						return
					}

					fs.open(this.path, this.flags, this.mode, function (err, fd) {
						if (err) {
							self.emit('error', err)
							self.readable = false
							return
						}

						self.fd = fd
						self.emit('open', fd)
						self._read()
					})
				}

				function WriteStream(path, options) {
					if (!(this instanceof WriteStream))
						return new WriteStream(path, options)

					Stream.call(this)

					this.path = path
					this.fd = null
					this.writable = true

					this.flags = 'w'
					this.encoding = 'binary'
					this.mode = 438 /*=0666*/
					this.bytesWritten = 0

					options = options || {}

					// Mixin options into this
					var keys = Object.keys(options)
					for (var index = 0, length = keys.length; index < length; index++) {
						var key = keys[index]
						this[key] = options[key]
					}

					if (this.start !== undefined) {
						if ('number' !== typeof this.start) {
							throw TypeError('start must be a Number')
						}
						if (this.start < 0) {
							throw new Error('start must be >= zero')
						}

						this.pos = this.start
					}

					this.busy = false
					this._queue = []

					if (this.fd === null) {
						this._open = fs.open
						this._queue.push([
							this._open,
							this.path,
							this.flags,
							this.mode,
							undefined,
						])
						this.flush()
					}
				}
			}

			/***/
		},

		/***/ 83501: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var constants = __nccwpck_require__(49140)

			var origCwd = process.cwd
			var cwd = null

			var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform

			process.cwd = function () {
				if (!cwd) cwd = origCwd.call(process)
				return cwd
			}
			try {
				process.cwd()
			} catch (er) {}

			// This check is needed until node.js 12 is required
			if (typeof process.chdir === 'function') {
				var chdir = process.chdir
				process.chdir = function (d) {
					cwd = null
					chdir.call(process, d)
				}
				if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir)
			}

			module.exports = patch

			function patch(fs) {
				// (re-)implement some things that are known busted or missing.

				// lchmod, broken prior to 0.6.2
				// back-port the fix here.
				if (
					constants.hasOwnProperty('O_SYMLINK') &&
					process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)
				) {
					patchLchmod(fs)
				}

				// lutimes implementation, or no-op
				if (!fs.lutimes) {
					patchLutimes(fs)
				}

				// https://github.com/isaacs/node-graceful-fs/issues/4
				// Chown should not fail on einval or eperm if non-root.
				// It should not fail on enosys ever, as this just indicates
				// that a fs doesn't support the intended operation.

				fs.chown = chownFix(fs.chown)
				fs.fchown = chownFix(fs.fchown)
				fs.lchown = chownFix(fs.lchown)

				fs.chmod = chmodFix(fs.chmod)
				fs.fchmod = chmodFix(fs.fchmod)
				fs.lchmod = chmodFix(fs.lchmod)

				fs.chownSync = chownFixSync(fs.chownSync)
				fs.fchownSync = chownFixSync(fs.fchownSync)
				fs.lchownSync = chownFixSync(fs.lchownSync)

				fs.chmodSync = chmodFixSync(fs.chmodSync)
				fs.fchmodSync = chmodFixSync(fs.fchmodSync)
				fs.lchmodSync = chmodFixSync(fs.lchmodSync)

				fs.stat = statFix(fs.stat)
				fs.fstat = statFix(fs.fstat)
				fs.lstat = statFix(fs.lstat)

				fs.statSync = statFixSync(fs.statSync)
				fs.fstatSync = statFixSync(fs.fstatSync)
				fs.lstatSync = statFixSync(fs.lstatSync)

				// if lchmod/lchown do not exist, then make them no-ops
				if (fs.chmod && !fs.lchmod) {
					fs.lchmod = function (path, mode, cb) {
						if (cb) process.nextTick(cb)
					}
					fs.lchmodSync = function () {}
				}
				if (fs.chown && !fs.lchown) {
					fs.lchown = function (path, uid, gid, cb) {
						if (cb) process.nextTick(cb)
					}
					fs.lchownSync = function () {}
				}

				// on Windows, A/V software can lock the directory, causing this
				// to fail with an EACCES or EPERM if the directory contains newly
				// created files.  Try again on failure, for up to 60 seconds.

				// Set the timeout this long because some Windows Anti-Virus, such as Parity
				// bit9, may lock files for up to a minute, causing npm package install
				// failures. Also, take care to yield the scheduler. Windows scheduling gives
				// CPU to a busy looping process, which can cause the program causing the lock
				// contention to be starved of CPU by node, so the contention doesn't resolve.
				if (platform === 'win32') {
					fs.rename =
						typeof fs.rename !== 'function'
							? fs.rename
							: (function (fs$rename) {
									function rename(from, to, cb) {
										var start = Date.now()
										var backoff = 0
										fs$rename(from, to, function CB(er) {
											if (
												er &&
												(er.code === 'EACCES' ||
													er.code === 'EPERM' ||
													er.code === 'EBUSY') &&
												Date.now() - start < 60000
											) {
												setTimeout(function () {
													fs.stat(to, function (stater, st) {
														if (stater && stater.code === 'ENOENT')
															fs$rename(from, to, CB)
														else cb(er)
													})
												}, backoff)
												if (backoff < 100) backoff += 10
												return
											}
											if (cb) cb(er)
										})
									}
									if (Object.setPrototypeOf)
										Object.setPrototypeOf(rename, fs$rename)
									return rename
								})(fs.rename)
				}

				// if read() returns EAGAIN, then just try it again.
				fs.read =
					typeof fs.read !== 'function'
						? fs.read
						: (function (fs$read) {
								function read(fd, buffer, offset, length, position, callback_) {
									var callback
									if (callback_ && typeof callback_ === 'function') {
										var eagCounter = 0
										callback = function (er, _, __) {
											if (er && er.code === 'EAGAIN' && eagCounter < 10) {
												eagCounter++
												return fs$read.call(
													fs,
													fd,
													buffer,
													offset,
													length,
													position,
													callback,
												)
											}
											callback_.apply(this, arguments)
										}
									}
									return fs$read.call(
										fs,
										fd,
										buffer,
										offset,
										length,
										position,
										callback,
									)
								}

								// This ensures `util.promisify` works as it does for native `fs.read`.
								if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read)
								return read
							})(fs.read)

				fs.readSync =
					typeof fs.readSync !== 'function'
						? fs.readSync
						: (function (fs$readSync) {
								return function (fd, buffer, offset, length, position) {
									var eagCounter = 0
									while (true) {
										try {
											return fs$readSync.call(
												fs,
												fd,
												buffer,
												offset,
												length,
												position,
											)
										} catch (er) {
											if (er.code === 'EAGAIN' && eagCounter < 10) {
												eagCounter++
												continue
											}
											throw er
										}
									}
								}
							})(fs.readSync)

				function patchLchmod(fs) {
					fs.lchmod = function (path, mode, callback) {
						fs.open(
							path,
							constants.O_WRONLY | constants.O_SYMLINK,
							mode,
							function (err, fd) {
								if (err) {
									if (callback) callback(err)
									return
								}
								// prefer to return the chmod error, if one occurs,
								// but still try to close, and report closing errors if they occur.
								fs.fchmod(fd, mode, function (err) {
									fs.close(fd, function (err2) {
										if (callback) callback(err || err2)
									})
								})
							},
						)
					}

					fs.lchmodSync = function (path, mode) {
						var fd = fs.openSync(
							path,
							constants.O_WRONLY | constants.O_SYMLINK,
							mode,
						)

						// prefer to return the chmod error, if one occurs,
						// but still try to close, and report closing errors if they occur.
						var threw = true
						var ret
						try {
							ret = fs.fchmodSync(fd, mode)
							threw = false
						} finally {
							if (threw) {
								try {
									fs.closeSync(fd)
								} catch (er) {}
							} else {
								fs.closeSync(fd)
							}
						}
						return ret
					}
				}

				function patchLutimes(fs) {
					if (constants.hasOwnProperty('O_SYMLINK') && fs.futimes) {
						fs.lutimes = function (path, at, mt, cb) {
							fs.open(path, constants.O_SYMLINK, function (er, fd) {
								if (er) {
									if (cb) cb(er)
									return
								}
								fs.futimes(fd, at, mt, function (er) {
									fs.close(fd, function (er2) {
										if (cb) cb(er || er2)
									})
								})
							})
						}

						fs.lutimesSync = function (path, at, mt) {
							var fd = fs.openSync(path, constants.O_SYMLINK)
							var ret
							var threw = true
							try {
								ret = fs.futimesSync(fd, at, mt)
								threw = false
							} finally {
								if (threw) {
									try {
										fs.closeSync(fd)
									} catch (er) {}
								} else {
									fs.closeSync(fd)
								}
							}
							return ret
						}
					} else if (fs.futimes) {
						fs.lutimes = function (_a, _b, _c, cb) {
							if (cb) process.nextTick(cb)
						}
						fs.lutimesSync = function () {}
					}
				}

				function chmodFix(orig) {
					if (!orig) return orig
					return function (target, mode, cb) {
						return orig.call(fs, target, mode, function (er) {
							if (chownErOk(er)) er = null
							if (cb) cb.apply(this, arguments)
						})
					}
				}

				function chmodFixSync(orig) {
					if (!orig) return orig
					return function (target, mode) {
						try {
							return orig.call(fs, target, mode)
						} catch (er) {
							if (!chownErOk(er)) throw er
						}
					}
				}

				function chownFix(orig) {
					if (!orig) return orig
					return function (target, uid, gid, cb) {
						return orig.call(fs, target, uid, gid, function (er) {
							if (chownErOk(er)) er = null
							if (cb) cb.apply(this, arguments)
						})
					}
				}

				function chownFixSync(orig) {
					if (!orig) return orig
					return function (target, uid, gid) {
						try {
							return orig.call(fs, target, uid, gid)
						} catch (er) {
							if (!chownErOk(er)) throw er
						}
					}
				}

				function statFix(orig) {
					if (!orig) return orig
					// Older versions of Node erroneously returned signed integers for
					// uid + gid.
					return function (target, options, cb) {
						if (typeof options === 'function') {
							cb = options
							options = null
						}
						function callback(er, stats) {
							if (stats) {
								if (stats.uid < 0) stats.uid += 0x100000000
								if (stats.gid < 0) stats.gid += 0x100000000
							}
							if (cb) cb.apply(this, arguments)
						}
						return options
							? orig.call(fs, target, options, callback)
							: orig.call(fs, target, callback)
					}
				}

				function statFixSync(orig) {
					if (!orig) return orig
					// Older versions of Node erroneously returned signed integers for
					// uid + gid.
					return function (target, options) {
						var stats = options
							? orig.call(fs, target, options)
							: orig.call(fs, target)
						if (stats) {
							if (stats.uid < 0) stats.uid += 0x100000000
							if (stats.gid < 0) stats.gid += 0x100000000
						}
						return stats
					}
				}

				// ENOSYS means that the fs doesn't support the op. Just ignore
				// that, because it doesn't matter.
				//
				// if there's no getuid, or if getuid() is something other
				// than 0, and the error is EINVAL or EPERM, then just ignore
				// it.
				//
				// This specific case is a silent failure in cp, install, tar,
				// and most other unix tools that manage permissions.
				//
				// When running as root, or if other types of errors are
				// encountered, then it's strict.
				function chownErOk(er) {
					if (!er) return true

					if (er.code === 'ENOSYS') return true

					var nonroot = !process.getuid || process.getuid() !== 0
					if (nonroot) {
						if (er.code === 'EINVAL' || er.code === 'EPERM') return true
					}

					return false
				}
			}

			/***/
		},

		/***/ 19599: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const fs = __nccwpck_require__(79896)
			const sections = __nccwpck_require__(89495)
			const defaults = __nccwpck_require__(27545)
			const stringify = __nccwpck_require__(34710)
			const excerpt = __nccwpck_require__(77894)
			const engines = __nccwpck_require__(74452)
			const toFile = __nccwpck_require__(48073)
			const parse = __nccwpck_require__(88120)
			const utils = __nccwpck_require__(58698)

			/**
			 * Takes a string or object with `content` property, extracts
			 * and parses front-matter from the string, then returns an object
			 * with `data`, `content` and other [useful properties](#returned-object).
			 *
			 * ```js
			 * const matter = require('gray-matter');
			 * console.log(matter('---\ntitle: Home\n---\nOther stuff'));
			 * //=> { data: { title: 'Home'}, content: 'Other stuff' }
			 * ```
			 * @param {Object|String} `input` String, or object with `content` string
			 * @param {Object} `options`
			 * @return {Object}
			 * @api public
			 */

			function matter(input, options) {
				if (input === '') {
					return { data: {}, content: input, excerpt: '', orig: input }
				}

				let file = toFile(input)
				const cached = matter.cache[file.content]

				if (!options) {
					if (cached) {
						file = Object.assign({}, cached)
						file.orig = cached.orig
						return file
					}

					// only cache if there are no options passed. if we cache when options
					// are passed, we would need to also cache options values, which would
					// negate any performance benefits of caching
					matter.cache[file.content] = file
				}

				return parseMatter(file, options)
			}

			/**
			 * Parse front matter
			 */

			function parseMatter(file, options) {
				const opts = defaults(options)
				const open = opts.delimiters[0]
				const close = '\n' + opts.delimiters[1]
				let str = file.content

				if (opts.language) {
					file.language = opts.language
				}

				// get the length of the opening delimiter
				const openLen = open.length
				if (!utils.startsWith(str, open, openLen)) {
					excerpt(file, opts)
					return file
				}

				// if the next character after the opening delimiter is
				// a character from the delimiter, then it's not a front-
				// matter delimiter
				if (str.charAt(openLen) === open.slice(-1)) {
					return file
				}

				// strip the opening delimiter
				str = str.slice(openLen)
				const len = str.length

				// use the language defined after first delimiter, if it exists
				const language = matter.language(str, opts)
				if (language.name) {
					file.language = language.name
					str = str.slice(language.raw.length)
				}

				// get the index of the closing delimiter
				let closeIndex = str.indexOf(close)
				if (closeIndex === -1) {
					closeIndex = len
				}

				// get the raw front-matter block
				file.matter = str.slice(0, closeIndex)

				const block = file.matter.replace(/^\s*#[^\n]+/gm, '').trim()
				if (block === '') {
					file.isEmpty = true
					file.empty = file.content
					file.data = {}
				} else {
					// create file.data by parsing the raw file.matter block
					file.data = parse(file.language, file.matter, opts)
				}

				// update file.content
				if (closeIndex === len) {
					file.content = ''
				} else {
					file.content = str.slice(closeIndex + close.length)
					if (file.content[0] === '\r') {
						file.content = file.content.slice(1)
					}
					if (file.content[0] === '\n') {
						file.content = file.content.slice(1)
					}
				}

				excerpt(file, opts)

				if (opts.sections === true || typeof opts.section === 'function') {
					sections(file, opts.section)
				}
				return file
			}

			/**
			 * Expose engines
			 */

			matter.engines = engines

			/**
			 * Stringify an object to YAML or the specified language, and
			 * append it to the given string. By default, only YAML and JSON
			 * can be stringified. See the [engines](#engines) section to learn
			 * how to stringify other languages.
			 *
			 * ```js
			 * console.log(matter.stringify('foo bar baz', {title: 'Home'}));
			 * // results in:
			 * // ---
			 * // title: Home
			 * // ---
			 * // foo bar baz
			 * ```
			 * @param {String|Object} `file` The content string to append to stringified front-matter, or a file object with `file.content` string.
			 * @param {Object} `data` Front matter to stringify.
			 * @param {Object} `options` [Options](#options) to pass to gray-matter and [js-yaml].
			 * @return {String} Returns a string created by wrapping stringified yaml with delimiters, and appending that to the given string.
			 * @api public
			 */

			matter.stringify = function (file, data, options) {
				if (typeof file === 'string') file = matter(file, options)
				return stringify(file, data, options)
			}

			/**
			 * Synchronously read a file from the file system and parse
			 * front matter. Returns the same object as the [main function](#matter).
			 *
			 * ```js
			 * const file = matter.read('./content/blog-post.md');
			 * ```
			 * @param {String} `filepath` file path of the file to read.
			 * @param {Object} `options` [Options](#options) to pass to gray-matter.
			 * @return {Object} Returns [an object](#returned-object) with `data` and `content`
			 * @api public
			 */

			matter.read = function (filepath, options) {
				const str = fs.readFileSync(filepath, 'utf8')
				const file = matter(str, options)
				file.path = filepath
				return file
			}

			/**
			 * Returns true if the given `string` has front matter.
			 * @param  {String} `string`
			 * @param  {Object} `options`
			 * @return {Boolean} True if front matter exists.
			 * @api public
			 */

			matter.test = function (str, options) {
				return utils.startsWith(str, defaults(options).delimiters[0])
			}

			/**
			 * Detect the language to use, if one is defined after the
			 * first front-matter delimiter.
			 * @param  {String} `string`
			 * @param  {Object} `options`
			 * @return {Object} Object with `raw` (actual language string), and `name`, the language with whitespace trimmed
			 */

			matter.language = function (str, options) {
				const opts = defaults(options)
				const open = opts.delimiters[0]

				if (matter.test(str)) {
					str = str.slice(open.length)
				}

				const language = str.slice(0, str.search(/\r?\n/))
				return {
					raw: language,
					name: language ? language.trim() : '',
				}
			}

			/**
			 * Expose `matter`
			 */

			matter.cache = {}
			matter.clearCache = function () {
				matter.cache = {}
			}
			module.exports = matter

			/***/
		},

		/***/ 27545: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const engines = __nccwpck_require__(74452)
			const utils = __nccwpck_require__(58698)

			module.exports = function (options) {
				const opts = Object.assign({}, options)

				// ensure that delimiters are an array
				opts.delimiters = utils.arrayify(
					opts.delims || opts.delimiters || '---',
				)
				if (opts.delimiters.length === 1) {
					opts.delimiters.push(opts.delimiters[0])
				}

				opts.language = (opts.language || opts.lang || 'yaml').toLowerCase()
				opts.engines = Object.assign({}, engines, opts.parsers, opts.engines)
				return opts
			}

			/***/
		},

		/***/ 5921: /***/ (module) => {
			'use strict'

			module.exports = function (name, options) {
				let engine = options.engines[name] || options.engines[aliase(name)]
				if (typeof engine === 'undefined') {
					throw new Error('gray-matter engine "' + name + '" is not registered')
				}
				if (typeof engine === 'function') {
					engine = { parse: engine }
				}
				return engine
			}

			function aliase(name) {
				switch (name.toLowerCase()) {
					case 'js':
					case 'javascript':
						return 'javascript'
					case 'coffee':
					case 'coffeescript':
					case 'cson':
						return 'coffee'
					case 'yaml':
					case 'yml':
						return 'yaml'
					default: {
						return name
					}
				}
			}

			/***/
		},

		/***/ 74452: /***/ (module, exports, __nccwpck_require__) => {
			'use strict'

			const yaml = __nccwpck_require__(74281)

			/**
			 * Default engines
			 */

			const engines = (exports = module.exports)

			/**
			 * YAML
			 */

			engines.yaml = {
				parse: yaml.safeLoad.bind(yaml),
				stringify: yaml.safeDump.bind(yaml),
			}

			/**
			 * JSON
			 */

			engines.json = {
				parse: JSON.parse.bind(JSON),
				stringify: function (obj, options) {
					const opts = Object.assign({ replacer: null, space: 2 }, options)
					return JSON.stringify(obj, opts.replacer, opts.space)
				},
			}

			/**
			 * JavaScript
			 */

			engines.javascript = {
				parse: function parse(str, options, wrap) {
					/* eslint no-eval: 0 */
					try {
						if (wrap !== false) {
							str = '(function() {\nreturn ' + str.trim() + ';\n}());'
						}
						return eval(str) || {}
					} catch (err) {
						if (
							wrap !== false &&
							/(unexpected|identifier)/i.test(err.message)
						) {
							return parse(str, options, false)
						}
						throw new SyntaxError(err)
					}
				},
				stringify: function () {
					throw new Error('stringifying JavaScript is not supported')
				},
			}

			/***/
		},

		/***/ 77894: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const defaults = __nccwpck_require__(27545)

			module.exports = function (file, options) {
				const opts = defaults(options)

				if (file.data == null) {
					file.data = {}
				}

				if (typeof opts.excerpt === 'function') {
					return opts.excerpt(file, opts)
				}

				const sep = file.data.excerpt_separator || opts.excerpt_separator
				if (sep == null && (opts.excerpt === false || opts.excerpt == null)) {
					return file
				}

				const delimiter =
					typeof opts.excerpt === 'string'
						? opts.excerpt
						: sep || opts.delimiters[0]

				// if enabled, get the excerpt defined after front-matter
				const idx = file.content.indexOf(delimiter)
				if (idx !== -1) {
					file.excerpt = file.content.slice(0, idx)
				}

				return file
			}

			/***/
		},

		/***/ 88120: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const getEngine = __nccwpck_require__(5921)
			const defaults = __nccwpck_require__(27545)

			module.exports = function (language, str, options) {
				const opts = defaults(options)
				const engine = getEngine(language, opts)
				if (typeof engine.parse !== 'function') {
					throw new TypeError(
						'expected "' + language + '.parse" to be a function',
					)
				}
				return engine.parse(str, opts)
			}

			/***/
		},

		/***/ 34710: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const typeOf = __nccwpck_require__(5140)
			const getEngine = __nccwpck_require__(5921)
			const defaults = __nccwpck_require__(27545)

			module.exports = function (file, data, options) {
				if (data == null && options == null) {
					switch (typeOf(file)) {
						case 'object':
							data = file.data
							options = {}
							break
						case 'string':
							return file
						default: {
							throw new TypeError('expected file to be a string or object')
						}
					}
				}

				const str = file.content
				const opts = defaults(options)
				if (data == null) {
					if (!opts.data) return file
					data = opts.data
				}

				const language = file.language || opts.language
				const engine = getEngine(language, opts)
				if (typeof engine.stringify !== 'function') {
					throw new TypeError(
						'expected "' + language + '.stringify" to be a function',
					)
				}

				data = Object.assign({}, file.data, data)
				const open = opts.delimiters[0]
				const close = opts.delimiters[1]
				const matter = engine.stringify(data, options).trim()
				let buf = ''

				if (matter !== '{}') {
					buf = newline(open) + newline(matter) + newline(close)
				}

				if (typeof file.excerpt === 'string' && file.excerpt !== '') {
					if (str.indexOf(file.excerpt.trim()) === -1) {
						buf += newline(file.excerpt) + newline(close)
					}
				}

				return buf + newline(str)
			}

			function newline(str) {
				return str.slice(-1) !== '\n' ? str + '\n' : str
			}

			/***/
		},

		/***/ 48073: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const typeOf = __nccwpck_require__(5140)
			const stringify = __nccwpck_require__(34710)
			const utils = __nccwpck_require__(58698)

			/**
			 * Normalize the given value to ensure an object is returned
			 * with the expected properties.
			 */

			module.exports = function (file) {
				if (typeOf(file) !== 'object') {
					file = { content: file }
				}

				if (typeOf(file.data) !== 'object') {
					file.data = {}
				}

				// if file was passed as an object, ensure that
				// "file.content" is set
				if (file.contents && file.content == null) {
					file.content = file.contents
				}

				// set non-enumerable properties on the file object
				utils.define(file, 'orig', utils.toBuffer(file.content))
				utils.define(file, 'language', file.language || '')
				utils.define(file, 'matter', file.matter || '')
				utils.define(file, 'stringify', function (data, options) {
					if (options && options.language) {
						file.language = options.language
					}
					return stringify(file, data, options)
				})

				// strip BOM and ensure that "file.content" is a string
				file.content = utils.toString(file.content)
				file.isEmpty = false
				file.excerpt = ''
				return file
			}

			/***/
		},

		/***/ 58698: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const stripBom = __nccwpck_require__(91389)
			const typeOf = __nccwpck_require__(5140)

			exports.define = function (obj, key, val) {
				Reflect.defineProperty(obj, key, {
					enumerable: false,
					configurable: true,
					writable: true,
					value: val,
				})
			}

			/**
			 * Returns true if `val` is a buffer
			 */

			exports.isBuffer = function (val) {
				return typeOf(val) === 'buffer'
			}

			/**
			 * Returns true if `val` is an object
			 */

			exports.isObject = function (val) {
				return typeOf(val) === 'object'
			}

			/**
			 * Cast `input` to a buffer
			 */

			exports.toBuffer = function (input) {
				return typeof input === 'string' ? Buffer.from(input) : input
			}

			/**
			 * Cast `val` to a string.
			 */

			exports.toString = function (input) {
				if (exports.isBuffer(input)) return stripBom(String(input))
				if (typeof input !== 'string') {
					throw new TypeError('expected input to be a string or buffer')
				}
				return stripBom(input)
			}

			/**
			 * Cast `val` to an array.
			 */

			exports.arrayify = function (val) {
				return val ? (Array.isArray(val) ? val : [val]) : []
			}

			/**
			 * Returns true if `str` starts with `substr`.
			 */

			exports.startsWith = function (str, substr, len) {
				if (typeof len !== 'number') len = substr.length
				return str.slice(0, len) === substr
			}

			/***/
		},

		/***/ 54076: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var call = Function.prototype.call
			var $hasOwn = Object.prototype.hasOwnProperty
			var bind = __nccwpck_require__(37564)

			/** @type {import('.')} */
			module.exports = bind.call(call, $hasOwn)

			/***/
		},

		/***/ 39598: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			try {
				var util = __nccwpck_require__(39023)
				/* istanbul ignore next */
				if (typeof util.inherits !== 'function') throw ''
				module.exports = util.inherits
			} catch (e) {
				/* istanbul ignore next */
				module.exports = __nccwpck_require__(26589)
			}

			/***/
		},

		/***/ 26589: /***/ (module) => {
			if (typeof Object.create === 'function') {
				// implementation from standard node.js 'util' module
				module.exports = function inherits(ctor, superCtor) {
					if (superCtor) {
						ctor.super_ = superCtor
						ctor.prototype = Object.create(superCtor.prototype, {
							constructor: {
								value: ctor,
								enumerable: false,
								writable: true,
								configurable: true,
							},
						})
					}
				}
			} else {
				// old school shim for old browsers
				module.exports = function inherits(ctor, superCtor) {
					if (superCtor) {
						ctor.super_ = superCtor
						var TempCtor = function () {}
						TempCtor.prototype = superCtor.prototype
						ctor.prototype = new TempCtor()
						ctor.prototype.constructor = ctor
					}
				}
			}

			/***/
		},

		/***/ 59201: /***/ (module) => {
			'use strict'

			module.exports = alphabetical

			// Check if the given character code, or the character code at the first
			// character, is alphabetical.
			function alphabetical(character) {
				var code =
					typeof character === 'string' ? character.charCodeAt(0) : character

				return (
					(code >= 97 && code <= 122) /* a-z */ ||
					(code >= 65 && code <= 90) /* A-Z */
				)
			}

			/***/
		},

		/***/ 99624: /***/ (module) => {
			'use strict'

			module.exports = function (str) {
				if (typeof str !== 'string') {
					throw new TypeError('Expected a string')
				}

				return !/[^0-9a-z\xDF-\xFF]/.test(str.toLowerCase())
			}

			/***/
		},

		/***/ 51685: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var alphabetical = __nccwpck_require__(59201)
			var decimal = __nccwpck_require__(96734)

			module.exports = alphanumerical

			// Check if the given character code, or the character code at the first
			// character, is alphanumerical.
			function alphanumerical(character) {
				return alphabetical(character) || decimal(character)
			}

			/***/
		},

		/***/ 65223: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var hasOwn = __nccwpck_require__(54076)

			function specifierIncluded(current, specifier) {
				var nodeParts = current.split('.')
				var parts = specifier.split(' ')
				var op = parts.length > 1 ? parts[0] : '='
				var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split('.')

				for (var i = 0; i < 3; ++i) {
					var cur = parseInt(nodeParts[i] || 0, 10)
					var ver = parseInt(versionParts[i] || 0, 10)
					if (cur === ver) {
						continue // eslint-disable-line no-restricted-syntax, no-continue
					}
					if (op === '<') {
						return cur < ver
					}
					if (op === '>=') {
						return cur >= ver
					}
					return false
				}
				return op === '>='
			}

			function matchesRange(current, range) {
				var specifiers = range.split(/ ?&& ?/)
				if (specifiers.length === 0) {
					return false
				}
				for (var i = 0; i < specifiers.length; ++i) {
					if (!specifierIncluded(current, specifiers[i])) {
						return false
					}
				}
				return true
			}

			function versionIncluded(nodeVersion, specifierValue) {
				if (typeof specifierValue === 'boolean') {
					return specifierValue
				}

				var current =
					typeof nodeVersion === 'undefined'
						? process.versions && process.versions.node
						: nodeVersion

				if (typeof current !== 'string') {
					throw new TypeError(
						typeof nodeVersion === 'undefined'
							? 'Unable to determine current node version'
							: 'If provided, a valid node version is required',
					)
				}

				if (specifierValue && typeof specifierValue === 'object') {
					for (var i = 0; i < specifierValue.length; ++i) {
						if (matchesRange(current, specifierValue[i])) {
							return true
						}
					}
					return false
				}
				return matchesRange(current, specifierValue)
			}

			var data = __nccwpck_require__(17324)

			module.exports = function isCore(x, nodeVersion) {
				return hasOwn(data, x) && versionIncluded(nodeVersion, data[x])
			}

			/***/
		},

		/***/ 96734: /***/ (module) => {
			'use strict'

			module.exports = decimal

			// Check if the given character code, or the character code at the first
			// character, is decimal.
			function decimal(character) {
				var code =
					typeof character === 'string' ? character.charCodeAt(0) : character

				return code >= 48 && code <= 57 /* 0-9 */
			}

			/***/
		},

		/***/ 36403: /***/ (module) => {
			'use strict'
			/*!
			 * is-extendable <https://github.com/jonschlinkert/is-extendable>
			 *
			 * Copyright (c) 2015, Jon Schlinkert.
			 * Licensed under the MIT License.
			 */

			module.exports = function isExtendable(val) {
				return (
					typeof val !== 'undefined' &&
					val !== null &&
					(typeof val === 'object' || typeof val === 'function')
				)
			}

			/***/
		},

		/***/ 84794: /***/ (module) => {
			'use strict'

			module.exports = hexadecimal

			// Check if the given character code, or the character code at the first
			// character, is hexadecimal.
			function hexadecimal(character) {
				var code =
					typeof character === 'string' ? character.charCodeAt(0) : character

				return (
					(code >= 97 /* a */ && code <= 102) /* z */ ||
					(code >= 65 /* A */ && code <= 70) /* Z */ ||
					(code >= 48 /* A */ && code <= 57) /* Z */
				)
			}

			/***/
		},

		/***/ 96472: /***/ (module) => {
			'use strict'

			module.exports = whitespace

			var fromCode = String.fromCharCode
			var re = /\s/

			// Check if the given character code, or the character code at the first
			// character, is a whitespace character.
			function whitespace(character) {
				return re.test(
					typeof character === 'number'
						? fromCode(character)
						: character.charAt(0),
				)
			}

			/***/
		},

		/***/ 70009: /***/ (module) => {
			'use strict'

			module.exports = wordCharacter

			var fromCode = String.fromCharCode
			var re = /\w/

			// Check if the given character code, or the character code at the first
			// character, is a word character.
			function wordCharacter(character) {
				return re.test(
					typeof character === 'number'
						? fromCode(character)
						: character.charAt(0),
				)
			}

			/***/
		},

		/***/ 85756: /***/ (__unused_webpack_module, exports) => {
			// Copyright 2014, 2015, 2016, 2017, 2018 Simon Lydell
			// License: MIT. (See LICENSE.)

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})

			// This regex comes from regex.coffee, and is inserted here by generate-index.js
			// (run `npm run build`).
			exports['default'] =
				/((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g

			exports.matchToToken = function (match) {
				var token = { type: 'invalid', value: match[0], closed: undefined }
				if (match[1])
					(token.type = 'string'), (token.closed = !!(match[3] || match[4]))
				else if (match[5]) token.type = 'comment'
				else if (match[6]) (token.type = 'comment'), (token.closed = !!match[7])
				else if (match[8]) token.type = 'regex'
				else if (match[9]) token.type = 'number'
				else if (match[10]) token.type = 'name'
				else if (match[11]) token.type = 'punctuator'
				else if (match[12]) token.type = 'whitespace'
				return token
			}

			/***/
		},

		/***/ 74281: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var yaml = __nccwpck_require__(24040)

			module.exports = yaml

			/***/
		},

		/***/ 24040: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var loader = __nccwpck_require__(75868)
			var dumper = __nccwpck_require__(45078)

			function deprecated(name) {
				return function () {
					throw new Error(
						'Function ' + name + ' is deprecated and cannot be used.',
					)
				}
			}

			module.exports.Type = __nccwpck_require__(50323)
			module.exports.Schema = __nccwpck_require__(45868)
			module.exports.FAILSAFE_SCHEMA = __nccwpck_require__(86810)
			module.exports.JSON_SCHEMA = __nccwpck_require__(96613)
			module.exports.CORE_SCHEMA = __nccwpck_require__(55116)
			module.exports.DEFAULT_SAFE_SCHEMA = __nccwpck_require__(76032)
			module.exports.DEFAULT_FULL_SCHEMA = __nccwpck_require__(60948)
			module.exports.load = loader.load
			module.exports.loadAll = loader.loadAll
			module.exports.safeLoad = loader.safeLoad
			module.exports.safeLoadAll = loader.safeLoadAll
			module.exports.dump = dumper.dump
			module.exports.safeDump = dumper.safeDump
			module.exports.YAMLException = __nccwpck_require__(15622)

			// Deprecated schema names from JS-YAML 2.0.x
			module.exports.MINIMAL_SCHEMA = __nccwpck_require__(86810)
			module.exports.SAFE_SCHEMA = __nccwpck_require__(76032)
			module.exports.DEFAULT_SCHEMA = __nccwpck_require__(60948)

			// Deprecated functions from JS-YAML 1.x.x
			module.exports.scan = deprecated('scan')
			module.exports.parse = deprecated('parse')
			module.exports.compose = deprecated('compose')
			module.exports.addConstructor = deprecated('addConstructor')

			/***/
		},

		/***/ 24206: /***/ (module) => {
			'use strict'

			function isNothing(subject) {
				return typeof subject === 'undefined' || subject === null
			}

			function isObject(subject) {
				return typeof subject === 'object' && subject !== null
			}

			function toArray(sequence) {
				if (Array.isArray(sequence)) return sequence
				else if (isNothing(sequence)) return []

				return [sequence]
			}

			function extend(target, source) {
				var index, length, key, sourceKeys

				if (source) {
					sourceKeys = Object.keys(source)

					for (
						index = 0, length = sourceKeys.length;
						index < length;
						index += 1
					) {
						key = sourceKeys[index]
						target[key] = source[key]
					}
				}

				return target
			}

			function repeat(string, count) {
				var result = '',
					cycle

				for (cycle = 0; cycle < count; cycle += 1) {
					result += string
				}

				return result
			}

			function isNegativeZero(number) {
				return number === 0 && Number.NEGATIVE_INFINITY === 1 / number
			}

			module.exports.isNothing = isNothing
			module.exports.isObject = isObject
			module.exports.toArray = toArray
			module.exports.repeat = repeat
			module.exports.isNegativeZero = isNegativeZero
			module.exports.extend = extend

			/***/
		},

		/***/ 45078: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			/*eslint-disable no-use-before-define*/

			var common = __nccwpck_require__(24206)
			var YAMLException = __nccwpck_require__(15622)
			var DEFAULT_FULL_SCHEMA = __nccwpck_require__(60948)
			var DEFAULT_SAFE_SCHEMA = __nccwpck_require__(76032)

			var _toString = Object.prototype.toString
			var _hasOwnProperty = Object.prototype.hasOwnProperty

			var CHAR_TAB = 0x09 /* Tab */
			var CHAR_LINE_FEED = 0x0a /* LF */
			var CHAR_CARRIAGE_RETURN = 0x0d /* CR */
			var CHAR_SPACE = 0x20 /* Space */
			var CHAR_EXCLAMATION = 0x21 /* ! */
			var CHAR_DOUBLE_QUOTE = 0x22 /* " */
			var CHAR_SHARP = 0x23 /* # */
			var CHAR_PERCENT = 0x25 /* % */
			var CHAR_AMPERSAND = 0x26 /* & */
			var CHAR_SINGLE_QUOTE = 0x27 /* ' */
			var CHAR_ASTERISK = 0x2a /* * */
			var CHAR_COMMA = 0x2c /* , */
			var CHAR_MINUS = 0x2d /* - */
			var CHAR_COLON = 0x3a /* : */
			var CHAR_EQUALS = 0x3d /* = */
			var CHAR_GREATER_THAN = 0x3e /* > */
			var CHAR_QUESTION = 0x3f /* ? */
			var CHAR_COMMERCIAL_AT = 0x40 /* @ */
			var CHAR_LEFT_SQUARE_BRACKET = 0x5b /* [ */
			var CHAR_RIGHT_SQUARE_BRACKET = 0x5d /* ] */
			var CHAR_GRAVE_ACCENT = 0x60 /* ` */
			var CHAR_LEFT_CURLY_BRACKET = 0x7b /* { */
			var CHAR_VERTICAL_LINE = 0x7c /* | */
			var CHAR_RIGHT_CURLY_BRACKET = 0x7d /* } */

			var ESCAPE_SEQUENCES = {}

			ESCAPE_SEQUENCES[0x00] = '\\0'
			ESCAPE_SEQUENCES[0x07] = '\\a'
			ESCAPE_SEQUENCES[0x08] = '\\b'
			ESCAPE_SEQUENCES[0x09] = '\\t'
			ESCAPE_SEQUENCES[0x0a] = '\\n'
			ESCAPE_SEQUENCES[0x0b] = '\\v'
			ESCAPE_SEQUENCES[0x0c] = '\\f'
			ESCAPE_SEQUENCES[0x0d] = '\\r'
			ESCAPE_SEQUENCES[0x1b] = '\\e'
			ESCAPE_SEQUENCES[0x22] = '\\"'
			ESCAPE_SEQUENCES[0x5c] = '\\\\'
			ESCAPE_SEQUENCES[0x85] = '\\N'
			ESCAPE_SEQUENCES[0xa0] = '\\_'
			ESCAPE_SEQUENCES[0x2028] = '\\L'
			ESCAPE_SEQUENCES[0x2029] = '\\P'

			var DEPRECATED_BOOLEANS_SYNTAX = [
				'y',
				'Y',
				'yes',
				'Yes',
				'YES',
				'on',
				'On',
				'ON',
				'n',
				'N',
				'no',
				'No',
				'NO',
				'off',
				'Off',
				'OFF',
			]

			function compileStyleMap(schema, map) {
				var result, keys, index, length, tag, style, type

				if (map === null) return {}

				result = {}
				keys = Object.keys(map)

				for (index = 0, length = keys.length; index < length; index += 1) {
					tag = keys[index]
					style = String(map[tag])

					if (tag.slice(0, 2) === '!!') {
						tag = 'tag:yaml.org,2002:' + tag.slice(2)
					}
					type = schema.compiledTypeMap['fallback'][tag]

					if (type && _hasOwnProperty.call(type.styleAliases, style)) {
						style = type.styleAliases[style]
					}

					result[tag] = style
				}

				return result
			}

			function encodeHex(character) {
				var string, handle, length

				string = character.toString(16).toUpperCase()

				if (character <= 0xff) {
					handle = 'x'
					length = 2
				} else if (character <= 0xffff) {
					handle = 'u'
					length = 4
				} else if (character <= 0xffffffff) {
					handle = 'U'
					length = 8
				} else {
					throw new YAMLException(
						'code point within a string may not be greater than 0xFFFFFFFF',
					)
				}

				return (
					'\\' + handle + common.repeat('0', length - string.length) + string
				)
			}

			function State(options) {
				this.schema = options['schema'] || DEFAULT_FULL_SCHEMA
				this.indent = Math.max(1, options['indent'] || 2)
				this.noArrayIndent = options['noArrayIndent'] || false
				this.skipInvalid = options['skipInvalid'] || false
				this.flowLevel = common.isNothing(options['flowLevel'])
					? -1
					: options['flowLevel']
				this.styleMap = compileStyleMap(this.schema, options['styles'] || null)
				this.sortKeys = options['sortKeys'] || false
				this.lineWidth = options['lineWidth'] || 80
				this.noRefs = options['noRefs'] || false
				this.noCompatMode = options['noCompatMode'] || false
				this.condenseFlow = options['condenseFlow'] || false

				this.implicitTypes = this.schema.compiledImplicit
				this.explicitTypes = this.schema.compiledExplicit

				this.tag = null
				this.result = ''

				this.duplicates = []
				this.usedDuplicates = null
			}

			// Indents every line in a string. Empty lines (\n only) are not indented.
			function indentString(string, spaces) {
				var ind = common.repeat(' ', spaces),
					position = 0,
					next = -1,
					result = '',
					line,
					length = string.length

				while (position < length) {
					next = string.indexOf('\n', position)
					if (next === -1) {
						line = string.slice(position)
						position = length
					} else {
						line = string.slice(position, next + 1)
						position = next + 1
					}

					if (line.length && line !== '\n') result += ind

					result += line
				}

				return result
			}

			function generateNextLine(state, level) {
				return '\n' + common.repeat(' ', state.indent * level)
			}

			function testImplicitResolving(state, str) {
				var index, length, type

				for (
					index = 0, length = state.implicitTypes.length;
					index < length;
					index += 1
				) {
					type = state.implicitTypes[index]

					if (type.resolve(str)) {
						return true
					}
				}

				return false
			}

			// [33] s-white ::= s-space | s-tab
			function isWhitespace(c) {
				return c === CHAR_SPACE || c === CHAR_TAB
			}

			// Returns true if the character can be printed without escaping.
			// From YAML 1.2: "any allowed characters known to be non-printable
			// should also be escaped. [However,] This isnt mandatory"
			// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
			function isPrintable(c) {
				return (
					(0x00020 <= c && c <= 0x00007e) ||
					(0x000a1 <= c && c <= 0x00d7ff && c !== 0x2028 && c !== 0x2029) ||
					(0x0e000 <= c && c <= 0x00fffd && c !== 0xfeff) /* BOM */ ||
					(0x10000 <= c && c <= 0x10ffff)
				)
			}

			// [34] ns-char ::= nb-char - s-white
			// [27] nb-char ::= c-printable - b-char - c-byte-order-mark
			// [26] b-char  ::= b-line-feed | b-carriage-return
			// [24] b-line-feed       ::=     #xA    /* LF */
			// [25] b-carriage-return ::=     #xD    /* CR */
			// [3]  c-byte-order-mark ::=     #xFEFF
			function isNsChar(c) {
				return (
					isPrintable(c) &&
					!isWhitespace(c) &&
					// byte-order-mark
					c !== 0xfeff &&
					// b-char
					c !== CHAR_CARRIAGE_RETURN &&
					c !== CHAR_LINE_FEED
				)
			}

			// Simplified test for values allowed after the first character in plain style.
			function isPlainSafe(c, prev) {
				// Uses a subset of nb-char - c-flow-indicator - ":" - "#"
				// where nb-char ::= c-printable - b-char - c-byte-order-mark.
				return (
					isPrintable(c) &&
					c !== 0xfeff &&
					// - c-flow-indicator
					c !== CHAR_COMMA &&
					c !== CHAR_LEFT_SQUARE_BRACKET &&
					c !== CHAR_RIGHT_SQUARE_BRACKET &&
					c !== CHAR_LEFT_CURLY_BRACKET &&
					c !== CHAR_RIGHT_CURLY_BRACKET &&
					// - ":" - "#"
					// /* An ns-char preceding */ "#"
					c !== CHAR_COLON &&
					(c !== CHAR_SHARP || (prev && isNsChar(prev)))
				)
			}

			// Simplified test for values allowed as the first character in plain style.
			function isPlainSafeFirst(c) {
				// Uses a subset of ns-char - c-indicator
				// where ns-char = nb-char - s-white.
				return (
					isPrintable(c) &&
					c !== 0xfeff &&
					!isWhitespace(c) && // - s-white
					// - (c-indicator ::=
					// - | ? | : | , | [ | ] | { | }
					c !== CHAR_MINUS &&
					c !== CHAR_QUESTION &&
					c !== CHAR_COLON &&
					c !== CHAR_COMMA &&
					c !== CHAR_LEFT_SQUARE_BRACKET &&
					c !== CHAR_RIGHT_SQUARE_BRACKET &&
					c !== CHAR_LEFT_CURLY_BRACKET &&
					c !== CHAR_RIGHT_CURLY_BRACKET &&
					// | # | & | * | ! | | | = | > | ' | "
					c !== CHAR_SHARP &&
					c !== CHAR_AMPERSAND &&
					c !== CHAR_ASTERISK &&
					c !== CHAR_EXCLAMATION &&
					c !== CHAR_VERTICAL_LINE &&
					c !== CHAR_EQUALS &&
					c !== CHAR_GREATER_THAN &&
					c !== CHAR_SINGLE_QUOTE &&
					c !== CHAR_DOUBLE_QUOTE &&
					// | % | @ | `)
					c !== CHAR_PERCENT &&
					c !== CHAR_COMMERCIAL_AT &&
					c !== CHAR_GRAVE_ACCENT
				)
			}

			// Determines whether block indentation indicator is required.
			function needIndentIndicator(string) {
				var leadingSpaceRe = /^\n* /
				return leadingSpaceRe.test(string)
			}

			var STYLE_PLAIN = 1,
				STYLE_SINGLE = 2,
				STYLE_LITERAL = 3,
				STYLE_FOLDED = 4,
				STYLE_DOUBLE = 5

			// Determines which scalar styles are possible and returns the preferred style.
			// lineWidth = -1 => no limit.
			// Pre-conditions: str.length > 0.
			// Post-conditions:
			//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
			//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
			//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
			function chooseScalarStyle(
				string,
				singleLineOnly,
				indentPerLevel,
				lineWidth,
				testAmbiguousType,
			) {
				var i
				var char, prev_char
				var hasLineBreak = false
				var hasFoldableLine = false // only checked if shouldTrackWidth
				var shouldTrackWidth = lineWidth !== -1
				var previousLineBreak = -1 // count the first line correctly
				var plain =
					isPlainSafeFirst(string.charCodeAt(0)) &&
					!isWhitespace(string.charCodeAt(string.length - 1))

				if (singleLineOnly) {
					// Case: no block styles.
					// Check for disallowed characters to rule out plain and single.
					for (i = 0; i < string.length; i++) {
						char = string.charCodeAt(i)
						if (!isPrintable(char)) {
							return STYLE_DOUBLE
						}
						prev_char = i > 0 ? string.charCodeAt(i - 1) : null
						plain = plain && isPlainSafe(char, prev_char)
					}
				} else {
					// Case: block styles permitted.
					for (i = 0; i < string.length; i++) {
						char = string.charCodeAt(i)
						if (char === CHAR_LINE_FEED) {
							hasLineBreak = true
							// Check if any line can be folded.
							if (shouldTrackWidth) {
								hasFoldableLine =
									hasFoldableLine ||
									// Foldable line = too long, and not more-indented.
									(i - previousLineBreak - 1 > lineWidth &&
										string[previousLineBreak + 1] !== ' ')
								previousLineBreak = i
							}
						} else if (!isPrintable(char)) {
							return STYLE_DOUBLE
						}
						prev_char = i > 0 ? string.charCodeAt(i - 1) : null
						plain = plain && isPlainSafe(char, prev_char)
					}
					// in case the end is missing a \n
					hasFoldableLine =
						hasFoldableLine ||
						(shouldTrackWidth &&
							i - previousLineBreak - 1 > lineWidth &&
							string[previousLineBreak + 1] !== ' ')
				}
				// Although every style can represent \n without escaping, prefer block styles
				// for multiline, since they're more readable and they don't add empty lines.
				// Also prefer folding a super-long line.
				if (!hasLineBreak && !hasFoldableLine) {
					// Strings interpretable as another type have to be quoted;
					// e.g. the string 'true' vs. the boolean true.
					return plain && !testAmbiguousType(string)
						? STYLE_PLAIN
						: STYLE_SINGLE
				}
				// Edge case: block indentation indicator can only have one digit.
				if (indentPerLevel > 9 && needIndentIndicator(string)) {
					return STYLE_DOUBLE
				}
				// At this point we know block styles are valid.
				// Prefer literal style unless we want to fold.
				return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL
			}

			// Note: line breaking/folding is implemented for only the folded style.
			// NB. We drop the last trailing newline (if any) of a returned block scalar
			//  since the dumper adds its own newline. This always works:
			//     No ending newline => unaffected; already using strip "-" chomping.
			//     Ending newline    => removed then restored.
			//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
			function writeScalar(state, string, level, iskey) {
				state.dump = (function () {
					if (string.length === 0) {
						return "''"
					}
					if (
						!state.noCompatMode &&
						DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1
					) {
						return "'" + string + "'"
					}

					var indent = state.indent * Math.max(1, level) // no 0-indent scalars
					// As indentation gets deeper, let the width decrease monotonically
					// to the lower bound min(state.lineWidth, 40).
					// Note that this implies
					//  state.lineWidth  40 + state.indent: width is fixed at the lower bound.
					//  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
					// This behaves better than a constant minimum width which disallows narrower options,
					// or an indent threshold which causes the width to suddenly increase.
					var lineWidth =
						state.lineWidth === -1
							? -1
							: Math.max(
									Math.min(state.lineWidth, 40),
									state.lineWidth - indent,
								)

					// Without knowing if keys are implicit/explicit, assume implicit for safety.
					var singleLineOnly =
						iskey ||
						// No block styles in flow mode.
						(state.flowLevel > -1 && level >= state.flowLevel)
					function testAmbiguity(string) {
						return testImplicitResolving(state, string)
					}

					switch (
						chooseScalarStyle(
							string,
							singleLineOnly,
							state.indent,
							lineWidth,
							testAmbiguity,
						)
					) {
						case STYLE_PLAIN:
							return string
						case STYLE_SINGLE:
							return "'" + string.replace(/'/g, "''") + "'"
						case STYLE_LITERAL:
							return (
								'|' +
								blockHeader(string, state.indent) +
								dropEndingNewline(indentString(string, indent))
							)
						case STYLE_FOLDED:
							return (
								'>' +
								blockHeader(string, state.indent) +
								dropEndingNewline(
									indentString(foldString(string, lineWidth), indent),
								)
							)
						case STYLE_DOUBLE:
							return '"' + escapeString(string, lineWidth) + '"'
						default:
							throw new YAMLException('impossible error: invalid scalar style')
					}
				})()
			}

			// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
			function blockHeader(string, indentPerLevel) {
				var indentIndicator = needIndentIndicator(string)
					? String(indentPerLevel)
					: ''

				// note the special case: the string '\n' counts as a "trailing" empty line.
				var clip = string[string.length - 1] === '\n'
				var keep =
					clip && (string[string.length - 2] === '\n' || string === '\n')
				var chomp = keep ? '+' : clip ? '' : '-'

				return indentIndicator + chomp + '\n'
			}

			// (See the note for writeScalar.)
			function dropEndingNewline(string) {
				return string[string.length - 1] === '\n' ? string.slice(0, -1) : string
			}

			// Note: a long line without a suitable break point will exceed the width limit.
			// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
			function foldString(string, width) {
				// In folded style, $k$ consecutive newlines output as $k+1$ newlines
				// unless they're before or after a more-indented line, or at the very
				// beginning or end, in which case $k$ maps to $k$.
				// Therefore, parse each chunk as newline(s) followed by a content line.
				var lineRe = /(\n+)([^\n]*)/g

				// first line (possibly an empty line)
				var result = (function () {
					var nextLF = string.indexOf('\n')
					nextLF = nextLF !== -1 ? nextLF : string.length
					lineRe.lastIndex = nextLF
					return foldLine(string.slice(0, nextLF), width)
				})()
				// If we haven't reached the first content line yet, don't add an extra \n.
				var prevMoreIndented = string[0] === '\n' || string[0] === ' '
				var moreIndented

				// rest of the lines
				var match
				while ((match = lineRe.exec(string))) {
					var prefix = match[1],
						line = match[2]
					moreIndented = line[0] === ' '
					result +=
						prefix +
						(!prevMoreIndented && !moreIndented && line !== '' ? '\n' : '') +
						foldLine(line, width)
					prevMoreIndented = moreIndented
				}

				return result
			}

			// Greedy line breaking.
			// Picks the longest line under the limit each time,
			// otherwise settles for the shortest line over the limit.
			// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
			function foldLine(line, width) {
				if (line === '' || line[0] === ' ') return line

				// Since a more-indented line adds a \n, breaks can't be followed by a space.
				var breakRe = / [^ ]/g // note: the match index will always be <= length-2.
				var match
				// start is an inclusive index. end, curr, and next are exclusive.
				var start = 0,
					end,
					curr = 0,
					next = 0
				var result = ''

				// Invariants: 0 <= start <= length-1.
				//   0 <= curr <= next <= max(0, length-2). curr - start <= width.
				// Inside the loop:
				//   A match implies length >= 2, so curr and next are <= length-2.
				while ((match = breakRe.exec(line))) {
					next = match.index
					// maintain invariant: curr - start <= width
					if (next - start > width) {
						end = curr > start ? curr : next // derive end <= length-2
						result += '\n' + line.slice(start, end)
						// skip the space that was output as \n
						start = end + 1 // derive start <= length-1
					}
					curr = next
				}

				// By the invariants, start <= length-1, so there is something left over.
				// It is either the whole string or a part starting from non-whitespace.
				result += '\n'
				// Insert a break if the remainder is too long and there is a break available.
				if (line.length - start > width && curr > start) {
					result += line.slice(start, curr) + '\n' + line.slice(curr + 1)
				} else {
					result += line.slice(start)
				}

				return result.slice(1) // drop extra \n joiner
			}

			// Escapes a double-quoted string.
			function escapeString(string) {
				var result = ''
				var char, nextChar
				var escapeSeq

				for (var i = 0; i < string.length; i++) {
					char = string.charCodeAt(i)
					// Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
					if (char >= 0xd800 && char <= 0xdbff /* high surrogate */) {
						nextChar = string.charCodeAt(i + 1)
						if (nextChar >= 0xdc00 && nextChar <= 0xdfff /* low surrogate */) {
							// Combine the surrogate pair and store it escaped.
							result += encodeHex(
								(char - 0xd800) * 0x400 + nextChar - 0xdc00 + 0x10000,
							)
							// Advance index one extra since we already used that char here.
							i++
							continue
						}
					}
					escapeSeq = ESCAPE_SEQUENCES[char]
					result +=
						!escapeSeq && isPrintable(char)
							? string[i]
							: escapeSeq || encodeHex(char)
				}

				return result
			}

			function writeFlowSequence(state, level, object) {
				var _result = '',
					_tag = state.tag,
					index,
					length

				for (index = 0, length = object.length; index < length; index += 1) {
					// Write only valid elements.
					if (writeNode(state, level, object[index], false, false)) {
						if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '')
						_result += state.dump
					}
				}

				state.tag = _tag
				state.dump = '[' + _result + ']'
			}

			function writeBlockSequence(state, level, object, compact) {
				var _result = '',
					_tag = state.tag,
					index,
					length

				for (index = 0, length = object.length; index < length; index += 1) {
					// Write only valid elements.
					if (writeNode(state, level + 1, object[index], true, true)) {
						if (!compact || index !== 0) {
							_result += generateNextLine(state, level)
						}

						if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
							_result += '-'
						} else {
							_result += '- '
						}

						_result += state.dump
					}
				}

				state.tag = _tag
				state.dump = _result || '[]' // Empty sequence if no valid values.
			}

			function writeFlowMapping(state, level, object) {
				var _result = '',
					_tag = state.tag,
					objectKeyList = Object.keys(object),
					index,
					length,
					objectKey,
					objectValue,
					pairBuffer

				for (
					index = 0, length = objectKeyList.length;
					index < length;
					index += 1
				) {
					pairBuffer = ''
					if (index !== 0) pairBuffer += ', '

					if (state.condenseFlow) pairBuffer += '"'

					objectKey = objectKeyList[index]
					objectValue = object[objectKey]

					if (!writeNode(state, level, objectKey, false, false)) {
						continue // Skip this pair because of invalid key;
					}

					if (state.dump.length > 1024) pairBuffer += '? '

					pairBuffer +=
						state.dump +
						(state.condenseFlow ? '"' : '') +
						':' +
						(state.condenseFlow ? '' : ' ')

					if (!writeNode(state, level, objectValue, false, false)) {
						continue // Skip this pair because of invalid value.
					}

					pairBuffer += state.dump

					// Both key and value are valid.
					_result += pairBuffer
				}

				state.tag = _tag
				state.dump = '{' + _result + '}'
			}

			function writeBlockMapping(state, level, object, compact) {
				var _result = '',
					_tag = state.tag,
					objectKeyList = Object.keys(object),
					index,
					length,
					objectKey,
					objectValue,
					explicitPair,
					pairBuffer

				// Allow sorting keys so that the output file is deterministic
				if (state.sortKeys === true) {
					// Default sorting
					objectKeyList.sort()
				} else if (typeof state.sortKeys === 'function') {
					// Custom sort function
					objectKeyList.sort(state.sortKeys)
				} else if (state.sortKeys) {
					// Something is wrong
					throw new YAMLException('sortKeys must be a boolean or a function')
				}

				for (
					index = 0, length = objectKeyList.length;
					index < length;
					index += 1
				) {
					pairBuffer = ''

					if (!compact || index !== 0) {
						pairBuffer += generateNextLine(state, level)
					}

					objectKey = objectKeyList[index]
					objectValue = object[objectKey]

					if (!writeNode(state, level + 1, objectKey, true, true, true)) {
						continue // Skip this pair because of invalid key.
					}

					explicitPair =
						(state.tag !== null && state.tag !== '?') ||
						(state.dump && state.dump.length > 1024)

					if (explicitPair) {
						if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
							pairBuffer += '?'
						} else {
							pairBuffer += '? '
						}
					}

					pairBuffer += state.dump

					if (explicitPair) {
						pairBuffer += generateNextLine(state, level)
					}

					if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
						continue // Skip this pair because of invalid value.
					}

					if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
						pairBuffer += ':'
					} else {
						pairBuffer += ': '
					}

					pairBuffer += state.dump

					// Both key and value are valid.
					_result += pairBuffer
				}

				state.tag = _tag
				state.dump = _result || '{}' // Empty mapping if no valid pairs.
			}

			function detectType(state, object, explicit) {
				var _result, typeList, index, length, type, style

				typeList = explicit ? state.explicitTypes : state.implicitTypes

				for (index = 0, length = typeList.length; index < length; index += 1) {
					type = typeList[index]

					if (
						(type.instanceOf || type.predicate) &&
						(!type.instanceOf ||
							(typeof object === 'object' &&
								object instanceof type.instanceOf)) &&
						(!type.predicate || type.predicate(object))
					) {
						state.tag = explicit ? type.tag : '?'

						if (type.represent) {
							style = state.styleMap[type.tag] || type.defaultStyle

							if (_toString.call(type.represent) === '[object Function]') {
								_result = type.represent(object, style)
							} else if (_hasOwnProperty.call(type.represent, style)) {
								_result = type.represent[style](object, style)
							} else {
								throw new YAMLException(
									'!<' +
										type.tag +
										'> tag resolver accepts not "' +
										style +
										'" style',
								)
							}

							state.dump = _result
						}

						return true
					}
				}

				return false
			}

			// Serializes `object` and writes it to global `result`.
			// Returns true on success, or false on invalid object.
			//
			function writeNode(state, level, object, block, compact, iskey) {
				state.tag = null
				state.dump = object

				if (!detectType(state, object, false)) {
					detectType(state, object, true)
				}

				var type = _toString.call(state.dump)

				if (block) {
					block = state.flowLevel < 0 || state.flowLevel > level
				}

				var objectOrArray =
						type === '[object Object]' || type === '[object Array]',
					duplicateIndex,
					duplicate

				if (objectOrArray) {
					duplicateIndex = state.duplicates.indexOf(object)
					duplicate = duplicateIndex !== -1
				}

				if (
					(state.tag !== null && state.tag !== '?') ||
					duplicate ||
					(state.indent !== 2 && level > 0)
				) {
					compact = false
				}

				if (duplicate && state.usedDuplicates[duplicateIndex]) {
					state.dump = '*ref_' + duplicateIndex
				} else {
					if (
						objectOrArray &&
						duplicate &&
						!state.usedDuplicates[duplicateIndex]
					) {
						state.usedDuplicates[duplicateIndex] = true
					}
					if (type === '[object Object]') {
						if (block && Object.keys(state.dump).length !== 0) {
							writeBlockMapping(state, level, state.dump, compact)
							if (duplicate) {
								state.dump = '&ref_' + duplicateIndex + state.dump
							}
						} else {
							writeFlowMapping(state, level, state.dump)
							if (duplicate) {
								state.dump = '&ref_' + duplicateIndex + ' ' + state.dump
							}
						}
					} else if (type === '[object Array]') {
						var arrayLevel =
							state.noArrayIndent && level > 0 ? level - 1 : level
						if (block && state.dump.length !== 0) {
							writeBlockSequence(state, arrayLevel, state.dump, compact)
							if (duplicate) {
								state.dump = '&ref_' + duplicateIndex + state.dump
							}
						} else {
							writeFlowSequence(state, arrayLevel, state.dump)
							if (duplicate) {
								state.dump = '&ref_' + duplicateIndex + ' ' + state.dump
							}
						}
					} else if (type === '[object String]') {
						if (state.tag !== '?') {
							writeScalar(state, state.dump, level, iskey)
						}
					} else {
						if (state.skipInvalid) return false
						throw new YAMLException(
							'unacceptable kind of an object to dump ' + type,
						)
					}

					if (state.tag !== null && state.tag !== '?') {
						state.dump = '!<' + state.tag + '> ' + state.dump
					}
				}

				return true
			}

			function getDuplicateReferences(object, state) {
				var objects = [],
					duplicatesIndexes = [],
					index,
					length

				inspectNode(object, objects, duplicatesIndexes)

				for (
					index = 0, length = duplicatesIndexes.length;
					index < length;
					index += 1
				) {
					state.duplicates.push(objects[duplicatesIndexes[index]])
				}
				state.usedDuplicates = new Array(length)
			}

			function inspectNode(object, objects, duplicatesIndexes) {
				var objectKeyList, index, length

				if (object !== null && typeof object === 'object') {
					index = objects.indexOf(object)
					if (index !== -1) {
						if (duplicatesIndexes.indexOf(index) === -1) {
							duplicatesIndexes.push(index)
						}
					} else {
						objects.push(object)

						if (Array.isArray(object)) {
							for (
								index = 0, length = object.length;
								index < length;
								index += 1
							) {
								inspectNode(object[index], objects, duplicatesIndexes)
							}
						} else {
							objectKeyList = Object.keys(object)

							for (
								index = 0, length = objectKeyList.length;
								index < length;
								index += 1
							) {
								inspectNode(
									object[objectKeyList[index]],
									objects,
									duplicatesIndexes,
								)
							}
						}
					}
				}
			}

			function dump(input, options) {
				options = options || {}

				var state = new State(options)

				if (!state.noRefs) getDuplicateReferences(input, state)

				if (writeNode(state, 0, input, true, true)) return state.dump + '\n'

				return ''
			}

			function safeDump(input, options) {
				return dump(
					input,
					common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options),
				)
			}

			module.exports.dump = dump
			module.exports.safeDump = safeDump

			/***/
		},

		/***/ 15622: /***/ (module) => {
			'use strict'
			// YAML error class. http://stackoverflow.com/questions/8458984
			//

			function YAMLException(reason, mark) {
				// Super constructor
				Error.call(this)

				this.name = 'YAMLException'
				this.reason = reason
				this.mark = mark
				this.message =
					(this.reason || '(unknown reason)') +
					(this.mark ? ' ' + this.mark.toString() : '')

				// Include stack trace in error object
				if (Error.captureStackTrace) {
					// Chrome and NodeJS
					Error.captureStackTrace(this, this.constructor)
				} else {
					// FF, IE 10+ and Safari 6+. Fallback for others
					this.stack = new Error().stack || ''
				}
			}

			// Inherit from Error
			YAMLException.prototype = Object.create(Error.prototype)
			YAMLException.prototype.constructor = YAMLException

			YAMLException.prototype.toString = function toString(compact) {
				var result = this.name + ': '

				result += this.reason || '(unknown reason)'

				if (!compact && this.mark) {
					result += ' ' + this.mark.toString()
				}

				return result
			}

			module.exports = YAMLException

			/***/
		},

		/***/ 75868: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			/*eslint-disable max-len,no-use-before-define*/

			var common = __nccwpck_require__(24206)
			var YAMLException = __nccwpck_require__(15622)
			var Mark = __nccwpck_require__(45622)
			var DEFAULT_SAFE_SCHEMA = __nccwpck_require__(76032)
			var DEFAULT_FULL_SCHEMA = __nccwpck_require__(60948)

			var _hasOwnProperty = Object.prototype.hasOwnProperty

			var CONTEXT_FLOW_IN = 1
			var CONTEXT_FLOW_OUT = 2
			var CONTEXT_BLOCK_IN = 3
			var CONTEXT_BLOCK_OUT = 4

			var CHOMPING_CLIP = 1
			var CHOMPING_STRIP = 2
			var CHOMPING_KEEP = 3

			var PATTERN_NON_PRINTABLE =
				/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/
			var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/
			var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/
			var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i
			var PATTERN_TAG_URI =
				/^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i

			function _class(obj) {
				return Object.prototype.toString.call(obj)
			}

			function is_EOL(c) {
				return c === 0x0a /* LF */ || c === 0x0d /* CR */
			}

			function is_WHITE_SPACE(c) {
				return c === 0x09 /* Tab */ || c === 0x20 /* Space */
			}

			function is_WS_OR_EOL(c) {
				return (
					c === 0x09 /* Tab */ ||
					c === 0x20 /* Space */ ||
					c === 0x0a /* LF */ ||
					c === 0x0d /* CR */
				)
			}

			function is_FLOW_INDICATOR(c) {
				return (
					c === 0x2c /* , */ ||
					c === 0x5b /* [ */ ||
					c === 0x5d /* ] */ ||
					c === 0x7b /* { */ ||
					c === 0x7d /* } */
				)
			}

			function fromHexCode(c) {
				var lc

				if (0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) {
					return c - 0x30
				}

				/*eslint-disable no-bitwise*/
				lc = c | 0x20

				if (0x61 /* a */ <= lc && lc <= 0x66 /* f */) {
					return lc - 0x61 + 10
				}

				return -1
			}

			function escapedHexLen(c) {
				if (c === 0x78 /* x */) {
					return 2
				}
				if (c === 0x75 /* u */) {
					return 4
				}
				if (c === 0x55 /* U */) {
					return 8
				}
				return 0
			}

			function fromDecimalCode(c) {
				if (0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) {
					return c - 0x30
				}

				return -1
			}

			function simpleEscapeSequence(c) {
				/* eslint-disable indent */
				return c === 0x30 /* 0 */
					? '\x00'
					: c === 0x61 /* a */
						? '\x07'
						: c === 0x62 /* b */
							? '\x08'
							: c === 0x74 /* t */
								? '\x09'
								: c === 0x09 /* Tab */
									? '\x09'
									: c === 0x6e /* n */
										? '\x0A'
										: c === 0x76 /* v */
											? '\x0B'
											: c === 0x66 /* f */
												? '\x0C'
												: c === 0x72 /* r */
													? '\x0D'
													: c === 0x65 /* e */
														? '\x1B'
														: c === 0x20 /* Space */
															? ' '
															: c === 0x22 /* " */
																? '\x22'
																: c === 0x2f /* / */
																	? '/'
																	: c === 0x5c /* \ */
																		? '\x5C'
																		: c === 0x4e /* N */
																			? '\x85'
																			: c === 0x5f /* _ */
																				? '\xA0'
																				: c === 0x4c /* L */
																					? '\u2028'
																					: c === 0x50 /* P */
																						? '\u2029'
																						: ''
			}

			function charFromCodepoint(c) {
				if (c <= 0xffff) {
					return String.fromCharCode(c)
				}
				// Encode UTF-16 surrogate pair
				// https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
				return String.fromCharCode(
					((c - 0x010000) >> 10) + 0xd800,
					((c - 0x010000) & 0x03ff) + 0xdc00,
				)
			}

			var simpleEscapeCheck = new Array(256) // integer, for fast access
			var simpleEscapeMap = new Array(256)
			for (var i = 0; i < 256; i++) {
				simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0
				simpleEscapeMap[i] = simpleEscapeSequence(i)
			}

			function State(input, options) {
				this.input = input

				this.filename = options['filename'] || null
				this.schema = options['schema'] || DEFAULT_FULL_SCHEMA
				this.onWarning = options['onWarning'] || null
				this.legacy = options['legacy'] || false
				this.json = options['json'] || false
				this.listener = options['listener'] || null

				this.implicitTypes = this.schema.compiledImplicit
				this.typeMap = this.schema.compiledTypeMap

				this.length = input.length
				this.position = 0
				this.line = 0
				this.lineStart = 0
				this.lineIndent = 0

				this.documents = []

				/*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/
			}

			function generateError(state, message) {
				return new YAMLException(
					message,
					new Mark(
						state.filename,
						state.input,
						state.position,
						state.line,
						state.position - state.lineStart,
					),
				)
			}

			function throwError(state, message) {
				throw generateError(state, message)
			}

			function throwWarning(state, message) {
				if (state.onWarning) {
					state.onWarning.call(null, generateError(state, message))
				}
			}

			var directiveHandlers = {
				YAML: function handleYamlDirective(state, name, args) {
					var match, major, minor

					if (state.version !== null) {
						throwError(state, 'duplication of %YAML directive')
					}

					if (args.length !== 1) {
						throwError(state, 'YAML directive accepts exactly one argument')
					}

					match = /^([0-9]+)\.([0-9]+)$/.exec(args[0])

					if (match === null) {
						throwError(state, 'ill-formed argument of the YAML directive')
					}

					major = parseInt(match[1], 10)
					minor = parseInt(match[2], 10)

					if (major !== 1) {
						throwError(state, 'unacceptable YAML version of the document')
					}

					state.version = args[0]
					state.checkLineBreaks = minor < 2

					if (minor !== 1 && minor !== 2) {
						throwWarning(state, 'unsupported YAML version of the document')
					}
				},

				TAG: function handleTagDirective(state, name, args) {
					var handle, prefix

					if (args.length !== 2) {
						throwError(state, 'TAG directive accepts exactly two arguments')
					}

					handle = args[0]
					prefix = args[1]

					if (!PATTERN_TAG_HANDLE.test(handle)) {
						throwError(
							state,
							'ill-formed tag handle (first argument) of the TAG directive',
						)
					}

					if (_hasOwnProperty.call(state.tagMap, handle)) {
						throwError(
							state,
							'there is a previously declared suffix for "' +
								handle +
								'" tag handle',
						)
					}

					if (!PATTERN_TAG_URI.test(prefix)) {
						throwError(
							state,
							'ill-formed tag prefix (second argument) of the TAG directive',
						)
					}

					state.tagMap[handle] = prefix
				},
			}

			function captureSegment(state, start, end, checkJson) {
				var _position, _length, _character, _result

				if (start < end) {
					_result = state.input.slice(start, end)

					if (checkJson) {
						for (
							_position = 0, _length = _result.length;
							_position < _length;
							_position += 1
						) {
							_character = _result.charCodeAt(_position)
							if (
								!(
									_character === 0x09 ||
									(0x20 <= _character && _character <= 0x10ffff)
								)
							) {
								throwError(state, 'expected valid JSON character')
							}
						}
					} else if (PATTERN_NON_PRINTABLE.test(_result)) {
						throwError(state, 'the stream contains non-printable characters')
					}

					state.result += _result
				}
			}

			function mergeMappings(state, destination, source, overridableKeys) {
				var sourceKeys, key, index, quantity

				if (!common.isObject(source)) {
					throwError(
						state,
						'cannot merge mappings; the provided source object is unacceptable',
					)
				}

				sourceKeys = Object.keys(source)

				for (
					index = 0, quantity = sourceKeys.length;
					index < quantity;
					index += 1
				) {
					key = sourceKeys[index]

					if (!_hasOwnProperty.call(destination, key)) {
						destination[key] = source[key]
						overridableKeys[key] = true
					}
				}
			}

			function storeMappingPair(
				state,
				_result,
				overridableKeys,
				keyTag,
				keyNode,
				valueNode,
				startLine,
				startPos,
			) {
				var index, quantity

				// The output is a plain object here, so keys can only be strings.
				// We need to convert keyNode to a string, but doing so can hang the process
				// (deeply nested arrays that explode exponentially using aliases).
				if (Array.isArray(keyNode)) {
					keyNode = Array.prototype.slice.call(keyNode)

					for (
						index = 0, quantity = keyNode.length;
						index < quantity;
						index += 1
					) {
						if (Array.isArray(keyNode[index])) {
							throwError(state, 'nested arrays are not supported inside keys')
						}

						if (
							typeof keyNode === 'object' &&
							_class(keyNode[index]) === '[object Object]'
						) {
							keyNode[index] = '[object Object]'
						}
					}
				}

				// Avoid code execution in load() via toString property
				// (still use its own toString for arrays, timestamps,
				// and whatever user schema extensions happen to have @@toStringTag)
				if (
					typeof keyNode === 'object' &&
					_class(keyNode) === '[object Object]'
				) {
					keyNode = '[object Object]'
				}

				keyNode = String(keyNode)

				if (_result === null) {
					_result = {}
				}

				if (keyTag === 'tag:yaml.org,2002:merge') {
					if (Array.isArray(valueNode)) {
						for (
							index = 0, quantity = valueNode.length;
							index < quantity;
							index += 1
						) {
							mergeMappings(state, _result, valueNode[index], overridableKeys)
						}
					} else {
						mergeMappings(state, _result, valueNode, overridableKeys)
					}
				} else {
					if (
						!state.json &&
						!_hasOwnProperty.call(overridableKeys, keyNode) &&
						_hasOwnProperty.call(_result, keyNode)
					) {
						state.line = startLine || state.line
						state.position = startPos || state.position
						throwError(state, 'duplicated mapping key')
					}
					_result[keyNode] = valueNode
					delete overridableKeys[keyNode]
				}

				return _result
			}

			function readLineBreak(state) {
				var ch

				ch = state.input.charCodeAt(state.position)

				if (ch === 0x0a /* LF */) {
					state.position++
				} else if (ch === 0x0d /* CR */) {
					state.position++
					if (state.input.charCodeAt(state.position) === 0x0a /* LF */) {
						state.position++
					}
				} else {
					throwError(state, 'a line break is expected')
				}

				state.line += 1
				state.lineStart = state.position
			}

			function skipSeparationSpace(state, allowComments, checkIndent) {
				var lineBreaks = 0,
					ch = state.input.charCodeAt(state.position)

				while (ch !== 0) {
					while (is_WHITE_SPACE(ch)) {
						ch = state.input.charCodeAt(++state.position)
					}

					if (allowComments && ch === 0x23 /* # */) {
						do {
							ch = state.input.charCodeAt(++state.position)
						} while (ch !== 0x0a /* LF */ && ch !== 0x0d /* CR */ && ch !== 0)
					}

					if (is_EOL(ch)) {
						readLineBreak(state)

						ch = state.input.charCodeAt(state.position)
						lineBreaks++
						state.lineIndent = 0

						while (ch === 0x20 /* Space */) {
							state.lineIndent++
							ch = state.input.charCodeAt(++state.position)
						}
					} else {
						break
					}
				}

				if (
					checkIndent !== -1 &&
					lineBreaks !== 0 &&
					state.lineIndent < checkIndent
				) {
					throwWarning(state, 'deficient indentation')
				}

				return lineBreaks
			}

			function testDocumentSeparator(state) {
				var _position = state.position,
					ch

				ch = state.input.charCodeAt(_position)

				// Condition state.position === state.lineStart is tested
				// in parent on each call, for efficiency. No needs to test here again.
				if (
					(ch === 0x2d /* - */ || ch === 0x2e) /* . */ &&
					ch === state.input.charCodeAt(_position + 1) &&
					ch === state.input.charCodeAt(_position + 2)
				) {
					_position += 3

					ch = state.input.charCodeAt(_position)

					if (ch === 0 || is_WS_OR_EOL(ch)) {
						return true
					}
				}

				return false
			}

			function writeFoldedLines(state, count) {
				if (count === 1) {
					state.result += ' '
				} else if (count > 1) {
					state.result += common.repeat('\n', count - 1)
				}
			}

			function readPlainScalar(state, nodeIndent, withinFlowCollection) {
				var preceding,
					following,
					captureStart,
					captureEnd,
					hasPendingContent,
					_line,
					_lineStart,
					_lineIndent,
					_kind = state.kind,
					_result = state.result,
					ch

				ch = state.input.charCodeAt(state.position)

				if (
					is_WS_OR_EOL(ch) ||
					is_FLOW_INDICATOR(ch) ||
					ch === 0x23 /* # */ ||
					ch === 0x26 /* & */ ||
					ch === 0x2a /* * */ ||
					ch === 0x21 /* ! */ ||
					ch === 0x7c /* | */ ||
					ch === 0x3e /* > */ ||
					ch === 0x27 /* ' */ ||
					ch === 0x22 /* " */ ||
					ch === 0x25 /* % */ ||
					ch === 0x40 /* @ */ ||
					ch === 0x60 /* ` */
				) {
					return false
				}

				if (ch === 0x3f /* ? */ || ch === 0x2d /* - */) {
					following = state.input.charCodeAt(state.position + 1)

					if (
						is_WS_OR_EOL(following) ||
						(withinFlowCollection && is_FLOW_INDICATOR(following))
					) {
						return false
					}
				}

				state.kind = 'scalar'
				state.result = ''
				captureStart = captureEnd = state.position
				hasPendingContent = false

				while (ch !== 0) {
					if (ch === 0x3a /* : */) {
						following = state.input.charCodeAt(state.position + 1)

						if (
							is_WS_OR_EOL(following) ||
							(withinFlowCollection && is_FLOW_INDICATOR(following))
						) {
							break
						}
					} else if (ch === 0x23 /* # */) {
						preceding = state.input.charCodeAt(state.position - 1)

						if (is_WS_OR_EOL(preceding)) {
							break
						}
					} else if (
						(state.position === state.lineStart &&
							testDocumentSeparator(state)) ||
						(withinFlowCollection && is_FLOW_INDICATOR(ch))
					) {
						break
					} else if (is_EOL(ch)) {
						_line = state.line
						_lineStart = state.lineStart
						_lineIndent = state.lineIndent
						skipSeparationSpace(state, false, -1)

						if (state.lineIndent >= nodeIndent) {
							hasPendingContent = true
							ch = state.input.charCodeAt(state.position)
							continue
						} else {
							state.position = captureEnd
							state.line = _line
							state.lineStart = _lineStart
							state.lineIndent = _lineIndent
							break
						}
					}

					if (hasPendingContent) {
						captureSegment(state, captureStart, captureEnd, false)
						writeFoldedLines(state, state.line - _line)
						captureStart = captureEnd = state.position
						hasPendingContent = false
					}

					if (!is_WHITE_SPACE(ch)) {
						captureEnd = state.position + 1
					}

					ch = state.input.charCodeAt(++state.position)
				}

				captureSegment(state, captureStart, captureEnd, false)

				if (state.result) {
					return true
				}

				state.kind = _kind
				state.result = _result
				return false
			}

			function readSingleQuotedScalar(state, nodeIndent) {
				var ch, captureStart, captureEnd

				ch = state.input.charCodeAt(state.position)

				if (ch !== 0x27 /* ' */) {
					return false
				}

				state.kind = 'scalar'
				state.result = ''
				state.position++
				captureStart = captureEnd = state.position

				while ((ch = state.input.charCodeAt(state.position)) !== 0) {
					if (ch === 0x27 /* ' */) {
						captureSegment(state, captureStart, state.position, true)
						ch = state.input.charCodeAt(++state.position)

						if (ch === 0x27 /* ' */) {
							captureStart = state.position
							state.position++
							captureEnd = state.position
						} else {
							return true
						}
					} else if (is_EOL(ch)) {
						captureSegment(state, captureStart, captureEnd, true)
						writeFoldedLines(
							state,
							skipSeparationSpace(state, false, nodeIndent),
						)
						captureStart = captureEnd = state.position
					} else if (
						state.position === state.lineStart &&
						testDocumentSeparator(state)
					) {
						throwError(
							state,
							'unexpected end of the document within a single quoted scalar',
						)
					} else {
						state.position++
						captureEnd = state.position
					}
				}

				throwError(
					state,
					'unexpected end of the stream within a single quoted scalar',
				)
			}

			function readDoubleQuotedScalar(state, nodeIndent) {
				var captureStart, captureEnd, hexLength, hexResult, tmp, ch

				ch = state.input.charCodeAt(state.position)

				if (ch !== 0x22 /* " */) {
					return false
				}

				state.kind = 'scalar'
				state.result = ''
				state.position++
				captureStart = captureEnd = state.position

				while ((ch = state.input.charCodeAt(state.position)) !== 0) {
					if (ch === 0x22 /* " */) {
						captureSegment(state, captureStart, state.position, true)
						state.position++
						return true
					} else if (ch === 0x5c /* \ */) {
						captureSegment(state, captureStart, state.position, true)
						ch = state.input.charCodeAt(++state.position)

						if (is_EOL(ch)) {
							skipSeparationSpace(state, false, nodeIndent)

							// TODO: rework to inline fn with no type cast?
						} else if (ch < 256 && simpleEscapeCheck[ch]) {
							state.result += simpleEscapeMap[ch]
							state.position++
						} else if ((tmp = escapedHexLen(ch)) > 0) {
							hexLength = tmp
							hexResult = 0

							for (; hexLength > 0; hexLength--) {
								ch = state.input.charCodeAt(++state.position)

								if ((tmp = fromHexCode(ch)) >= 0) {
									hexResult = (hexResult << 4) + tmp
								} else {
									throwError(state, 'expected hexadecimal character')
								}
							}

							state.result += charFromCodepoint(hexResult)

							state.position++
						} else {
							throwError(state, 'unknown escape sequence')
						}

						captureStart = captureEnd = state.position
					} else if (is_EOL(ch)) {
						captureSegment(state, captureStart, captureEnd, true)
						writeFoldedLines(
							state,
							skipSeparationSpace(state, false, nodeIndent),
						)
						captureStart = captureEnd = state.position
					} else if (
						state.position === state.lineStart &&
						testDocumentSeparator(state)
					) {
						throwError(
							state,
							'unexpected end of the document within a double quoted scalar',
						)
					} else {
						state.position++
						captureEnd = state.position
					}
				}

				throwError(
					state,
					'unexpected end of the stream within a double quoted scalar',
				)
			}

			function readFlowCollection(state, nodeIndent) {
				var readNext = true,
					_line,
					_tag = state.tag,
					_result,
					_anchor = state.anchor,
					following,
					terminator,
					isPair,
					isExplicitPair,
					isMapping,
					overridableKeys = {},
					keyNode,
					keyTag,
					valueNode,
					ch

				ch = state.input.charCodeAt(state.position)

				if (ch === 0x5b /* [ */) {
					terminator = 0x5d /* ] */
					isMapping = false
					_result = []
				} else if (ch === 0x7b /* { */) {
					terminator = 0x7d /* } */
					isMapping = true
					_result = {}
				} else {
					return false
				}

				if (state.anchor !== null) {
					state.anchorMap[state.anchor] = _result
				}

				ch = state.input.charCodeAt(++state.position)

				while (ch !== 0) {
					skipSeparationSpace(state, true, nodeIndent)

					ch = state.input.charCodeAt(state.position)

					if (ch === terminator) {
						state.position++
						state.tag = _tag
						state.anchor = _anchor
						state.kind = isMapping ? 'mapping' : 'sequence'
						state.result = _result
						return true
					} else if (!readNext) {
						throwError(state, 'missed comma between flow collection entries')
					}

					keyTag = keyNode = valueNode = null
					isPair = isExplicitPair = false

					if (ch === 0x3f /* ? */) {
						following = state.input.charCodeAt(state.position + 1)

						if (is_WS_OR_EOL(following)) {
							isPair = isExplicitPair = true
							state.position++
							skipSeparationSpace(state, true, nodeIndent)
						}
					}

					_line = state.line
					composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true)
					keyTag = state.tag
					keyNode = state.result
					skipSeparationSpace(state, true, nodeIndent)

					ch = state.input.charCodeAt(state.position)

					if ((isExplicitPair || state.line === _line) && ch === 0x3a /* : */) {
						isPair = true
						ch = state.input.charCodeAt(++state.position)
						skipSeparationSpace(state, true, nodeIndent)
						composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true)
						valueNode = state.result
					}

					if (isMapping) {
						storeMappingPair(
							state,
							_result,
							overridableKeys,
							keyTag,
							keyNode,
							valueNode,
						)
					} else if (isPair) {
						_result.push(
							storeMappingPair(
								state,
								null,
								overridableKeys,
								keyTag,
								keyNode,
								valueNode,
							),
						)
					} else {
						_result.push(keyNode)
					}

					skipSeparationSpace(state, true, nodeIndent)

					ch = state.input.charCodeAt(state.position)

					if (ch === 0x2c /* , */) {
						readNext = true
						ch = state.input.charCodeAt(++state.position)
					} else {
						readNext = false
					}
				}

				throwError(
					state,
					'unexpected end of the stream within a flow collection',
				)
			}

			function readBlockScalar(state, nodeIndent) {
				var captureStart,
					folding,
					chomping = CHOMPING_CLIP,
					didReadContent = false,
					detectedIndent = false,
					textIndent = nodeIndent,
					emptyLines = 0,
					atMoreIndented = false,
					tmp,
					ch

				ch = state.input.charCodeAt(state.position)

				if (ch === 0x7c /* | */) {
					folding = false
				} else if (ch === 0x3e /* > */) {
					folding = true
				} else {
					return false
				}

				state.kind = 'scalar'
				state.result = ''

				while (ch !== 0) {
					ch = state.input.charCodeAt(++state.position)

					if (ch === 0x2b /* + */ || ch === 0x2d /* - */) {
						if (CHOMPING_CLIP === chomping) {
							chomping = ch === 0x2b /* + */ ? CHOMPING_KEEP : CHOMPING_STRIP
						} else {
							throwError(state, 'repeat of a chomping mode identifier')
						}
					} else if ((tmp = fromDecimalCode(ch)) >= 0) {
						if (tmp === 0) {
							throwError(
								state,
								'bad explicit indentation width of a block scalar; it cannot be less than one',
							)
						} else if (!detectedIndent) {
							textIndent = nodeIndent + tmp - 1
							detectedIndent = true
						} else {
							throwError(state, 'repeat of an indentation width identifier')
						}
					} else {
						break
					}
				}

				if (is_WHITE_SPACE(ch)) {
					do {
						ch = state.input.charCodeAt(++state.position)
					} while (is_WHITE_SPACE(ch))

					if (ch === 0x23 /* # */) {
						do {
							ch = state.input.charCodeAt(++state.position)
						} while (!is_EOL(ch) && ch !== 0)
					}
				}

				while (ch !== 0) {
					readLineBreak(state)
					state.lineIndent = 0

					ch = state.input.charCodeAt(state.position)

					while (
						(!detectedIndent || state.lineIndent < textIndent) &&
						ch === 0x20 /* Space */
					) {
						state.lineIndent++
						ch = state.input.charCodeAt(++state.position)
					}

					if (!detectedIndent && state.lineIndent > textIndent) {
						textIndent = state.lineIndent
					}

					if (is_EOL(ch)) {
						emptyLines++
						continue
					}

					// End of the scalar.
					if (state.lineIndent < textIndent) {
						// Perform the chomping.
						if (chomping === CHOMPING_KEEP) {
							state.result += common.repeat(
								'\n',
								didReadContent ? 1 + emptyLines : emptyLines,
							)
						} else if (chomping === CHOMPING_CLIP) {
							if (didReadContent) {
								// i.e. only if the scalar is not empty.
								state.result += '\n'
							}
						}

						// Break this `while` cycle and go to the funciton's epilogue.
						break
					}

					// Folded style: use fancy rules to handle line breaks.
					if (folding) {
						// Lines starting with white space characters (more-indented lines) are not folded.
						if (is_WHITE_SPACE(ch)) {
							atMoreIndented = true
							// except for the first content line (cf. Example 8.1)
							state.result += common.repeat(
								'\n',
								didReadContent ? 1 + emptyLines : emptyLines,
							)

							// End of more-indented block.
						} else if (atMoreIndented) {
							atMoreIndented = false
							state.result += common.repeat('\n', emptyLines + 1)

							// Just one line break - perceive as the same line.
						} else if (emptyLines === 0) {
							if (didReadContent) {
								// i.e. only if we have already read some scalar content.
								state.result += ' '
							}

							// Several line breaks - perceive as different lines.
						} else {
							state.result += common.repeat('\n', emptyLines)
						}

						// Literal style: just add exact number of line breaks between content lines.
					} else {
						// Keep all line breaks except the header line break.
						state.result += common.repeat(
							'\n',
							didReadContent ? 1 + emptyLines : emptyLines,
						)
					}

					didReadContent = true
					detectedIndent = true
					emptyLines = 0
					captureStart = state.position

					while (!is_EOL(ch) && ch !== 0) {
						ch = state.input.charCodeAt(++state.position)
					}

					captureSegment(state, captureStart, state.position, false)
				}

				return true
			}

			function readBlockSequence(state, nodeIndent) {
				var _line,
					_tag = state.tag,
					_anchor = state.anchor,
					_result = [],
					following,
					detected = false,
					ch

				if (state.anchor !== null) {
					state.anchorMap[state.anchor] = _result
				}

				ch = state.input.charCodeAt(state.position)

				while (ch !== 0) {
					if (ch !== 0x2d /* - */) {
						break
					}

					following = state.input.charCodeAt(state.position + 1)

					if (!is_WS_OR_EOL(following)) {
						break
					}

					detected = true
					state.position++

					if (skipSeparationSpace(state, true, -1)) {
						if (state.lineIndent <= nodeIndent) {
							_result.push(null)
							ch = state.input.charCodeAt(state.position)
							continue
						}
					}

					_line = state.line
					composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true)
					_result.push(state.result)
					skipSeparationSpace(state, true, -1)

					ch = state.input.charCodeAt(state.position)

					if (
						(state.line === _line || state.lineIndent > nodeIndent) &&
						ch !== 0
					) {
						throwError(state, 'bad indentation of a sequence entry')
					} else if (state.lineIndent < nodeIndent) {
						break
					}
				}

				if (detected) {
					state.tag = _tag
					state.anchor = _anchor
					state.kind = 'sequence'
					state.result = _result
					return true
				}
				return false
			}

			function readBlockMapping(state, nodeIndent, flowIndent) {
				var following,
					allowCompact,
					_line,
					_pos,
					_tag = state.tag,
					_anchor = state.anchor,
					_result = {},
					overridableKeys = {},
					keyTag = null,
					keyNode = null,
					valueNode = null,
					atExplicitKey = false,
					detected = false,
					ch

				if (state.anchor !== null) {
					state.anchorMap[state.anchor] = _result
				}

				ch = state.input.charCodeAt(state.position)

				while (ch !== 0) {
					following = state.input.charCodeAt(state.position + 1)
					_line = state.line // Save the current line.
					_pos = state.position

					//
					// Explicit notation case. There are two separate blocks:
					// first for the key (denoted by "?") and second for the value (denoted by ":")
					//
					if (
						(ch === 0x3f /* ? */ || ch === 0x3a) /* : */ &&
						is_WS_OR_EOL(following)
					) {
						if (ch === 0x3f /* ? */) {
							if (atExplicitKey) {
								storeMappingPair(
									state,
									_result,
									overridableKeys,
									keyTag,
									keyNode,
									null,
								)
								keyTag = keyNode = valueNode = null
							}

							detected = true
							atExplicitKey = true
							allowCompact = true
						} else if (atExplicitKey) {
							// i.e. 0x3A/* : */ === character after the explicit key.
							atExplicitKey = false
							allowCompact = true
						} else {
							throwError(
								state,
								'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line',
							)
						}

						state.position += 1
						ch = following

						//
						// Implicit notation case. Flow-style node as the key first, then ":", and the value.
						//
					} else if (
						composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)
					) {
						if (state.line === _line) {
							ch = state.input.charCodeAt(state.position)

							while (is_WHITE_SPACE(ch)) {
								ch = state.input.charCodeAt(++state.position)
							}

							if (ch === 0x3a /* : */) {
								ch = state.input.charCodeAt(++state.position)

								if (!is_WS_OR_EOL(ch)) {
									throwError(
										state,
										'a whitespace character is expected after the key-value separator within a block mapping',
									)
								}

								if (atExplicitKey) {
									storeMappingPair(
										state,
										_result,
										overridableKeys,
										keyTag,
										keyNode,
										null,
									)
									keyTag = keyNode = valueNode = null
								}

								detected = true
								atExplicitKey = false
								allowCompact = false
								keyTag = state.tag
								keyNode = state.result
							} else if (detected) {
								throwError(
									state,
									'can not read an implicit mapping pair; a colon is missed',
								)
							} else {
								state.tag = _tag
								state.anchor = _anchor
								return true // Keep the result of `composeNode`.
							}
						} else if (detected) {
							throwError(
								state,
								'can not read a block mapping entry; a multiline key may not be an implicit key',
							)
						} else {
							state.tag = _tag
							state.anchor = _anchor
							return true // Keep the result of `composeNode`.
						}
					} else {
						break // Reading is done. Go to the epilogue.
					}

					//
					// Common reading code for both explicit and implicit notations.
					//
					if (state.line === _line || state.lineIndent > nodeIndent) {
						if (
							composeNode(
								state,
								nodeIndent,
								CONTEXT_BLOCK_OUT,
								true,
								allowCompact,
							)
						) {
							if (atExplicitKey) {
								keyNode = state.result
							} else {
								valueNode = state.result
							}
						}

						if (!atExplicitKey) {
							storeMappingPair(
								state,
								_result,
								overridableKeys,
								keyTag,
								keyNode,
								valueNode,
								_line,
								_pos,
							)
							keyTag = keyNode = valueNode = null
						}

						skipSeparationSpace(state, true, -1)
						ch = state.input.charCodeAt(state.position)
					}

					if (state.lineIndent > nodeIndent && ch !== 0) {
						throwError(state, 'bad indentation of a mapping entry')
					} else if (state.lineIndent < nodeIndent) {
						break
					}
				}

				//
				// Epilogue.
				//

				// Special case: last mapping's node contains only the key in explicit notation.
				if (atExplicitKey) {
					storeMappingPair(
						state,
						_result,
						overridableKeys,
						keyTag,
						keyNode,
						null,
					)
				}

				// Expose the resulting mapping.
				if (detected) {
					state.tag = _tag
					state.anchor = _anchor
					state.kind = 'mapping'
					state.result = _result
				}

				return detected
			}

			function readTagProperty(state) {
				var _position,
					isVerbatim = false,
					isNamed = false,
					tagHandle,
					tagName,
					ch

				ch = state.input.charCodeAt(state.position)

				if (ch !== 0x21 /* ! */) return false

				if (state.tag !== null) {
					throwError(state, 'duplication of a tag property')
				}

				ch = state.input.charCodeAt(++state.position)

				if (ch === 0x3c /* < */) {
					isVerbatim = true
					ch = state.input.charCodeAt(++state.position)
				} else if (ch === 0x21 /* ! */) {
					isNamed = true
					tagHandle = '!!'
					ch = state.input.charCodeAt(++state.position)
				} else {
					tagHandle = '!'
				}

				_position = state.position

				if (isVerbatim) {
					do {
						ch = state.input.charCodeAt(++state.position)
					} while (ch !== 0 && ch !== 0x3e /* > */)

					if (state.position < state.length) {
						tagName = state.input.slice(_position, state.position)
						ch = state.input.charCodeAt(++state.position)
					} else {
						throwError(
							state,
							'unexpected end of the stream within a verbatim tag',
						)
					}
				} else {
					while (ch !== 0 && !is_WS_OR_EOL(ch)) {
						if (ch === 0x21 /* ! */) {
							if (!isNamed) {
								tagHandle = state.input.slice(_position - 1, state.position + 1)

								if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
									throwError(
										state,
										'named tag handle cannot contain such characters',
									)
								}

								isNamed = true
								_position = state.position + 1
							} else {
								throwError(state, 'tag suffix cannot contain exclamation marks')
							}
						}

						ch = state.input.charCodeAt(++state.position)
					}

					tagName = state.input.slice(_position, state.position)

					if (PATTERN_FLOW_INDICATORS.test(tagName)) {
						throwError(
							state,
							'tag suffix cannot contain flow indicator characters',
						)
					}
				}

				if (tagName && !PATTERN_TAG_URI.test(tagName)) {
					throwError(
						state,
						'tag name cannot contain such characters: ' + tagName,
					)
				}

				if (isVerbatim) {
					state.tag = tagName
				} else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
					state.tag = state.tagMap[tagHandle] + tagName
				} else if (tagHandle === '!') {
					state.tag = '!' + tagName
				} else if (tagHandle === '!!') {
					state.tag = 'tag:yaml.org,2002:' + tagName
				} else {
					throwError(state, 'undeclared tag handle "' + tagHandle + '"')
				}

				return true
			}

			function readAnchorProperty(state) {
				var _position, ch

				ch = state.input.charCodeAt(state.position)

				if (ch !== 0x26 /* & */) return false

				if (state.anchor !== null) {
					throwError(state, 'duplication of an anchor property')
				}

				ch = state.input.charCodeAt(++state.position)
				_position = state.position

				while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
					ch = state.input.charCodeAt(++state.position)
				}

				if (state.position === _position) {
					throwError(
						state,
						'name of an anchor node must contain at least one character',
					)
				}

				state.anchor = state.input.slice(_position, state.position)
				return true
			}

			function readAlias(state) {
				var _position, alias, ch

				ch = state.input.charCodeAt(state.position)

				if (ch !== 0x2a /* * */) return false

				ch = state.input.charCodeAt(++state.position)
				_position = state.position

				while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
					ch = state.input.charCodeAt(++state.position)
				}

				if (state.position === _position) {
					throwError(
						state,
						'name of an alias node must contain at least one character',
					)
				}

				alias = state.input.slice(_position, state.position)

				if (!_hasOwnProperty.call(state.anchorMap, alias)) {
					throwError(state, 'unidentified alias "' + alias + '"')
				}

				state.result = state.anchorMap[alias]
				skipSeparationSpace(state, true, -1)
				return true
			}

			function composeNode(
				state,
				parentIndent,
				nodeContext,
				allowToSeek,
				allowCompact,
			) {
				var allowBlockStyles,
					allowBlockScalars,
					allowBlockCollections,
					indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
					atNewLine = false,
					hasContent = false,
					typeIndex,
					typeQuantity,
					type,
					flowIndent,
					blockIndent

				if (state.listener !== null) {
					state.listener('open', state)
				}

				state.tag = null
				state.anchor = null
				state.kind = null
				state.result = null

				allowBlockStyles =
					allowBlockScalars =
					allowBlockCollections =
						CONTEXT_BLOCK_OUT === nodeContext ||
						CONTEXT_BLOCK_IN === nodeContext

				if (allowToSeek) {
					if (skipSeparationSpace(state, true, -1)) {
						atNewLine = true

						if (state.lineIndent > parentIndent) {
							indentStatus = 1
						} else if (state.lineIndent === parentIndent) {
							indentStatus = 0
						} else if (state.lineIndent < parentIndent) {
							indentStatus = -1
						}
					}
				}

				if (indentStatus === 1) {
					while (readTagProperty(state) || readAnchorProperty(state)) {
						if (skipSeparationSpace(state, true, -1)) {
							atNewLine = true
							allowBlockCollections = allowBlockStyles

							if (state.lineIndent > parentIndent) {
								indentStatus = 1
							} else if (state.lineIndent === parentIndent) {
								indentStatus = 0
							} else if (state.lineIndent < parentIndent) {
								indentStatus = -1
							}
						} else {
							allowBlockCollections = false
						}
					}
				}

				if (allowBlockCollections) {
					allowBlockCollections = atNewLine || allowCompact
				}

				if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
					if (
						CONTEXT_FLOW_IN === nodeContext ||
						CONTEXT_FLOW_OUT === nodeContext
					) {
						flowIndent = parentIndent
					} else {
						flowIndent = parentIndent + 1
					}

					blockIndent = state.position - state.lineStart

					if (indentStatus === 1) {
						if (
							(allowBlockCollections &&
								(readBlockSequence(state, blockIndent) ||
									readBlockMapping(state, blockIndent, flowIndent))) ||
							readFlowCollection(state, flowIndent)
						) {
							hasContent = true
						} else {
							if (
								(allowBlockScalars && readBlockScalar(state, flowIndent)) ||
								readSingleQuotedScalar(state, flowIndent) ||
								readDoubleQuotedScalar(state, flowIndent)
							) {
								hasContent = true
							} else if (readAlias(state)) {
								hasContent = true

								if (state.tag !== null || state.anchor !== null) {
									throwError(state, 'alias node should not have any properties')
								}
							} else if (
								readPlainScalar(
									state,
									flowIndent,
									CONTEXT_FLOW_IN === nodeContext,
								)
							) {
								hasContent = true

								if (state.tag === null) {
									state.tag = '?'
								}
							}

							if (state.anchor !== null) {
								state.anchorMap[state.anchor] = state.result
							}
						}
					} else if (indentStatus === 0) {
						// Special case: block sequences are allowed to have same indentation level as the parent.
						// http://www.yaml.org/spec/1.2/spec.html#id2799784
						hasContent =
							allowBlockCollections && readBlockSequence(state, blockIndent)
					}
				}

				if (state.tag !== null && state.tag !== '!') {
					if (state.tag === '?') {
						// Implicit resolving is not allowed for non-scalar types, and '?'
						// non-specific tag is only automatically assigned to plain scalars.
						//
						// We only need to check kind conformity in case user explicitly assigns '?'
						// tag, for example like this: "!<?> [0]"
						//
						if (state.result !== null && state.kind !== 'scalar') {
							throwError(
								state,
								'unacceptable node kind for !<?> tag; it should be "scalar", not "' +
									state.kind +
									'"',
							)
						}

						for (
							typeIndex = 0, typeQuantity = state.implicitTypes.length;
							typeIndex < typeQuantity;
							typeIndex += 1
						) {
							type = state.implicitTypes[typeIndex]

							if (type.resolve(state.result)) {
								// `state.result` updated in resolver if matched
								state.result = type.construct(state.result)
								state.tag = type.tag
								if (state.anchor !== null) {
									state.anchorMap[state.anchor] = state.result
								}
								break
							}
						}
					} else if (
						_hasOwnProperty.call(
							state.typeMap[state.kind || 'fallback'],
							state.tag,
						)
					) {
						type = state.typeMap[state.kind || 'fallback'][state.tag]

						if (state.result !== null && type.kind !== state.kind) {
							throwError(
								state,
								'unacceptable node kind for !<' +
									state.tag +
									'> tag; it should be "' +
									type.kind +
									'", not "' +
									state.kind +
									'"',
							)
						}

						if (!type.resolve(state.result)) {
							// `state.result` updated in resolver if matched
							throwError(
								state,
								'cannot resolve a node with !<' + state.tag + '> explicit tag',
							)
						} else {
							state.result = type.construct(state.result)
							if (state.anchor !== null) {
								state.anchorMap[state.anchor] = state.result
							}
						}
					} else {
						throwError(state, 'unknown tag !<' + state.tag + '>')
					}
				}

				if (state.listener !== null) {
					state.listener('close', state)
				}
				return state.tag !== null || state.anchor !== null || hasContent
			}

			function readDocument(state) {
				var documentStart = state.position,
					_position,
					directiveName,
					directiveArgs,
					hasDirectives = false,
					ch

				state.version = null
				state.checkLineBreaks = state.legacy
				state.tagMap = {}
				state.anchorMap = {}

				while ((ch = state.input.charCodeAt(state.position)) !== 0) {
					skipSeparationSpace(state, true, -1)

					ch = state.input.charCodeAt(state.position)

					if (state.lineIndent > 0 || ch !== 0x25 /* % */) {
						break
					}

					hasDirectives = true
					ch = state.input.charCodeAt(++state.position)
					_position = state.position

					while (ch !== 0 && !is_WS_OR_EOL(ch)) {
						ch = state.input.charCodeAt(++state.position)
					}

					directiveName = state.input.slice(_position, state.position)
					directiveArgs = []

					if (directiveName.length < 1) {
						throwError(
							state,
							'directive name must not be less than one character in length',
						)
					}

					while (ch !== 0) {
						while (is_WHITE_SPACE(ch)) {
							ch = state.input.charCodeAt(++state.position)
						}

						if (ch === 0x23 /* # */) {
							do {
								ch = state.input.charCodeAt(++state.position)
							} while (ch !== 0 && !is_EOL(ch))
							break
						}

						if (is_EOL(ch)) break

						_position = state.position

						while (ch !== 0 && !is_WS_OR_EOL(ch)) {
							ch = state.input.charCodeAt(++state.position)
						}

						directiveArgs.push(state.input.slice(_position, state.position))
					}

					if (ch !== 0) readLineBreak(state)

					if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
						directiveHandlers[directiveName](
							state,
							directiveName,
							directiveArgs,
						)
					} else {
						throwWarning(
							state,
							'unknown document directive "' + directiveName + '"',
						)
					}
				}

				skipSeparationSpace(state, true, -1)

				if (
					state.lineIndent === 0 &&
					state.input.charCodeAt(state.position) === 0x2d /* - */ &&
					state.input.charCodeAt(state.position + 1) === 0x2d /* - */ &&
					state.input.charCodeAt(state.position + 2) === 0x2d /* - */
				) {
					state.position += 3
					skipSeparationSpace(state, true, -1)
				} else if (hasDirectives) {
					throwError(state, 'directives end mark is expected')
				}

				composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true)
				skipSeparationSpace(state, true, -1)

				if (
					state.checkLineBreaks &&
					PATTERN_NON_ASCII_LINE_BREAKS.test(
						state.input.slice(documentStart, state.position),
					)
				) {
					throwWarning(
						state,
						'non-ASCII line breaks are interpreted as content',
					)
				}

				state.documents.push(state.result)

				if (
					state.position === state.lineStart &&
					testDocumentSeparator(state)
				) {
					if (state.input.charCodeAt(state.position) === 0x2e /* . */) {
						state.position += 3
						skipSeparationSpace(state, true, -1)
					}
					return
				}

				if (state.position < state.length - 1) {
					throwError(
						state,
						'end of the stream or a document separator is expected',
					)
				} else {
					return
				}
			}

			function loadDocuments(input, options) {
				input = String(input)
				options = options || {}

				if (input.length !== 0) {
					// Add tailing `\n` if not exists
					if (
						input.charCodeAt(input.length - 1) !== 0x0a /* LF */ &&
						input.charCodeAt(input.length - 1) !== 0x0d /* CR */
					) {
						input += '\n'
					}

					// Strip BOM
					if (input.charCodeAt(0) === 0xfeff) {
						input = input.slice(1)
					}
				}

				var state = new State(input, options)

				var nullpos = input.indexOf('\0')

				if (nullpos !== -1) {
					state.position = nullpos
					throwError(state, 'null byte is not allowed in input')
				}

				// Use 0 as string terminator. That significantly simplifies bounds check.
				state.input += '\0'

				while (state.input.charCodeAt(state.position) === 0x20 /* Space */) {
					state.lineIndent += 1
					state.position += 1
				}

				while (state.position < state.length - 1) {
					readDocument(state)
				}

				return state.documents
			}

			function loadAll(input, iterator, options) {
				if (
					iterator !== null &&
					typeof iterator === 'object' &&
					typeof options === 'undefined'
				) {
					options = iterator
					iterator = null
				}

				var documents = loadDocuments(input, options)

				if (typeof iterator !== 'function') {
					return documents
				}

				for (
					var index = 0, length = documents.length;
					index < length;
					index += 1
				) {
					iterator(documents[index])
				}
			}

			function load(input, options) {
				var documents = loadDocuments(input, options)

				if (documents.length === 0) {
					/*eslint-disable no-undefined*/
					return undefined
				} else if (documents.length === 1) {
					return documents[0]
				}
				throw new YAMLException(
					'expected a single document in the stream, but found more',
				)
			}

			function safeLoadAll(input, iterator, options) {
				if (
					typeof iterator === 'object' &&
					iterator !== null &&
					typeof options === 'undefined'
				) {
					options = iterator
					iterator = null
				}

				return loadAll(
					input,
					iterator,
					common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options),
				)
			}

			function safeLoad(input, options) {
				return load(
					input,
					common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options),
				)
			}

			module.exports.loadAll = loadAll
			module.exports.load = load
			module.exports.safeLoadAll = safeLoadAll
			module.exports.safeLoad = safeLoad

			/***/
		},

		/***/ 45622: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var common = __nccwpck_require__(24206)

			function Mark(name, buffer, position, line, column) {
				this.name = name
				this.buffer = buffer
				this.position = position
				this.line = line
				this.column = column
			}

			Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
				var head, start, tail, end, snippet

				if (!this.buffer) return null

				indent = indent || 4
				maxLength = maxLength || 75

				head = ''
				start = this.position

				while (
					start > 0 &&
					'\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) ===
						-1
				) {
					start -= 1
					if (this.position - start > maxLength / 2 - 1) {
						head = ' ... '
						start += 5
						break
					}
				}

				tail = ''
				end = this.position

				while (
					end < this.buffer.length &&
					'\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1
				) {
					end += 1
					if (end - this.position > maxLength / 2 - 1) {
						tail = ' ... '
						end -= 5
						break
					}
				}

				snippet = this.buffer.slice(start, end)

				return (
					common.repeat(' ', indent) +
					head +
					snippet +
					tail +
					'\n' +
					common.repeat(' ', indent + this.position - start + head.length) +
					'^'
				)
			}

			Mark.prototype.toString = function toString(compact) {
				var snippet,
					where = ''

				if (this.name) {
					where += 'in "' + this.name + '" '
				}

				where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1)

				if (!compact) {
					snippet = this.getSnippet()

					if (snippet) {
						where += ':\n' + snippet
					}
				}

				return where
			}

			module.exports = Mark

			/***/
		},

		/***/ 45868: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			/*eslint-disable max-len*/

			var common = __nccwpck_require__(24206)
			var YAMLException = __nccwpck_require__(15622)
			var Type = __nccwpck_require__(50323)

			function compileList(schema, name, result) {
				var exclude = []

				schema.include.forEach(function (includedSchema) {
					result = compileList(includedSchema, name, result)
				})

				schema[name].forEach(function (currentType) {
					result.forEach(function (previousType, previousIndex) {
						if (
							previousType.tag === currentType.tag &&
							previousType.kind === currentType.kind
						) {
							exclude.push(previousIndex)
						}
					})

					result.push(currentType)
				})

				return result.filter(function (type, index) {
					return exclude.indexOf(index) === -1
				})
			}

			function compileMap(/* lists... */) {
				var result = {
						scalar: {},
						sequence: {},
						mapping: {},
						fallback: {},
					},
					index,
					length

				function collectType(type) {
					result[type.kind][type.tag] = result['fallback'][type.tag] = type
				}

				for (index = 0, length = arguments.length; index < length; index += 1) {
					arguments[index].forEach(collectType)
				}
				return result
			}

			function Schema(definition) {
				this.include = definition.include || []
				this.implicit = definition.implicit || []
				this.explicit = definition.explicit || []

				this.implicit.forEach(function (type) {
					if (type.loadKind && type.loadKind !== 'scalar') {
						throw new YAMLException(
							'There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.',
						)
					}
				})

				this.compiledImplicit = compileList(this, 'implicit', [])
				this.compiledExplicit = compileList(this, 'explicit', [])
				this.compiledTypeMap = compileMap(
					this.compiledImplicit,
					this.compiledExplicit,
				)
			}

			Schema.DEFAULT = null

			Schema.create = function createSchema() {
				var schemas, types

				switch (arguments.length) {
					case 1:
						schemas = Schema.DEFAULT
						types = arguments[0]
						break

					case 2:
						schemas = arguments[0]
						types = arguments[1]
						break

					default:
						throw new YAMLException(
							'Wrong number of arguments for Schema.create function',
						)
				}

				schemas = common.toArray(schemas)
				types = common.toArray(types)

				if (
					!schemas.every(function (schema) {
						return schema instanceof Schema
					})
				) {
					throw new YAMLException(
						'Specified list of super schemas (or a single Schema object) contains a non-Schema object.',
					)
				}

				if (
					!types.every(function (type) {
						return type instanceof Type
					})
				) {
					throw new YAMLException(
						'Specified list of YAML types (or a single Type object) contains a non-Type object.',
					)
				}

				return new Schema({
					include: schemas,
					explicit: types,
				})
			}

			module.exports = Schema

			/***/
		},

		/***/ 55116: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'
			// Standard YAML's Core schema.
			// http://www.yaml.org/spec/1.2/spec.html#id2804923
			//
			// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
			// So, Core schema has no distinctions from JSON schema is JS-YAML.

			var Schema = __nccwpck_require__(45868)

			module.exports = new Schema({
				include: [__nccwpck_require__(96613)],
			})

			/***/
		},

		/***/ 60948: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'
			// JS-YAML's default schema for `load` function.
			// It is not described in the YAML specification.
			//
			// This schema is based on JS-YAML's default safe schema and includes
			// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
			//
			// Also this schema is used as default base schema at `Schema.create` function.

			var Schema = __nccwpck_require__(45868)

			module.exports = Schema.DEFAULT = new Schema({
				include: [__nccwpck_require__(76032)],
				explicit: [
					__nccwpck_require__(49178),
					__nccwpck_require__(98953),
					__nccwpck_require__(31832),
				],
			})

			/***/
		},

		/***/ 76032: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'
			// JS-YAML's default schema for `safeLoad` function.
			// It is not described in the YAML specification.
			//
			// This schema is based on standard YAML's Core schema and includes most of
			// extra types described at YAML tag repository. (http://yaml.org/type/)

			var Schema = __nccwpck_require__(45868)

			module.exports = new Schema({
				include: [__nccwpck_require__(55116)],
				implicit: [__nccwpck_require__(37044), __nccwpck_require__(70112)],
				explicit: [
					__nccwpck_require__(95295),
					__nccwpck_require__(47395),
					__nccwpck_require__(59117),
					__nccwpck_require__(17812),
				],
			})

			/***/
		},

		/***/ 86810: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'
			// Standard YAML's Failsafe schema.
			// http://www.yaml.org/spec/1.2/spec.html#id2802346

			var Schema = __nccwpck_require__(45868)

			module.exports = new Schema({
				explicit: [
					__nccwpck_require__(94107),
					__nccwpck_require__(12863),
					__nccwpck_require__(54278),
				],
			})

			/***/
		},

		/***/ 96613: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'
			// Standard YAML's JSON schema.
			// http://www.yaml.org/spec/1.2/spec.html#id2803231
			//
			// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
			// So, this schema is not such strict as defined in the YAML specification.
			// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.

			var Schema = __nccwpck_require__(45868)

			module.exports = new Schema({
				include: [__nccwpck_require__(86810)],
				implicit: [
					__nccwpck_require__(37767),
					__nccwpck_require__(23066),
					__nccwpck_require__(90053),
					__nccwpck_require__(13122),
				],
			})

			/***/
		},

		/***/ 50323: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var YAMLException = __nccwpck_require__(15622)

			var TYPE_CONSTRUCTOR_OPTIONS = [
				'kind',
				'resolve',
				'construct',
				'instanceOf',
				'predicate',
				'represent',
				'defaultStyle',
				'styleAliases',
			]

			var YAML_NODE_KINDS = ['scalar', 'sequence', 'mapping']

			function compileStyleAliases(map) {
				var result = {}

				if (map !== null) {
					Object.keys(map).forEach(function (style) {
						map[style].forEach(function (alias) {
							result[String(alias)] = style
						})
					})
				}

				return result
			}

			function Type(tag, options) {
				options = options || {}

				Object.keys(options).forEach(function (name) {
					if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
						throw new YAMLException(
							'Unknown option "' +
								name +
								'" is met in definition of "' +
								tag +
								'" YAML type.',
						)
					}
				})

				// TODO: Add tag format check.
				this.tag = tag
				this.kind = options['kind'] || null
				this.resolve =
					options['resolve'] ||
					function () {
						return true
					}
				this.construct =
					options['construct'] ||
					function (data) {
						return data
					}
				this.instanceOf = options['instanceOf'] || null
				this.predicate = options['predicate'] || null
				this.represent = options['represent'] || null
				this.defaultStyle = options['defaultStyle'] || null
				this.styleAliases = compileStyleAliases(options['styleAliases'] || null)

				if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
					throw new YAMLException(
						'Unknown kind "' +
							this.kind +
							'" is specified for "' +
							tag +
							'" YAML type.',
					)
				}
			}

			module.exports = Type

			/***/
		},

		/***/ 95295: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			/*eslint-disable no-bitwise*/

			var NodeBuffer

			try {
				// A trick for browserified version, to not include `Buffer` shim
				var _require = require
				NodeBuffer = _require('buffer').Buffer
			} catch (__) {}

			var Type = __nccwpck_require__(50323)

			// [ 64, 65, 66 ] -> [ padding, CR, LF ]
			var BASE64_MAP =
				'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r'

			function resolveYamlBinary(data) {
				if (data === null) return false

				var code,
					idx,
					bitlen = 0,
					max = data.length,
					map = BASE64_MAP

				// Convert one by one.
				for (idx = 0; idx < max; idx++) {
					code = map.indexOf(data.charAt(idx))

					// Skip CR/LF
					if (code > 64) continue

					// Fail on illegal characters
					if (code < 0) return false

					bitlen += 6
				}

				// If there are any bits left, source was corrupted
				return bitlen % 8 === 0
			}

			function constructYamlBinary(data) {
				var idx,
					tailbits,
					input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
					max = input.length,
					map = BASE64_MAP,
					bits = 0,
					result = []

				// Collect by 6*4 bits (3 bytes)

				for (idx = 0; idx < max; idx++) {
					if (idx % 4 === 0 && idx) {
						result.push((bits >> 16) & 0xff)
						result.push((bits >> 8) & 0xff)
						result.push(bits & 0xff)
					}

					bits = (bits << 6) | map.indexOf(input.charAt(idx))
				}

				// Dump tail

				tailbits = (max % 4) * 6

				if (tailbits === 0) {
					result.push((bits >> 16) & 0xff)
					result.push((bits >> 8) & 0xff)
					result.push(bits & 0xff)
				} else if (tailbits === 18) {
					result.push((bits >> 10) & 0xff)
					result.push((bits >> 2) & 0xff)
				} else if (tailbits === 12) {
					result.push((bits >> 4) & 0xff)
				}

				// Wrap into Buffer for NodeJS and leave Array for browser
				if (NodeBuffer) {
					// Support node 6.+ Buffer API when available
					return NodeBuffer.from
						? NodeBuffer.from(result)
						: new NodeBuffer(result)
				}

				return result
			}

			function representYamlBinary(object /*, style*/) {
				var result = '',
					bits = 0,
					idx,
					tail,
					max = object.length,
					map = BASE64_MAP

				// Convert every three bytes to 4 ASCII characters.

				for (idx = 0; idx < max; idx++) {
					if (idx % 3 === 0 && idx) {
						result += map[(bits >> 18) & 0x3f]
						result += map[(bits >> 12) & 0x3f]
						result += map[(bits >> 6) & 0x3f]
						result += map[bits & 0x3f]
					}

					bits = (bits << 8) + object[idx]
				}

				// Dump tail

				tail = max % 3

				if (tail === 0) {
					result += map[(bits >> 18) & 0x3f]
					result += map[(bits >> 12) & 0x3f]
					result += map[(bits >> 6) & 0x3f]
					result += map[bits & 0x3f]
				} else if (tail === 2) {
					result += map[(bits >> 10) & 0x3f]
					result += map[(bits >> 4) & 0x3f]
					result += map[(bits << 2) & 0x3f]
					result += map[64]
				} else if (tail === 1) {
					result += map[(bits >> 2) & 0x3f]
					result += map[(bits << 4) & 0x3f]
					result += map[64]
					result += map[64]
				}

				return result
			}

			function isBinary(object) {
				return NodeBuffer && NodeBuffer.isBuffer(object)
			}

			module.exports = new Type('tag:yaml.org,2002:binary', {
				kind: 'scalar',
				resolve: resolveYamlBinary,
				construct: constructYamlBinary,
				predicate: isBinary,
				represent: representYamlBinary,
			})

			/***/
		},

		/***/ 23066: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var Type = __nccwpck_require__(50323)

			function resolveYamlBoolean(data) {
				if (data === null) return false

				var max = data.length

				return (
					(max === 4 &&
						(data === 'true' || data === 'True' || data === 'TRUE')) ||
					(max === 5 &&
						(data === 'false' || data === 'False' || data === 'FALSE'))
				)
			}

			function constructYamlBoolean(data) {
				return data === 'true' || data === 'True' || data === 'TRUE'
			}

			function isBoolean(object) {
				return Object.prototype.toString.call(object) === '[object Boolean]'
			}

			module.exports = new Type('tag:yaml.org,2002:bool', {
				kind: 'scalar',
				resolve: resolveYamlBoolean,
				construct: constructYamlBoolean,
				predicate: isBoolean,
				represent: {
					lowercase: function (object) {
						return object ? 'true' : 'false'
					},
					uppercase: function (object) {
						return object ? 'TRUE' : 'FALSE'
					},
					camelcase: function (object) {
						return object ? 'True' : 'False'
					},
				},
				defaultStyle: 'lowercase',
			})

			/***/
		},

		/***/ 13122: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var common = __nccwpck_require__(24206)
			var Type = __nccwpck_require__(50323)

			var YAML_FLOAT_PATTERN = new RegExp(
				// 2.5e4, 2.5 and integers
				'^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
					// .2e4, .2
					// special case, seems not from spec
					'|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
					// 20:59
					'|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
					// .inf
					'|[-+]?\\.(?:inf|Inf|INF)' +
					// .nan
					'|\\.(?:nan|NaN|NAN))$',
			)

			function resolveYamlFloat(data) {
				if (data === null) return false

				if (
					!YAML_FLOAT_PATTERN.test(data) ||
					// Quick hack to not allow integers end with `_`
					// Probably should update regexp & check speed
					data[data.length - 1] === '_'
				) {
					return false
				}

				return true
			}

			function constructYamlFloat(data) {
				var value, sign, base, digits

				value = data.replace(/_/g, '').toLowerCase()
				sign = value[0] === '-' ? -1 : 1
				digits = []

				if ('+-'.indexOf(value[0]) >= 0) {
					value = value.slice(1)
				}

				if (value === '.inf') {
					return sign === 1
						? Number.POSITIVE_INFINITY
						: Number.NEGATIVE_INFINITY
				} else if (value === '.nan') {
					return NaN
				} else if (value.indexOf(':') >= 0) {
					value.split(':').forEach(function (v) {
						digits.unshift(parseFloat(v, 10))
					})

					value = 0.0
					base = 1

					digits.forEach(function (d) {
						value += d * base
						base *= 60
					})

					return sign * value
				}
				return sign * parseFloat(value, 10)
			}

			var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/

			function representYamlFloat(object, style) {
				var res

				if (isNaN(object)) {
					switch (style) {
						case 'lowercase':
							return '.nan'
						case 'uppercase':
							return '.NAN'
						case 'camelcase':
							return '.NaN'
					}
				} else if (Number.POSITIVE_INFINITY === object) {
					switch (style) {
						case 'lowercase':
							return '.inf'
						case 'uppercase':
							return '.INF'
						case 'camelcase':
							return '.Inf'
					}
				} else if (Number.NEGATIVE_INFINITY === object) {
					switch (style) {
						case 'lowercase':
							return '-.inf'
						case 'uppercase':
							return '-.INF'
						case 'camelcase':
							return '-.Inf'
					}
				} else if (common.isNegativeZero(object)) {
					return '-0.0'
				}

				res = object.toString(10)

				// JS stringifier can build scientific format without dots: 5e-100,
				// while YAML requres dot: 5.e-100. Fix it with simple hack

				return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res
			}

			function isFloat(object) {
				return (
					Object.prototype.toString.call(object) === '[object Number]' &&
					(object % 1 !== 0 || common.isNegativeZero(object))
				)
			}

			module.exports = new Type('tag:yaml.org,2002:float', {
				kind: 'scalar',
				resolve: resolveYamlFloat,
				construct: constructYamlFloat,
				predicate: isFloat,
				represent: representYamlFloat,
				defaultStyle: 'lowercase',
			})

			/***/
		},

		/***/ 90053: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var common = __nccwpck_require__(24206)
			var Type = __nccwpck_require__(50323)

			function isHexCode(c) {
				return (
					(0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) ||
					(0x41 /* A */ <= c && c <= 0x46 /* F */) ||
					(0x61 /* a */ <= c && c <= 0x66 /* f */)
				)
			}

			function isOctCode(c) {
				return 0x30 /* 0 */ <= c && c <= 0x37 /* 7 */
			}

			function isDecCode(c) {
				return 0x30 /* 0 */ <= c && c <= 0x39 /* 9 */
			}

			function resolveYamlInteger(data) {
				if (data === null) return false

				var max = data.length,
					index = 0,
					hasDigits = false,
					ch

				if (!max) return false

				ch = data[index]

				// sign
				if (ch === '-' || ch === '+') {
					ch = data[++index]
				}

				if (ch === '0') {
					// 0
					if (index + 1 === max) return true
					ch = data[++index]

					// base 2, base 8, base 16

					if (ch === 'b') {
						// base 2
						index++

						for (; index < max; index++) {
							ch = data[index]
							if (ch === '_') continue
							if (ch !== '0' && ch !== '1') return false
							hasDigits = true
						}
						return hasDigits && ch !== '_'
					}

					if (ch === 'x') {
						// base 16
						index++

						for (; index < max; index++) {
							ch = data[index]
							if (ch === '_') continue
							if (!isHexCode(data.charCodeAt(index))) return false
							hasDigits = true
						}
						return hasDigits && ch !== '_'
					}

					// base 8
					for (; index < max; index++) {
						ch = data[index]
						if (ch === '_') continue
						if (!isOctCode(data.charCodeAt(index))) return false
						hasDigits = true
					}
					return hasDigits && ch !== '_'
				}

				// base 10 (except 0) or base 60

				// value should not start with `_`;
				if (ch === '_') return false

				for (; index < max; index++) {
					ch = data[index]
					if (ch === '_') continue
					if (ch === ':') break
					if (!isDecCode(data.charCodeAt(index))) {
						return false
					}
					hasDigits = true
				}

				// Should have digits and should not end with `_`
				if (!hasDigits || ch === '_') return false

				// if !base60 - done;
				if (ch !== ':') return true

				// base60 almost not used, no needs to optimize
				return /^(:[0-5]?[0-9])+$/.test(data.slice(index))
			}

			function constructYamlInteger(data) {
				var value = data,
					sign = 1,
					ch,
					base,
					digits = []

				if (value.indexOf('_') !== -1) {
					value = value.replace(/_/g, '')
				}

				ch = value[0]

				if (ch === '-' || ch === '+') {
					if (ch === '-') sign = -1
					value = value.slice(1)
					ch = value[0]
				}

				if (value === '0') return 0

				if (ch === '0') {
					if (value[1] === 'b') return sign * parseInt(value.slice(2), 2)
					if (value[1] === 'x') return sign * parseInt(value, 16)
					return sign * parseInt(value, 8)
				}

				if (value.indexOf(':') !== -1) {
					value.split(':').forEach(function (v) {
						digits.unshift(parseInt(v, 10))
					})

					value = 0
					base = 1

					digits.forEach(function (d) {
						value += d * base
						base *= 60
					})

					return sign * value
				}

				return sign * parseInt(value, 10)
			}

			function isInteger(object) {
				return (
					Object.prototype.toString.call(object) === '[object Number]' &&
					object % 1 === 0 &&
					!common.isNegativeZero(object)
				)
			}

			module.exports = new Type('tag:yaml.org,2002:int', {
				kind: 'scalar',
				resolve: resolveYamlInteger,
				construct: constructYamlInteger,
				predicate: isInteger,
				represent: {
					binary: function (obj) {
						return obj >= 0
							? '0b' + obj.toString(2)
							: '-0b' + obj.toString(2).slice(1)
					},
					octal: function (obj) {
						return obj >= 0
							? '0' + obj.toString(8)
							: '-0' + obj.toString(8).slice(1)
					},
					decimal: function (obj) {
						return obj.toString(10)
					},
					/* eslint-disable max-len */
					hexadecimal: function (obj) {
						return obj >= 0
							? '0x' + obj.toString(16).toUpperCase()
							: '-0x' + obj.toString(16).toUpperCase().slice(1)
					},
				},
				defaultStyle: 'decimal',
				styleAliases: {
					binary: [2, 'bin'],
					octal: [8, 'oct'],
					decimal: [10, 'dec'],
					hexadecimal: [16, 'hex'],
				},
			})

			/***/
		},

		/***/ 31832: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var esprima

			// Browserified version does not have esprima
			//
			// 1. For node.js just require module as deps
			// 2. For browser try to require mudule via external AMD system.
			//    If not found - try to fallback to window.esprima. If not
			//    found too - then fail to parse.
			//
			try {
				// workaround to exclude package from browserify list.
				var _require = require
				esprima = _require('esprima')
			} catch (_) {
				/* eslint-disable no-redeclare */
				/* global window */
				if (typeof window !== 'undefined') esprima = window.esprima
			}

			var Type = __nccwpck_require__(50323)

			function resolveJavascriptFunction(data) {
				if (data === null) return false

				try {
					var source = '(' + data + ')',
						ast = esprima.parse(source, { range: true })

					if (
						ast.type !== 'Program' ||
						ast.body.length !== 1 ||
						ast.body[0].type !== 'ExpressionStatement' ||
						(ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
							ast.body[0].expression.type !== 'FunctionExpression')
					) {
						return false
					}

					return true
				} catch (err) {
					return false
				}
			}

			function constructJavascriptFunction(data) {
				/*jslint evil:true*/

				var source = '(' + data + ')',
					ast = esprima.parse(source, { range: true }),
					params = [],
					body

				if (
					ast.type !== 'Program' ||
					ast.body.length !== 1 ||
					ast.body[0].type !== 'ExpressionStatement' ||
					(ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
						ast.body[0].expression.type !== 'FunctionExpression')
				) {
					throw new Error('Failed to resolve function')
				}

				ast.body[0].expression.params.forEach(function (param) {
					params.push(param.name)
				})

				body = ast.body[0].expression.body.range

				// Esprima's ranges include the first '{' and the last '}' characters on
				// function expressions. So cut them out.
				if (ast.body[0].expression.body.type === 'BlockStatement') {
					/*eslint-disable no-new-func*/
					return new Function(params, source.slice(body[0] + 1, body[1] - 1))
				}
				// ES6 arrow functions can omit the BlockStatement. In that case, just return
				// the body.
				/*eslint-disable no-new-func*/
				return new Function(params, 'return ' + source.slice(body[0], body[1]))
			}

			function representJavascriptFunction(object /*, style*/) {
				return object.toString()
			}

			function isFunction(object) {
				return Object.prototype.toString.call(object) === '[object Function]'
			}

			module.exports = new Type('tag:yaml.org,2002:js/function', {
				kind: 'scalar',
				resolve: resolveJavascriptFunction,
				construct: constructJavascriptFunction,
				predicate: isFunction,
				represent: representJavascriptFunction,
			})

			/***/
		},

		/***/ 98953: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var Type = __nccwpck_require__(50323)

			function resolveJavascriptRegExp(data) {
				if (data === null) return false
				if (data.length === 0) return false

				var regexp = data,
					tail = /\/([gim]*)$/.exec(data),
					modifiers = ''

				// if regexp starts with '/' it can have modifiers and must be properly closed
				// `/foo/gim` - modifiers tail can be maximum 3 chars
				if (regexp[0] === '/') {
					if (tail) modifiers = tail[1]

					if (modifiers.length > 3) return false
					// if expression starts with /, is should be properly terminated
					if (regexp[regexp.length - modifiers.length - 1] !== '/') return false
				}

				return true
			}

			function constructJavascriptRegExp(data) {
				var regexp = data,
					tail = /\/([gim]*)$/.exec(data),
					modifiers = ''

				// `/foo/gim` - tail can be maximum 4 chars
				if (regexp[0] === '/') {
					if (tail) modifiers = tail[1]
					regexp = regexp.slice(1, regexp.length - modifiers.length - 1)
				}

				return new RegExp(regexp, modifiers)
			}

			function representJavascriptRegExp(object /*, style*/) {
				var result = '/' + object.source + '/'

				if (object.global) result += 'g'
				if (object.multiline) result += 'm'
				if (object.ignoreCase) result += 'i'

				return result
			}

			function isRegExp(object) {
				return Object.prototype.toString.call(object) === '[object RegExp]'
			}

			module.exports = new Type('tag:yaml.org,2002:js/regexp', {
				kind: 'scalar',
				resolve: resolveJavascriptRegExp,
				construct: constructJavascriptRegExp,
				predicate: isRegExp,
				represent: representJavascriptRegExp,
			})

			/***/
		},

		/***/ 49178: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var Type = __nccwpck_require__(50323)

			function resolveJavascriptUndefined() {
				return true
			}

			function constructJavascriptUndefined() {
				/*eslint-disable no-undefined*/
				return undefined
			}

			function representJavascriptUndefined() {
				return ''
			}

			function isUndefined(object) {
				return typeof object === 'undefined'
			}

			module.exports = new Type('tag:yaml.org,2002:js/undefined', {
				kind: 'scalar',
				resolve: resolveJavascriptUndefined,
				construct: constructJavascriptUndefined,
				predicate: isUndefined,
				represent: representJavascriptUndefined,
			})

			/***/
		},

		/***/ 54278: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var Type = __nccwpck_require__(50323)

			module.exports = new Type('tag:yaml.org,2002:map', {
				kind: 'mapping',
				construct: function (data) {
					return data !== null ? data : {}
				},
			})

			/***/
		},

		/***/ 70112: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var Type = __nccwpck_require__(50323)

			function resolveYamlMerge(data) {
				return data === '<<' || data === null
			}

			module.exports = new Type('tag:yaml.org,2002:merge', {
				kind: 'scalar',
				resolve: resolveYamlMerge,
			})

			/***/
		},

		/***/ 37767: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var Type = __nccwpck_require__(50323)

			function resolveYamlNull(data) {
				if (data === null) return true

				var max = data.length

				return (
					(max === 1 && data === '~') ||
					(max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'))
				)
			}

			function constructYamlNull() {
				return null
			}

			function isNull(object) {
				return object === null
			}

			module.exports = new Type('tag:yaml.org,2002:null', {
				kind: 'scalar',
				resolve: resolveYamlNull,
				construct: constructYamlNull,
				predicate: isNull,
				represent: {
					canonical: function () {
						return '~'
					},
					lowercase: function () {
						return 'null'
					},
					uppercase: function () {
						return 'NULL'
					},
					camelcase: function () {
						return 'Null'
					},
				},
				defaultStyle: 'lowercase',
			})

			/***/
		},

		/***/ 47395: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var Type = __nccwpck_require__(50323)

			var _hasOwnProperty = Object.prototype.hasOwnProperty
			var _toString = Object.prototype.toString

			function resolveYamlOmap(data) {
				if (data === null) return true

				var objectKeys = [],
					index,
					length,
					pair,
					pairKey,
					pairHasKey,
					object = data

				for (index = 0, length = object.length; index < length; index += 1) {
					pair = object[index]
					pairHasKey = false

					if (_toString.call(pair) !== '[object Object]') return false

					for (pairKey in pair) {
						if (_hasOwnProperty.call(pair, pairKey)) {
							if (!pairHasKey) pairHasKey = true
							else return false
						}
					}

					if (!pairHasKey) return false

					if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey)
					else return false
				}

				return true
			}

			function constructYamlOmap(data) {
				return data !== null ? data : []
			}

			module.exports = new Type('tag:yaml.org,2002:omap', {
				kind: 'sequence',
				resolve: resolveYamlOmap,
				construct: constructYamlOmap,
			})

			/***/
		},

		/***/ 59117: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var Type = __nccwpck_require__(50323)

			var _toString = Object.prototype.toString

			function resolveYamlPairs(data) {
				if (data === null) return true

				var index,
					length,
					pair,
					keys,
					result,
					object = data

				result = new Array(object.length)

				for (index = 0, length = object.length; index < length; index += 1) {
					pair = object[index]

					if (_toString.call(pair) !== '[object Object]') return false

					keys = Object.keys(pair)

					if (keys.length !== 1) return false

					result[index] = [keys[0], pair[keys[0]]]
				}

				return true
			}

			function constructYamlPairs(data) {
				if (data === null) return []

				var index,
					length,
					pair,
					keys,
					result,
					object = data

				result = new Array(object.length)

				for (index = 0, length = object.length; index < length; index += 1) {
					pair = object[index]

					keys = Object.keys(pair)

					result[index] = [keys[0], pair[keys[0]]]
				}

				return result
			}

			module.exports = new Type('tag:yaml.org,2002:pairs', {
				kind: 'sequence',
				resolve: resolveYamlPairs,
				construct: constructYamlPairs,
			})

			/***/
		},

		/***/ 12863: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var Type = __nccwpck_require__(50323)

			module.exports = new Type('tag:yaml.org,2002:seq', {
				kind: 'sequence',
				construct: function (data) {
					return data !== null ? data : []
				},
			})

			/***/
		},

		/***/ 17812: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var Type = __nccwpck_require__(50323)

			var _hasOwnProperty = Object.prototype.hasOwnProperty

			function resolveYamlSet(data) {
				if (data === null) return true

				var key,
					object = data

				for (key in object) {
					if (_hasOwnProperty.call(object, key)) {
						if (object[key] !== null) return false
					}
				}

				return true
			}

			function constructYamlSet(data) {
				return data !== null ? data : {}
			}

			module.exports = new Type('tag:yaml.org,2002:set', {
				kind: 'mapping',
				resolve: resolveYamlSet,
				construct: constructYamlSet,
			})

			/***/
		},

		/***/ 94107: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var Type = __nccwpck_require__(50323)

			module.exports = new Type('tag:yaml.org,2002:str', {
				kind: 'scalar',
				construct: function (data) {
					return data !== null ? data : ''
				},
			})

			/***/
		},

		/***/ 37044: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var Type = __nccwpck_require__(50323)

			var YAML_DATE_REGEXP = new RegExp(
				'^([0-9][0-9][0-9][0-9])' + // [1] year
					'-([0-9][0-9])' + // [2] month
					'-([0-9][0-9])$',
			) // [3] day

			var YAML_TIMESTAMP_REGEXP = new RegExp(
				'^([0-9][0-9][0-9][0-9])' + // [1] year
					'-([0-9][0-9]?)' + // [2] month
					'-([0-9][0-9]?)' + // [3] day
					'(?:[Tt]|[ \\t]+)' + // ...
					'([0-9][0-9]?)' + // [4] hour
					':([0-9][0-9])' + // [5] minute
					':([0-9][0-9])' + // [6] second
					'(?:\\.([0-9]*))?' + // [7] fraction
					'(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
					'(?::([0-9][0-9]))?))?$',
			) // [11] tz_minute

			function resolveYamlTimestamp(data) {
				if (data === null) return false
				if (YAML_DATE_REGEXP.exec(data) !== null) return true
				if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true
				return false
			}

			function constructYamlTimestamp(data) {
				var match,
					year,
					month,
					day,
					hour,
					minute,
					second,
					fraction = 0,
					delta = null,
					tz_hour,
					tz_minute,
					date

				match = YAML_DATE_REGEXP.exec(data)
				if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data)

				if (match === null) throw new Error('Date resolve error')

				// match: [1] year [2] month [3] day

				year = +match[1]
				month = +match[2] - 1 // JS month starts with 0
				day = +match[3]

				if (!match[4]) {
					// no hour
					return new Date(Date.UTC(year, month, day))
				}

				// match: [4] hour [5] minute [6] second [7] fraction

				hour = +match[4]
				minute = +match[5]
				second = +match[6]

				if (match[7]) {
					fraction = match[7].slice(0, 3)
					while (fraction.length < 3) {
						// milli-seconds
						fraction += '0'
					}
					fraction = +fraction
				}

				// match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

				if (match[9]) {
					tz_hour = +match[10]
					tz_minute = +(match[11] || 0)
					delta = (tz_hour * 60 + tz_minute) * 60000 // delta in mili-seconds
					if (match[9] === '-') delta = -delta
				}

				date = new Date(
					Date.UTC(year, month, day, hour, minute, second, fraction),
				)

				if (delta) date.setTime(date.getTime() - delta)

				return date
			}

			function representYamlTimestamp(object /*, style*/) {
				return object.toISOString()
			}

			module.exports = new Type('tag:yaml.org,2002:timestamp', {
				kind: 'scalar',
				resolve: resolveYamlTimestamp,
				construct: constructYamlTimestamp,
				instanceOf: Date,
				represent: representYamlTimestamp,
			})

			/***/
		},

		/***/ 59376: /***/ (module) => {
			'use strict'

			const object = {}
			const hasOwnProperty = object.hasOwnProperty
			const forOwn = (object, callback) => {
				for (const key in object) {
					if (hasOwnProperty.call(object, key)) {
						callback(key, object[key])
					}
				}
			}

			const extend = (destination, source) => {
				if (!source) {
					return destination
				}
				forOwn(source, (key, value) => {
					destination[key] = value
				})
				return destination
			}

			const forEach = (array, callback) => {
				const length = array.length
				let index = -1
				while (++index < length) {
					callback(array[index])
				}
			}

			const fourHexEscape = (hex) => {
				return '\\u' + ('0000' + hex).slice(-4)
			}

			const hexadecimal = (code, lowercase) => {
				let hexadecimal = code.toString(16)
				if (lowercase) return hexadecimal
				return hexadecimal.toUpperCase()
			}

			const toString = object.toString
			const isArray = Array.isArray
			const isBuffer = (value) => {
				return typeof Buffer === 'function' && Buffer.isBuffer(value)
			}
			const isObject = (value) => {
				// This is a very simple check, but its good enough for what we need.
				return toString.call(value) == '[object Object]'
			}
			const isString = (value) => {
				return (
					typeof value == 'string' || toString.call(value) == '[object String]'
				)
			}
			const isNumber = (value) => {
				return (
					typeof value == 'number' || toString.call(value) == '[object Number]'
				)
			}
			const isBigInt = (value) => {
				return typeof value == 'bigint'
			}
			const isFunction = (value) => {
				return typeof value == 'function'
			}
			const isMap = (value) => {
				return toString.call(value) == '[object Map]'
			}
			const isSet = (value) => {
				return toString.call(value) == '[object Set]'
			}

			/*--------------------------------------------------------------------------*/

			// https://mathiasbynens.be/notes/javascript-escapes#single
			const singleEscapes = {
				'\\': '\\\\',
				'\b': '\\b',
				'\f': '\\f',
				'\n': '\\n',
				'\r': '\\r',
				'\t': '\\t',
				// `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
				// '\v': '\\x0B'
			}
			const regexSingleEscape = /[\\\b\f\n\r\t]/

			const regexDigit = /[0-9]/
			const regexWhitespace =
				/[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/

			const escapeEverythingRegex =
				/([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g
			const escapeNonAsciiRegex =
				/([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g

			const jsesc = (argument, options) => {
				const increaseIndentation = () => {
					oldIndent = indent
					++options.indentLevel
					indent = options.indent.repeat(options.indentLevel)
				}
				// Handle options
				const defaults = {
					escapeEverything: false,
					minimal: false,
					isScriptContext: false,
					quotes: 'single',
					wrap: false,
					es6: false,
					json: false,
					compact: true,
					lowercaseHex: false,
					numbers: 'decimal',
					indent: '\t',
					indentLevel: 0,
					__inline1__: false,
					__inline2__: false,
				}
				const json = options && options.json
				if (json) {
					defaults.quotes = 'double'
					defaults.wrap = true
				}
				options = extend(defaults, options)
				if (
					options.quotes != 'single' &&
					options.quotes != 'double' &&
					options.quotes != 'backtick'
				) {
					options.quotes = 'single'
				}
				const quote =
					options.quotes == 'double'
						? '"'
						: options.quotes == 'backtick'
							? '`'
							: "'"
				const compact = options.compact
				const lowercaseHex = options.lowercaseHex
				let indent = options.indent.repeat(options.indentLevel)
				let oldIndent = ''
				const inline1 = options.__inline1__
				const inline2 = options.__inline2__
				const newLine = compact ? '' : '\n'
				let result
				let isEmpty = true
				const useBinNumbers = options.numbers == 'binary'
				const useOctNumbers = options.numbers == 'octal'
				const useDecNumbers = options.numbers == 'decimal'
				const useHexNumbers = options.numbers == 'hexadecimal'

				if (json && argument && isFunction(argument.toJSON)) {
					argument = argument.toJSON()
				}

				if (!isString(argument)) {
					if (isMap(argument)) {
						if (argument.size == 0) {
							return 'new Map()'
						}
						if (!compact) {
							options.__inline1__ = true
							options.__inline2__ = false
						}
						return 'new Map(' + jsesc(Array.from(argument), options) + ')'
					}
					if (isSet(argument)) {
						if (argument.size == 0) {
							return 'new Set()'
						}
						return 'new Set(' + jsesc(Array.from(argument), options) + ')'
					}
					if (isBuffer(argument)) {
						if (argument.length == 0) {
							return 'Buffer.from([])'
						}
						return 'Buffer.from(' + jsesc(Array.from(argument), options) + ')'
					}
					if (isArray(argument)) {
						result = []
						options.wrap = true
						if (inline1) {
							options.__inline1__ = false
							options.__inline2__ = true
						}
						if (!inline2) {
							increaseIndentation()
						}
						forEach(argument, (value) => {
							isEmpty = false
							if (inline2) {
								options.__inline2__ = false
							}
							result.push(
								(compact || inline2 ? '' : indent) + jsesc(value, options),
							)
						})
						if (isEmpty) {
							return '[]'
						}
						if (inline2) {
							return '[' + result.join(', ') + ']'
						}
						return (
							'[' +
							newLine +
							result.join(',' + newLine) +
							newLine +
							(compact ? '' : oldIndent) +
							']'
						)
					} else if (isNumber(argument) || isBigInt(argument)) {
						if (json) {
							// Some number values (e.g. `Infinity`) cannot be represented in JSON.
							// `BigInt` values less than `-Number.MAX_VALUE` or greater than
							// `Number.MAX_VALUE` cannot be represented in JSON so they will become
							// `-Infinity` or `Infinity`, respectively, and then become `null` when
							// stringified.
							return JSON.stringify(Number(argument))
						}

						let result
						if (useDecNumbers) {
							result = String(argument)
						} else if (useHexNumbers) {
							let hexadecimal = argument.toString(16)
							if (!lowercaseHex) {
								hexadecimal = hexadecimal.toUpperCase()
							}
							result = '0x' + hexadecimal
						} else if (useBinNumbers) {
							result = '0b' + argument.toString(2)
						} else if (useOctNumbers) {
							result = '0o' + argument.toString(8)
						}

						if (isBigInt(argument)) {
							return result + 'n'
						}
						return result
					} else if (isBigInt(argument)) {
						if (json) {
							// `BigInt` values less than `-Number.MAX_VALUE` or greater than
							// `Number.MAX_VALUE` will become `-Infinity` or `Infinity`,
							// respectively, and cannot be represented in JSON.
							return JSON.stringify(Number(argument))
						}
						return argument + 'n'
					} else if (!isObject(argument)) {
						if (json) {
							// For some values (e.g. `undefined`, `function` objects),
							// `JSON.stringify(value)` returns `undefined` (which isnt valid
							// JSON) instead of `'null'`.
							return JSON.stringify(argument) || 'null'
						}
						return String(argument)
					} else {
						// its an object
						result = []
						options.wrap = true
						increaseIndentation()
						forOwn(argument, (key, value) => {
							isEmpty = false
							result.push(
								(compact ? '' : indent) +
									jsesc(key, options) +
									':' +
									(compact ? '' : ' ') +
									jsesc(value, options),
							)
						})
						if (isEmpty) {
							return '{}'
						}
						return (
							'{' +
							newLine +
							result.join(',' + newLine) +
							newLine +
							(compact ? '' : oldIndent) +
							'}'
						)
					}
				}

				const regex = options.escapeEverything
					? escapeEverythingRegex
					: escapeNonAsciiRegex
				result = argument.replace(
					regex,
					(char, pair, lone, quoteChar, index, string) => {
						if (pair) {
							if (options.minimal) return pair
							const first = pair.charCodeAt(0)
							const second = pair.charCodeAt(1)
							if (options.es6) {
								// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
								const codePoint =
									(first - 0xd800) * 0x400 + second - 0xdc00 + 0x10000
								const hex = hexadecimal(codePoint, lowercaseHex)
								return '\\u{' + hex + '}'
							}
							return (
								fourHexEscape(hexadecimal(first, lowercaseHex)) +
								fourHexEscape(hexadecimal(second, lowercaseHex))
							)
						}

						if (lone) {
							return fourHexEscape(
								hexadecimal(lone.charCodeAt(0), lowercaseHex),
							)
						}

						if (
							char == '\0' &&
							!json &&
							!regexDigit.test(string.charAt(index + 1))
						) {
							return '\\0'
						}

						if (quoteChar) {
							if (quoteChar == quote || options.escapeEverything) {
								return '\\' + quoteChar
							}
							return quoteChar
						}

						if (regexSingleEscape.test(char)) {
							// no need for a `hasOwnProperty` check here
							return singleEscapes[char]
						}

						if (options.minimal && !regexWhitespace.test(char)) {
							return char
						}

						const hex = hexadecimal(char.charCodeAt(0), lowercaseHex)
						if (json || hex.length > 2) {
							return fourHexEscape(hex)
						}

						return '\\x' + ('00' + hex).slice(-2)
					},
				)

				if (quote == '`') {
					result = result.replace(/\$\{/g, '\\${')
				}
				if (options.isScriptContext) {
					// https://mathiasbynens.be/notes/etago
					result = result
						.replace(/<\/(script|style)/gi, '<\\/$1')
						.replace(/<!--/g, json ? '\\u003C!--' : '\\x3C!--')
				}
				if (options.wrap) {
					result = quote + result + quote
				}
				return result
			}

			jsesc.version = '3.0.2'

			module.exports = jsesc

			/***/
		},

		/***/ 84841: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			const parse = __nccwpck_require__(55438)
			const stringify = __nccwpck_require__(91568)

			const JSON5 = {
				parse,
				stringify,
			}

			module.exports = JSON5

			/***/
		},

		/***/ 55438: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			const util = __nccwpck_require__(37393)

			let source
			let parseState
			let stack
			let pos
			let line
			let column
			let token
			let key
			let root

			module.exports = function parse(text, reviver) {
				source = String(text)
				parseState = 'start'
				stack = []
				pos = 0
				line = 1
				column = 0
				token = undefined
				key = undefined
				root = undefined

				do {
					token = lex()

					// This code is unreachable.
					// if (!parseStates[parseState]) {
					//     throw invalidParseState()
					// }

					parseStates[parseState]()
				} while (token.type !== 'eof')

				if (typeof reviver === 'function') {
					return internalize({ '': root }, '', reviver)
				}

				return root
			}

			function internalize(holder, name, reviver) {
				const value = holder[name]
				if (value != null && typeof value === 'object') {
					if (Array.isArray(value)) {
						for (let i = 0; i < value.length; i++) {
							const key = String(i)
							const replacement = internalize(value, key, reviver)
							if (replacement === undefined) {
								delete value[key]
							} else {
								Object.defineProperty(value, key, {
									value: replacement,
									writable: true,
									enumerable: true,
									configurable: true,
								})
							}
						}
					} else {
						for (const key in value) {
							const replacement = internalize(value, key, reviver)
							if (replacement === undefined) {
								delete value[key]
							} else {
								Object.defineProperty(value, key, {
									value: replacement,
									writable: true,
									enumerable: true,
									configurable: true,
								})
							}
						}
					}
				}

				return reviver.call(holder, name, value)
			}

			let lexState
			let buffer
			let doubleQuote
			let sign
			let c

			function lex() {
				lexState = 'default'
				buffer = ''
				doubleQuote = false
				sign = 1

				for (;;) {
					c = peek()

					// This code is unreachable.
					// if (!lexStates[lexState]) {
					//     throw invalidLexState(lexState)
					// }

					const token = lexStates[lexState]()
					if (token) {
						return token
					}
				}
			}

			function peek() {
				if (source[pos]) {
					return String.fromCodePoint(source.codePointAt(pos))
				}
			}

			function read() {
				const c = peek()

				if (c === '\n') {
					line++
					column = 0
				} else if (c) {
					column += c.length
				} else {
					column++
				}

				if (c) {
					pos += c.length
				}

				return c
			}

			const lexStates = {
				default() {
					switch (c) {
						case '\t':
						case '\v':
						case '\f':
						case ' ':
						case '\u00A0':
						case '\uFEFF':
						case '\n':
						case '\r':
						case '\u2028':
						case '\u2029':
							read()
							return

						case '/':
							read()
							lexState = 'comment'
							return

						case undefined:
							read()
							return newToken('eof')
					}

					if (util.isSpaceSeparator(c)) {
						read()
						return
					}

					// This code is unreachable.
					// if (!lexStates[parseState]) {
					//     throw invalidLexState(parseState)
					// }

					return lexStates[parseState]()
				},

				comment() {
					switch (c) {
						case '*':
							read()
							lexState = 'multiLineComment'
							return

						case '/':
							read()
							lexState = 'singleLineComment'
							return
					}

					throw invalidChar(read())
				},

				multiLineComment() {
					switch (c) {
						case '*':
							read()
							lexState = 'multiLineCommentAsterisk'
							return

						case undefined:
							throw invalidChar(read())
					}

					read()
				},

				multiLineCommentAsterisk() {
					switch (c) {
						case '*':
							read()
							return

						case '/':
							read()
							lexState = 'default'
							return

						case undefined:
							throw invalidChar(read())
					}

					read()
					lexState = 'multiLineComment'
				},

				singleLineComment() {
					switch (c) {
						case '\n':
						case '\r':
						case '\u2028':
						case '\u2029':
							read()
							lexState = 'default'
							return

						case undefined:
							read()
							return newToken('eof')
					}

					read()
				},

				value() {
					switch (c) {
						case '{':
						case '[':
							return newToken('punctuator', read())

						case 'n':
							read()
							literal('ull')
							return newToken('null', null)

						case 't':
							read()
							literal('rue')
							return newToken('boolean', true)

						case 'f':
							read()
							literal('alse')
							return newToken('boolean', false)

						case '-':
						case '+':
							if (read() === '-') {
								sign = -1
							}

							lexState = 'sign'
							return

						case '.':
							buffer = read()
							lexState = 'decimalPointLeading'
							return

						case '0':
							buffer = read()
							lexState = 'zero'
							return

						case '1':
						case '2':
						case '3':
						case '4':
						case '5':
						case '6':
						case '7':
						case '8':
						case '9':
							buffer = read()
							lexState = 'decimalInteger'
							return

						case 'I':
							read()
							literal('nfinity')
							return newToken('numeric', Infinity)

						case 'N':
							read()
							literal('aN')
							return newToken('numeric', NaN)

						case '"':
						case "'":
							doubleQuote = read() === '"'
							buffer = ''
							lexState = 'string'
							return
					}

					throw invalidChar(read())
				},

				identifierNameStartEscape() {
					if (c !== 'u') {
						throw invalidChar(read())
					}

					read()
					const u = unicodeEscape()
					switch (u) {
						case '$':
						case '_':
							break

						default:
							if (!util.isIdStartChar(u)) {
								throw invalidIdentifier()
							}

							break
					}

					buffer += u
					lexState = 'identifierName'
				},

				identifierName() {
					switch (c) {
						case '$':
						case '_':
						case '\u200C':
						case '\u200D':
							buffer += read()
							return

						case '\\':
							read()
							lexState = 'identifierNameEscape'
							return
					}

					if (util.isIdContinueChar(c)) {
						buffer += read()
						return
					}

					return newToken('identifier', buffer)
				},

				identifierNameEscape() {
					if (c !== 'u') {
						throw invalidChar(read())
					}

					read()
					const u = unicodeEscape()
					switch (u) {
						case '$':
						case '_':
						case '\u200C':
						case '\u200D':
							break

						default:
							if (!util.isIdContinueChar(u)) {
								throw invalidIdentifier()
							}

							break
					}

					buffer += u
					lexState = 'identifierName'
				},

				sign() {
					switch (c) {
						case '.':
							buffer = read()
							lexState = 'decimalPointLeading'
							return

						case '0':
							buffer = read()
							lexState = 'zero'
							return

						case '1':
						case '2':
						case '3':
						case '4':
						case '5':
						case '6':
						case '7':
						case '8':
						case '9':
							buffer = read()
							lexState = 'decimalInteger'
							return

						case 'I':
							read()
							literal('nfinity')
							return newToken('numeric', sign * Infinity)

						case 'N':
							read()
							literal('aN')
							return newToken('numeric', NaN)
					}

					throw invalidChar(read())
				},

				zero() {
					switch (c) {
						case '.':
							buffer += read()
							lexState = 'decimalPoint'
							return

						case 'e':
						case 'E':
							buffer += read()
							lexState = 'decimalExponent'
							return

						case 'x':
						case 'X':
							buffer += read()
							lexState = 'hexadecimal'
							return
					}

					return newToken('numeric', sign * 0)
				},

				decimalInteger() {
					switch (c) {
						case '.':
							buffer += read()
							lexState = 'decimalPoint'
							return

						case 'e':
						case 'E':
							buffer += read()
							lexState = 'decimalExponent'
							return
					}

					if (util.isDigit(c)) {
						buffer += read()
						return
					}

					return newToken('numeric', sign * Number(buffer))
				},

				decimalPointLeading() {
					if (util.isDigit(c)) {
						buffer += read()
						lexState = 'decimalFraction'
						return
					}

					throw invalidChar(read())
				},

				decimalPoint() {
					switch (c) {
						case 'e':
						case 'E':
							buffer += read()
							lexState = 'decimalExponent'
							return
					}

					if (util.isDigit(c)) {
						buffer += read()
						lexState = 'decimalFraction'
						return
					}

					return newToken('numeric', sign * Number(buffer))
				},

				decimalFraction() {
					switch (c) {
						case 'e':
						case 'E':
							buffer += read()
							lexState = 'decimalExponent'
							return
					}

					if (util.isDigit(c)) {
						buffer += read()
						return
					}

					return newToken('numeric', sign * Number(buffer))
				},

				decimalExponent() {
					switch (c) {
						case '+':
						case '-':
							buffer += read()
							lexState = 'decimalExponentSign'
							return
					}

					if (util.isDigit(c)) {
						buffer += read()
						lexState = 'decimalExponentInteger'
						return
					}

					throw invalidChar(read())
				},

				decimalExponentSign() {
					if (util.isDigit(c)) {
						buffer += read()
						lexState = 'decimalExponentInteger'
						return
					}

					throw invalidChar(read())
				},

				decimalExponentInteger() {
					if (util.isDigit(c)) {
						buffer += read()
						return
					}

					return newToken('numeric', sign * Number(buffer))
				},

				hexadecimal() {
					if (util.isHexDigit(c)) {
						buffer += read()
						lexState = 'hexadecimalInteger'
						return
					}

					throw invalidChar(read())
				},

				hexadecimalInteger() {
					if (util.isHexDigit(c)) {
						buffer += read()
						return
					}

					return newToken('numeric', sign * Number(buffer))
				},

				string() {
					switch (c) {
						case '\\':
							read()
							buffer += escape()
							return

						case '"':
							if (doubleQuote) {
								read()
								return newToken('string', buffer)
							}

							buffer += read()
							return

						case "'":
							if (!doubleQuote) {
								read()
								return newToken('string', buffer)
							}

							buffer += read()
							return

						case '\n':
						case '\r':
							throw invalidChar(read())

						case '\u2028':
						case '\u2029':
							separatorChar(c)
							break

						case undefined:
							throw invalidChar(read())
					}

					buffer += read()
				},

				start() {
					switch (c) {
						case '{':
						case '[':
							return newToken('punctuator', read())

						// This code is unreachable since the default lexState handles eof.
						// case undefined:
						//     return newToken('eof')
					}

					lexState = 'value'
				},

				beforePropertyName() {
					switch (c) {
						case '$':
						case '_':
							buffer = read()
							lexState = 'identifierName'
							return

						case '\\':
							read()
							lexState = 'identifierNameStartEscape'
							return

						case '}':
							return newToken('punctuator', read())

						case '"':
						case "'":
							doubleQuote = read() === '"'
							lexState = 'string'
							return
					}

					if (util.isIdStartChar(c)) {
						buffer += read()
						lexState = 'identifierName'
						return
					}

					throw invalidChar(read())
				},

				afterPropertyName() {
					if (c === ':') {
						return newToken('punctuator', read())
					}

					throw invalidChar(read())
				},

				beforePropertyValue() {
					lexState = 'value'
				},

				afterPropertyValue() {
					switch (c) {
						case ',':
						case '}':
							return newToken('punctuator', read())
					}

					throw invalidChar(read())
				},

				beforeArrayValue() {
					if (c === ']') {
						return newToken('punctuator', read())
					}

					lexState = 'value'
				},

				afterArrayValue() {
					switch (c) {
						case ',':
						case ']':
							return newToken('punctuator', read())
					}

					throw invalidChar(read())
				},

				end() {
					// This code is unreachable since it's handled by the default lexState.
					// if (c === undefined) {
					//     read()
					//     return newToken('eof')
					// }

					throw invalidChar(read())
				},
			}

			function newToken(type, value) {
				return {
					type,
					value,
					line,
					column,
				}
			}

			function literal(s) {
				for (const c of s) {
					const p = peek()

					if (p !== c) {
						throw invalidChar(read())
					}

					read()
				}
			}

			function escape() {
				const c = peek()
				switch (c) {
					case 'b':
						read()
						return '\b'

					case 'f':
						read()
						return '\f'

					case 'n':
						read()
						return '\n'

					case 'r':
						read()
						return '\r'

					case 't':
						read()
						return '\t'

					case 'v':
						read()
						return '\v'

					case '0':
						read()
						if (util.isDigit(peek())) {
							throw invalidChar(read())
						}

						return '\0'

					case 'x':
						read()
						return hexEscape()

					case 'u':
						read()
						return unicodeEscape()

					case '\n':
					case '\u2028':
					case '\u2029':
						read()
						return ''

					case '\r':
						read()
						if (peek() === '\n') {
							read()
						}

						return ''

					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
						throw invalidChar(read())

					case undefined:
						throw invalidChar(read())
				}

				return read()
			}

			function hexEscape() {
				let buffer = ''
				let c = peek()

				if (!util.isHexDigit(c)) {
					throw invalidChar(read())
				}

				buffer += read()

				c = peek()
				if (!util.isHexDigit(c)) {
					throw invalidChar(read())
				}

				buffer += read()

				return String.fromCodePoint(parseInt(buffer, 16))
			}

			function unicodeEscape() {
				let buffer = ''
				let count = 4

				while (count-- > 0) {
					const c = peek()
					if (!util.isHexDigit(c)) {
						throw invalidChar(read())
					}

					buffer += read()
				}

				return String.fromCodePoint(parseInt(buffer, 16))
			}

			const parseStates = {
				start() {
					if (token.type === 'eof') {
						throw invalidEOF()
					}

					push()
				},

				beforePropertyName() {
					switch (token.type) {
						case 'identifier':
						case 'string':
							key = token.value
							parseState = 'afterPropertyName'
							return

						case 'punctuator':
							// This code is unreachable since it's handled by the lexState.
							// if (token.value !== '}') {
							//     throw invalidToken()
							// }

							pop()
							return

						case 'eof':
							throw invalidEOF()
					}

					// This code is unreachable since it's handled by the lexState.
					// throw invalidToken()
				},

				afterPropertyName() {
					// This code is unreachable since it's handled by the lexState.
					// if (token.type !== 'punctuator' || token.value !== ':') {
					//     throw invalidToken()
					// }

					if (token.type === 'eof') {
						throw invalidEOF()
					}

					parseState = 'beforePropertyValue'
				},

				beforePropertyValue() {
					if (token.type === 'eof') {
						throw invalidEOF()
					}

					push()
				},

				beforeArrayValue() {
					if (token.type === 'eof') {
						throw invalidEOF()
					}

					if (token.type === 'punctuator' && token.value === ']') {
						pop()
						return
					}

					push()
				},

				afterPropertyValue() {
					// This code is unreachable since it's handled by the lexState.
					// if (token.type !== 'punctuator') {
					//     throw invalidToken()
					// }

					if (token.type === 'eof') {
						throw invalidEOF()
					}

					switch (token.value) {
						case ',':
							parseState = 'beforePropertyName'
							return

						case '}':
							pop()
					}

					// This code is unreachable since it's handled by the lexState.
					// throw invalidToken()
				},

				afterArrayValue() {
					// This code is unreachable since it's handled by the lexState.
					// if (token.type !== 'punctuator') {
					//     throw invalidToken()
					// }

					if (token.type === 'eof') {
						throw invalidEOF()
					}

					switch (token.value) {
						case ',':
							parseState = 'beforeArrayValue'
							return

						case ']':
							pop()
					}

					// This code is unreachable since it's handled by the lexState.
					// throw invalidToken()
				},

				end() {
					// This code is unreachable since it's handled by the lexState.
					// if (token.type !== 'eof') {
					//     throw invalidToken()
					// }
				},
			}

			function push() {
				let value

				switch (token.type) {
					case 'punctuator':
						switch (token.value) {
							case '{':
								value = {}
								break

							case '[':
								value = []
								break
						}

						break

					case 'null':
					case 'boolean':
					case 'numeric':
					case 'string':
						value = token.value
						break

					// This code is unreachable.
					// default:
					//     throw invalidToken()
				}

				if (root === undefined) {
					root = value
				} else {
					const parent = stack[stack.length - 1]
					if (Array.isArray(parent)) {
						parent.push(value)
					} else {
						Object.defineProperty(parent, key, {
							value,
							writable: true,
							enumerable: true,
							configurable: true,
						})
					}
				}

				if (value !== null && typeof value === 'object') {
					stack.push(value)

					if (Array.isArray(value)) {
						parseState = 'beforeArrayValue'
					} else {
						parseState = 'beforePropertyName'
					}
				} else {
					const current = stack[stack.length - 1]
					if (current == null) {
						parseState = 'end'
					} else if (Array.isArray(current)) {
						parseState = 'afterArrayValue'
					} else {
						parseState = 'afterPropertyValue'
					}
				}
			}

			function pop() {
				stack.pop()

				const current = stack[stack.length - 1]
				if (current == null) {
					parseState = 'end'
				} else if (Array.isArray(current)) {
					parseState = 'afterArrayValue'
				} else {
					parseState = 'afterPropertyValue'
				}
			}

			// This code is unreachable.
			// function invalidParseState () {
			//     return new Error(`JSON5: invalid parse state '${parseState}'`)
			// }

			// This code is unreachable.
			// function invalidLexState (state) {
			//     return new Error(`JSON5: invalid lex state '${state}'`)
			// }

			function invalidChar(c) {
				if (c === undefined) {
					return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)
				}

				return syntaxError(
					`JSON5: invalid character '${formatChar(c)}' at ${line}:${column}`,
				)
			}

			function invalidEOF() {
				return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)
			}

			// This code is unreachable.
			// function invalidToken () {
			//     if (token.type === 'eof') {
			//         return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)
			//     }

			//     const c = String.fromCodePoint(token.value.codePointAt(0))
			//     return syntaxError(`JSON5: invalid character '${formatChar(c)}' at ${line}:${column}`)
			// }

			function invalidIdentifier() {
				column -= 5
				return syntaxError(
					`JSON5: invalid identifier character at ${line}:${column}`,
				)
			}

			function separatorChar(c) {
				console.warn(
					`JSON5: '${formatChar(c)}' in strings is not valid ECMAScript; consider escaping`,
				)
			}

			function formatChar(c) {
				const replacements = {
					"'": "\\'",
					'"': '\\"',
					'\\': '\\\\',
					'\b': '\\b',
					'\f': '\\f',
					'\n': '\\n',
					'\r': '\\r',
					'\t': '\\t',
					'\v': '\\v',
					'\0': '\\0',
					'\u2028': '\\u2028',
					'\u2029': '\\u2029',
				}

				if (replacements[c]) {
					return replacements[c]
				}

				if (c < ' ') {
					const hexString = c.charCodeAt(0).toString(16)
					return '\\x' + ('00' + hexString).substring(hexString.length)
				}

				return c
			}

			function syntaxError(message) {
				const err = new SyntaxError(message)
				err.lineNumber = line
				err.columnNumber = column
				return err
			}

			/***/
		},

		/***/ 91568: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			const util = __nccwpck_require__(37393)

			module.exports = function stringify(value, replacer, space) {
				const stack = []
				let indent = ''
				let propertyList
				let replacerFunc
				let gap = ''
				let quote

				if (
					replacer != null &&
					typeof replacer === 'object' &&
					!Array.isArray(replacer)
				) {
					space = replacer.space
					quote = replacer.quote
					replacer = replacer.replacer
				}

				if (typeof replacer === 'function') {
					replacerFunc = replacer
				} else if (Array.isArray(replacer)) {
					propertyList = []
					for (const v of replacer) {
						let item

						if (typeof v === 'string') {
							item = v
						} else if (
							typeof v === 'number' ||
							v instanceof String ||
							v instanceof Number
						) {
							item = String(v)
						}

						if (item !== undefined && propertyList.indexOf(item) < 0) {
							propertyList.push(item)
						}
					}
				}

				if (space instanceof Number) {
					space = Number(space)
				} else if (space instanceof String) {
					space = String(space)
				}

				if (typeof space === 'number') {
					if (space > 0) {
						space = Math.min(10, Math.floor(space))
						gap = '          '.substr(0, space)
					}
				} else if (typeof space === 'string') {
					gap = space.substr(0, 10)
				}

				return serializeProperty('', { '': value })

				function serializeProperty(key, holder) {
					let value = holder[key]
					if (value != null) {
						if (typeof value.toJSON5 === 'function') {
							value = value.toJSON5(key)
						} else if (typeof value.toJSON === 'function') {
							value = value.toJSON(key)
						}
					}

					if (replacerFunc) {
						value = replacerFunc.call(holder, key, value)
					}

					if (value instanceof Number) {
						value = Number(value)
					} else if (value instanceof String) {
						value = String(value)
					} else if (value instanceof Boolean) {
						value = value.valueOf()
					}

					switch (value) {
						case null:
							return 'null'
						case true:
							return 'true'
						case false:
							return 'false'
					}

					if (typeof value === 'string') {
						return quoteString(value, false)
					}

					if (typeof value === 'number') {
						return String(value)
					}

					if (typeof value === 'object') {
						return Array.isArray(value)
							? serializeArray(value)
							: serializeObject(value)
					}

					return undefined
				}

				function quoteString(value) {
					const quotes = {
						"'": 0.1,
						'"': 0.2,
					}

					const replacements = {
						"'": "\\'",
						'"': '\\"',
						'\\': '\\\\',
						'\b': '\\b',
						'\f': '\\f',
						'\n': '\\n',
						'\r': '\\r',
						'\t': '\\t',
						'\v': '\\v',
						'\0': '\\0',
						'\u2028': '\\u2028',
						'\u2029': '\\u2029',
					}

					let product = ''

					for (let i = 0; i < value.length; i++) {
						const c = value[i]
						switch (c) {
							case "'":
							case '"':
								quotes[c]++
								product += c
								continue

							case '\0':
								if (util.isDigit(value[i + 1])) {
									product += '\\x00'
									continue
								}
						}

						if (replacements[c]) {
							product += replacements[c]
							continue
						}

						if (c < ' ') {
							let hexString = c.charCodeAt(0).toString(16)
							product += '\\x' + ('00' + hexString).substring(hexString.length)
							continue
						}

						product += c
					}

					const quoteChar =
						quote ||
						Object.keys(quotes).reduce((a, b) =>
							quotes[a] < quotes[b] ? a : b,
						)

					product = product.replace(
						new RegExp(quoteChar, 'g'),
						replacements[quoteChar],
					)

					return quoteChar + product + quoteChar
				}

				function serializeObject(value) {
					if (stack.indexOf(value) >= 0) {
						throw TypeError('Converting circular structure to JSON5')
					}

					stack.push(value)

					let stepback = indent
					indent = indent + gap

					let keys = propertyList || Object.keys(value)
					let partial = []
					for (const key of keys) {
						const propertyString = serializeProperty(key, value)
						if (propertyString !== undefined) {
							let member = serializeKey(key) + ':'
							if (gap !== '') {
								member += ' '
							}
							member += propertyString
							partial.push(member)
						}
					}

					let final
					if (partial.length === 0) {
						final = '{}'
					} else {
						let properties
						if (gap === '') {
							properties = partial.join(',')
							final = '{' + properties + '}'
						} else {
							let separator = ',\n' + indent
							properties = partial.join(separator)
							final = '{\n' + indent + properties + ',\n' + stepback + '}'
						}
					}

					stack.pop()
					indent = stepback
					return final
				}

				function serializeKey(key) {
					if (key.length === 0) {
						return quoteString(key, true)
					}

					const firstChar = String.fromCodePoint(key.codePointAt(0))
					if (!util.isIdStartChar(firstChar)) {
						return quoteString(key, true)
					}

					for (let i = firstChar.length; i < key.length; i++) {
						if (
							!util.isIdContinueChar(String.fromCodePoint(key.codePointAt(i)))
						) {
							return quoteString(key, true)
						}
					}

					return key
				}

				function serializeArray(value) {
					if (stack.indexOf(value) >= 0) {
						throw TypeError('Converting circular structure to JSON5')
					}

					stack.push(value)

					let stepback = indent
					indent = indent + gap

					let partial = []
					for (let i = 0; i < value.length; i++) {
						const propertyString = serializeProperty(String(i), value)
						partial.push(propertyString !== undefined ? propertyString : 'null')
					}

					let final
					if (partial.length === 0) {
						final = '[]'
					} else {
						if (gap === '') {
							let properties = partial.join(',')
							final = '[' + properties + ']'
						} else {
							let separator = ',\n' + indent
							let properties = partial.join(separator)
							final = '[\n' + indent + properties + ',\n' + stepback + ']'
						}
					}

					stack.pop()
					indent = stepback
					return final
				}
			}

			/***/
		},

		/***/ 57414: /***/ (module) => {
			// This is a generated file. Do not edit.
			module.exports.Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/
			module.exports.ID_Start =
				/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/
			module.exports.ID_Continue =
				/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/

			/***/
		},

		/***/ 37393: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			const unicode = __nccwpck_require__(57414)

			module.exports = {
				isSpaceSeparator(c) {
					return typeof c === 'string' && unicode.Space_Separator.test(c)
				},

				isIdStartChar(c) {
					return (
						typeof c === 'string' &&
						((c >= 'a' && c <= 'z') ||
							(c >= 'A' && c <= 'Z') ||
							c === '$' ||
							c === '_' ||
							unicode.ID_Start.test(c))
					)
				},

				isIdContinueChar(c) {
					return (
						typeof c === 'string' &&
						((c >= 'a' && c <= 'z') ||
							(c >= 'A' && c <= 'Z') ||
							(c >= '0' && c <= '9') ||
							c === '$' ||
							c === '_' ||
							c === '\u200C' ||
							c === '\u200D' ||
							unicode.ID_Continue.test(c))
					)
				},

				isDigit(c) {
					return typeof c === 'string' && /[0-9]/.test(c)
				},

				isHexDigit(c) {
					return typeof c === 'string' && /[0-9A-Fa-f]/.test(c)
				},
			}

			/***/
		},

		/***/ 5140: /***/ (module) => {
			var toString = Object.prototype.toString

			module.exports = function kindOf(val) {
				if (val === void 0) return 'undefined'
				if (val === null) return 'null'

				var type = typeof val
				if (type === 'boolean') return 'boolean'
				if (type === 'string') return 'string'
				if (type === 'number') return 'number'
				if (type === 'symbol') return 'symbol'
				if (type === 'function') {
					return isGeneratorFn(val) ? 'generatorfunction' : 'function'
				}

				if (isArray(val)) return 'array'
				if (isBuffer(val)) return 'buffer'
				if (isArguments(val)) return 'arguments'
				if (isDate(val)) return 'date'
				if (isError(val)) return 'error'
				if (isRegexp(val)) return 'regexp'

				switch (ctorName(val)) {
					case 'Symbol':
						return 'symbol'
					case 'Promise':
						return 'promise'

					// Set, Map, WeakSet, WeakMap
					case 'WeakMap':
						return 'weakmap'
					case 'WeakSet':
						return 'weakset'
					case 'Map':
						return 'map'
					case 'Set':
						return 'set'

					// 8-bit typed arrays
					case 'Int8Array':
						return 'int8array'
					case 'Uint8Array':
						return 'uint8array'
					case 'Uint8ClampedArray':
						return 'uint8clampedarray'

					// 16-bit typed arrays
					case 'Int16Array':
						return 'int16array'
					case 'Uint16Array':
						return 'uint16array'

					// 32-bit typed arrays
					case 'Int32Array':
						return 'int32array'
					case 'Uint32Array':
						return 'uint32array'
					case 'Float32Array':
						return 'float32array'
					case 'Float64Array':
						return 'float64array'
				}

				if (isGeneratorObj(val)) {
					return 'generator'
				}

				// Non-plain objects
				type = toString.call(val)
				switch (type) {
					case '[object Object]':
						return 'object'
					// iterators
					case '[object Map Iterator]':
						return 'mapiterator'
					case '[object Set Iterator]':
						return 'setiterator'
					case '[object String Iterator]':
						return 'stringiterator'
					case '[object Array Iterator]':
						return 'arrayiterator'
				}

				// other
				return type.slice(8, -1).toLowerCase().replace(/\s/g, '')
			}

			function ctorName(val) {
				return typeof val.constructor === 'function'
					? val.constructor.name
					: null
			}

			function isArray(val) {
				if (Array.isArray) return Array.isArray(val)
				return val instanceof Array
			}

			function isError(val) {
				return (
					val instanceof Error ||
					(typeof val.message === 'string' &&
						val.constructor &&
						typeof val.constructor.stackTraceLimit === 'number')
				)
			}

			function isDate(val) {
				if (val instanceof Date) return true
				return (
					typeof val.toDateString === 'function' &&
					typeof val.getDate === 'function' &&
					typeof val.setDate === 'function'
				)
			}

			function isRegexp(val) {
				if (val instanceof RegExp) return true
				return (
					typeof val.flags === 'string' &&
					typeof val.ignoreCase === 'boolean' &&
					typeof val.multiline === 'boolean' &&
					typeof val.global === 'boolean'
				)
			}

			function isGeneratorFn(name, val) {
				return ctorName(name) === 'GeneratorFunction'
			}

			function isGeneratorObj(val) {
				return (
					typeof val.throw === 'function' &&
					typeof val.return === 'function' &&
					typeof val.next === 'function'
				)
			}

			function isArguments(val) {
				try {
					if (
						typeof val.length === 'number' &&
						typeof val.callee === 'function'
					) {
						return true
					}
				} catch (err) {
					if (err.message.indexOf('callee') !== -1) {
						return true
					}
				}
				return false
			}

			/**
			 * If you need to support Safari 5-7 (8-10 yr-old browser),
			 * take a look at https://github.com/feross/is-buffer
			 */

			function isBuffer(val) {
				if (val.constructor && typeof val.constructor.isBuffer === 'function') {
					return val.constructor.isBuffer(val)
				}
				return false
			}

			/***/
		},

		/***/ 71628: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const fs = __nccwpck_require__(35744)
			const path = __nccwpck_require__(16928)

			function klawSync(dir, opts, ls) {
				if (!ls) {
					ls = []
					dir = path.resolve(dir)
					opts = opts || {}
					opts.fs = opts.fs || fs
					if (opts.depthLimit > -1)
						opts.rootDepth = dir.split(path.sep).length + 1
				}
				const paths = opts.fs.readdirSync(dir).map((p) => dir + path.sep + p)
				for (var i = 0; i < paths.length; i += 1) {
					const pi = paths[i]
					const st = opts.fs.lstatSync(pi)
					const item = { path: pi, stats: st }
					const isUnderDepthLimit =
						!opts.rootDepth ||
						pi.split(path.sep).length - opts.rootDepth < opts.depthLimit
					const filterResult = opts.filter ? opts.filter(item) : true
					const isDir = st.isDirectory()
					const shouldAdd = filterResult && (isDir ? !opts.nodir : !opts.nofile)
					const shouldTraverse =
						isDir && isUnderDepthLimit && (opts.traverseAll || filterResult)
					if (shouldAdd) ls.push(item)
					if (shouldTraverse) ls = klawSync(pi, opts, ls)
				}
				return ls
			}

			module.exports = klawSync

			/***/
		},

		/***/ 47033: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var getNative = __nccwpck_require__(68573),
				root = __nccwpck_require__(6748)

			/* Built-in method references that are verified to be native. */
			var DataView = getNative(root, 'DataView')

			module.exports = DataView

			/***/
		},

		/***/ 66320: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var hashClear = __nccwpck_require__(48051),
				hashDelete = __nccwpck_require__(15431),
				hashGet = __nccwpck_require__(26934),
				hashHas = __nccwpck_require__(64306),
				hashSet = __nccwpck_require__(17226)

			/**
			 * Creates a hash object.
			 *
			 * @private
			 * @constructor
			 * @param {Array} [entries] The key-value pairs to cache.
			 */
			function Hash(entries) {
				var index = -1,
					length = entries == null ? 0 : entries.length

				this.clear()
				while (++index < length) {
					var entry = entries[index]
					this.set(entry[0], entry[1])
				}
			}

			// Add methods to `Hash`.
			Hash.prototype.clear = hashClear
			Hash.prototype['delete'] = hashDelete
			Hash.prototype.get = hashGet
			Hash.prototype.has = hashHas
			Hash.prototype.set = hashSet

			module.exports = Hash

			/***/
		},

		/***/ 68884: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var listCacheClear = __nccwpck_require__(99791),
				listCacheDelete = __nccwpck_require__(24555),
				listCacheGet = __nccwpck_require__(86634),
				listCacheHas = __nccwpck_require__(8430),
				listCacheSet = __nccwpck_require__(36918)

			/**
			 * Creates an list cache object.
			 *
			 * @private
			 * @constructor
			 * @param {Array} [entries] The key-value pairs to cache.
			 */
			function ListCache(entries) {
				var index = -1,
					length = entries == null ? 0 : entries.length

				this.clear()
				while (++index < length) {
					var entry = entries[index]
					this.set(entry[0], entry[1])
				}
			}

			// Add methods to `ListCache`.
			ListCache.prototype.clear = listCacheClear
			ListCache.prototype['delete'] = listCacheDelete
			ListCache.prototype.get = listCacheGet
			ListCache.prototype.has = listCacheHas
			ListCache.prototype.set = listCacheSet

			module.exports = ListCache

			/***/
		},

		/***/ 98272: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var getNative = __nccwpck_require__(68573),
				root = __nccwpck_require__(6748)

			/* Built-in method references that are verified to be native. */
			var Map = getNative(root, 'Map')

			module.exports = Map

			/***/
		},

		/***/ 79660: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var mapCacheClear = __nccwpck_require__(88487),
				mapCacheDelete = __nccwpck_require__(36275),
				mapCacheGet = __nccwpck_require__(30130),
				mapCacheHas = __nccwpck_require__(69254),
				mapCacheSet = __nccwpck_require__(59806)

			/**
			 * Creates a map cache object to store key-value pairs.
			 *
			 * @private
			 * @constructor
			 * @param {Array} [entries] The key-value pairs to cache.
			 */
			function MapCache(entries) {
				var index = -1,
					length = entries == null ? 0 : entries.length

				this.clear()
				while (++index < length) {
					var entry = entries[index]
					this.set(entry[0], entry[1])
				}
			}

			// Add methods to `MapCache`.
			MapCache.prototype.clear = mapCacheClear
			MapCache.prototype['delete'] = mapCacheDelete
			MapCache.prototype.get = mapCacheGet
			MapCache.prototype.has = mapCacheHas
			MapCache.prototype.set = mapCacheSet

			module.exports = MapCache

			/***/
		},

		/***/ 4455: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var getNative = __nccwpck_require__(68573),
				root = __nccwpck_require__(6748)

			/* Built-in method references that are verified to be native. */
			var Promise = getNative(root, 'Promise')

			module.exports = Promise

			/***/
		},

		/***/ 84986: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var getNative = __nccwpck_require__(68573),
				root = __nccwpck_require__(6748)

			/* Built-in method references that are verified to be native. */
			var Set = getNative(root, 'Set')

			module.exports = Set

			/***/
		},

		/***/ 23706: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var MapCache = __nccwpck_require__(79660),
				setCacheAdd = __nccwpck_require__(44671),
				setCacheHas = __nccwpck_require__(71884)

			/**
			 *
			 * Creates an array cache object to store unique values.
			 *
			 * @private
			 * @constructor
			 * @param {Array} [values] The values to cache.
			 */
			function SetCache(values) {
				var index = -1,
					length = values == null ? 0 : values.length

				this.__data__ = new MapCache()
				while (++index < length) {
					this.add(values[index])
				}
			}

			// Add methods to `SetCache`.
			SetCache.prototype.add = SetCache.prototype.push = setCacheAdd
			SetCache.prototype.has = setCacheHas

			module.exports = SetCache

			/***/
		},

		/***/ 73262: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var ListCache = __nccwpck_require__(68884),
				stackClear = __nccwpck_require__(91509),
				stackDelete = __nccwpck_require__(837),
				stackGet = __nccwpck_require__(46572),
				stackHas = __nccwpck_require__(66216),
				stackSet = __nccwpck_require__(51976)

			/**
			 * Creates a stack cache object to store key-value pairs.
			 *
			 * @private
			 * @constructor
			 * @param {Array} [entries] The key-value pairs to cache.
			 */
			function Stack(entries) {
				var data = (this.__data__ = new ListCache(entries))
				this.size = data.size
			}

			// Add methods to `Stack`.
			Stack.prototype.clear = stackClear
			Stack.prototype['delete'] = stackDelete
			Stack.prototype.get = stackGet
			Stack.prototype.has = stackHas
			Stack.prototype.set = stackSet

			module.exports = Stack

			/***/
		},

		/***/ 38584: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var root = __nccwpck_require__(6748)

			/** Built-in value references. */
			var Symbol = root.Symbol

			module.exports = Symbol

			/***/
		},

		/***/ 59525: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var root = __nccwpck_require__(6748)

			/** Built-in value references. */
			var Uint8Array = root.Uint8Array

			module.exports = Uint8Array

			/***/
		},

		/***/ 97364: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var getNative = __nccwpck_require__(68573),
				root = __nccwpck_require__(6748)

			/* Built-in method references that are verified to be native. */
			var WeakMap = getNative(root, 'WeakMap')

			module.exports = WeakMap

			/***/
		},

		/***/ 59678: /***/ (module) => {
			/**
			 * A faster alternative to `Function#apply`, this function invokes `func`
			 * with the `this` binding of `thisArg` and the arguments of `args`.
			 *
			 * @private
			 * @param {Function} func The function to invoke.
			 * @param {*} thisArg The `this` binding of `func`.
			 * @param {Array} args The arguments to invoke `func` with.
			 * @returns {*} Returns the result of `func`.
			 */
			function apply(func, thisArg, args) {
				switch (args.length) {
					case 0:
						return func.call(thisArg)
					case 1:
						return func.call(thisArg, args[0])
					case 2:
						return func.call(thisArg, args[0], args[1])
					case 3:
						return func.call(thisArg, args[0], args[1], args[2])
				}
				return func.apply(thisArg, args)
			}

			module.exports = apply

			/***/
		},

		/***/ 19362: /***/ (module) => {
			/**
			 * A specialized version of `_.forEach` for arrays without support for
			 * iteratee shorthands.
			 *
			 * @private
			 * @param {Array} [array] The array to iterate over.
			 * @param {Function} iteratee The function invoked per iteration.
			 * @returns {Array} Returns `array`.
			 */
			function arrayEach(array, iteratee) {
				var index = -1,
					length = array == null ? 0 : array.length

				while (++index < length) {
					if (iteratee(array[index], index, array) === false) {
						break
					}
				}
				return array
			}

			module.exports = arrayEach

			/***/
		},

		/***/ 78573: /***/ (module) => {
			/**
			 * A specialized version of `_.filter` for arrays without support for
			 * iteratee shorthands.
			 *
			 * @private
			 * @param {Array} [array] The array to iterate over.
			 * @param {Function} predicate The function invoked per iteration.
			 * @returns {Array} Returns the new filtered array.
			 */
			function arrayFilter(array, predicate) {
				var index = -1,
					length = array == null ? 0 : array.length,
					resIndex = 0,
					result = []

				while (++index < length) {
					var value = array[index]
					if (predicate(value, index, array)) {
						result[resIndex++] = value
					}
				}
				return result
			}

			module.exports = arrayFilter

			/***/
		},

		/***/ 62000: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var baseTimes = __nccwpck_require__(21299),
				isArguments = __nccwpck_require__(60541),
				isArray = __nccwpck_require__(77192),
				isBuffer = __nccwpck_require__(43739),
				isIndex = __nccwpck_require__(37446),
				isTypedArray = __nccwpck_require__(35000)

			/** Used for built-in method references. */
			var objectProto = Object.prototype

			/** Used to check objects for own properties. */
			var hasOwnProperty = objectProto.hasOwnProperty

			/**
			 * Creates an array of the enumerable property names of the array-like `value`.
			 *
			 * @private
			 * @param {*} value The value to query.
			 * @param {boolean} inherited Specify returning inherited property names.
			 * @returns {Array} Returns the array of property names.
			 */
			function arrayLikeKeys(value, inherited) {
				var isArr = isArray(value),
					isArg = !isArr && isArguments(value),
					isBuff = !isArr && !isArg && isBuffer(value),
					isType = !isArr && !isArg && !isBuff && isTypedArray(value),
					skipIndexes = isArr || isArg || isBuff || isType,
					result = skipIndexes ? baseTimes(value.length, String) : [],
					length = result.length

				for (var key in value) {
					if (
						(inherited || hasOwnProperty.call(value, key)) &&
						!(
							skipIndexes &&
							// Safari 9 has enumerable `arguments.length` in strict mode.
							(key == 'length' ||
								// Node.js 0.10 has enumerable non-index properties on buffers.
								(isBuff && (key == 'offset' || key == 'parent')) ||
								// PhantomJS 2 has enumerable non-index properties on typed arrays.
								(isType &&
									(key == 'buffer' ||
										key == 'byteLength' ||
										key == 'byteOffset')) ||
								// Skip index properties.
								isIndex(key, length))
						)
					) {
						result.push(key)
					}
				}
				return result
			}

			module.exports = arrayLikeKeys

			/***/
		},

		/***/ 56649: /***/ (module) => {
			/**
			 * A specialized version of `_.map` for arrays without support for iteratee
			 * shorthands.
			 *
			 * @private
			 * @param {Array} [array] The array to iterate over.
			 * @param {Function} iteratee The function invoked per iteration.
			 * @returns {Array} Returns the new mapped array.
			 */
			function arrayMap(array, iteratee) {
				var index = -1,
					length = array == null ? 0 : array.length,
					result = Array(length)

				while (++index < length) {
					result[index] = iteratee(array[index], index, array)
				}
				return result
			}

			module.exports = arrayMap

			/***/
		},

		/***/ 50827: /***/ (module) => {
			/**
			 * Appends the elements of `values` to `array`.
			 *
			 * @private
			 * @param {Array} array The array to modify.
			 * @param {Array} values The values to append.
			 * @returns {Array} Returns `array`.
			 */
			function arrayPush(array, values) {
				var index = -1,
					length = values.length,
					offset = array.length

				while (++index < length) {
					array[offset + index] = values[index]
				}
				return array
			}

			module.exports = arrayPush

			/***/
		},

		/***/ 90935: /***/ (module) => {
			/**
			 * A specialized version of `_.some` for arrays without support for iteratee
			 * shorthands.
			 *
			 * @private
			 * @param {Array} [array] The array to iterate over.
			 * @param {Function} predicate The function invoked per iteration.
			 * @returns {boolean} Returns `true` if any element passes the predicate check,
			 *  else `false`.
			 */
			function arraySome(array, predicate) {
				var index = -1,
					length = array == null ? 0 : array.length

				while (++index < length) {
					if (predicate(array[index], index, array)) {
						return true
					}
				}
				return false
			}

			module.exports = arraySome

			/***/
		},

		/***/ 99128: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var baseAssignValue = __nccwpck_require__(63579),
				eq = __nccwpck_require__(75199)

			/** Used for built-in method references. */
			var objectProto = Object.prototype

			/** Used to check objects for own properties. */
			var hasOwnProperty = objectProto.hasOwnProperty

			/**
			 * Assigns `value` to `key` of `object` if the existing value is not equivalent
			 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
			 * for equality comparisons.
			 *
			 * @private
			 * @param {Object} object The object to modify.
			 * @param {string} key The key of the property to assign.
			 * @param {*} value The value to assign.
			 */
			function assignValue(object, key, value) {
				var objValue = object[key]
				if (
					!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
					(value === undefined && !(key in object))
				) {
					baseAssignValue(object, key, value)
				}
			}

			module.exports = assignValue

			/***/
		},

		/***/ 74024: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var eq = __nccwpck_require__(75199)

			/**
			 * Gets the index at which the `key` is found in `array` of key-value pairs.
			 *
			 * @private
			 * @param {Array} array The array to inspect.
			 * @param {*} key The key to search for.
			 * @returns {number} Returns the index of the matched value, else `-1`.
			 */
			function assocIndexOf(array, key) {
				var length = array.length
				while (length--) {
					if (eq(array[length][0], key)) {
						return length
					}
				}
				return -1
			}

			module.exports = assocIndexOf

			/***/
		},

		/***/ 31684: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var copyObject = __nccwpck_require__(69330),
				keys = __nccwpck_require__(26741)

			/**
			 * The base implementation of `_.assign` without support for multiple sources
			 * or `customizer` functions.
			 *
			 * @private
			 * @param {Object} object The destination object.
			 * @param {Object} source The source object.
			 * @returns {Object} Returns `object`.
			 */
			function baseAssign(object, source) {
				return object && copyObject(source, keys(source), object)
			}

			module.exports = baseAssign

			/***/
		},

		/***/ 30731: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var copyObject = __nccwpck_require__(69330),
				keysIn = __nccwpck_require__(19430)

			/**
			 * The base implementation of `_.assignIn` without support for multiple sources
			 * or `customizer` functions.
			 *
			 * @private
			 * @param {Object} object The destination object.
			 * @param {Object} source The source object.
			 * @returns {Object} Returns `object`.
			 */
			function baseAssignIn(object, source) {
				return object && copyObject(source, keysIn(source), object)
			}

			module.exports = baseAssignIn

			/***/
		},

		/***/ 63579: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var defineProperty = __nccwpck_require__(83106)

			/**
			 * The base implementation of `assignValue` and `assignMergeValue` without
			 * value checks.
			 *
			 * @private
			 * @param {Object} object The object to modify.
			 * @param {string} key The key of the property to assign.
			 * @param {*} value The value to assign.
			 */
			function baseAssignValue(object, key, value) {
				if (key == '__proto__' && defineProperty) {
					defineProperty(object, key, {
						configurable: true,
						enumerable: true,
						value: value,
						writable: true,
					})
				} else {
					object[key] = value
				}
			}

			module.exports = baseAssignValue

			/***/
		},

		/***/ 62504: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var Stack = __nccwpck_require__(73262),
				arrayEach = __nccwpck_require__(19362),
				assignValue = __nccwpck_require__(99128),
				baseAssign = __nccwpck_require__(31684),
				baseAssignIn = __nccwpck_require__(30731),
				cloneBuffer = __nccwpck_require__(165),
				copyArray = __nccwpck_require__(77560),
				copySymbols = __nccwpck_require__(97472),
				copySymbolsIn = __nccwpck_require__(61935),
				getAllKeys = __nccwpck_require__(78479),
				getAllKeysIn = __nccwpck_require__(17172),
				getTag = __nccwpck_require__(44512),
				initCloneArray = __nccwpck_require__(43688),
				initCloneByTag = __nccwpck_require__(75906),
				initCloneObject = __nccwpck_require__(20866),
				isArray = __nccwpck_require__(77192),
				isBuffer = __nccwpck_require__(43739),
				isMap = __nccwpck_require__(85995),
				isObject = __nccwpck_require__(96482),
				isSet = __nccwpck_require__(27077),
				keys = __nccwpck_require__(26741),
				keysIn = __nccwpck_require__(19430)

			/** Used to compose bitmasks for cloning. */
			var CLONE_DEEP_FLAG = 1,
				CLONE_FLAT_FLAG = 2,
				CLONE_SYMBOLS_FLAG = 4

			/** `Object#toString` result references. */
			var argsTag = '[object Arguments]',
				arrayTag = '[object Array]',
				boolTag = '[object Boolean]',
				dateTag = '[object Date]',
				errorTag = '[object Error]',
				funcTag = '[object Function]',
				genTag = '[object GeneratorFunction]',
				mapTag = '[object Map]',
				numberTag = '[object Number]',
				objectTag = '[object Object]',
				regexpTag = '[object RegExp]',
				setTag = '[object Set]',
				stringTag = '[object String]',
				symbolTag = '[object Symbol]',
				weakMapTag = '[object WeakMap]'

			var arrayBufferTag = '[object ArrayBuffer]',
				dataViewTag = '[object DataView]',
				float32Tag = '[object Float32Array]',
				float64Tag = '[object Float64Array]',
				int8Tag = '[object Int8Array]',
				int16Tag = '[object Int16Array]',
				int32Tag = '[object Int32Array]',
				uint8Tag = '[object Uint8Array]',
				uint8ClampedTag = '[object Uint8ClampedArray]',
				uint16Tag = '[object Uint16Array]',
				uint32Tag = '[object Uint32Array]'

			/** Used to identify `toStringTag` values supported by `_.clone`. */
			var cloneableTags = {}
			cloneableTags[argsTag] =
				cloneableTags[arrayTag] =
				cloneableTags[arrayBufferTag] =
				cloneableTags[dataViewTag] =
				cloneableTags[boolTag] =
				cloneableTags[dateTag] =
				cloneableTags[float32Tag] =
				cloneableTags[float64Tag] =
				cloneableTags[int8Tag] =
				cloneableTags[int16Tag] =
				cloneableTags[int32Tag] =
				cloneableTags[mapTag] =
				cloneableTags[numberTag] =
				cloneableTags[objectTag] =
				cloneableTags[regexpTag] =
				cloneableTags[setTag] =
				cloneableTags[stringTag] =
				cloneableTags[symbolTag] =
				cloneableTags[uint8Tag] =
				cloneableTags[uint8ClampedTag] =
				cloneableTags[uint16Tag] =
				cloneableTags[uint32Tag] =
					true
			cloneableTags[errorTag] =
				cloneableTags[funcTag] =
				cloneableTags[weakMapTag] =
					false

			/**
			 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
			 * traversed objects.
			 *
			 * @private
			 * @param {*} value The value to clone.
			 * @param {boolean} bitmask The bitmask flags.
			 *  1 - Deep clone
			 *  2 - Flatten inherited properties
			 *  4 - Clone symbols
			 * @param {Function} [customizer] The function to customize cloning.
			 * @param {string} [key] The key of `value`.
			 * @param {Object} [object] The parent object of `value`.
			 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
			 * @returns {*} Returns the cloned value.
			 */
			function baseClone(value, bitmask, customizer, key, object, stack) {
				var result,
					isDeep = bitmask & CLONE_DEEP_FLAG,
					isFlat = bitmask & CLONE_FLAT_FLAG,
					isFull = bitmask & CLONE_SYMBOLS_FLAG

				if (customizer) {
					result = object
						? customizer(value, key, object, stack)
						: customizer(value)
				}
				if (result !== undefined) {
					return result
				}
				if (!isObject(value)) {
					return value
				}
				var isArr = isArray(value)
				if (isArr) {
					result = initCloneArray(value)
					if (!isDeep) {
						return copyArray(value, result)
					}
				} else {
					var tag = getTag(value),
						isFunc = tag == funcTag || tag == genTag

					if (isBuffer(value)) {
						return cloneBuffer(value, isDeep)
					}
					if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
						result = isFlat || isFunc ? {} : initCloneObject(value)
						if (!isDeep) {
							return isFlat
								? copySymbolsIn(value, baseAssignIn(result, value))
								: copySymbols(value, baseAssign(result, value))
						}
					} else {
						if (!cloneableTags[tag]) {
							return object ? value : {}
						}
						result = initCloneByTag(value, tag, isDeep)
					}
				}
				// Check for circular references and return its corresponding clone.
				stack || (stack = new Stack())
				var stacked = stack.get(value)
				if (stacked) {
					return stacked
				}
				stack.set(value, result)

				if (isSet(value)) {
					value.forEach(function (subValue) {
						result.add(
							baseClone(subValue, bitmask, customizer, subValue, value, stack),
						)
					})
				} else if (isMap(value)) {
					value.forEach(function (subValue, key) {
						result.set(
							key,
							baseClone(subValue, bitmask, customizer, key, value, stack),
						)
					})
				}

				var keysFunc = isFull
					? isFlat
						? getAllKeysIn
						: getAllKeys
					: isFlat
						? keysIn
						: keys

				var props = isArr ? undefined : keysFunc(value)
				arrayEach(props || value, function (subValue, key) {
					if (props) {
						key = subValue
						subValue = value[key]
					}
					// Recursively populate clone (susceptible to call stack limits).
					assignValue(
						result,
						key,
						baseClone(subValue, bitmask, customizer, key, value, stack),
					)
				})
				return result
			}

			module.exports = baseClone

			/***/
		},

		/***/ 33733: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var isObject = __nccwpck_require__(96482)

			/** Built-in value references. */
			var objectCreate = Object.create

			/**
			 * The base implementation of `_.create` without support for assigning
			 * properties to the created object.
			 *
			 * @private
			 * @param {Object} proto The object to inherit from.
			 * @returns {Object} Returns the new object.
			 */
			var baseCreate = (function () {
				function object() {}
				return function (proto) {
					if (!isObject(proto)) {
						return {}
					}
					if (objectCreate) {
						return objectCreate(proto)
					}
					object.prototype = proto
					var result = new object()
					object.prototype = undefined
					return result
				}
			})()

			module.exports = baseCreate

			/***/
		},

		/***/ 11616: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var baseForOwn = __nccwpck_require__(16484),
				createBaseEach = __nccwpck_require__(40728)

			/**
			 * The base implementation of `_.forEach` without support for iteratee shorthands.
			 *
			 * @private
			 * @param {Array|Object} collection The collection to iterate over.
			 * @param {Function} iteratee The function invoked per iteration.
			 * @returns {Array|Object} Returns `collection`.
			 */
			var baseEach = createBaseEach(baseForOwn)

			module.exports = baseEach

			/***/
		},

		/***/ 63183: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var arrayPush = __nccwpck_require__(50827),
				isFlattenable = __nccwpck_require__(45088)

			/**
			 * The base implementation of `_.flatten` with support for restricting flattening.
			 *
			 * @private
			 * @param {Array} array The array to flatten.
			 * @param {number} depth The maximum recursion depth.
			 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
			 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
			 * @param {Array} [result=[]] The initial result value.
			 * @returns {Array} Returns the new flattened array.
			 */
			function baseFlatten(array, depth, predicate, isStrict, result) {
				var index = -1,
					length = array.length

				predicate || (predicate = isFlattenable)
				result || (result = [])

				while (++index < length) {
					var value = array[index]
					if (depth > 0 && predicate(value)) {
						if (depth > 1) {
							// Recursively flatten arrays (susceptible to call stack limits).
							baseFlatten(value, depth - 1, predicate, isStrict, result)
						} else {
							arrayPush(result, value)
						}
					} else if (!isStrict) {
						result[result.length] = value
					}
				}
				return result
			}

			module.exports = baseFlatten

			/***/
		},

		/***/ 26798: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var createBaseFor = __nccwpck_require__(13142)

			/**
			 * The base implementation of `baseForOwn` which iterates over `object`
			 * properties returned by `keysFunc` and invokes `iteratee` for each property.
			 * Iteratee functions may exit iteration early by explicitly returning `false`.
			 *
			 * @private
			 * @param {Object} object The object to iterate over.
			 * @param {Function} iteratee The function invoked per iteration.
			 * @param {Function} keysFunc The function to get the keys of `object`.
			 * @returns {Object} Returns `object`.
			 */
			var baseFor = createBaseFor()

			module.exports = baseFor

			/***/
		},

		/***/ 16484: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var baseFor = __nccwpck_require__(26798),
				keys = __nccwpck_require__(26741)

			/**
			 * The base implementation of `_.forOwn` without support for iteratee shorthands.
			 *
			 * @private
			 * @param {Object} object The object to iterate over.
			 * @param {Function} iteratee The function invoked per iteration.
			 * @returns {Object} Returns `object`.
			 */
			function baseForOwn(object, iteratee) {
				return object && baseFor(object, iteratee, keys)
			}

			module.exports = baseForOwn

			/***/
		},

		/***/ 40877: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var castPath = __nccwpck_require__(77336),
				toKey = __nccwpck_require__(95086)

			/**
			 * The base implementation of `_.get` without support for default values.
			 *
			 * @private
			 * @param {Object} object The object to query.
			 * @param {Array|string} path The path of the property to get.
			 * @returns {*} Returns the resolved value.
			 */
			function baseGet(object, path) {
				path = castPath(path, object)

				var index = 0,
					length = path.length

				while (object != null && index < length) {
					object = object[toKey(path[index++])]
				}
				return index && index == length ? object : undefined
			}

			module.exports = baseGet

			/***/
		},

		/***/ 24586: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var arrayPush = __nccwpck_require__(50827),
				isArray = __nccwpck_require__(77192)

			/**
			 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
			 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
			 * symbols of `object`.
			 *
			 * @private
			 * @param {Object} object The object to query.
			 * @param {Function} keysFunc The function to get the keys of `object`.
			 * @param {Function} symbolsFunc The function to get the symbols of `object`.
			 * @returns {Array} Returns the array of property names and symbols.
			 */
			function baseGetAllKeys(object, keysFunc, symbolsFunc) {
				var result = keysFunc(object)
				return isArray(object) ? result : arrayPush(result, symbolsFunc(object))
			}

			module.exports = baseGetAllKeys

			/***/
		},

		/***/ 29117: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var Symbol = __nccwpck_require__(38584),
				getRawTag = __nccwpck_require__(95292),
				objectToString = __nccwpck_require__(71723)

			/** `Object#toString` result references. */
			var nullTag = '[object Null]',
				undefinedTag = '[object Undefined]'

			/** Built-in value references. */
			var symToStringTag = Symbol ? Symbol.toStringTag : undefined

			/**
			 * The base implementation of `getTag` without fallbacks for buggy environments.
			 *
			 * @private
			 * @param {*} value The value to query.
			 * @returns {string} Returns the `toStringTag`.
			 */
			function baseGetTag(value) {
				if (value == null) {
					return value === undefined ? undefinedTag : nullTag
				}
				return symToStringTag && symToStringTag in Object(value)
					? getRawTag(value)
					: objectToString(value)
			}

			module.exports = baseGetTag

			/***/
		},

		/***/ 6186: /***/ (module) => {
			/**
			 * The base implementation of `_.hasIn` without support for deep paths.
			 *
			 * @private
			 * @param {Object} [object] The object to query.
			 * @param {Array|string} key The key to check.
			 * @returns {boolean} Returns `true` if `key` exists, else `false`.
			 */
			function baseHasIn(object, key) {
				return object != null && key in Object(object)
			}

			module.exports = baseHasIn

			/***/
		},

		/***/ 93605: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var baseGetTag = __nccwpck_require__(29117),
				isObjectLike = __nccwpck_require__(51645)

			/** `Object#toString` result references. */
			var argsTag = '[object Arguments]'

			/**
			 * The base implementation of `_.isArguments`.
			 *
			 * @private
			 * @param {*} value The value to check.
			 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
			 */
			function baseIsArguments(value) {
				return isObjectLike(value) && baseGetTag(value) == argsTag
			}

			module.exports = baseIsArguments

			/***/
		},

		/***/ 95777: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var baseIsEqualDeep = __nccwpck_require__(19275),
				isObjectLike = __nccwpck_require__(51645)

			/**
			 * The base implementation of `_.isEqual` which supports partial comparisons
			 * and tracks traversed objects.
			 *
			 * @private
			 * @param {*} value The value to compare.
			 * @param {*} other The other value to compare.
			 * @param {boolean} bitmask The bitmask flags.
			 *  1 - Unordered comparison
			 *  2 - Partial comparison
			 * @param {Function} [customizer] The function to customize comparisons.
			 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
			 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
			 */
			function baseIsEqual(value, other, bitmask, customizer, stack) {
				if (value === other) {
					return true
				}
				if (
					value == null ||
					other == null ||
					(!isObjectLike(value) && !isObjectLike(other))
				) {
					return value !== value && other !== other
				}
				return baseIsEqualDeep(
					value,
					other,
					bitmask,
					customizer,
					baseIsEqual,
					stack,
				)
			}

			module.exports = baseIsEqual

			/***/
		},

		/***/ 19275: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var Stack = __nccwpck_require__(73262),
				equalArrays = __nccwpck_require__(5248),
				equalByTag = __nccwpck_require__(9895),
				equalObjects = __nccwpck_require__(52500),
				getTag = __nccwpck_require__(44512),
				isArray = __nccwpck_require__(77192),
				isBuffer = __nccwpck_require__(43739),
				isTypedArray = __nccwpck_require__(35000)

			/** Used to compose bitmasks for value comparisons. */
			var COMPARE_PARTIAL_FLAG = 1

			/** `Object#toString` result references. */
			var argsTag = '[object Arguments]',
				arrayTag = '[object Array]',
				objectTag = '[object Object]'

			/** Used for built-in method references. */
			var objectProto = Object.prototype

			/** Used to check objects for own properties. */
			var hasOwnProperty = objectProto.hasOwnProperty

			/**
			 * A specialized version of `baseIsEqual` for arrays and objects which performs
			 * deep comparisons and tracks traversed objects enabling objects with circular
			 * references to be compared.
			 *
			 * @private
			 * @param {Object} object The object to compare.
			 * @param {Object} other The other object to compare.
			 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
			 * @param {Function} customizer The function to customize comparisons.
			 * @param {Function} equalFunc The function to determine equivalents of values.
			 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
			 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
			 */
			function baseIsEqualDeep(
				object,
				other,
				bitmask,
				customizer,
				equalFunc,
				stack,
			) {
				var objIsArr = isArray(object),
					othIsArr = isArray(other),
					objTag = objIsArr ? arrayTag : getTag(object),
					othTag = othIsArr ? arrayTag : getTag(other)

				objTag = objTag == argsTag ? objectTag : objTag
				othTag = othTag == argsTag ? objectTag : othTag

				var objIsObj = objTag == objectTag,
					othIsObj = othTag == objectTag,
					isSameTag = objTag == othTag

				if (isSameTag && isBuffer(object)) {
					if (!isBuffer(other)) {
						return false
					}
					objIsArr = true
					objIsObj = false
				}
				if (isSameTag && !objIsObj) {
					stack || (stack = new Stack())
					return objIsArr || isTypedArray(object)
						? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
						: equalByTag(
								object,
								other,
								objTag,
								bitmask,
								customizer,
								equalFunc,
								stack,
							)
				}
				if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
					var objIsWrapped =
							objIsObj && hasOwnProperty.call(object, '__wrapped__'),
						othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__')

					if (objIsWrapped || othIsWrapped) {
						var objUnwrapped = objIsWrapped ? object.value() : object,
							othUnwrapped = othIsWrapped ? other.value() : other

						stack || (stack = new Stack())
						return equalFunc(
							objUnwrapped,
							othUnwrapped,
							bitmask,
							customizer,
							stack,
						)
					}
				}
				if (!isSameTag) {
					return false
				}
				stack || (stack = new Stack())
				return equalObjects(
					object,
					other,
					bitmask,
					customizer,
					equalFunc,
					stack,
				)
			}

			module.exports = baseIsEqualDeep

			/***/
		},

		/***/ 66051: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var getTag = __nccwpck_require__(44512),
				isObjectLike = __nccwpck_require__(51645)

			/** `Object#toString` result references. */
			var mapTag = '[object Map]'

			/**
			 * The base implementation of `_.isMap` without Node.js optimizations.
			 *
			 * @private
			 * @param {*} value The value to check.
			 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
			 */
			function baseIsMap(value) {
				return isObjectLike(value) && getTag(value) == mapTag
			}

			module.exports = baseIsMap

			/***/
		},

		/***/ 67792: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var Stack = __nccwpck_require__(73262),
				baseIsEqual = __nccwpck_require__(95777)

			/** Used to compose bitmasks for value comparisons. */
			var COMPARE_PARTIAL_FLAG = 1,
				COMPARE_UNORDERED_FLAG = 2

			/**
			 * The base implementation of `_.isMatch` without support for iteratee shorthands.
			 *
			 * @private
			 * @param {Object} object The object to inspect.
			 * @param {Object} source The object of property values to match.
			 * @param {Array} matchData The property names, values, and compare flags to match.
			 * @param {Function} [customizer] The function to customize comparisons.
			 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
			 */
			function baseIsMatch(object, source, matchData, customizer) {
				var index = matchData.length,
					length = index,
					noCustomizer = !customizer

				if (object == null) {
					return !length
				}
				object = Object(object)
				while (index--) {
					var data = matchData[index]
					if (
						noCustomizer && data[2]
							? data[1] !== object[data[0]]
							: !(data[0] in object)
					) {
						return false
					}
				}
				while (++index < length) {
					data = matchData[index]
					var key = data[0],
						objValue = object[key],
						srcValue = data[1]

					if (noCustomizer && data[2]) {
						if (objValue === undefined && !(key in object)) {
							return false
						}
					} else {
						var stack = new Stack()
						if (customizer) {
							var result = customizer(
								objValue,
								srcValue,
								key,
								object,
								source,
								stack,
							)
						}
						if (
							!(result === undefined
								? baseIsEqual(
										srcValue,
										objValue,
										COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG,
										customizer,
										stack,
									)
								: result)
						) {
							return false
						}
					}
				}
				return true
			}

			module.exports = baseIsMatch

			/***/
		},

		/***/ 92334: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var isFunction = __nccwpck_require__(34329),
				isMasked = __nccwpck_require__(46613),
				isObject = __nccwpck_require__(96482),
				toSource = __nccwpck_require__(57192)

			/**
			 * Used to match `RegExp`
			 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
			 */
			var reRegExpChar = /[\\^$.*+?()[\]{}|]/g

			/** Used to detect host constructors (Safari). */
			var reIsHostCtor = /^\[object .+?Constructor\]$/

			/** Used for built-in method references. */
			var funcProto = Function.prototype,
				objectProto = Object.prototype

			/** Used to resolve the decompiled source of functions. */
			var funcToString = funcProto.toString

			/** Used to check objects for own properties. */
			var hasOwnProperty = objectProto.hasOwnProperty

			/** Used to detect if a method is native. */
			var reIsNative = RegExp(
				'^' +
					funcToString
						.call(hasOwnProperty)
						.replace(reRegExpChar, '\\$&')
						.replace(
							/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
							'$1.*?',
						) +
					'$',
			)

			/**
			 * The base implementation of `_.isNative` without bad shim checks.
			 *
			 * @private
			 * @param {*} value The value to check.
			 * @returns {boolean} Returns `true` if `value` is a native function,
			 *  else `false`.
			 */
			function baseIsNative(value) {
				if (!isObject(value) || isMasked(value)) {
					return false
				}
				var pattern = isFunction(value) ? reIsNative : reIsHostCtor
				return pattern.test(toSource(value))
			}

			module.exports = baseIsNative

			/***/
		},

		/***/ 85901: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var getTag = __nccwpck_require__(44512),
				isObjectLike = __nccwpck_require__(51645)

			/** `Object#toString` result references. */
			var setTag = '[object Set]'

			/**
			 * The base implementation of `_.isSet` without Node.js optimizations.
			 *
			 * @private
			 * @param {*} value The value to check.
			 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
			 */
			function baseIsSet(value) {
				return isObjectLike(value) && getTag(value) == setTag
			}

			module.exports = baseIsSet

			/***/
		},

		/***/ 16880: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var baseGetTag = __nccwpck_require__(29117),
				isLength = __nccwpck_require__(56657),
				isObjectLike = __nccwpck_require__(51645)

			/** `Object#toString` result references. */
			var argsTag = '[object Arguments]',
				arrayTag = '[object Array]',
				boolTag = '[object Boolean]',
				dateTag = '[object Date]',
				errorTag = '[object Error]',
				funcTag = '[object Function]',
				mapTag = '[object Map]',
				numberTag = '[object Number]',
				objectTag = '[object Object]',
				regexpTag = '[object RegExp]',
				setTag = '[object Set]',
				stringTag = '[object String]',
				weakMapTag = '[object WeakMap]'

			var arrayBufferTag = '[object ArrayBuffer]',
				dataViewTag = '[object DataView]',
				float32Tag = '[object Float32Array]',
				float64Tag = '[object Float64Array]',
				int8Tag = '[object Int8Array]',
				int16Tag = '[object Int16Array]',
				int32Tag = '[object Int32Array]',
				uint8Tag = '[object Uint8Array]',
				uint8ClampedTag = '[object Uint8ClampedArray]',
				uint16Tag = '[object Uint16Array]',
				uint32Tag = '[object Uint32Array]'

			/** Used to identify `toStringTag` values of typed arrays. */
			var typedArrayTags = {}
			typedArrayTags[float32Tag] =
				typedArrayTags[float64Tag] =
				typedArrayTags[int8Tag] =
				typedArrayTags[int16Tag] =
				typedArrayTags[int32Tag] =
				typedArrayTags[uint8Tag] =
				typedArrayTags[uint8ClampedTag] =
				typedArrayTags[uint16Tag] =
				typedArrayTags[uint32Tag] =
					true
			typedArrayTags[argsTag] =
				typedArrayTags[arrayTag] =
				typedArrayTags[arrayBufferTag] =
				typedArrayTags[boolTag] =
				typedArrayTags[dataViewTag] =
				typedArrayTags[dateTag] =
				typedArrayTags[errorTag] =
				typedArrayTags[funcTag] =
				typedArrayTags[mapTag] =
				typedArrayTags[numberTag] =
				typedArrayTags[objectTag] =
				typedArrayTags[regexpTag] =
				typedArrayTags[setTag] =
				typedArrayTags[stringTag] =
				typedArrayTags[weakMapTag] =
					false

			/**
			 * The base implementation of `_.isTypedArray` without Node.js optimizations.
			 *
			 * @private
			 * @param {*} value The value to check.
			 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
			 */
			function baseIsTypedArray(value) {
				return (
					isObjectLike(value) &&
					isLength(value.length) &&
					!!typedArrayTags[baseGetTag(value)]
				)
			}

			module.exports = baseIsTypedArray

			/***/
		},

		/***/ 47988: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var baseMatches = __nccwpck_require__(21244),
				baseMatchesProperty = __nccwpck_require__(66481),
				identity = __nccwpck_require__(46851),
				isArray = __nccwpck_require__(77192),
				property = __nccwpck_require__(11024)

			/**
			 * The base implementation of `_.iteratee`.
			 *
			 * @private
			 * @param {*} [value=_.identity] The value to convert to an iteratee.
			 * @returns {Function} Returns the iteratee.
			 */
			function baseIteratee(value) {
				// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
				// See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
				if (typeof value == 'function') {
					return value
				}
				if (value == null) {
					return identity
				}
				if (typeof value == 'object') {
					return isArray(value)
						? baseMatchesProperty(value[0], value[1])
						: baseMatches(value)
				}
				return property(value)
			}

			module.exports = baseIteratee

			/***/
		},

		/***/ 31517: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var isPrototype = __nccwpck_require__(55944),
				nativeKeys = __nccwpck_require__(63787)

			/** Used for built-in method references. */
			var objectProto = Object.prototype

			/** Used to check objects for own properties. */
			var hasOwnProperty = objectProto.hasOwnProperty

			/**
			 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
			 *
			 * @private
			 * @param {Object} object The object to query.
			 * @returns {Array} Returns the array of property names.
			 */
			function baseKeys(object) {
				if (!isPrototype(object)) {
					return nativeKeys(object)
				}
				var result = []
				for (var key in Object(object)) {
					if (hasOwnProperty.call(object, key) && key != 'constructor') {
						result.push(key)
					}
				}
				return result
			}

			module.exports = baseKeys

			/***/
		},

		/***/ 82094: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var isObject = __nccwpck_require__(96482),
				isPrototype = __nccwpck_require__(55944),
				nativeKeysIn = __nccwpck_require__(94008)

			/** Used for built-in method references. */
			var objectProto = Object.prototype

			/** Used to check objects for own properties. */
			var hasOwnProperty = objectProto.hasOwnProperty

			/**
			 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
			 *
			 * @private
			 * @param {Object} object The object to query.
			 * @returns {Array} Returns the array of property names.
			 */
			function baseKeysIn(object) {
				if (!isObject(object)) {
					return nativeKeysIn(object)
				}
				var isProto = isPrototype(object),
					result = []

				for (var key in object) {
					if (
						!(
							key == 'constructor' &&
							(isProto || !hasOwnProperty.call(object, key))
						)
					) {
						result.push(key)
					}
				}
				return result
			}

			module.exports = baseKeysIn

			/***/
		},

		/***/ 44503: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var baseEach = __nccwpck_require__(11616),
				isArrayLike = __nccwpck_require__(75119)

			/**
			 * The base implementation of `_.map` without support for iteratee shorthands.
			 *
			 * @private
			 * @param {Array|Object} collection The collection to iterate over.
			 * @param {Function} iteratee The function invoked per iteration.
			 * @returns {Array} Returns the new mapped array.
			 */
			function baseMap(collection, iteratee) {
				var index = -1,
					result = isArrayLike(collection) ? Array(collection.length) : []

				baseEach(collection, function (value, key, collection) {
					result[++index] = iteratee(value, key, collection)
				})
				return result
			}

			module.exports = baseMap

			/***/
		},

		/***/ 21244: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var baseIsMatch = __nccwpck_require__(67792),
				getMatchData = __nccwpck_require__(69081),
				matchesStrictComparable = __nccwpck_require__(78218)

			/**
			 * The base implementation of `_.matches` which doesn't clone `source`.
			 *
			 * @private
			 * @param {Object} source The object of property values to match.
			 * @returns {Function} Returns the new spec function.
			 */
			function baseMatches(source) {
				var matchData = getMatchData(source)
				if (matchData.length == 1 && matchData[0][2]) {
					return matchesStrictComparable(matchData[0][0], matchData[0][1])
				}
				return function (object) {
					return object === source || baseIsMatch(object, source, matchData)
				}
			}

			module.exports = baseMatches

			/***/
		},

		/***/ 66481: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var baseIsEqual = __nccwpck_require__(95777),
				get = __nccwpck_require__(40181),
				hasIn = __nccwpck_require__(66306),
				isKey = __nccwpck_require__(20897),
				isStrictComparable = __nccwpck_require__(12757),
				matchesStrictComparable = __nccwpck_require__(78218),
				toKey = __nccwpck_require__(95086)

			/** Used to compose bitmasks for value comparisons. */
			var COMPARE_PARTIAL_FLAG = 1,
				COMPARE_UNORDERED_FLAG = 2

			/**
			 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
			 *
			 * @private
			 * @param {string} path The path of the property to get.
			 * @param {*} srcValue The value to match.
			 * @returns {Function} Returns the new spec function.
			 */
			function baseMatchesProperty(path, srcValue) {
				if (isKey(path) && isStrictComparable(srcValue)) {
					return matchesStrictComparable(toKey(path), srcValue)
				}
				return function (object) {
					var objValue = get(object, path)
					return objValue === undefined && objValue === srcValue
						? hasIn(object, path)
						: baseIsEqual(
								srcValue,
								objValue,
								COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG,
							)
				}
			}

			module.exports = baseMatchesProperty

			/***/
		},

		/***/ 89196: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var arrayMap = __nccwpck_require__(56649),
				baseGet = __nccwpck_require__(40877),
				baseIteratee = __nccwpck_require__(47988),
				baseMap = __nccwpck_require__(44503),
				baseSortBy = __nccwpck_require__(22388),
				baseUnary = __nccwpck_require__(55506),
				compareMultiple = __nccwpck_require__(37073),
				identity = __nccwpck_require__(46851),
				isArray = __nccwpck_require__(77192)

			/**
			 * The base implementation of `_.orderBy` without param guards.
			 *
			 * @private
			 * @param {Array|Object} collection The collection to iterate over.
			 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
			 * @param {string[]} orders The sort orders of `iteratees`.
			 * @returns {Array} Returns the new sorted array.
			 */
			function baseOrderBy(collection, iteratees, orders) {
				if (iteratees.length) {
					iteratees = arrayMap(iteratees, function (iteratee) {
						if (isArray(iteratee)) {
							return function (value) {
								return baseGet(
									value,
									iteratee.length === 1 ? iteratee[0] : iteratee,
								)
							}
						}
						return iteratee
					})
				} else {
					iteratees = [identity]
				}

				var index = -1
				iteratees = arrayMap(iteratees, baseUnary(baseIteratee))

				var result = baseMap(collection, function (value, key, collection) {
					var criteria = arrayMap(iteratees, function (iteratee) {
						return iteratee(value)
					})
					return { criteria: criteria, index: ++index, value: value }
				})

				return baseSortBy(result, function (object, other) {
					return compareMultiple(object, other, orders)
				})
			}

			module.exports = baseOrderBy

			/***/
		},

		/***/ 66136: /***/ (module) => {
			/**
			 * The base implementation of `_.property` without support for deep paths.
			 *
			 * @private
			 * @param {string} key The key of the property to get.
			 * @returns {Function} Returns the new accessor function.
			 */
			function baseProperty(key) {
				return function (object) {
					return object == null ? undefined : object[key]
				}
			}

			module.exports = baseProperty

			/***/
		},

		/***/ 32310: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var baseGet = __nccwpck_require__(40877)

			/**
			 * A specialized version of `baseProperty` which supports deep paths.
			 *
			 * @private
			 * @param {Array|string} path The path of the property to get.
			 * @returns {Function} Returns the new accessor function.
			 */
			function basePropertyDeep(path) {
				return function (object) {
					return baseGet(object, path)
				}
			}

			module.exports = basePropertyDeep

			/***/
		},

		/***/ 22035: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var identity = __nccwpck_require__(46851),
				overRest = __nccwpck_require__(20168),
				setToString = __nccwpck_require__(59402)

			/**
			 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
			 *
			 * @private
			 * @param {Function} func The function to apply a rest parameter to.
			 * @param {number} [start=func.length-1] The start position of the rest parameter.
			 * @returns {Function} Returns the new function.
			 */
			function baseRest(func, start) {
				return setToString(overRest(func, start, identity), func + '')
			}

			module.exports = baseRest

			/***/
		},

		/***/ 64953: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var constant = __nccwpck_require__(85089),
				defineProperty = __nccwpck_require__(83106),
				identity = __nccwpck_require__(46851)

			/**
			 * The base implementation of `setToString` without support for hot loop shorting.
			 *
			 * @private
			 * @param {Function} func The function to modify.
			 * @param {Function} string The `toString` result.
			 * @returns {Function} Returns `func`.
			 */
			var baseSetToString = !defineProperty
				? identity
				: function (func, string) {
						return defineProperty(func, 'toString', {
							configurable: true,
							enumerable: false,
							value: constant(string),
							writable: true,
						})
					}

			module.exports = baseSetToString

			/***/
		},

		/***/ 22388: /***/ (module) => {
			/**
			 * The base implementation of `_.sortBy` which uses `comparer` to define the
			 * sort order of `array` and replaces criteria objects with their corresponding
			 * values.
			 *
			 * @private
			 * @param {Array} array The array to sort.
			 * @param {Function} comparer The function to define sort order.
			 * @returns {Array} Returns `array`.
			 */
			function baseSortBy(array, comparer) {
				var length = array.length

				array.sort(comparer)
				while (length--) {
					array[length] = array[length].value
				}
				return array
			}

			module.exports = baseSortBy

			/***/
		},

		/***/ 21299: /***/ (module) => {
			/**
			 * The base implementation of `_.times` without support for iteratee shorthands
			 * or max array length checks.
			 *
			 * @private
			 * @param {number} n The number of times to invoke `iteratee`.
			 * @param {Function} iteratee The function invoked per iteration.
			 * @returns {Array} Returns the array of results.
			 */
			function baseTimes(n, iteratee) {
				var index = -1,
					result = Array(n)

				while (++index < n) {
					result[index] = iteratee(index)
				}
				return result
			}

			module.exports = baseTimes

			/***/
		},

		/***/ 17625: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var Symbol = __nccwpck_require__(38584),
				arrayMap = __nccwpck_require__(56649),
				isArray = __nccwpck_require__(77192),
				isSymbol = __nccwpck_require__(70661)

			/** Used as references for various `Number` constants. */
			var INFINITY = 1 / 0

			/** Used to convert symbols to primitives and strings. */
			var symbolProto = Symbol ? Symbol.prototype : undefined,
				symbolToString = symbolProto ? symbolProto.toString : undefined

			/**
			 * The base implementation of `_.toString` which doesn't convert nullish
			 * values to empty strings.
			 *
			 * @private
			 * @param {*} value The value to process.
			 * @returns {string} Returns the string.
			 */
			function baseToString(value) {
				// Exit early for strings to avoid a performance hit in some environments.
				if (typeof value == 'string') {
					return value
				}
				if (isArray(value)) {
					// Recursively convert values (susceptible to call stack limits).
					return arrayMap(value, baseToString) + ''
				}
				if (isSymbol(value)) {
					return symbolToString ? symbolToString.call(value) : ''
				}
				var result = value + ''
				return result == '0' && 1 / value == -INFINITY ? '-0' : result
			}

			module.exports = baseToString

			/***/
		},

		/***/ 55506: /***/ (module) => {
			/**
			 * The base implementation of `_.unary` without support for storing metadata.
			 *
			 * @private
			 * @param {Function} func The function to cap arguments for.
			 * @returns {Function} Returns the new capped function.
			 */
			function baseUnary(func) {
				return function (value) {
					return func(value)
				}
			}

			module.exports = baseUnary

			/***/
		},

		/***/ 64486: /***/ (module) => {
			/**
			 * Checks if a `cache` value for `key` exists.
			 *
			 * @private
			 * @param {Object} cache The cache to query.
			 * @param {string} key The key of the entry to check.
			 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
			 */
			function cacheHas(cache, key) {
				return cache.has(key)
			}

			module.exports = cacheHas

			/***/
		},

		/***/ 77336: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var isArray = __nccwpck_require__(77192),
				isKey = __nccwpck_require__(20897),
				stringToPath = __nccwpck_require__(72187),
				toString = __nccwpck_require__(87233)

			/**
			 * Casts `value` to a path array if it's not one.
			 *
			 * @private
			 * @param {*} value The value to inspect.
			 * @param {Object} [object] The object to query keys on.
			 * @returns {Array} Returns the cast property path array.
			 */
			function castPath(value, object) {
				if (isArray(value)) {
					return value
				}
				return isKey(value, object) ? [value] : stringToPath(toString(value))
			}

			module.exports = castPath

			/***/
		},

		/***/ 71336: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var Uint8Array = __nccwpck_require__(59525)

			/**
			 * Creates a clone of `arrayBuffer`.
			 *
			 * @private
			 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
			 * @returns {ArrayBuffer} Returns the cloned array buffer.
			 */
			function cloneArrayBuffer(arrayBuffer) {
				var result = new arrayBuffer.constructor(arrayBuffer.byteLength)
				new Uint8Array(result).set(new Uint8Array(arrayBuffer))
				return result
			}

			module.exports = cloneArrayBuffer

			/***/
		},

		/***/ 165: /***/ (module, exports, __nccwpck_require__) => {
			/* module decorator */ module = __nccwpck_require__.nmd(module)
			var root = __nccwpck_require__(6748)

			/** Detect free variable `exports`. */
			var freeExports = true && exports && !exports.nodeType && exports

			/** Detect free variable `module`. */
			var freeModule =
				freeExports &&
				'object' == 'object' &&
				module &&
				!module.nodeType &&
				module

			/** Detect the popular CommonJS extension `module.exports`. */
			var moduleExports = freeModule && freeModule.exports === freeExports

			/** Built-in value references. */
			var Buffer = moduleExports ? root.Buffer : undefined,
				allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined

			/**
			 * Creates a clone of  `buffer`.
			 *
			 * @private
			 * @param {Buffer} buffer The buffer to clone.
			 * @param {boolean} [isDeep] Specify a deep clone.
			 * @returns {Buffer} Returns the cloned buffer.
			 */
			function cloneBuffer(buffer, isDeep) {
				if (isDeep) {
					return buffer.slice()
				}
				var length = buffer.length,
					result = allocUnsafe
						? allocUnsafe(length)
						: new buffer.constructor(length)

				buffer.copy(result)
				return result
			}

			module.exports = cloneBuffer

			/***/
		},

		/***/ 20114: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var cloneArrayBuffer = __nccwpck_require__(71336)

			/**
			 * Creates a clone of `dataView`.
			 *
			 * @private
			 * @param {Object} dataView The data view to clone.
			 * @param {boolean} [isDeep] Specify a deep clone.
			 * @returns {Object} Returns the cloned data view.
			 */
			function cloneDataView(dataView, isDeep) {
				var buffer = isDeep
					? cloneArrayBuffer(dataView.buffer)
					: dataView.buffer
				return new dataView.constructor(
					buffer,
					dataView.byteOffset,
					dataView.byteLength,
				)
			}

			module.exports = cloneDataView

			/***/
		},

		/***/ 14798: /***/ (module) => {
			/** Used to match `RegExp` flags from their coerced string values. */
			var reFlags = /\w*$/

			/**
			 * Creates a clone of `regexp`.
			 *
			 * @private
			 * @param {Object} regexp The regexp to clone.
			 * @returns {Object} Returns the cloned regexp.
			 */
			function cloneRegExp(regexp) {
				var result = new regexp.constructor(regexp.source, reFlags.exec(regexp))
				result.lastIndex = regexp.lastIndex
				return result
			}

			module.exports = cloneRegExp

			/***/
		},

		/***/ 10539: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var Symbol = __nccwpck_require__(38584)

			/** Used to convert symbols to primitives and strings. */
			var symbolProto = Symbol ? Symbol.prototype : undefined,
				symbolValueOf = symbolProto ? symbolProto.valueOf : undefined

			/**
			 * Creates a clone of the `symbol` object.
			 *
			 * @private
			 * @param {Object} symbol The symbol object to clone.
			 * @returns {Object} Returns the cloned symbol object.
			 */
			function cloneSymbol(symbol) {
				return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {}
			}

			module.exports = cloneSymbol

			/***/
		},

		/***/ 60946: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var cloneArrayBuffer = __nccwpck_require__(71336)

			/**
			 * Creates a clone of `typedArray`.
			 *
			 * @private
			 * @param {Object} typedArray The typed array to clone.
			 * @param {boolean} [isDeep] Specify a deep clone.
			 * @returns {Object} Returns the cloned typed array.
			 */
			function cloneTypedArray(typedArray, isDeep) {
				var buffer = isDeep
					? cloneArrayBuffer(typedArray.buffer)
					: typedArray.buffer
				return new typedArray.constructor(
					buffer,
					typedArray.byteOffset,
					typedArray.length,
				)
			}

			module.exports = cloneTypedArray

			/***/
		},

		/***/ 63427: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var isSymbol = __nccwpck_require__(70661)

			/**
			 * Compares values to sort them in ascending order.
			 *
			 * @private
			 * @param {*} value The value to compare.
			 * @param {*} other The other value to compare.
			 * @returns {number} Returns the sort order indicator for `value`.
			 */
			function compareAscending(value, other) {
				if (value !== other) {
					var valIsDefined = value !== undefined,
						valIsNull = value === null,
						valIsReflexive = value === value,
						valIsSymbol = isSymbol(value)

					var othIsDefined = other !== undefined,
						othIsNull = other === null,
						othIsReflexive = other === other,
						othIsSymbol = isSymbol(other)

					if (
						(!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
						(valIsSymbol &&
							othIsDefined &&
							othIsReflexive &&
							!othIsNull &&
							!othIsSymbol) ||
						(valIsNull && othIsDefined && othIsReflexive) ||
						(!valIsDefined && othIsReflexive) ||
						!valIsReflexive
					) {
						return 1
					}
					if (
						(!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
						(othIsSymbol &&
							valIsDefined &&
							valIsReflexive &&
							!valIsNull &&
							!valIsSymbol) ||
						(othIsNull && valIsDefined && valIsReflexive) ||
						(!othIsDefined && valIsReflexive) ||
						!othIsReflexive
					) {
						return -1
					}
				}
				return 0
			}

			module.exports = compareAscending

			/***/
		},

		/***/ 37073: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var compareAscending = __nccwpck_require__(63427)

			/**
			 * Used by `_.orderBy` to compare multiple properties of a value to another
			 * and stable sort them.
			 *
			 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
			 * specify an order of "desc" for descending or "asc" for ascending sort order
			 * of corresponding values.
			 *
			 * @private
			 * @param {Object} object The object to compare.
			 * @param {Object} other The other object to compare.
			 * @param {boolean[]|string[]} orders The order to sort by for each property.
			 * @returns {number} Returns the sort order indicator for `object`.
			 */
			function compareMultiple(object, other, orders) {
				var index = -1,
					objCriteria = object.criteria,
					othCriteria = other.criteria,
					length = objCriteria.length,
					ordersLength = orders.length

				while (++index < length) {
					var result = compareAscending(objCriteria[index], othCriteria[index])
					if (result) {
						if (index >= ordersLength) {
							return result
						}
						var order = orders[index]
						return result * (order == 'desc' ? -1 : 1)
					}
				}
				// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
				// that causes it, under certain circumstances, to provide the same value for
				// `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
				// for more details.
				//
				// This also ensures a stable sort in V8 and other engines.
				// See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
				return object.index - other.index
			}

			module.exports = compareMultiple

			/***/
		},

		/***/ 77560: /***/ (module) => {
			/**
			 * Copies the values of `source` to `array`.
			 *
			 * @private
			 * @param {Array} source The array to copy values from.
			 * @param {Array} [array=[]] The array to copy values to.
			 * @returns {Array} Returns `array`.
			 */
			function copyArray(source, array) {
				var index = -1,
					length = source.length

				array || (array = Array(length))
				while (++index < length) {
					array[index] = source[index]
				}
				return array
			}

			module.exports = copyArray

			/***/
		},

		/***/ 69330: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var assignValue = __nccwpck_require__(99128),
				baseAssignValue = __nccwpck_require__(63579)

			/**
			 * Copies properties of `source` to `object`.
			 *
			 * @private
			 * @param {Object} source The object to copy properties from.
			 * @param {Array} props The property identifiers to copy.
			 * @param {Object} [object={}] The object to copy properties to.
			 * @param {Function} [customizer] The function to customize copied values.
			 * @returns {Object} Returns `object`.
			 */
			function copyObject(source, props, object, customizer) {
				var isNew = !object
				object || (object = {})

				var index = -1,
					length = props.length

				while (++index < length) {
					var key = props[index]

					var newValue = customizer
						? customizer(object[key], source[key], key, object, source)
						: undefined

					if (newValue === undefined) {
						newValue = source[key]
					}
					if (isNew) {
						baseAssignValue(object, key, newValue)
					} else {
						assignValue(object, key, newValue)
					}
				}
				return object
			}

			module.exports = copyObject

			/***/
		},

		/***/ 97472: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var copyObject = __nccwpck_require__(69330),
				getSymbols = __nccwpck_require__(65889)

			/**
			 * Copies own symbols of `source` to `object`.
			 *
			 * @private
			 * @param {Object} source The object to copy symbols from.
			 * @param {Object} [object={}] The object to copy symbols to.
			 * @returns {Object} Returns `object`.
			 */
			function copySymbols(source, object) {
				return copyObject(source, getSymbols(source), object)
			}

			module.exports = copySymbols

			/***/
		},

		/***/ 61935: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var copyObject = __nccwpck_require__(69330),
				getSymbolsIn = __nccwpck_require__(99882)

			/**
			 * Copies own and inherited symbols of `source` to `object`.
			 *
			 * @private
			 * @param {Object} source The object to copy symbols from.
			 * @param {Object} [object={}] The object to copy symbols to.
			 * @returns {Object} Returns `object`.
			 */
			function copySymbolsIn(source, object) {
				return copyObject(source, getSymbolsIn(source), object)
			}

			module.exports = copySymbolsIn

			/***/
		},

		/***/ 60252: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var root = __nccwpck_require__(6748)

			/** Used to detect overreaching core-js shims. */
			var coreJsData = root['__core-js_shared__']

			module.exports = coreJsData

			/***/
		},

		/***/ 40728: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var isArrayLike = __nccwpck_require__(75119)

			/**
			 * Creates a `baseEach` or `baseEachRight` function.
			 *
			 * @private
			 * @param {Function} eachFunc The function to iterate over a collection.
			 * @param {boolean} [fromRight] Specify iterating from right to left.
			 * @returns {Function} Returns the new base function.
			 */
			function createBaseEach(eachFunc, fromRight) {
				return function (collection, iteratee) {
					if (collection == null) {
						return collection
					}
					if (!isArrayLike(collection)) {
						return eachFunc(collection, iteratee)
					}
					var length = collection.length,
						index = fromRight ? length : -1,
						iterable = Object(collection)

					while (fromRight ? index-- : ++index < length) {
						if (iteratee(iterable[index], index, iterable) === false) {
							break
						}
					}
					return collection
				}
			}

			module.exports = createBaseEach

			/***/
		},

		/***/ 13142: /***/ (module) => {
			/**
			 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
			 *
			 * @private
			 * @param {boolean} [fromRight] Specify iterating from right to left.
			 * @returns {Function} Returns the new base function.
			 */
			function createBaseFor(fromRight) {
				return function (object, iteratee, keysFunc) {
					var index = -1,
						iterable = Object(object),
						props = keysFunc(object),
						length = props.length

					while (length--) {
						var key = props[fromRight ? length : ++index]
						if (iteratee(iterable[key], key, iterable) === false) {
							break
						}
					}
					return object
				}
			}

			module.exports = createBaseFor

			/***/
		},

		/***/ 83106: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var getNative = __nccwpck_require__(68573)

			var defineProperty = (function () {
				try {
					var func = getNative(Object, 'defineProperty')
					func({}, '', {})
					return func
				} catch (e) {}
			})()

			module.exports = defineProperty

			/***/
		},

		/***/ 5248: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var SetCache = __nccwpck_require__(23706),
				arraySome = __nccwpck_require__(90935),
				cacheHas = __nccwpck_require__(64486)

			/** Used to compose bitmasks for value comparisons. */
			var COMPARE_PARTIAL_FLAG = 1,
				COMPARE_UNORDERED_FLAG = 2

			/**
			 * A specialized version of `baseIsEqualDeep` for arrays with support for
			 * partial deep comparisons.
			 *
			 * @private
			 * @param {Array} array The array to compare.
			 * @param {Array} other The other array to compare.
			 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
			 * @param {Function} customizer The function to customize comparisons.
			 * @param {Function} equalFunc The function to determine equivalents of values.
			 * @param {Object} stack Tracks traversed `array` and `other` objects.
			 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
			 */
			function equalArrays(
				array,
				other,
				bitmask,
				customizer,
				equalFunc,
				stack,
			) {
				var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
					arrLength = array.length,
					othLength = other.length

				if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
					return false
				}
				// Check that cyclic values are equal.
				var arrStacked = stack.get(array)
				var othStacked = stack.get(other)
				if (arrStacked && othStacked) {
					return arrStacked == other && othStacked == array
				}
				var index = -1,
					result = true,
					seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined

				stack.set(array, other)
				stack.set(other, array)

				// Ignore non-index properties.
				while (++index < arrLength) {
					var arrValue = array[index],
						othValue = other[index]

					if (customizer) {
						var compared = isPartial
							? customizer(othValue, arrValue, index, other, array, stack)
							: customizer(arrValue, othValue, index, array, other, stack)
					}
					if (compared !== undefined) {
						if (compared) {
							continue
						}
						result = false
						break
					}
					// Recursively compare arrays (susceptible to call stack limits).
					if (seen) {
						if (
							!arraySome(other, function (othValue, othIndex) {
								if (
									!cacheHas(seen, othIndex) &&
									(arrValue === othValue ||
										equalFunc(arrValue, othValue, bitmask, customizer, stack))
								) {
									return seen.push(othIndex)
								}
							})
						) {
							result = false
							break
						}
					} else if (
						!(
							arrValue === othValue ||
							equalFunc(arrValue, othValue, bitmask, customizer, stack)
						)
					) {
						result = false
						break
					}
				}
				stack['delete'](array)
				stack['delete'](other)
				return result
			}

			module.exports = equalArrays

			/***/
		},

		/***/ 9895: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var Symbol = __nccwpck_require__(38584),
				Uint8Array = __nccwpck_require__(59525),
				eq = __nccwpck_require__(75199),
				equalArrays = __nccwpck_require__(5248),
				mapToArray = __nccwpck_require__(43428),
				setToArray = __nccwpck_require__(11894)

			/** Used to compose bitmasks for value comparisons. */
			var COMPARE_PARTIAL_FLAG = 1,
				COMPARE_UNORDERED_FLAG = 2

			/** `Object#toString` result references. */
			var boolTag = '[object Boolean]',
				dateTag = '[object Date]',
				errorTag = '[object Error]',
				mapTag = '[object Map]',
				numberTag = '[object Number]',
				regexpTag = '[object RegExp]',
				setTag = '[object Set]',
				stringTag = '[object String]',
				symbolTag = '[object Symbol]'

			var arrayBufferTag = '[object ArrayBuffer]',
				dataViewTag = '[object DataView]'

			/** Used to convert symbols to primitives and strings. */
			var symbolProto = Symbol ? Symbol.prototype : undefined,
				symbolValueOf = symbolProto ? symbolProto.valueOf : undefined

			/**
			 * A specialized version of `baseIsEqualDeep` for comparing objects of
			 * the same `toStringTag`.
			 *
			 * **Note:** This function only supports comparing values with tags of
			 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
			 *
			 * @private
			 * @param {Object} object The object to compare.
			 * @param {Object} other The other object to compare.
			 * @param {string} tag The `toStringTag` of the objects to compare.
			 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
			 * @param {Function} customizer The function to customize comparisons.
			 * @param {Function} equalFunc The function to determine equivalents of values.
			 * @param {Object} stack Tracks traversed `object` and `other` objects.
			 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
			 */
			function equalByTag(
				object,
				other,
				tag,
				bitmask,
				customizer,
				equalFunc,
				stack,
			) {
				switch (tag) {
					case dataViewTag:
						if (
							object.byteLength != other.byteLength ||
							object.byteOffset != other.byteOffset
						) {
							return false
						}
						object = object.buffer
						other = other.buffer

					case arrayBufferTag:
						if (
							object.byteLength != other.byteLength ||
							!equalFunc(new Uint8Array(object), new Uint8Array(other))
						) {
							return false
						}
						return true

					case boolTag:
					case dateTag:
					case numberTag:
						// Coerce booleans to `1` or `0` and dates to milliseconds.
						// Invalid dates are coerced to `NaN`.
						return eq(+object, +other)

					case errorTag:
						return object.name == other.name && object.message == other.message

					case regexpTag:
					case stringTag:
						// Coerce regexes to strings and treat strings, primitives and objects,
						// as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
						// for more details.
						return object == other + ''

					case mapTag:
						var convert = mapToArray

					case setTag:
						var isPartial = bitmask & COMPARE_PARTIAL_FLAG
						convert || (convert = setToArray)

						if (object.size != other.size && !isPartial) {
							return false
						}
						// Assume cyclic values are equal.
						var stacked = stack.get(object)
						if (stacked) {
							return stacked == other
						}
						bitmask |= COMPARE_UNORDERED_FLAG

						// Recursively compare objects (susceptible to call stack limits).
						stack.set(object, other)
						var result = equalArrays(
							convert(object),
							convert(other),
							bitmask,
							customizer,
							equalFunc,
							stack,
						)
						stack['delete'](object)
						return result

					case symbolTag:
						if (symbolValueOf) {
							return symbolValueOf.call(object) == symbolValueOf.call(other)
						}
				}
				return false
			}

			module.exports = equalByTag

			/***/
		},

		/***/ 52500: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var getAllKeys = __nccwpck_require__(78479)

			/** Used to compose bitmasks for value comparisons. */
			var COMPARE_PARTIAL_FLAG = 1

			/** Used for built-in method references. */
			var objectProto = Object.prototype

			/** Used to check objects for own properties. */
			var hasOwnProperty = objectProto.hasOwnProperty

			/**
			 * A specialized version of `baseIsEqualDeep` for objects with support for
			 * partial deep comparisons.
			 *
			 * @private
			 * @param {Object} object The object to compare.
			 * @param {Object} other The other object to compare.
			 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
			 * @param {Function} customizer The function to customize comparisons.
			 * @param {Function} equalFunc The function to determine equivalents of values.
			 * @param {Object} stack Tracks traversed `object` and `other` objects.
			 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
			 */
			function equalObjects(
				object,
				other,
				bitmask,
				customizer,
				equalFunc,
				stack,
			) {
				var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
					objProps = getAllKeys(object),
					objLength = objProps.length,
					othProps = getAllKeys(other),
					othLength = othProps.length

				if (objLength != othLength && !isPartial) {
					return false
				}
				var index = objLength
				while (index--) {
					var key = objProps[index]
					if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
						return false
					}
				}
				// Check that cyclic values are equal.
				var objStacked = stack.get(object)
				var othStacked = stack.get(other)
				if (objStacked && othStacked) {
					return objStacked == other && othStacked == object
				}
				var result = true
				stack.set(object, other)
				stack.set(other, object)

				var skipCtor = isPartial
				while (++index < objLength) {
					key = objProps[index]
					var objValue = object[key],
						othValue = other[key]

					if (customizer) {
						var compared = isPartial
							? customizer(othValue, objValue, key, other, object, stack)
							: customizer(objValue, othValue, key, object, other, stack)
					}
					// Recursively compare objects (susceptible to call stack limits).
					if (
						!(compared === undefined
							? objValue === othValue ||
								equalFunc(objValue, othValue, bitmask, customizer, stack)
							: compared)
					) {
						result = false
						break
					}
					skipCtor || (skipCtor = key == 'constructor')
				}
				if (result && !skipCtor) {
					var objCtor = object.constructor,
						othCtor = other.constructor

					// Non `Object` object instances with different constructors are not equal.
					if (
						objCtor != othCtor &&
						'constructor' in object &&
						'constructor' in other &&
						!(
							typeof objCtor == 'function' &&
							objCtor instanceof objCtor &&
							typeof othCtor == 'function' &&
							othCtor instanceof othCtor
						)
					) {
						result = false
					}
				}
				stack['delete'](object)
				stack['delete'](other)
				return result
			}

			module.exports = equalObjects

			/***/
		},

		/***/ 78997: /***/ (module) => {
			/** Detect free variable `global` from Node.js. */
			var freeGlobal =
				typeof global == 'object' &&
				global &&
				global.Object === Object &&
				global

			module.exports = freeGlobal

			/***/
		},

		/***/ 78479: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var baseGetAllKeys = __nccwpck_require__(24586),
				getSymbols = __nccwpck_require__(65889),
				keys = __nccwpck_require__(26741)

			/**
			 * Creates an array of own enumerable property names and symbols of `object`.
			 *
			 * @private
			 * @param {Object} object The object to query.
			 * @returns {Array} Returns the array of property names and symbols.
			 */
			function getAllKeys(object) {
				return baseGetAllKeys(object, keys, getSymbols)
			}

			module.exports = getAllKeys

			/***/
		},

		/***/ 17172: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var baseGetAllKeys = __nccwpck_require__(24586),
				getSymbolsIn = __nccwpck_require__(99882),
				keysIn = __nccwpck_require__(19430)

			/**
			 * Creates an array of own and inherited enumerable property names and
			 * symbols of `object`.
			 *
			 * @private
			 * @param {Object} object The object to query.
			 * @returns {Array} Returns the array of property names and symbols.
			 */
			function getAllKeysIn(object) {
				return baseGetAllKeys(object, keysIn, getSymbolsIn)
			}

			module.exports = getAllKeysIn

			/***/
		},

		/***/ 1194: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var isKeyable = __nccwpck_require__(93245)

			/**
			 * Gets the data for `map`.
			 *
			 * @private
			 * @param {Object} map The map to query.
			 * @param {string} key The reference key.
			 * @returns {*} Returns the map data.
			 */
			function getMapData(map, key) {
				var data = map.__data__
				return isKeyable(key)
					? data[typeof key == 'string' ? 'string' : 'hash']
					: data.map
			}

			module.exports = getMapData

			/***/
		},

		/***/ 69081: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var isStrictComparable = __nccwpck_require__(12757),
				keys = __nccwpck_require__(26741)

			/**
			 * Gets the property names, values, and compare flags of `object`.
			 *
			 * @private
			 * @param {Object} object The object to query.
			 * @returns {Array} Returns the match data of `object`.
			 */
			function getMatchData(object) {
				var result = keys(object),
					length = result.length

				while (length--) {
					var key = result[length],
						value = object[key]

					result[length] = [key, value, isStrictComparable(value)]
				}
				return result
			}

			module.exports = getMatchData

			/***/
		},

		/***/ 68573: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var baseIsNative = __nccwpck_require__(92334),
				getValue = __nccwpck_require__(8293)

			/**
			 * Gets the native function at `key` of `object`.
			 *
			 * @private
			 * @param {Object} object The object to query.
			 * @param {string} key The key of the method to get.
			 * @returns {*} Returns the function if it's native, else `undefined`.
			 */
			function getNative(object, key) {
				var value = getValue(object, key)
				return baseIsNative(value) ? value : undefined
			}

			module.exports = getNative

			/***/
		},

		/***/ 86194: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var overArg = __nccwpck_require__(61128)

			/** Built-in value references. */
			var getPrototype = overArg(Object.getPrototypeOf, Object)

			module.exports = getPrototype

			/***/
		},

		/***/ 95292: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var Symbol = __nccwpck_require__(38584)

			/** Used for built-in method references. */
			var objectProto = Object.prototype

			/** Used to check objects for own properties. */
			var hasOwnProperty = objectProto.hasOwnProperty

			/**
			 * Used to resolve the
			 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
			 * of values.
			 */
			var nativeObjectToString = objectProto.toString

			/** Built-in value references. */
			var symToStringTag = Symbol ? Symbol.toStringTag : undefined

			/**
			 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
			 *
			 * @private
			 * @param {*} value The value to query.
			 * @returns {string} Returns the raw `toStringTag`.
			 */
			function getRawTag(value) {
				var isOwn = hasOwnProperty.call(value, symToStringTag),
					tag = value[symToStringTag]

				try {
					value[symToStringTag] = undefined
					var unmasked = true
				} catch (e) {}

				var result = nativeObjectToString.call(value)
				if (unmasked) {
					if (isOwn) {
						value[symToStringTag] = tag
					} else {
						delete value[symToStringTag]
					}
				}
				return result
			}

			module.exports = getRawTag

			/***/
		},

		/***/ 65889: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var arrayFilter = __nccwpck_require__(78573),
				stubArray = __nccwpck_require__(43400)

			/** Used for built-in method references. */
			var objectProto = Object.prototype

			/** Built-in value references. */
			var propertyIsEnumerable = objectProto.propertyIsEnumerable

			/* Built-in method references for those with the same name as other `lodash` methods. */
			var nativeGetSymbols = Object.getOwnPropertySymbols

			/**
			 * Creates an array of the own enumerable symbols of `object`.
			 *
			 * @private
			 * @param {Object} object The object to query.
			 * @returns {Array} Returns the array of symbols.
			 */
			var getSymbols = !nativeGetSymbols
				? stubArray
				: function (object) {
						if (object == null) {
							return []
						}
						object = Object(object)
						return arrayFilter(nativeGetSymbols(object), function (symbol) {
							return propertyIsEnumerable.call(object, symbol)
						})
					}

			module.exports = getSymbols

			/***/
		},

		/***/ 99882: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var arrayPush = __nccwpck_require__(50827),
				getPrototype = __nccwpck_require__(86194),
				getSymbols = __nccwpck_require__(65889),
				stubArray = __nccwpck_require__(43400)

			/* Built-in method references for those with the same name as other `lodash` methods. */
			var nativeGetSymbols = Object.getOwnPropertySymbols

			/**
			 * Creates an array of the own and inherited enumerable symbols of `object`.
			 *
			 * @private
			 * @param {Object} object The object to query.
			 * @returns {Array} Returns the array of symbols.
			 */
			var getSymbolsIn = !nativeGetSymbols
				? stubArray
				: function (object) {
						var result = []
						while (object) {
							arrayPush(result, getSymbols(object))
							object = getPrototype(object)
						}
						return result
					}

			module.exports = getSymbolsIn

			/***/
		},

		/***/ 44512: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var DataView = __nccwpck_require__(47033),
				Map = __nccwpck_require__(98272),
				Promise = __nccwpck_require__(4455),
				Set = __nccwpck_require__(84986),
				WeakMap = __nccwpck_require__(97364),
				baseGetTag = __nccwpck_require__(29117),
				toSource = __nccwpck_require__(57192)

			/** `Object#toString` result references. */
			var mapTag = '[object Map]',
				objectTag = '[object Object]',
				promiseTag = '[object Promise]',
				setTag = '[object Set]',
				weakMapTag = '[object WeakMap]'

			var dataViewTag = '[object DataView]'

			/** Used to detect maps, sets, and weakmaps. */
			var dataViewCtorString = toSource(DataView),
				mapCtorString = toSource(Map),
				promiseCtorString = toSource(Promise),
				setCtorString = toSource(Set),
				weakMapCtorString = toSource(WeakMap)

			/**
			 * Gets the `toStringTag` of `value`.
			 *
			 * @private
			 * @param {*} value The value to query.
			 * @returns {string} Returns the `toStringTag`.
			 */
			var getTag = baseGetTag

			// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
			if (
				(DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
				(Map && getTag(new Map()) != mapTag) ||
				(Promise && getTag(Promise.resolve()) != promiseTag) ||
				(Set && getTag(new Set()) != setTag) ||
				(WeakMap && getTag(new WeakMap()) != weakMapTag)
			) {
				getTag = function (value) {
					var result = baseGetTag(value),
						Ctor = result == objectTag ? value.constructor : undefined,
						ctorString = Ctor ? toSource(Ctor) : ''

					if (ctorString) {
						switch (ctorString) {
							case dataViewCtorString:
								return dataViewTag
							case mapCtorString:
								return mapTag
							case promiseCtorString:
								return promiseTag
							case setCtorString:
								return setTag
							case weakMapCtorString:
								return weakMapTag
						}
					}
					return result
				}
			}

			module.exports = getTag

			/***/
		},

		/***/ 8293: /***/ (module) => {
			/**
			 * Gets the value at `key` of `object`.
			 *
			 * @private
			 * @param {Object} [object] The object to query.
			 * @param {string} key The key of the property to get.
			 * @returns {*} Returns the property value.
			 */
			function getValue(object, key) {
				return object == null ? undefined : object[key]
			}

			module.exports = getValue

			/***/
		},

		/***/ 48253: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var castPath = __nccwpck_require__(77336),
				isArguments = __nccwpck_require__(60541),
				isArray = __nccwpck_require__(77192),
				isIndex = __nccwpck_require__(37446),
				isLength = __nccwpck_require__(56657),
				toKey = __nccwpck_require__(95086)

			/**
			 * Checks if `path` exists on `object`.
			 *
			 * @private
			 * @param {Object} object The object to query.
			 * @param {Array|string} path The path to check.
			 * @param {Function} hasFunc The function to check properties.
			 * @returns {boolean} Returns `true` if `path` exists, else `false`.
			 */
			function hasPath(object, path, hasFunc) {
				path = castPath(path, object)

				var index = -1,
					length = path.length,
					result = false

				while (++index < length) {
					var key = toKey(path[index])
					if (!(result = object != null && hasFunc(object, key))) {
						break
					}
					object = object[key]
				}
				if (result || ++index != length) {
					return result
				}
				length = object == null ? 0 : object.length
				return (
					!!length &&
					isLength(length) &&
					isIndex(key, length) &&
					(isArray(object) || isArguments(object))
				)
			}

			module.exports = hasPath

			/***/
		},

		/***/ 48051: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var nativeCreate = __nccwpck_require__(71563)

			/**
			 * Removes all key-value entries from the hash.
			 *
			 * @private
			 * @name clear
			 * @memberOf Hash
			 */
			function hashClear() {
				this.__data__ = nativeCreate ? nativeCreate(null) : {}
				this.size = 0
			}

			module.exports = hashClear

			/***/
		},

		/***/ 15431: /***/ (module) => {
			/**
			 * Removes `key` and its value from the hash.
			 *
			 * @private
			 * @name delete
			 * @memberOf Hash
			 * @param {Object} hash The hash to modify.
			 * @param {string} key The key of the value to remove.
			 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
			 */
			function hashDelete(key) {
				var result = this.has(key) && delete this.__data__[key]
				this.size -= result ? 1 : 0
				return result
			}

			module.exports = hashDelete

			/***/
		},

		/***/ 26934: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var nativeCreate = __nccwpck_require__(71563)

			/** Used to stand-in for `undefined` hash values. */
			var HASH_UNDEFINED = '__lodash_hash_undefined__'

			/** Used for built-in method references. */
			var objectProto = Object.prototype

			/** Used to check objects for own properties. */
			var hasOwnProperty = objectProto.hasOwnProperty

			/**
			 * Gets the hash value for `key`.
			 *
			 * @private
			 * @name get
			 * @memberOf Hash
			 * @param {string} key The key of the value to get.
			 * @returns {*} Returns the entry value.
			 */
			function hashGet(key) {
				var data = this.__data__
				if (nativeCreate) {
					var result = data[key]
					return result === HASH_UNDEFINED ? undefined : result
				}
				return hasOwnProperty.call(data, key) ? data[key] : undefined
			}

			module.exports = hashGet

			/***/
		},

		/***/ 64306: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var nativeCreate = __nccwpck_require__(71563)

			/** Used for built-in method references. */
			var objectProto = Object.prototype

			/** Used to check objects for own properties. */
			var hasOwnProperty = objectProto.hasOwnProperty

			/**
			 * Checks if a hash value for `key` exists.
			 *
			 * @private
			 * @name has
			 * @memberOf Hash
			 * @param {string} key The key of the entry to check.
			 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
			 */
			function hashHas(key) {
				var data = this.__data__
				return nativeCreate
					? data[key] !== undefined
					: hasOwnProperty.call(data, key)
			}

			module.exports = hashHas

			/***/
		},

		/***/ 17226: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var nativeCreate = __nccwpck_require__(71563)

			/** Used to stand-in for `undefined` hash values. */
			var HASH_UNDEFINED = '__lodash_hash_undefined__'

			/**
			 * Sets the hash `key` to `value`.
			 *
			 * @private
			 * @name set
			 * @memberOf Hash
			 * @param {string} key The key of the value to set.
			 * @param {*} value The value to set.
			 * @returns {Object} Returns the hash instance.
			 */
			function hashSet(key, value) {
				var data = this.__data__
				this.size += this.has(key) ? 0 : 1
				data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value
				return this
			}

			module.exports = hashSet

			/***/
		},

		/***/ 43688: /***/ (module) => {
			/** Used for built-in method references. */
			var objectProto = Object.prototype

			/** Used to check objects for own properties. */
			var hasOwnProperty = objectProto.hasOwnProperty

			/**
			 * Initializes an array clone.
			 *
			 * @private
			 * @param {Array} array The array to clone.
			 * @returns {Array} Returns the initialized clone.
			 */
			function initCloneArray(array) {
				var length = array.length,
					result = new array.constructor(length)

				// Add properties assigned by `RegExp#exec`.
				if (
					length &&
					typeof array[0] == 'string' &&
					hasOwnProperty.call(array, 'index')
				) {
					result.index = array.index
					result.input = array.input
				}
				return result
			}

			module.exports = initCloneArray

			/***/
		},

		/***/ 75906: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var cloneArrayBuffer = __nccwpck_require__(71336),
				cloneDataView = __nccwpck_require__(20114),
				cloneRegExp = __nccwpck_require__(14798),
				cloneSymbol = __nccwpck_require__(10539),
				cloneTypedArray = __nccwpck_require__(60946)

			/** `Object#toString` result references. */
			var boolTag = '[object Boolean]',
				dateTag = '[object Date]',
				mapTag = '[object Map]',
				numberTag = '[object Number]',
				regexpTag = '[object RegExp]',
				setTag = '[object Set]',
				stringTag = '[object String]',
				symbolTag = '[object Symbol]'

			var arrayBufferTag = '[object ArrayBuffer]',
				dataViewTag = '[object DataView]',
				float32Tag = '[object Float32Array]',
				float64Tag = '[object Float64Array]',
				int8Tag = '[object Int8Array]',
				int16Tag = '[object Int16Array]',
				int32Tag = '[object Int32Array]',
				uint8Tag = '[object Uint8Array]',
				uint8ClampedTag = '[object Uint8ClampedArray]',
				uint16Tag = '[object Uint16Array]',
				uint32Tag = '[object Uint32Array]'

			/**
			 * Initializes an object clone based on its `toStringTag`.
			 *
			 * **Note:** This function only supports cloning values with tags of
			 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
			 *
			 * @private
			 * @param {Object} object The object to clone.
			 * @param {string} tag The `toStringTag` of the object to clone.
			 * @param {boolean} [isDeep] Specify a deep clone.
			 * @returns {Object} Returns the initialized clone.
			 */
			function initCloneByTag(object, tag, isDeep) {
				var Ctor = object.constructor
				switch (tag) {
					case arrayBufferTag:
						return cloneArrayBuffer(object)

					case boolTag:
					case dateTag:
						return new Ctor(+object)

					case dataViewTag:
						return cloneDataView(object, isDeep)

					case float32Tag:
					case float64Tag:
					case int8Tag:
					case int16Tag:
					case int32Tag:
					case uint8Tag:
					case uint8ClampedTag:
					case uint16Tag:
					case uint32Tag:
						return cloneTypedArray(object, isDeep)

					case mapTag:
						return new Ctor()

					case numberTag:
					case stringTag:
						return new Ctor(object)

					case regexpTag:
						return cloneRegExp(object)

					case setTag:
						return new Ctor()

					case symbolTag:
						return cloneSymbol(object)
				}
			}

			module.exports = initCloneByTag

			/***/
		},

		/***/ 20866: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var baseCreate = __nccwpck_require__(33733),
				getPrototype = __nccwpck_require__(86194),
				isPrototype = __nccwpck_require__(55944)

			/**
			 * Initializes an object clone.
			 *
			 * @private
			 * @param {Object} object The object to clone.
			 * @returns {Object} Returns the initialized clone.
			 */
			function initCloneObject(object) {
				return typeof object.constructor == 'function' && !isPrototype(object)
					? baseCreate(getPrototype(object))
					: {}
			}

			module.exports = initCloneObject

			/***/
		},

		/***/ 45088: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var Symbol = __nccwpck_require__(38584),
				isArguments = __nccwpck_require__(60541),
				isArray = __nccwpck_require__(77192)

			/** Built-in value references. */
			var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined

			/**
			 * Checks if `value` is a flattenable `arguments` object or array.
			 *
			 * @private
			 * @param {*} value The value to check.
			 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
			 */
			function isFlattenable(value) {
				return (
					isArray(value) ||
					isArguments(value) ||
					!!(spreadableSymbol && value && value[spreadableSymbol])
				)
			}

			module.exports = isFlattenable

			/***/
		},

		/***/ 37446: /***/ (module) => {
			/** Used as references for various `Number` constants. */
			var MAX_SAFE_INTEGER = 9007199254740991

			/** Used to detect unsigned integer values. */
			var reIsUint = /^(?:0|[1-9]\d*)$/

			/**
			 * Checks if `value` is a valid array-like index.
			 *
			 * @private
			 * @param {*} value The value to check.
			 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
			 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
			 */
			function isIndex(value, length) {
				var type = typeof value
				length = length == null ? MAX_SAFE_INTEGER : length

				return (
					!!length &&
					(type == 'number' || (type != 'symbol' && reIsUint.test(value))) &&
					value > -1 &&
					value % 1 == 0 &&
					value < length
				)
			}

			module.exports = isIndex

			/***/
		},

		/***/ 3349: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var eq = __nccwpck_require__(75199),
				isArrayLike = __nccwpck_require__(75119),
				isIndex = __nccwpck_require__(37446),
				isObject = __nccwpck_require__(96482)

			/**
			 * Checks if the given arguments are from an iteratee call.
			 *
			 * @private
			 * @param {*} value The potential iteratee value argument.
			 * @param {*} index The potential iteratee index or key argument.
			 * @param {*} object The potential iteratee object argument.
			 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
			 *  else `false`.
			 */
			function isIterateeCall(value, index, object) {
				if (!isObject(object)) {
					return false
				}
				var type = typeof index
				if (
					type == 'number'
						? isArrayLike(object) && isIndex(index, object.length)
						: type == 'string' && index in object
				) {
					return eq(object[index], value)
				}
				return false
			}

			module.exports = isIterateeCall

			/***/
		},

		/***/ 20897: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var isArray = __nccwpck_require__(77192),
				isSymbol = __nccwpck_require__(70661)

			/** Used to match property names within property paths. */
			var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
				reIsPlainProp = /^\w*$/

			/**
			 * Checks if `value` is a property name and not a property path.
			 *
			 * @private
			 * @param {*} value The value to check.
			 * @param {Object} [object] The object to query keys on.
			 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
			 */
			function isKey(value, object) {
				if (isArray(value)) {
					return false
				}
				var type = typeof value
				if (
					type == 'number' ||
					type == 'symbol' ||
					type == 'boolean' ||
					value == null ||
					isSymbol(value)
				) {
					return true
				}
				return (
					reIsPlainProp.test(value) ||
					!reIsDeepProp.test(value) ||
					(object != null && value in Object(object))
				)
			}

			module.exports = isKey

			/***/
		},

		/***/ 93245: /***/ (module) => {
			/**
			 * Checks if `value` is suitable for use as unique object key.
			 *
			 * @private
			 * @param {*} value The value to check.
			 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
			 */
			function isKeyable(value) {
				var type = typeof value
				return type == 'string' ||
					type == 'number' ||
					type == 'symbol' ||
					type == 'boolean'
					? value !== '__proto__'
					: value === null
			}

			module.exports = isKeyable

			/***/
		},

		/***/ 46613: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var coreJsData = __nccwpck_require__(60252)

			/** Used to detect methods masquerading as native. */
			var maskSrcKey = (function () {
				var uid = /[^.]+$/.exec(
					(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || '',
				)
				return uid ? 'Symbol(src)_1.' + uid : ''
			})()

			/**
			 * Checks if `func` has its source masked.
			 *
			 * @private
			 * @param {Function} func The function to check.
			 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
			 */
			function isMasked(func) {
				return !!maskSrcKey && maskSrcKey in func
			}

			module.exports = isMasked

			/***/
		},

		/***/ 55944: /***/ (module) => {
			/** Used for built-in method references. */
			var objectProto = Object.prototype

			/**
			 * Checks if `value` is likely a prototype object.
			 *
			 * @private
			 * @param {*} value The value to check.
			 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
			 */
			function isPrototype(value) {
				var Ctor = value && value.constructor,
					proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto

				return value === proto
			}

			module.exports = isPrototype

			/***/
		},

		/***/ 12757: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var isObject = __nccwpck_require__(96482)

			/**
			 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
			 *
			 * @private
			 * @param {*} value The value to check.
			 * @returns {boolean} Returns `true` if `value` if suitable for strict
			 *  equality comparisons, else `false`.
			 */
			function isStrictComparable(value) {
				return value === value && !isObject(value)
			}

			module.exports = isStrictComparable

			/***/
		},

		/***/ 99791: /***/ (module) => {
			/**
			 * Removes all key-value entries from the list cache.
			 *
			 * @private
			 * @name clear
			 * @memberOf ListCache
			 */
			function listCacheClear() {
				this.__data__ = []
				this.size = 0
			}

			module.exports = listCacheClear

			/***/
		},

		/***/ 24555: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var assocIndexOf = __nccwpck_require__(74024)

			/** Used for built-in method references. */
			var arrayProto = Array.prototype

			/** Built-in value references. */
			var splice = arrayProto.splice

			/**
			 * Removes `key` and its value from the list cache.
			 *
			 * @private
			 * @name delete
			 * @memberOf ListCache
			 * @param {string} key The key of the value to remove.
			 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
			 */
			function listCacheDelete(key) {
				var data = this.__data__,
					index = assocIndexOf(data, key)

				if (index < 0) {
					return false
				}
				var lastIndex = data.length - 1
				if (index == lastIndex) {
					data.pop()
				} else {
					splice.call(data, index, 1)
				}
				--this.size
				return true
			}

			module.exports = listCacheDelete

			/***/
		},

		/***/ 86634: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var assocIndexOf = __nccwpck_require__(74024)

			/**
			 * Gets the list cache value for `key`.
			 *
			 * @private
			 * @name get
			 * @memberOf ListCache
			 * @param {string} key The key of the value to get.
			 * @returns {*} Returns the entry value.
			 */
			function listCacheGet(key) {
				var data = this.__data__,
					index = assocIndexOf(data, key)

				return index < 0 ? undefined : data[index][1]
			}

			module.exports = listCacheGet

			/***/
		},

		/***/ 8430: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var assocIndexOf = __nccwpck_require__(74024)

			/**
			 * Checks if a list cache value for `key` exists.
			 *
			 * @private
			 * @name has
			 * @memberOf ListCache
			 * @param {string} key The key of the entry to check.
			 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
			 */
			function listCacheHas(key) {
				return assocIndexOf(this.__data__, key) > -1
			}

			module.exports = listCacheHas

			/***/
		},

		/***/ 36918: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var assocIndexOf = __nccwpck_require__(74024)

			/**
			 * Sets the list cache `key` to `value`.
			 *
			 * @private
			 * @name set
			 * @memberOf ListCache
			 * @param {string} key The key of the value to set.
			 * @param {*} value The value to set.
			 * @returns {Object} Returns the list cache instance.
			 */
			function listCacheSet(key, value) {
				var data = this.__data__,
					index = assocIndexOf(data, key)

				if (index < 0) {
					++this.size
					data.push([key, value])
				} else {
					data[index][1] = value
				}
				return this
			}

			module.exports = listCacheSet

			/***/
		},

		/***/ 88487: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var Hash = __nccwpck_require__(66320),
				ListCache = __nccwpck_require__(68884),
				Map = __nccwpck_require__(98272)

			/**
			 * Removes all key-value entries from the map.
			 *
			 * @private
			 * @name clear
			 * @memberOf MapCache
			 */
			function mapCacheClear() {
				this.size = 0
				this.__data__ = {
					hash: new Hash(),
					map: new (Map || ListCache)(),
					string: new Hash(),
				}
			}

			module.exports = mapCacheClear

			/***/
		},

		/***/ 36275: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var getMapData = __nccwpck_require__(1194)

			/**
			 * Removes `key` and its value from the map.
			 *
			 * @private
			 * @name delete
			 * @memberOf MapCache
			 * @param {string} key The key of the value to remove.
			 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
			 */
			function mapCacheDelete(key) {
				var result = getMapData(this, key)['delete'](key)
				this.size -= result ? 1 : 0
				return result
			}

			module.exports = mapCacheDelete

			/***/
		},

		/***/ 30130: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var getMapData = __nccwpck_require__(1194)

			/**
			 * Gets the map value for `key`.
			 *
			 * @private
			 * @name get
			 * @memberOf MapCache
			 * @param {string} key The key of the value to get.
			 * @returns {*} Returns the entry value.
			 */
			function mapCacheGet(key) {
				return getMapData(this, key).get(key)
			}

			module.exports = mapCacheGet

			/***/
		},

		/***/ 69254: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var getMapData = __nccwpck_require__(1194)

			/**
			 * Checks if a map value for `key` exists.
			 *
			 * @private
			 * @name has
			 * @memberOf MapCache
			 * @param {string} key The key of the entry to check.
			 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
			 */
			function mapCacheHas(key) {
				return getMapData(this, key).has(key)
			}

			module.exports = mapCacheHas

			/***/
		},

		/***/ 59806: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var getMapData = __nccwpck_require__(1194)

			/**
			 * Sets the map `key` to `value`.
			 *
			 * @private
			 * @name set
			 * @memberOf MapCache
			 * @param {string} key The key of the value to set.
			 * @param {*} value The value to set.
			 * @returns {Object} Returns the map cache instance.
			 */
			function mapCacheSet(key, value) {
				var data = getMapData(this, key),
					size = data.size

				data.set(key, value)
				this.size += data.size == size ? 0 : 1
				return this
			}

			module.exports = mapCacheSet

			/***/
		},

		/***/ 43428: /***/ (module) => {
			/**
			 * Converts `map` to its key-value pairs.
			 *
			 * @private
			 * @param {Object} map The map to convert.
			 * @returns {Array} Returns the key-value pairs.
			 */
			function mapToArray(map) {
				var index = -1,
					result = Array(map.size)

				map.forEach(function (value, key) {
					result[++index] = [key, value]
				})
				return result
			}

			module.exports = mapToArray

			/***/
		},

		/***/ 78218: /***/ (module) => {
			/**
			 * A specialized version of `matchesProperty` for source values suitable
			 * for strict equality comparisons, i.e. `===`.
			 *
			 * @private
			 * @param {string} key The key of the property to get.
			 * @param {*} srcValue The value to match.
			 * @returns {Function} Returns the new spec function.
			 */
			function matchesStrictComparable(key, srcValue) {
				return function (object) {
					if (object == null) {
						return false
					}
					return (
						object[key] === srcValue &&
						(srcValue !== undefined || key in Object(object))
					)
				}
			}

			module.exports = matchesStrictComparable

			/***/
		},

		/***/ 41471: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var memoize = __nccwpck_require__(24769)

			/** Used as the maximum memoize cache size. */
			var MAX_MEMOIZE_SIZE = 500

			/**
			 * A specialized version of `_.memoize` which clears the memoized function's
			 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
			 *
			 * @private
			 * @param {Function} func The function to have its output memoized.
			 * @returns {Function} Returns the new memoized function.
			 */
			function memoizeCapped(func) {
				var result = memoize(func, function (key) {
					if (cache.size === MAX_MEMOIZE_SIZE) {
						cache.clear()
					}
					return key
				})

				var cache = result.cache
				return result
			}

			module.exports = memoizeCapped

			/***/
		},

		/***/ 71563: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var getNative = __nccwpck_require__(68573)

			/* Built-in method references that are verified to be native. */
			var nativeCreate = getNative(Object, 'create')

			module.exports = nativeCreate

			/***/
		},

		/***/ 63787: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var overArg = __nccwpck_require__(61128)

			/* Built-in method references for those with the same name as other `lodash` methods. */
			var nativeKeys = overArg(Object.keys, Object)

			module.exports = nativeKeys

			/***/
		},

		/***/ 94008: /***/ (module) => {
			/**
			 * This function is like
			 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
			 * except that it includes inherited enumerable properties.
			 *
			 * @private
			 * @param {Object} object The object to query.
			 * @returns {Array} Returns the array of property names.
			 */
			function nativeKeysIn(object) {
				var result = []
				if (object != null) {
					for (var key in Object(object)) {
						result.push(key)
					}
				}
				return result
			}

			module.exports = nativeKeysIn

			/***/
		},

		/***/ 88724: /***/ (module, exports, __nccwpck_require__) => {
			/* module decorator */ module = __nccwpck_require__.nmd(module)
			var freeGlobal = __nccwpck_require__(78997)

			/** Detect free variable `exports`. */
			var freeExports = true && exports && !exports.nodeType && exports

			/** Detect free variable `module`. */
			var freeModule =
				freeExports &&
				'object' == 'object' &&
				module &&
				!module.nodeType &&
				module

			/** Detect the popular CommonJS extension `module.exports`. */
			var moduleExports = freeModule && freeModule.exports === freeExports

			/** Detect free variable `process` from Node.js. */
			var freeProcess = moduleExports && freeGlobal.process

			/** Used to access faster Node.js helpers. */
			var nodeUtil = (function () {
				try {
					// Use `util.types` for Node.js 10+.
					var types =
						freeModule && freeModule.require && freeModule.require('util').types

					if (types) {
						return types
					}

					// Legacy `process.binding('util')` for Node.js < 10.
					return (
						freeProcess && freeProcess.binding && freeProcess.binding('util')
					)
				} catch (e) {}
			})()

			module.exports = nodeUtil

			/***/
		},

		/***/ 71723: /***/ (module) => {
			/** Used for built-in method references. */
			var objectProto = Object.prototype

			/**
			 * Used to resolve the
			 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
			 * of values.
			 */
			var nativeObjectToString = objectProto.toString

			/**
			 * Converts `value` to a string using `Object.prototype.toString`.
			 *
			 * @private
			 * @param {*} value The value to convert.
			 * @returns {string} Returns the converted string.
			 */
			function objectToString(value) {
				return nativeObjectToString.call(value)
			}

			module.exports = objectToString

			/***/
		},

		/***/ 61128: /***/ (module) => {
			/**
			 * Creates a unary function that invokes `func` with its argument transformed.
			 *
			 * @private
			 * @param {Function} func The function to wrap.
			 * @param {Function} transform The argument transform.
			 * @returns {Function} Returns the new function.
			 */
			function overArg(func, transform) {
				return function (arg) {
					return func(transform(arg))
				}
			}

			module.exports = overArg

			/***/
		},

		/***/ 20168: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var apply = __nccwpck_require__(59678)

			/* Built-in method references for those with the same name as other `lodash` methods. */
			var nativeMax = Math.max

			/**
			 * A specialized version of `baseRest` which transforms the rest array.
			 *
			 * @private
			 * @param {Function} func The function to apply a rest parameter to.
			 * @param {number} [start=func.length-1] The start position of the rest parameter.
			 * @param {Function} transform The rest array transform.
			 * @returns {Function} Returns the new function.
			 */
			function overRest(func, start, transform) {
				start = nativeMax(start === undefined ? func.length - 1 : start, 0)
				return function () {
					var args = arguments,
						index = -1,
						length = nativeMax(args.length - start, 0),
						array = Array(length)

					while (++index < length) {
						array[index] = args[start + index]
					}
					index = -1
					var otherArgs = Array(start + 1)
					while (++index < start) {
						otherArgs[index] = args[index]
					}
					otherArgs[start] = transform(array)
					return apply(func, this, otherArgs)
				}
			}

			module.exports = overRest

			/***/
		},

		/***/ 6748: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var freeGlobal = __nccwpck_require__(78997)

			/** Detect free variable `self`. */
			var freeSelf =
				typeof self == 'object' && self && self.Object === Object && self

			/** Used as a reference to the global object. */
			var root = freeGlobal || freeSelf || Function('return this')()

			module.exports = root

			/***/
		},

		/***/ 44671: /***/ (module) => {
			/** Used to stand-in for `undefined` hash values. */
			var HASH_UNDEFINED = '__lodash_hash_undefined__'

			/**
			 * Adds `value` to the array cache.
			 *
			 * @private
			 * @name add
			 * @memberOf SetCache
			 * @alias push
			 * @param {*} value The value to cache.
			 * @returns {Object} Returns the cache instance.
			 */
			function setCacheAdd(value) {
				this.__data__.set(value, HASH_UNDEFINED)
				return this
			}

			module.exports = setCacheAdd

			/***/
		},

		/***/ 71884: /***/ (module) => {
			/**
			 * Checks if `value` is in the array cache.
			 *
			 * @private
			 * @name has
			 * @memberOf SetCache
			 * @param {*} value The value to search for.
			 * @returns {number} Returns `true` if `value` is found, else `false`.
			 */
			function setCacheHas(value) {
				return this.__data__.has(value)
			}

			module.exports = setCacheHas

			/***/
		},

		/***/ 11894: /***/ (module) => {
			/**
			 * Converts `set` to an array of its values.
			 *
			 * @private
			 * @param {Object} set The set to convert.
			 * @returns {Array} Returns the values.
			 */
			function setToArray(set) {
				var index = -1,
					result = Array(set.size)

				set.forEach(function (value) {
					result[++index] = value
				})
				return result
			}

			module.exports = setToArray

			/***/
		},

		/***/ 59402: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var baseSetToString = __nccwpck_require__(64953),
				shortOut = __nccwpck_require__(83286)

			/**
			 * Sets the `toString` method of `func` to return `string`.
			 *
			 * @private
			 * @param {Function} func The function to modify.
			 * @param {Function} string The `toString` result.
			 * @returns {Function} Returns `func`.
			 */
			var setToString = shortOut(baseSetToString)

			module.exports = setToString

			/***/
		},

		/***/ 83286: /***/ (module) => {
			/** Used to detect hot functions by number of calls within a span of milliseconds. */
			var HOT_COUNT = 800,
				HOT_SPAN = 16

			/* Built-in method references for those with the same name as other `lodash` methods. */
			var nativeNow = Date.now

			/**
			 * Creates a function that'll short out and invoke `identity` instead
			 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
			 * milliseconds.
			 *
			 * @private
			 * @param {Function} func The function to restrict.
			 * @returns {Function} Returns the new shortable function.
			 */
			function shortOut(func) {
				var count = 0,
					lastCalled = 0

				return function () {
					var stamp = nativeNow(),
						remaining = HOT_SPAN - (stamp - lastCalled)

					lastCalled = stamp
					if (remaining > 0) {
						if (++count >= HOT_COUNT) {
							return arguments[0]
						}
					} else {
						count = 0
					}
					return func.apply(undefined, arguments)
				}
			}

			module.exports = shortOut

			/***/
		},

		/***/ 91509: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var ListCache = __nccwpck_require__(68884)

			/**
			 * Removes all key-value entries from the stack.
			 *
			 * @private
			 * @name clear
			 * @memberOf Stack
			 */
			function stackClear() {
				this.__data__ = new ListCache()
				this.size = 0
			}

			module.exports = stackClear

			/***/
		},

		/***/ 837: /***/ (module) => {
			/**
			 * Removes `key` and its value from the stack.
			 *
			 * @private
			 * @name delete
			 * @memberOf Stack
			 * @param {string} key The key of the value to remove.
			 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
			 */
			function stackDelete(key) {
				var data = this.__data__,
					result = data['delete'](key)

				this.size = data.size
				return result
			}

			module.exports = stackDelete

			/***/
		},

		/***/ 46572: /***/ (module) => {
			/**
			 * Gets the stack value for `key`.
			 *
			 * @private
			 * @name get
			 * @memberOf Stack
			 * @param {string} key The key of the value to get.
			 * @returns {*} Returns the entry value.
			 */
			function stackGet(key) {
				return this.__data__.get(key)
			}

			module.exports = stackGet

			/***/
		},

		/***/ 66216: /***/ (module) => {
			/**
			 * Checks if a stack value for `key` exists.
			 *
			 * @private
			 * @name has
			 * @memberOf Stack
			 * @param {string} key The key of the entry to check.
			 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
			 */
			function stackHas(key) {
				return this.__data__.has(key)
			}

			module.exports = stackHas

			/***/
		},

		/***/ 51976: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var ListCache = __nccwpck_require__(68884),
				Map = __nccwpck_require__(98272),
				MapCache = __nccwpck_require__(79660)

			/** Used as the size to enable large array optimizations. */
			var LARGE_ARRAY_SIZE = 200

			/**
			 * Sets the stack `key` to `value`.
			 *
			 * @private
			 * @name set
			 * @memberOf Stack
			 * @param {string} key The key of the value to set.
			 * @param {*} value The value to set.
			 * @returns {Object} Returns the stack cache instance.
			 */
			function stackSet(key, value) {
				var data = this.__data__
				if (data instanceof ListCache) {
					var pairs = data.__data__
					if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
						pairs.push([key, value])
						this.size = ++data.size
						return this
					}
					data = this.__data__ = new MapCache(pairs)
				}
				data.set(key, value)
				this.size = data.size
				return this
			}

			module.exports = stackSet

			/***/
		},

		/***/ 72187: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var memoizeCapped = __nccwpck_require__(41471)

			/** Used to match property names within property paths. */
			var rePropName =
				/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g

			/** Used to match backslashes in property paths. */
			var reEscapeChar = /\\(\\)?/g

			/**
			 * Converts `string` to a property path array.
			 *
			 * @private
			 * @param {string} string The string to convert.
			 * @returns {Array} Returns the property path array.
			 */
			var stringToPath = memoizeCapped(function (string) {
				var result = []
				if (string.charCodeAt(0) === 46 /* . */) {
					result.push('')
				}
				string.replace(rePropName, function (match, number, quote, subString) {
					result.push(
						quote ? subString.replace(reEscapeChar, '$1') : number || match,
					)
				})
				return result
			})

			module.exports = stringToPath

			/***/
		},

		/***/ 95086: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var isSymbol = __nccwpck_require__(70661)

			/** Used as references for various `Number` constants. */
			var INFINITY = 1 / 0

			/**
			 * Converts `value` to a string key if it's not a string or symbol.
			 *
			 * @private
			 * @param {*} value The value to inspect.
			 * @returns {string|symbol} Returns the key.
			 */
			function toKey(value) {
				if (typeof value == 'string' || isSymbol(value)) {
					return value
				}
				var result = value + ''
				return result == '0' && 1 / value == -INFINITY ? '-0' : result
			}

			module.exports = toKey

			/***/
		},

		/***/ 57192: /***/ (module) => {
			/** Used for built-in method references. */
			var funcProto = Function.prototype

			/** Used to resolve the decompiled source of functions. */
			var funcToString = funcProto.toString

			/**
			 * Converts `func` to its source code.
			 *
			 * @private
			 * @param {Function} func The function to convert.
			 * @returns {string} Returns the source code.
			 */
			function toSource(func) {
				if (func != null) {
					try {
						return funcToString.call(func)
					} catch (e) {}
					try {
						return func + ''
					} catch (e) {}
				}
				return ''
			}

			module.exports = toSource

			/***/
		},

		/***/ 80542: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var baseClone = __nccwpck_require__(62504)

			/** Used to compose bitmasks for cloning. */
			var CLONE_DEEP_FLAG = 1,
				CLONE_SYMBOLS_FLAG = 4

			/**
			 * This method is like `_.clone` except that it recursively clones `value`.
			 *
			 * @static
			 * @memberOf _
			 * @since 1.0.0
			 * @category Lang
			 * @param {*} value The value to recursively clone.
			 * @returns {*} Returns the deep cloned value.
			 * @see _.clone
			 * @example
			 *
			 * var objects = [{ 'a': 1 }, { 'b': 2 }];
			 *
			 * var deep = _.cloneDeep(objects);
			 * console.log(deep[0] === objects[0]);
			 * // => false
			 */
			function cloneDeep(value) {
				return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG)
			}

			module.exports = cloneDeep

			/***/
		},

		/***/ 85089: /***/ (module) => {
			/**
			 * Creates a function that returns `value`.
			 *
			 * @static
			 * @memberOf _
			 * @since 2.4.0
			 * @category Util
			 * @param {*} value The value to return from the new function.
			 * @returns {Function} Returns the new constant function.
			 * @example
			 *
			 * var objects = _.times(2, _.constant({ 'a': 1 }));
			 *
			 * console.log(objects);
			 * // => [{ 'a': 1 }, { 'a': 1 }]
			 *
			 * console.log(objects[0] === objects[1]);
			 * // => true
			 */
			function constant(value) {
				return function () {
					return value
				}
			}

			module.exports = constant

			/***/
		},

		/***/ 75199: /***/ (module) => {
			/**
			 * Performs a
			 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
			 * comparison between two values to determine if they are equivalent.
			 *
			 * @static
			 * @memberOf _
			 * @since 4.0.0
			 * @category Lang
			 * @param {*} value The value to compare.
			 * @param {*} other The other value to compare.
			 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
			 * @example
			 *
			 * var object = { 'a': 1 };
			 * var other = { 'a': 1 };
			 *
			 * _.eq(object, object);
			 * // => true
			 *
			 * _.eq(object, other);
			 * // => false
			 *
			 * _.eq('a', 'a');
			 * // => true
			 *
			 * _.eq('a', Object('a'));
			 * // => false
			 *
			 * _.eq(NaN, NaN);
			 * // => true
			 */
			function eq(value, other) {
				return value === other || (value !== value && other !== other)
			}

			module.exports = eq

			/***/
		},

		/***/ 66195: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var toString = __nccwpck_require__(87233)

			/**
			 * Used to match `RegExp`
			 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
			 */
			var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
				reHasRegExpChar = RegExp(reRegExpChar.source)

			/**
			 * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
			 * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
			 *
			 * @static
			 * @memberOf _
			 * @since 3.0.0
			 * @category String
			 * @param {string} [string=''] The string to escape.
			 * @returns {string} Returns the escaped string.
			 * @example
			 *
			 * _.escapeRegExp('[lodash](https://lodash.com/)');
			 * // => '\[lodash\]\(https://lodash\.com/\)'
			 */
			function escapeRegExp(string) {
				string = toString(string)
				return string && reHasRegExpChar.test(string)
					? string.replace(reRegExpChar, '\\$&')
					: string
			}

			module.exports = escapeRegExp

			/***/
		},

		/***/ 40181: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var baseGet = __nccwpck_require__(40877)

			/**
			 * Gets the value at `path` of `object`. If the resolved value is
			 * `undefined`, the `defaultValue` is returned in its place.
			 *
			 * @static
			 * @memberOf _
			 * @since 3.7.0
			 * @category Object
			 * @param {Object} object The object to query.
			 * @param {Array|string} path The path of the property to get.
			 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
			 * @returns {*} Returns the resolved value.
			 * @example
			 *
			 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
			 *
			 * _.get(object, 'a[0].b.c');
			 * // => 3
			 *
			 * _.get(object, ['a', '0', 'b', 'c']);
			 * // => 3
			 *
			 * _.get(object, 'a.b.c', 'default');
			 * // => 'default'
			 */
			function get(object, path, defaultValue) {
				var result = object == null ? undefined : baseGet(object, path)
				return result === undefined ? defaultValue : result
			}

			module.exports = get

			/***/
		},

		/***/ 66306: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var baseHasIn = __nccwpck_require__(6186),
				hasPath = __nccwpck_require__(48253)

			/**
			 * Checks if `path` is a direct or inherited property of `object`.
			 *
			 * @static
			 * @memberOf _
			 * @since 4.0.0
			 * @category Object
			 * @param {Object} object The object to query.
			 * @param {Array|string} path The path to check.
			 * @returns {boolean} Returns `true` if `path` exists, else `false`.
			 * @example
			 *
			 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
			 *
			 * _.hasIn(object, 'a');
			 * // => true
			 *
			 * _.hasIn(object, 'a.b');
			 * // => true
			 *
			 * _.hasIn(object, ['a', 'b']);
			 * // => true
			 *
			 * _.hasIn(object, 'b');
			 * // => false
			 */
			function hasIn(object, path) {
				return object != null && hasPath(object, path, baseHasIn)
			}

			module.exports = hasIn

			/***/
		},

		/***/ 46851: /***/ (module) => {
			/**
			 * This method returns the first argument it receives.
			 *
			 * @static
			 * @since 0.1.0
			 * @memberOf _
			 * @category Util
			 * @param {*} value Any value.
			 * @returns {*} Returns `value`.
			 * @example
			 *
			 * var object = { 'a': 1 };
			 *
			 * console.log(_.identity(object) === object);
			 * // => true
			 */
			function identity(value) {
				return value
			}

			module.exports = identity

			/***/
		},

		/***/ 60541: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var baseIsArguments = __nccwpck_require__(93605),
				isObjectLike = __nccwpck_require__(51645)

			/** Used for built-in method references. */
			var objectProto = Object.prototype

			/** Used to check objects for own properties. */
			var hasOwnProperty = objectProto.hasOwnProperty

			/** Built-in value references. */
			var propertyIsEnumerable = objectProto.propertyIsEnumerable

			/**
			 * Checks if `value` is likely an `arguments` object.
			 *
			 * @static
			 * @memberOf _
			 * @since 0.1.0
			 * @category Lang
			 * @param {*} value The value to check.
			 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
			 *  else `false`.
			 * @example
			 *
			 * _.isArguments(function() { return arguments; }());
			 * // => true
			 *
			 * _.isArguments([1, 2, 3]);
			 * // => false
			 */
			var isArguments = baseIsArguments(
				(function () {
					return arguments
				})(),
			)
				? baseIsArguments
				: function (value) {
						return (
							isObjectLike(value) &&
							hasOwnProperty.call(value, 'callee') &&
							!propertyIsEnumerable.call(value, 'callee')
						)
					}

			module.exports = isArguments

			/***/
		},

		/***/ 77192: /***/ (module) => {
			/**
			 * Checks if `value` is classified as an `Array` object.
			 *
			 * @static
			 * @memberOf _
			 * @since 0.1.0
			 * @category Lang
			 * @param {*} value The value to check.
			 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
			 * @example
			 *
			 * _.isArray([1, 2, 3]);
			 * // => true
			 *
			 * _.isArray(document.body.children);
			 * // => false
			 *
			 * _.isArray('abc');
			 * // => false
			 *
			 * _.isArray(_.noop);
			 * // => false
			 */
			var isArray = Array.isArray

			module.exports = isArray

			/***/
		},

		/***/ 75119: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var isFunction = __nccwpck_require__(34329),
				isLength = __nccwpck_require__(56657)

			/**
			 * Checks if `value` is array-like. A value is considered array-like if it's
			 * not a function and has a `value.length` that's an integer greater than or
			 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
			 *
			 * @static
			 * @memberOf _
			 * @since 4.0.0
			 * @category Lang
			 * @param {*} value The value to check.
			 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
			 * @example
			 *
			 * _.isArrayLike([1, 2, 3]);
			 * // => true
			 *
			 * _.isArrayLike(document.body.children);
			 * // => true
			 *
			 * _.isArrayLike('abc');
			 * // => true
			 *
			 * _.isArrayLike(_.noop);
			 * // => false
			 */
			function isArrayLike(value) {
				return value != null && isLength(value.length) && !isFunction(value)
			}

			module.exports = isArrayLike

			/***/
		},

		/***/ 43739: /***/ (module, exports, __nccwpck_require__) => {
			/* module decorator */ module = __nccwpck_require__.nmd(module)
			var root = __nccwpck_require__(6748),
				stubFalse = __nccwpck_require__(92074)

			/** Detect free variable `exports`. */
			var freeExports = true && exports && !exports.nodeType && exports

			/** Detect free variable `module`. */
			var freeModule =
				freeExports &&
				'object' == 'object' &&
				module &&
				!module.nodeType &&
				module

			/** Detect the popular CommonJS extension `module.exports`. */
			var moduleExports = freeModule && freeModule.exports === freeExports

			/** Built-in value references. */
			var Buffer = moduleExports ? root.Buffer : undefined

			/* Built-in method references for those with the same name as other `lodash` methods. */
			var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined

			/**
			 * Checks if `value` is a buffer.
			 *
			 * @static
			 * @memberOf _
			 * @since 4.3.0
			 * @category Lang
			 * @param {*} value The value to check.
			 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
			 * @example
			 *
			 * _.isBuffer(new Buffer(2));
			 * // => true
			 *
			 * _.isBuffer(new Uint8Array(2));
			 * // => false
			 */
			var isBuffer = nativeIsBuffer || stubFalse

			module.exports = isBuffer

			/***/
		},

		/***/ 34329: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var baseGetTag = __nccwpck_require__(29117),
				isObject = __nccwpck_require__(96482)

			/** `Object#toString` result references. */
			var asyncTag = '[object AsyncFunction]',
				funcTag = '[object Function]',
				genTag = '[object GeneratorFunction]',
				proxyTag = '[object Proxy]'

			/**
			 * Checks if `value` is classified as a `Function` object.
			 *
			 * @static
			 * @memberOf _
			 * @since 0.1.0
			 * @category Lang
			 * @param {*} value The value to check.
			 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
			 * @example
			 *
			 * _.isFunction(_);
			 * // => true
			 *
			 * _.isFunction(/abc/);
			 * // => false
			 */
			function isFunction(value) {
				if (!isObject(value)) {
					return false
				}
				// The use of `Object#toString` avoids issues with the `typeof` operator
				// in Safari 9 which returns 'object' for typed arrays and other constructors.
				var tag = baseGetTag(value)
				return (
					tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag
				)
			}

			module.exports = isFunction

			/***/
		},

		/***/ 56657: /***/ (module) => {
			/** Used as references for various `Number` constants. */
			var MAX_SAFE_INTEGER = 9007199254740991

			/**
			 * Checks if `value` is a valid array-like length.
			 *
			 * **Note:** This method is loosely based on
			 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
			 *
			 * @static
			 * @memberOf _
			 * @since 4.0.0
			 * @category Lang
			 * @param {*} value The value to check.
			 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
			 * @example
			 *
			 * _.isLength(3);
			 * // => true
			 *
			 * _.isLength(Number.MIN_VALUE);
			 * // => false
			 *
			 * _.isLength(Infinity);
			 * // => false
			 *
			 * _.isLength('3');
			 * // => false
			 */
			function isLength(value) {
				return (
					typeof value == 'number' &&
					value > -1 &&
					value % 1 == 0 &&
					value <= MAX_SAFE_INTEGER
				)
			}

			module.exports = isLength

			/***/
		},

		/***/ 85995: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var baseIsMap = __nccwpck_require__(66051),
				baseUnary = __nccwpck_require__(55506),
				nodeUtil = __nccwpck_require__(88724)

			/* Node.js helper references. */
			var nodeIsMap = nodeUtil && nodeUtil.isMap

			/**
			 * Checks if `value` is classified as a `Map` object.
			 *
			 * @static
			 * @memberOf _
			 * @since 4.3.0
			 * @category Lang
			 * @param {*} value The value to check.
			 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
			 * @example
			 *
			 * _.isMap(new Map);
			 * // => true
			 *
			 * _.isMap(new WeakMap);
			 * // => false
			 */
			var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap

			module.exports = isMap

			/***/
		},

		/***/ 96482: /***/ (module) => {
			/**
			 * Checks if `value` is the
			 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
			 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
			 *
			 * @static
			 * @memberOf _
			 * @since 0.1.0
			 * @category Lang
			 * @param {*} value The value to check.
			 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
			 * @example
			 *
			 * _.isObject({});
			 * // => true
			 *
			 * _.isObject([1, 2, 3]);
			 * // => true
			 *
			 * _.isObject(_.noop);
			 * // => true
			 *
			 * _.isObject(null);
			 * // => false
			 */
			function isObject(value) {
				var type = typeof value
				return value != null && (type == 'object' || type == 'function')
			}

			module.exports = isObject

			/***/
		},

		/***/ 51645: /***/ (module) => {
			/**
			 * Checks if `value` is object-like. A value is object-like if it's not `null`
			 * and has a `typeof` result of "object".
			 *
			 * @static
			 * @memberOf _
			 * @since 4.0.0
			 * @category Lang
			 * @param {*} value The value to check.
			 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
			 * @example
			 *
			 * _.isObjectLike({});
			 * // => true
			 *
			 * _.isObjectLike([1, 2, 3]);
			 * // => true
			 *
			 * _.isObjectLike(_.noop);
			 * // => false
			 *
			 * _.isObjectLike(null);
			 * // => false
			 */
			function isObjectLike(value) {
				return value != null && typeof value == 'object'
			}

			module.exports = isObjectLike

			/***/
		},

		/***/ 27077: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var baseIsSet = __nccwpck_require__(85901),
				baseUnary = __nccwpck_require__(55506),
				nodeUtil = __nccwpck_require__(88724)

			/* Node.js helper references. */
			var nodeIsSet = nodeUtil && nodeUtil.isSet

			/**
			 * Checks if `value` is classified as a `Set` object.
			 *
			 * @static
			 * @memberOf _
			 * @since 4.3.0
			 * @category Lang
			 * @param {*} value The value to check.
			 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
			 * @example
			 *
			 * _.isSet(new Set);
			 * // => true
			 *
			 * _.isSet(new WeakSet);
			 * // => false
			 */
			var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet

			module.exports = isSet

			/***/
		},

		/***/ 70661: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var baseGetTag = __nccwpck_require__(29117),
				isObjectLike = __nccwpck_require__(51645)

			/** `Object#toString` result references. */
			var symbolTag = '[object Symbol]'

			/**
			 * Checks if `value` is classified as a `Symbol` primitive or object.
			 *
			 * @static
			 * @memberOf _
			 * @since 4.0.0
			 * @category Lang
			 * @param {*} value The value to check.
			 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
			 * @example
			 *
			 * _.isSymbol(Symbol.iterator);
			 * // => true
			 *
			 * _.isSymbol('abc');
			 * // => false
			 */
			function isSymbol(value) {
				return (
					typeof value == 'symbol' ||
					(isObjectLike(value) && baseGetTag(value) == symbolTag)
				)
			}

			module.exports = isSymbol

			/***/
		},

		/***/ 35000: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var baseIsTypedArray = __nccwpck_require__(16880),
				baseUnary = __nccwpck_require__(55506),
				nodeUtil = __nccwpck_require__(88724)

			/* Node.js helper references. */
			var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray

			/**
			 * Checks if `value` is classified as a typed array.
			 *
			 * @static
			 * @memberOf _
			 * @since 3.0.0
			 * @category Lang
			 * @param {*} value The value to check.
			 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
			 * @example
			 *
			 * _.isTypedArray(new Uint8Array);
			 * // => true
			 *
			 * _.isTypedArray([]);
			 * // => false
			 */
			var isTypedArray = nodeIsTypedArray
				? baseUnary(nodeIsTypedArray)
				: baseIsTypedArray

			module.exports = isTypedArray

			/***/
		},

		/***/ 26741: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var arrayLikeKeys = __nccwpck_require__(62000),
				baseKeys = __nccwpck_require__(31517),
				isArrayLike = __nccwpck_require__(75119)

			/**
			 * Creates an array of the own enumerable property names of `object`.
			 *
			 * **Note:** Non-object values are coerced to objects. See the
			 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
			 * for more details.
			 *
			 * @static
			 * @since 0.1.0
			 * @memberOf _
			 * @category Object
			 * @param {Object} object The object to query.
			 * @returns {Array} Returns the array of property names.
			 * @example
			 *
			 * function Foo() {
			 *   this.a = 1;
			 *   this.b = 2;
			 * }
			 *
			 * Foo.prototype.c = 3;
			 *
			 * _.keys(new Foo);
			 * // => ['a', 'b'] (iteration order is not guaranteed)
			 *
			 * _.keys('hi');
			 * // => ['0', '1']
			 */
			function keys(object) {
				return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object)
			}

			module.exports = keys

			/***/
		},

		/***/ 19430: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var arrayLikeKeys = __nccwpck_require__(62000),
				baseKeysIn = __nccwpck_require__(82094),
				isArrayLike = __nccwpck_require__(75119)

			/**
			 * Creates an array of the own and inherited enumerable property names of `object`.
			 *
			 * **Note:** Non-object values are coerced to objects.
			 *
			 * @static
			 * @memberOf _
			 * @since 3.0.0
			 * @category Object
			 * @param {Object} object The object to query.
			 * @returns {Array} Returns the array of property names.
			 * @example
			 *
			 * function Foo() {
			 *   this.a = 1;
			 *   this.b = 2;
			 * }
			 *
			 * Foo.prototype.c = 3;
			 *
			 * _.keysIn(new Foo);
			 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
			 */
			function keysIn(object) {
				return isArrayLike(object)
					? arrayLikeKeys(object, true)
					: baseKeysIn(object)
			}

			module.exports = keysIn

			/***/
		},

		/***/ 24769: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var MapCache = __nccwpck_require__(79660)

			/** Error message constants. */
			var FUNC_ERROR_TEXT = 'Expected a function'

			/**
			 * Creates a function that memoizes the result of `func`. If `resolver` is
			 * provided, it determines the cache key for storing the result based on the
			 * arguments provided to the memoized function. By default, the first argument
			 * provided to the memoized function is used as the map cache key. The `func`
			 * is invoked with the `this` binding of the memoized function.
			 *
			 * **Note:** The cache is exposed as the `cache` property on the memoized
			 * function. Its creation may be customized by replacing the `_.memoize.Cache`
			 * constructor with one whose instances implement the
			 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
			 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
			 *
			 * @static
			 * @memberOf _
			 * @since 0.1.0
			 * @category Function
			 * @param {Function} func The function to have its output memoized.
			 * @param {Function} [resolver] The function to resolve the cache key.
			 * @returns {Function} Returns the new memoized function.
			 * @example
			 *
			 * var object = { 'a': 1, 'b': 2 };
			 * var other = { 'c': 3, 'd': 4 };
			 *
			 * var values = _.memoize(_.values);
			 * values(object);
			 * // => [1, 2]
			 *
			 * values(other);
			 * // => [3, 4]
			 *
			 * object.a = 2;
			 * values(object);
			 * // => [1, 2]
			 *
			 * // Modify the result cache.
			 * values.cache.set(object, ['a', 'b']);
			 * values(object);
			 * // => ['a', 'b']
			 *
			 * // Replace `_.memoize.Cache`.
			 * _.memoize.Cache = WeakMap;
			 */
			function memoize(func, resolver) {
				if (
					typeof func != 'function' ||
					(resolver != null && typeof resolver != 'function')
				) {
					throw new TypeError(FUNC_ERROR_TEXT)
				}
				var memoized = function () {
					var args = arguments,
						key = resolver ? resolver.apply(this, args) : args[0],
						cache = memoized.cache

					if (cache.has(key)) {
						return cache.get(key)
					}
					var result = func.apply(this, args)
					memoized.cache = cache.set(key, result) || cache
					return result
				}
				memoized.cache = new (memoize.Cache || MapCache)()
				return memoized
			}

			// Expose `MapCache`.
			memoize.Cache = MapCache

			module.exports = memoize

			/***/
		},

		/***/ 11024: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var baseProperty = __nccwpck_require__(66136),
				basePropertyDeep = __nccwpck_require__(32310),
				isKey = __nccwpck_require__(20897),
				toKey = __nccwpck_require__(95086)

			/**
			 * Creates a function that returns the value at `path` of a given object.
			 *
			 * @static
			 * @memberOf _
			 * @since 2.4.0
			 * @category Util
			 * @param {Array|string} path The path of the property to get.
			 * @returns {Function} Returns the new accessor function.
			 * @example
			 *
			 * var objects = [
			 *   { 'a': { 'b': 2 } },
			 *   { 'a': { 'b': 1 } }
			 * ];
			 *
			 * _.map(objects, _.property('a.b'));
			 * // => [2, 1]
			 *
			 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
			 * // => [1, 2]
			 */
			function property(path) {
				return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path)
			}

			module.exports = property

			/***/
		},

		/***/ 94604: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var baseFlatten = __nccwpck_require__(63183),
				baseOrderBy = __nccwpck_require__(89196),
				baseRest = __nccwpck_require__(22035),
				isIterateeCall = __nccwpck_require__(3349)

			/**
			 * Creates an array of elements, sorted in ascending order by the results of
			 * running each element in a collection thru each iteratee. This method
			 * performs a stable sort, that is, it preserves the original sort order of
			 * equal elements. The iteratees are invoked with one argument: (value).
			 *
			 * @static
			 * @memberOf _
			 * @since 0.1.0
			 * @category Collection
			 * @param {Array|Object} collection The collection to iterate over.
			 * @param {...(Function|Function[])} [iteratees=[_.identity]]
			 *  The iteratees to sort by.
			 * @returns {Array} Returns the new sorted array.
			 * @example
			 *
			 * var users = [
			 *   { 'user': 'fred',   'age': 48 },
			 *   { 'user': 'barney', 'age': 36 },
			 *   { 'user': 'fred',   'age': 30 },
			 *   { 'user': 'barney', 'age': 34 }
			 * ];
			 *
			 * _.sortBy(users, [function(o) { return o.user; }]);
			 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
			 *
			 * _.sortBy(users, ['user', 'age']);
			 * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
			 */
			var sortBy = baseRest(function (collection, iteratees) {
				if (collection == null) {
					return []
				}
				var length = iteratees.length
				if (
					length > 1 &&
					isIterateeCall(collection, iteratees[0], iteratees[1])
				) {
					iteratees = []
				} else if (
					length > 2 &&
					isIterateeCall(iteratees[0], iteratees[1], iteratees[2])
				) {
					iteratees = [iteratees[0]]
				}
				return baseOrderBy(collection, baseFlatten(iteratees, 1), [])
			})

			module.exports = sortBy

			/***/
		},

		/***/ 43400: /***/ (module) => {
			/**
			 * This method returns a new empty array.
			 *
			 * @static
			 * @memberOf _
			 * @since 4.13.0
			 * @category Util
			 * @returns {Array} Returns the new empty array.
			 * @example
			 *
			 * var arrays = _.times(2, _.stubArray);
			 *
			 * console.log(arrays);
			 * // => [[], []]
			 *
			 * console.log(arrays[0] === arrays[1]);
			 * // => false
			 */
			function stubArray() {
				return []
			}

			module.exports = stubArray

			/***/
		},

		/***/ 92074: /***/ (module) => {
			/**
			 * This method returns `false`.
			 *
			 * @static
			 * @memberOf _
			 * @since 4.13.0
			 * @category Util
			 * @returns {boolean} Returns `false`.
			 * @example
			 *
			 * _.times(2, _.stubFalse);
			 * // => [false, false]
			 */
			function stubFalse() {
				return false
			}

			module.exports = stubFalse

			/***/
		},

		/***/ 87233: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var baseToString = __nccwpck_require__(17625)

			/**
			 * Converts `value` to a string. An empty string is returned for `null`
			 * and `undefined` values. The sign of `-0` is preserved.
			 *
			 * @static
			 * @memberOf _
			 * @since 4.0.0
			 * @category Lang
			 * @param {*} value The value to convert.
			 * @returns {string} Returns the converted string.
			 * @example
			 *
			 * _.toString(null);
			 * // => ''
			 *
			 * _.toString(-0);
			 * // => '-0'
			 *
			 * _.toString([1, 2, 3]);
			 * // => '1,2,3'
			 */
			function toString(value) {
				return value == null ? '' : baseToString(value)
			}

			module.exports = toString

			/***/
		},

		/***/ 86863: /***/ (module) => {
			'use strict'

			module.exports = longestStreak

			// Get the count of the longest repeating streak of `character` in `value`.
			function longestStreak(value, character) {
				var count = 0
				var maximum = 0
				var expected
				var index

				if (typeof character !== 'string' || character.length !== 1) {
					throw new Error('Expected character')
				}

				value = String(value)
				index = value.indexOf(character)
				expected = index

				while (index !== -1) {
					count++

					if (index === expected) {
						if (count > maximum) {
							maximum = count
						}
					} else {
						count = 1
					}

					expected = index + 1
					index = value.indexOf(character, expected)
				}

				return maximum
			}

			/***/
		},

		/***/ 80872: /***/ (module) => {
			'use strict'

			module.exports = escapes

			var defaults = [
				'\\',
				'`',
				'*',
				'{',
				'}',
				'[',
				']',
				'(',
				')',
				'#',
				'+',
				'-',
				'.',
				'!',
				'_',
				'>',
			]

			var gfm = defaults.concat(['~', '|'])

			var commonmark = gfm.concat([
				'\n',
				'"',
				'$',
				'%',
				'&',
				"'",
				',',
				'/',
				':',
				';',
				'<',
				'=',
				'?',
				'@',
				'^',
			])

			escapes.default = defaults
			escapes.gfm = gfm
			escapes.commonmark = commonmark

			// Get markdown escapes.
			function escapes(options) {
				var settings = options || {}

				if (settings.commonmark) {
					return commonmark
				}

				return settings.gfm ? gfm : defaults
			}

			/***/
		},

		/***/ 56558: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var visit = __nccwpck_require__(21916)

			module.exports = compact

			// Make an mdast tree compact by merging adjacent text nodes.
			function compact(tree, commonmark) {
				visit(tree, visitor)

				return tree

				function visitor(child, index, parent) {
					var siblings = parent ? parent.children : []
					var prev = index && siblings[index - 1]

					if (
						prev &&
						child.type === prev.type &&
						mergeable(prev, commonmark) &&
						mergeable(child, commonmark)
					) {
						if (child.value) {
							prev.value += child.value
						}

						if (child.children) {
							prev.children = prev.children.concat(child.children)
						}

						siblings.splice(index, 1)

						if (prev.position && child.position) {
							prev.position.end = child.position.end
						}

						return index
					}
				}
			}

			function mergeable(node, commonmark) {
				var start
				var end

				if (node.type === 'text') {
					if (!node.position) {
						return true
					}

					start = node.position.start
					end = node.position.end

					// Only merge nodes which occupy the same size as their `value`.
					return (
						start.line !== end.line ||
						end.column - start.column === node.value.length
					)
				}

				return commonmark && node.type === 'blockquote'
			}

			/***/
		},

		/***/ 43478: /***/ (module) => {
			'use strict'

			module.exports = convert

			function convert(test) {
				if (test == null) {
					return ok
				}

				if (typeof test === 'string') {
					return typeFactory(test)
				}

				if (typeof test === 'object') {
					return 'length' in test ? anyFactory(test) : allFactory(test)
				}

				if (typeof test === 'function') {
					return test
				}

				throw new Error('Expected function, string, or object as test')
			}

			// Utility assert each property in `test` is represented in `node`, and each
			// values are strictly equal.
			function allFactory(test) {
				return all

				function all(node) {
					var key

					for (key in test) {
						if (node[key] !== test[key]) return false
					}

					return true
				}
			}

			function anyFactory(tests) {
				var checks = []
				var index = -1

				while (++index < tests.length) {
					checks[index] = convert(tests[index])
				}

				return any

				function any() {
					var index = -1

					while (++index < checks.length) {
						if (checks[index].apply(this, arguments)) {
							return true
						}
					}

					return false
				}
			}

			// Utility to convert a string into a function which checks a given nodes type
			// for said string.
			function typeFactory(test) {
				return type

				function type(node) {
					return Boolean(node && node.type === test)
				}
			}

			// Utility to return true.
			function ok() {
				return true
			}

			/***/
		},

		/***/ 25511: /***/ (module) => {
			module.exports = color
			function color(d) {
				return '\u001B[33m' + d + '\u001B[39m'
			}

			/***/
		},

		/***/ 63024: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			module.exports = visitParents

			var convert = __nccwpck_require__(43478)
			var color = __nccwpck_require__(25511)

			var CONTINUE = true
			var SKIP = 'skip'
			var EXIT = false

			visitParents.CONTINUE = CONTINUE
			visitParents.SKIP = SKIP
			visitParents.EXIT = EXIT

			function visitParents(tree, test, visitor, reverse) {
				var step
				var is

				if (typeof test === 'function' && typeof visitor !== 'function') {
					reverse = visitor
					visitor = test
					test = null
				}

				is = convert(test)
				step = reverse ? -1 : 1

				factory(tree, null, [])()

				function factory(node, index, parents) {
					var value = typeof node === 'object' && node !== null ? node : {}
					var name

					if (typeof value.type === 'string') {
						name =
							typeof value.tagName === 'string'
								? value.tagName
								: typeof value.name === 'string'
									? value.name
									: undefined

						visit.displayName =
							'node (' +
							color(value.type + (name ? '<' + name + '>' : '')) +
							')'
					}

					return visit

					function visit() {
						var grandparents = parents.concat(node)
						var result = []
						var subresult
						var offset

						if (!test || is(node, index, parents[parents.length - 1] || null)) {
							result = toResult(visitor(node, parents))

							if (result[0] === EXIT) {
								return result
							}
						}

						if (node.children && result[0] !== SKIP) {
							offset = (reverse ? node.children.length : -1) + step

							while (offset > -1 && offset < node.children.length) {
								subresult = factory(
									node.children[offset],
									offset,
									grandparents,
								)()

								if (subresult[0] === EXIT) {
									return subresult
								}

								offset =
									typeof subresult[1] === 'number'
										? subresult[1]
										: offset + step
							}
						}

						return result
					}
				}
			}

			function toResult(value) {
				if (value !== null && typeof value === 'object' && 'length' in value) {
					return value
				}

				if (typeof value === 'number') {
					return [CONTINUE, value]
				}

				return [value]
			}

			/***/
		},

		/***/ 21916: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			module.exports = visit

			var visitParents = __nccwpck_require__(63024)

			var CONTINUE = visitParents.CONTINUE
			var SKIP = visitParents.SKIP
			var EXIT = visitParents.EXIT

			visit.CONTINUE = CONTINUE
			visit.SKIP = SKIP
			visit.EXIT = EXIT

			function visit(tree, test, visitor, reverse) {
				if (typeof test === 'function' && typeof visitor !== 'function') {
					reverse = visitor
					visitor = test
					test = null
				}

				visitParents(tree, test, overload, reverse)

				function overload(node, parents) {
					var parent = parents[parents.length - 1]
					var index = parent ? parent.children.indexOf(node) : null
					return visitor(node, index, parent)
				}
			}

			/***/
		},

		/***/ 70744: /***/ (module) => {
			/**
			 * Helpers.
			 */

			var s = 1000
			var m = s * 60
			var h = m * 60
			var d = h * 24
			var w = d * 7
			var y = d * 365.25

			/**
			 * Parse or format the given `val`.
			 *
			 * Options:
			 *
			 *  - `long` verbose formatting [false]
			 *
			 * @param {String|Number} val
			 * @param {Object} [options]
			 * @throws {Error} throw an error if val is not a non-empty string or a number
			 * @return {String|Number}
			 * @api public
			 */

			module.exports = function (val, options) {
				options = options || {}
				var type = typeof val
				if (type === 'string' && val.length > 0) {
					return parse(val)
				} else if (type === 'number' && isFinite(val)) {
					return options.long ? fmtLong(val) : fmtShort(val)
				}
				throw new Error(
					'val is not a non-empty string or a valid number. val=' +
						JSON.stringify(val),
				)
			}

			/**
			 * Parse the given `str` and return milliseconds.
			 *
			 * @param {String} str
			 * @return {Number}
			 * @api private
			 */

			function parse(str) {
				str = String(str)
				if (str.length > 100) {
					return
				}
				var match =
					/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
						str,
					)
				if (!match) {
					return
				}
				var n = parseFloat(match[1])
				var type = (match[2] || 'ms').toLowerCase()
				switch (type) {
					case 'years':
					case 'year':
					case 'yrs':
					case 'yr':
					case 'y':
						return n * y
					case 'weeks':
					case 'week':
					case 'w':
						return n * w
					case 'days':
					case 'day':
					case 'd':
						return n * d
					case 'hours':
					case 'hour':
					case 'hrs':
					case 'hr':
					case 'h':
						return n * h
					case 'minutes':
					case 'minute':
					case 'mins':
					case 'min':
					case 'm':
						return n * m
					case 'seconds':
					case 'second':
					case 'secs':
					case 'sec':
					case 's':
						return n * s
					case 'milliseconds':
					case 'millisecond':
					case 'msecs':
					case 'msec':
					case 'ms':
						return n
					default:
						return undefined
				}
			}

			/**
			 * Short format for `ms`.
			 *
			 * @param {Number} ms
			 * @return {String}
			 * @api private
			 */

			function fmtShort(ms) {
				var msAbs = Math.abs(ms)
				if (msAbs >= d) {
					return Math.round(ms / d) + 'd'
				}
				if (msAbs >= h) {
					return Math.round(ms / h) + 'h'
				}
				if (msAbs >= m) {
					return Math.round(ms / m) + 'm'
				}
				if (msAbs >= s) {
					return Math.round(ms / s) + 's'
				}
				return ms + 'ms'
			}

			/**
			 * Long format for `ms`.
			 *
			 * @param {Number} ms
			 * @return {String}
			 * @api private
			 */

			function fmtLong(ms) {
				var msAbs = Math.abs(ms)
				if (msAbs >= d) {
					return plural(ms, msAbs, d, 'day')
				}
				if (msAbs >= h) {
					return plural(ms, msAbs, h, 'hour')
				}
				if (msAbs >= m) {
					return plural(ms, msAbs, m, 'minute')
				}
				if (msAbs >= s) {
					return plural(ms, msAbs, s, 'second')
				}
				return ms + ' ms'
			}

			/**
			 * Pluralization helper.
			 */

			function plural(ms, msAbs, n, name) {
				var isPlural = msAbs >= n * 1.5
				return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '')
			}

			/***/
		},

		/***/ 37879: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var characterEntities = __nccwpck_require__(37839)

			module.exports = decodeEntity

			var own = {}.hasOwnProperty

			function decodeEntity(characters) {
				return own.call(characterEntities, characters)
					? characterEntities[characters]
					: false
			}

			/***/
		},

		/***/ 75165: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var legacy = __nccwpck_require__(82719)
			var invalid = __nccwpck_require__(21257)
			var decimal = __nccwpck_require__(96734)
			var hexadecimal = __nccwpck_require__(84794)
			var alphanumerical = __nccwpck_require__(51685)
			var decodeEntity = __nccwpck_require__(37879)

			module.exports = parseEntities

			var own = {}.hasOwnProperty
			var fromCharCode = String.fromCharCode
			var noop = Function.prototype

			// Default settings.
			var defaults = {
				warning: null,
				reference: null,
				text: null,
				warningContext: null,
				referenceContext: null,
				textContext: null,
				position: {},
				additional: null,
				attribute: false,
				nonTerminated: true,
			}

			// Characters.
			var tab = 9 // '\t'
			var lineFeed = 10 // '\n'
			var formFeed = 12 // '\f'
			var space = 32 // ' '
			var ampersand = 38 // '&'
			var semicolon = 59 // ';'
			var lessThan = 60 // '<'
			var equalsTo = 61 // '='
			var numberSign = 35 // '#'
			var uppercaseX = 88 // 'X'
			var lowercaseX = 120 // 'x'
			var replacementCharacter = 65533 // ''

			// Reference types.
			var name = 'named'
			var hexa = 'hexadecimal'
			var deci = 'decimal'

			// Map of bases.
			var bases = {}

			bases[hexa] = 16
			bases[deci] = 10

			// Map of types to tests.
			// Each type of character reference accepts different characters.
			// This test is used to detect whether a reference has ended (as the semicolon
			// is not strictly needed).
			var tests = {}

			tests[name] = alphanumerical
			tests[deci] = decimal
			tests[hexa] = hexadecimal

			// Warning types.
			var namedNotTerminated = 1
			var numericNotTerminated = 2
			var namedEmpty = 3
			var numericEmpty = 4
			var namedUnknown = 5
			var numericDisallowed = 6
			var numericProhibited = 7

			// Warning messages.
			var messages = {}

			messages[namedNotTerminated] =
				'Named character references must be terminated by a semicolon'
			messages[numericNotTerminated] =
				'Numeric character references must be terminated by a semicolon'
			messages[namedEmpty] = 'Named character references cannot be empty'
			messages[numericEmpty] = 'Numeric character references cannot be empty'
			messages[namedUnknown] = 'Named character references must be known'
			messages[numericDisallowed] =
				'Numeric character references cannot be disallowed'
			messages[numericProhibited] =
				'Numeric character references cannot be outside the permissible Unicode range'

			// Wrap to ensure clean parameters are given to `parse`.
			function parseEntities(value, options) {
				var settings = {}
				var option
				var key

				if (!options) {
					options = {}
				}

				for (key in defaults) {
					option = options[key]
					settings[key] =
						option === null || option === undefined ? defaults[key] : option
				}

				if (settings.position.indent || settings.position.start) {
					settings.indent = settings.position.indent || []
					settings.position = settings.position.start
				}

				return parse(value, settings)
			}

			// Parse entities.
			// eslint-disable-next-line complexity
			function parse(value, settings) {
				var additional = settings.additional
				var nonTerminated = settings.nonTerminated
				var handleText = settings.text
				var handleReference = settings.reference
				var handleWarning = settings.warning
				var textContext = settings.textContext
				var referenceContext = settings.referenceContext
				var warningContext = settings.warningContext
				var pos = settings.position
				var indent = settings.indent || []
				var length = value.length
				var index = 0
				var lines = -1
				var column = pos.column || 1
				var line = pos.line || 1
				var queue = ''
				var result = []
				var entityCharacters
				var namedEntity
				var terminated
				var characters
				var character
				var reference
				var following
				var warning
				var reason
				var output
				var entity
				var begin
				var start
				var type
				var test
				var prev
				var next
				var diff
				var end

				if (typeof additional === 'string') {
					additional = additional.charCodeAt(0)
				}

				// Cache the current point.
				prev = now()

				// Wrap `handleWarning`.
				warning = handleWarning ? parseError : noop

				// Ensure the algorithm walks over the first character and the end
				// (inclusive).
				index--
				length++

				while (++index < length) {
					// If the previous character was a newline.
					if (character === lineFeed) {
						column = indent[lines] || 1
					}

					character = value.charCodeAt(index)

					if (character === ampersand) {
						following = value.charCodeAt(index + 1)

						// The behaviour depends on the identity of the next character.
						if (
							following === tab ||
							following === lineFeed ||
							following === formFeed ||
							following === space ||
							following === ampersand ||
							following === lessThan ||
							following !== following ||
							(additional && following === additional)
						) {
							// Not a character reference.
							// No characters are consumed, and nothing is returned.
							// This is not an error, either.
							queue += fromCharCode(character)
							column++

							continue
						}

						start = index + 1
						begin = start
						end = start

						if (following === numberSign) {
							// Numerical entity.
							end = ++begin

							// The behaviour further depends on the next character.
							following = value.charCodeAt(end)

							if (following === uppercaseX || following === lowercaseX) {
								// ASCII hex digits.
								type = hexa
								end = ++begin
							} else {
								// ASCII digits.
								type = deci
							}
						} else {
							// Named entity.
							type = name
						}

						entityCharacters = ''
						entity = ''
						characters = ''
						test = tests[type]
						end--

						while (++end < length) {
							following = value.charCodeAt(end)

							if (!test(following)) {
								break
							}

							characters += fromCharCode(following)

							// Check if we can match a legacy named reference.
							// If so, we cache that as the last viable named reference.
							// This ensures we do not need to walk backwards later.
							if (type === name && own.call(legacy, characters)) {
								entityCharacters = characters
								entity = legacy[characters]
							}
						}

						terminated = value.charCodeAt(end) === semicolon

						if (terminated) {
							end++

							namedEntity = type === name ? decodeEntity(characters) : false

							if (namedEntity) {
								entityCharacters = characters
								entity = namedEntity
							}
						}

						diff = 1 + end - start

						if (!terminated && !nonTerminated) {
							// Empty.
						} else if (!characters) {
							// An empty (possible) entity is valid, unless its numeric (thus an
							// ampersand followed by an octothorp).
							if (type !== name) {
								warning(numericEmpty, diff)
							}
						} else if (type === name) {
							// An ampersand followed by anything unknown, and not terminated, is
							// invalid.
							if (terminated && !entity) {
								warning(namedUnknown, 1)
							} else {
								// If theres something after an entity name which is not known, cap
								// the reference.
								if (entityCharacters !== characters) {
									end = begin + entityCharacters.length
									diff = 1 + end - begin
									terminated = false
								}

								// If the reference is not terminated, warn.
								if (!terminated) {
									reason = entityCharacters ? namedNotTerminated : namedEmpty

									if (settings.attribute) {
										following = value.charCodeAt(end)

										if (following === equalsTo) {
											warning(reason, diff)
											entity = null
										} else if (alphanumerical(following)) {
											entity = null
										} else {
											warning(reason, diff)
										}
									} else {
										warning(reason, diff)
									}
								}
							}

							reference = entity
						} else {
							if (!terminated) {
								// All non-terminated numeric entities are not rendered, and trigger a
								// warning.
								warning(numericNotTerminated, diff)
							}

							// When terminated and number, parse as either hexadecimal or decimal.
							reference = parseInt(characters, bases[type])

							// Trigger a warning when the parsed number is prohibited, and replace
							// with replacement character.
							if (prohibited(reference)) {
								warning(numericProhibited, diff)
								reference = fromCharCode(replacementCharacter)
							} else if (reference in invalid) {
								// Trigger a warning when the parsed number is disallowed, and replace
								// by an alternative.
								warning(numericDisallowed, diff)
								reference = invalid[reference]
							} else {
								// Parse the number.
								output = ''

								// Trigger a warning when the parsed number should not be used.
								if (disallowed(reference)) {
									warning(numericDisallowed, diff)
								}

								// Stringify the number.
								if (reference > 0xffff) {
									reference -= 0x10000
									output += fromCharCode((reference >>> (10 & 0x3ff)) | 0xd800)
									reference = 0xdc00 | (reference & 0x3ff)
								}

								reference = output + fromCharCode(reference)
							}
						}

						// Found it!
						// First eat the queued characters as normal text, then eat an entity.
						if (reference) {
							flush()

							prev = now()
							index = end - 1
							column += end - start + 1
							result.push(reference)
							next = now()
							next.offset++

							if (handleReference) {
								handleReference.call(
									referenceContext,
									reference,
									{ start: prev, end: next },
									value.slice(start - 1, end),
								)
							}

							prev = next
						} else {
							// If we could not find a reference, queue the checked characters (as
							// normal characters), and move the pointer to their end.
							// This is possible because we can be certain neither newlines nor
							// ampersands are included.
							characters = value.slice(start - 1, end)
							queue += characters
							column += characters.length
							index = end - 1
						}
					} else {
						// Handle anything other than an ampersand, including newlines and EOF.
						if (
							character === 10 // Line feed
						) {
							line++
							lines++
							column = 0
						}

						if (character === character) {
							queue += fromCharCode(character)
							column++
						} else {
							flush()
						}
					}
				}

				// Return the reduced nodes.
				return result.join('')

				// Get current position.
				function now() {
					return {
						line: line,
						column: column,
						offset: index + (pos.offset || 0),
					}
				}

				// Throw a parse-error: a warning.
				function parseError(code, offset) {
					var position = now()

					position.column += offset
					position.offset += offset

					handleWarning.call(warningContext, messages[code], position, code)
				}

				// Flush `queue` (normal text).
				// Macro invoked before each entity and at the end of `value`.
				// Does nothing when `queue` is empty.
				function flush() {
					if (queue) {
						result.push(queue)

						if (handleText) {
							handleText.call(textContext, queue, { start: prev, end: now() })
						}

						queue = ''
					}
				}
			}

			// Check if `character` is outside the permissible unicode range.
			function prohibited(code) {
				return (code >= 0xd800 && code <= 0xdfff) || code > 0x10ffff
			}

			// Check if `character` is disallowed.
			function disallowed(code) {
				return (
					(code >= 0x0001 && code <= 0x0008) ||
					code === 0x000b ||
					(code >= 0x000d && code <= 0x001f) ||
					(code >= 0x007f && code <= 0x009f) ||
					(code >= 0xfdd0 && code <= 0xfdef) ||
					(code & 0xffff) === 0xffff ||
					(code & 0xffff) === 0xfffe
				)
			}

			/***/
		},

		/***/ 33269: /***/ (module) => {
			'use strict'

			var isWindows = process.platform === 'win32'

			// Regex to split a windows path into into [dir, root, basename, name, ext]
			var splitWindowsRe =
				/^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/

			var win32 = {}

			function win32SplitPath(filename) {
				return splitWindowsRe.exec(filename).slice(1)
			}

			win32.parse = function (pathString) {
				if (typeof pathString !== 'string') {
					throw new TypeError(
						"Parameter 'pathString' must be a string, not " + typeof pathString,
					)
				}
				var allParts = win32SplitPath(pathString)
				if (!allParts || allParts.length !== 5) {
					throw new TypeError("Invalid path '" + pathString + "'")
				}
				return {
					root: allParts[1],
					dir:
						allParts[0] === allParts[1]
							? allParts[0]
							: allParts[0].slice(0, -1),
					base: allParts[2],
					ext: allParts[4],
					name: allParts[3],
				}
			}

			// Split a filename into [dir, root, basename, name, ext], unix version
			// 'root' is just a slash, or nothing.
			var splitPathRe =
				/^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/
			var posix = {}

			function posixSplitPath(filename) {
				return splitPathRe.exec(filename).slice(1)
			}

			posix.parse = function (pathString) {
				if (typeof pathString !== 'string') {
					throw new TypeError(
						"Parameter 'pathString' must be a string, not " + typeof pathString,
					)
				}
				var allParts = posixSplitPath(pathString)
				if (!allParts || allParts.length !== 5) {
					throw new TypeError("Invalid path '" + pathString + "'")
				}

				return {
					root: allParts[1],
					dir: allParts[0].slice(0, -1),
					base: allParts[2],
					ext: allParts[4],
					name: allParts[3],
				}
			}

			if (isWindows) module.exports = win32.parse /* posix */
			else module.exports = posix.parse

			module.exports.posix = posix.parse
			module.exports.win32 = win32.parse

			/***/
		},

		/***/ 57336: /***/ (module) => {
			let p = process || {},
				argv = p.argv || [],
				env = p.env || {}
			let isColorSupported =
				!(!!env.NO_COLOR || argv.includes('--no-color')) &&
				(!!env.FORCE_COLOR ||
					argv.includes('--color') ||
					p.platform === 'win32' ||
					((p.stdout || {}).isTTY && env.TERM !== 'dumb') ||
					!!env.CI)

			let formatter =
				(open, close, replace = open) =>
				(input) => {
					let string = '' + input,
						index = string.indexOf(close, open.length)
					return ~index
						? open + replaceClose(string, close, replace, index) + close
						: open + string + close
				}

			let replaceClose = (string, close, replace, index) => {
				let result = '',
					cursor = 0
				do {
					result += string.substring(cursor, index) + replace
					cursor = index + close.length
					index = string.indexOf(close, cursor)
				} while (~index)
				return result + string.substring(cursor)
			}

			let createColors = (enabled = isColorSupported) => {
				let f = enabled ? formatter : () => String
				return {
					isColorSupported: enabled,
					reset: f('\x1b[0m', '\x1b[0m'),
					bold: f('\x1b[1m', '\x1b[22m', '\x1b[22m\x1b[1m'),
					dim: f('\x1b[2m', '\x1b[22m', '\x1b[22m\x1b[2m'),
					italic: f('\x1b[3m', '\x1b[23m'),
					underline: f('\x1b[4m', '\x1b[24m'),
					inverse: f('\x1b[7m', '\x1b[27m'),
					hidden: f('\x1b[8m', '\x1b[28m'),
					strikethrough: f('\x1b[9m', '\x1b[29m'),

					black: f('\x1b[30m', '\x1b[39m'),
					red: f('\x1b[31m', '\x1b[39m'),
					green: f('\x1b[32m', '\x1b[39m'),
					yellow: f('\x1b[33m', '\x1b[39m'),
					blue: f('\x1b[34m', '\x1b[39m'),
					magenta: f('\x1b[35m', '\x1b[39m'),
					cyan: f('\x1b[36m', '\x1b[39m'),
					white: f('\x1b[37m', '\x1b[39m'),
					gray: f('\x1b[90m', '\x1b[39m'),

					bgBlack: f('\x1b[40m', '\x1b[49m'),
					bgRed: f('\x1b[41m', '\x1b[49m'),
					bgGreen: f('\x1b[42m', '\x1b[49m'),
					bgYellow: f('\x1b[43m', '\x1b[49m'),
					bgBlue: f('\x1b[44m', '\x1b[49m'),
					bgMagenta: f('\x1b[45m', '\x1b[49m'),
					bgCyan: f('\x1b[46m', '\x1b[49m'),
					bgWhite: f('\x1b[47m', '\x1b[49m'),

					blackBright: f('\x1b[90m', '\x1b[39m'),
					redBright: f('\x1b[91m', '\x1b[39m'),
					greenBright: f('\x1b[92m', '\x1b[39m'),
					yellowBright: f('\x1b[93m', '\x1b[39m'),
					blueBright: f('\x1b[94m', '\x1b[39m'),
					magentaBright: f('\x1b[95m', '\x1b[39m'),
					cyanBright: f('\x1b[96m', '\x1b[39m'),
					whiteBright: f('\x1b[97m', '\x1b[39m'),

					bgBlackBright: f('\x1b[100m', '\x1b[49m'),
					bgRedBright: f('\x1b[101m', '\x1b[49m'),
					bgGreenBright: f('\x1b[102m', '\x1b[49m'),
					bgYellowBright: f('\x1b[103m', '\x1b[49m'),
					bgBlueBright: f('\x1b[104m', '\x1b[49m'),
					bgMagentaBright: f('\x1b[105m', '\x1b[49m'),
					bgCyanBright: f('\x1b[106m', '\x1b[49m'),
					bgWhiteBright: f('\x1b[107m', '\x1b[49m'),
				}
			}

			module.exports = createColors()
			module.exports.createColors = createColors

			/***/
		},

		/***/ 79719: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			// Source copied and then modified from
			// https://github.com/remarkjs/remark/blob/master/packages/remark-parse/lib/tokenize/html-block.js
			//
			// MIT License https://github.com/remarkjs/remark/blob/master/license

			const { openCloseTag } = __nccwpck_require__(59982)

			module.exports = blockHtml

			const tab = '\t'
			const space = ' '
			const lineFeed = '\n'
			const lessThan = '<'

			const rawOpenExpression = /^<(script|pre|style)(?=(\s|>|$))/i
			const rawCloseExpression = /<\/(script|pre|style)>/i
			const commentOpenExpression = /^<!--/
			const commentCloseExpression = /-->/
			const instructionOpenExpression = /^<\?/
			const instructionCloseExpression = /\?>/
			const directiveOpenExpression = /^<![A-Za-z]/
			const directiveCloseExpression = />/
			const cdataOpenExpression = /^<!\[CDATA\[/
			const cdataCloseExpression = /\]\]>/
			const elementCloseExpression = /^$/
			const otherElementOpenExpression = new RegExp(
				openCloseTag.source + '\\s*$',
			)
			const fragmentOpenExpression = /^<>/

			function blockHtml(eat, value, silent) {
				const blocks = '[a-z\\.]*(\\.){0,1}[a-z][a-z0-9\\.]*'
				const elementOpenExpression = new RegExp(
					'^</?(' + blocks + ')(?=(\\s|/?>|$))',
					'i',
				)

				const length = value.length
				let index = 0
				let next
				let line
				let offset
				let character
				let count
				let sequence
				let subvalue

				const sequences = [
					[rawOpenExpression, rawCloseExpression, true],
					[commentOpenExpression, commentCloseExpression, true],
					[instructionOpenExpression, instructionCloseExpression, true],
					[directiveOpenExpression, directiveCloseExpression, true],
					[cdataOpenExpression, cdataCloseExpression, true],
					[elementOpenExpression, elementCloseExpression, true],
					[fragmentOpenExpression, elementCloseExpression, true],
					[otherElementOpenExpression, elementCloseExpression, false],
				]

				// Eat initial spacing.
				while (index < length) {
					character = value.charAt(index)

					if (character !== tab && character !== space) {
						break
					}

					index++
				}

				if (value.charAt(index) !== lessThan) {
					return
				}

				next = value.indexOf(lineFeed, index + 1)
				next = next === -1 ? length : next
				line = value.slice(index, next)
				offset = -1
				count = sequences.length

				while (++offset < count) {
					if (sequences[offset][0].test(line)) {
						sequence = sequences[offset]
						break
					}
				}

				if (!sequence) {
					return
				}

				if (silent) {
					return sequence[2]
				}

				index = next

				if (!sequence[1].test(line)) {
					while (index < length) {
						next = value.indexOf(lineFeed, index + 1)
						next = next === -1 ? length : next
						line = value.slice(index + 1, next)

						if (sequence[1].test(line)) {
							if (line) {
								index = next
							}

							break
						}

						index = next
					}
				}

				subvalue = value.slice(0, index)

				return eat(subvalue)({ type: 'html', value: subvalue })
			}

			/***/
		},

		/***/ 66226: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			const { transformSync } = __nccwpck_require__(85414)
			const declare = __nccwpck_require__(25683).declare

			const syntaxJsxPlugin = __nccwpck_require__(47358)
			const proposalObjectRestSpreadPlugin = __nccwpck_require__(16186)

			class BabelPluginExtractImportsAndExports {
				constructor() {
					const nodes = []
					this.state = { nodes }

					this.plugin = declare((api) => {
						api.assertVersion(7)

						return {
							visitor: {
								ExportDefaultDeclaration(path) {
									const { start } = path.node
									nodes.push({ type: 'export', start, default: true })
								},
								ExportNamedDeclaration(path) {
									const { start } = path.node
									nodes.push({ type: 'export', start })
								},
								ExportAllDeclaration(path) {
									const { start } = path.node
									nodes.push({ type: 'export', start })
								},
								ImportDeclaration(path) {
									const { start } = path.node

									// Imports that are used in exports can end up as
									// ImportDeclarations with no start/end metadata,
									// these can be ignored
									if (start === undefined) {
										return
									}

									nodes.push({ type: 'import', start })
								},
							},
						}
					})
				}
			}

			const partitionString = (str, indices) =>
				indices.map((val, i) => {
					return str.slice(val, indices[i + 1])
				})

			module.exports = (value, vfile) => {
				const instance = new BabelPluginExtractImportsAndExports()

				transformSync(value, {
					plugins: [
						syntaxJsxPlugin,
						proposalObjectRestSpreadPlugin,
						instance.plugin,
					],
					filename: vfile.path,
					configFile: false,
					babelrc: false,
				})

				const sortedNodes = instance.state.nodes.sort(
					(a, b) => a.start - b.start,
				)
				const nodeStarts = sortedNodes.map((n) => n.start)
				const values = partitionString(value, nodeStarts)

				const allNodes = sortedNodes.map(({ start: _, ...node }, i) => {
					const value = values[i]
					return { ...node, value }
				})

				// Group adjacent nodes of the same type so that they can be combined
				// into a single node later, this also ensures that order is preserved
				let currType = allNodes[0].type
				const groupedNodes = allNodes.reduce(
					(acc, curr) => {
						// Default export nodes shouldn't be grouped with other exports
						// because they're handled specially by MDX
						if (curr.default) {
							currType = 'default'
							return [...acc, [curr]]
						}

						if (curr.type === currType) {
							const lastNodes = acc.pop()
							return [...acc, [...lastNodes, curr]]
						}

						currType = curr.type
						return [...acc, [curr]]
					},
					[[]],
				)

				// Combine adjacent nodes into a single node
				return groupedNodes
					.filter((a) => a.length)
					.reduce((acc, curr) => {
						const node = curr.reduce((acc, curr) => ({
							...acc,
							value: acc.value + curr.value,
						}))

						return [...acc, node]
					}, [])
			}

			/***/
		},

		/***/ 47926: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			const isAlphabetical = __nccwpck_require__(59201)
			const { isImportOrExport, EMPTY_NEWLINE } = __nccwpck_require__(73654)
			const extractImportsAndExports = __nccwpck_require__(66226)
			const block = __nccwpck_require__(79719)
			const { tag } = __nccwpck_require__(59982)

			const LESS_THAN = '<'
			const GREATER_THAN = '>'
			const SLASH = '/'
			const EXCLAMATION = '!'

			module.exports = mdx

			mdx.default = mdx

			tokenizeEsSyntax.locator = tokenizeEsSyntaxLocator

			function mdx(_options) {
				const parser = this.Parser
				const compiler = this.Compiler

				if (parser && parser.prototype && parser.prototype.blockTokenizers) {
					attachParser(parser)
				}

				if (compiler && compiler.prototype && compiler.prototype.visitors) {
					attachCompiler(compiler)
				}
			}

			function attachParser(parser) {
				const blocks = parser.prototype.blockTokenizers
				const inlines = parser.prototype.inlineTokenizers
				const methods = parser.prototype.blockMethods

				blocks.esSyntax = tokenizeEsSyntax
				blocks.html = wrap(block)
				inlines.html = wrap(inlines.html, inlineJsx)

				tokenizeEsSyntax.notInBlock = true

				methods.splice(methods.indexOf('paragraph'), 0, 'esSyntax')

				function wrap(original, customTokenizer) {
					const tokenizer = customTokenizer || tokenizeJsx
					tokenizer.locator = original.locator

					return tokenizer

					function tokenizeJsx() {
						const node = original.apply(this, arguments)

						if (node) {
							node.type = 'jsx'
						}

						return node
					}
				}

				function inlineJsx(eat, value) {
					if (value.charAt(0) !== LESS_THAN) {
						return
					}

					const nextChar = value.charAt(1)
					if (
						nextChar !== GREATER_THAN &&
						nextChar !== SLASH &&
						nextChar !== EXCLAMATION &&
						!isAlphabetical(nextChar)
					) {
						return
					}

					const subvalueMatches = value.match(tag)
					if (!subvalueMatches) {
						return
					}

					const subvalue = subvalueMatches[0]
					return eat(subvalue)({ type: 'jsx', value: subvalue })
				}
			}

			function attachCompiler(compiler) {
				const proto = compiler.prototype

				proto.visitors = Object.assign({}, proto.visitors, {
					import: stringifyEsSyntax,
					export: stringifyEsSyntax,
					jsx: stringifyEsSyntax,
				})
			}

			function stringifyEsSyntax(node) {
				return node.value.trim()
			}

			function tokenizeEsSyntax(eat, value) {
				const index = value.indexOf(EMPTY_NEWLINE)
				const subvalue = index !== -1 ? value.slice(0, index) : value

				if (isImportOrExport(subvalue)) {
					const nodes = extractImportsAndExports(subvalue, this.file)
					nodes.map((node) => eat(node.value)(node))
				}
			}

			function tokenizeEsSyntaxLocator(value, _fromIndex) {
				return isImportOrExport(value) ? -1 : 1
			}

			/***/
		},

		/***/ 59982: /***/ (__unused_webpack_module, exports) => {
			// Source copied and then modified from
			// https://github.com/remarkjs/remark/blob/master/packages/remark-parse/lib/util/html.js
			//
			// MIT License https://github.com/remarkjs/remark/blob/master/license

			// https://github.com/DmitrySoshnikov/babel-plugin-transform-modern-regexp#dotall-s-flag
			// Firefox and other browsers don't support the dotAll ("s") flag, but it can be polyfilled via this:
			const dotAllPolyfill = '[\0-\uFFFF]'

			const attributeName = '[a-zA-Z_:][a-zA-Z0-9:._-]*'
			const unquoted = '[^"\'=<>`\\u0000-\\u0020]+'
			const singleQuoted = "'[^']*'"
			const doubleQuoted = '"[^"]*"'
			const jsProps = '{.*}'.replace('.', dotAllPolyfill)
			const attributeValue =
				'(?:' +
				unquoted +
				'|' +
				singleQuoted +
				'|' +
				doubleQuoted +
				'|' +
				jsProps +
				')'
			const attribute =
				'(?:\\s+' + attributeName + '(?:\\s*=\\s*' + attributeValue + ')?)'
			const openTag = '<[A-Za-z]*[A-Za-z0-9\\.\\-]*' + attribute + '*\\s*\\/?>'
			const closeTag = '<\\/[A-Za-z][A-Za-z0-9\\.\\-]*\\s*>'
			const comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->'
			const processing = '<[?].*?[?]>'.replace('.', dotAllPolyfill)
			const declaration = '<![A-Za-z]+\\s+[^>]*>'
			const cdata = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>'

			exports.openCloseTag = new RegExp('^(?:' + openTag + '|' + closeTag + ')')

			exports.tag = new RegExp(
				'^(?:' +
					openTag +
					'|' +
					closeTag +
					'|' +
					comment +
					'|' +
					processing +
					'|' +
					declaration +
					'|' +
					cdata +
					')',
			)

			/***/
		},

		/***/ 24982: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var unherit = __nccwpck_require__(25351)
			var xtend = __nccwpck_require__(80869)
			var Parser = __nccwpck_require__(39651)

			module.exports = parse
			parse.Parser = Parser

			function parse(options) {
				var settings = this.data('settings')
				var Local = unherit(Parser)

				Local.prototype.options = xtend(
					Local.prototype.options,
					settings,
					options,
				)

				this.Parser = Local
			}

			/***/
		},

		/***/ 42029: /***/ (module) => {
			'use strict'

			module.exports = [
				'address',
				'article',
				'aside',
				'base',
				'basefont',
				'blockquote',
				'body',
				'caption',
				'center',
				'col',
				'colgroup',
				'dd',
				'details',
				'dialog',
				'dir',
				'div',
				'dl',
				'dt',
				'fieldset',
				'figcaption',
				'figure',
				'footer',
				'form',
				'frame',
				'frameset',
				'h1',
				'h2',
				'h3',
				'h4',
				'h5',
				'h6',
				'head',
				'header',
				'hgroup',
				'hr',
				'html',
				'iframe',
				'legend',
				'li',
				'link',
				'main',
				'menu',
				'menuitem',
				'meta',
				'nav',
				'noframes',
				'ol',
				'optgroup',
				'option',
				'p',
				'param',
				'pre',
				'section',
				'source',
				'title',
				'summary',
				'table',
				'tbody',
				'td',
				'tfoot',
				'th',
				'thead',
				'title',
				'tr',
				'track',
				'ul',
			]

			/***/
		},

		/***/ 18934: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var xtend = __nccwpck_require__(80869)
			var entities = __nccwpck_require__(75165)

			module.exports = factory

			// Factory to create an entity decoder.
			function factory(ctx) {
				decoder.raw = decodeRaw

				return decoder

				// Normalize `position` to add an `indent`.
				function normalize(position) {
					var offsets = ctx.offset
					var line = position.line
					var result = []

					while (++line) {
						if (!(line in offsets)) {
							break
						}

						result.push((offsets[line] || 0) + 1)
					}

					return { start: position, indent: result }
				}

				// Decode `value` (at `position`) into text-nodes.
				function decoder(value, position, handler) {
					entities(value, {
						position: normalize(position),
						warning: handleWarning,
						text: handler,
						reference: handler,
						textContext: ctx,
						referenceContext: ctx,
					})
				}

				// Decode `value` (at `position`) into a string.
				function decodeRaw(value, position, options) {
					return entities(
						value,
						xtend(options, {
							position: normalize(position),
							warning: handleWarning,
						}),
					)
				}

				// Handle a warning.
				// See <https://github.com/wooorm/parse-entities> for the warnings.
				function handleWarning(reason, position, code) {
					if (code !== 3) {
						ctx.file.message(reason, position)
					}
				}
			}

			/***/
		},

		/***/ 96206: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			module.exports = {
				position: true,
				gfm: true,
				commonmark: false,
				pedantic: false,
				blocks: __nccwpck_require__(42029),
			}

			/***/
		},

		/***/ 91702: /***/ (module) => {
			'use strict'

			module.exports = locate

			function locate(value, fromIndex) {
				var index = value.indexOf('\n', fromIndex)

				while (index > fromIndex) {
					if (value.charAt(index - 1) !== ' ') {
						break
					}

					index--
				}

				return index
			}

			/***/
		},

		/***/ 99740: /***/ (module) => {
			'use strict'

			module.exports = locate

			function locate(value, fromIndex) {
				return value.indexOf('`', fromIndex)
			}

			/***/
		},

		/***/ 49250: /***/ (module) => {
			'use strict'

			module.exports = locate

			function locate(value, fromIndex) {
				return value.indexOf('~~', fromIndex)
			}

			/***/
		},

		/***/ 22637: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var decimal = __nccwpck_require__(96734)
			var alphabetical = __nccwpck_require__(59201)

			var plusSign = 43 // '+'
			var dash = 45 // '-'
			var dot = 46 // '.'
			var underscore = 95 // '_'

			module.exports = locate

			// See: <https://github.github.com/gfm/#extended-email-autolink>
			function locate(value, fromIndex) {
				var self = this
				var at
				var position

				if (!this.options.gfm) {
					return -1
				}

				at = value.indexOf('@', fromIndex)

				if (at === -1) {
					return -1
				}

				position = at

				if (
					position === fromIndex ||
					!isGfmAtext(value.charCodeAt(position - 1))
				) {
					return locate.call(self, value, at + 1)
				}

				while (
					position > fromIndex &&
					isGfmAtext(value.charCodeAt(position - 1))
				) {
					position--
				}

				return position
			}

			function isGfmAtext(code) {
				return (
					decimal(code) ||
					alphabetical(code) ||
					code === plusSign ||
					code === dash ||
					code === dot ||
					code === underscore
				)
			}

			/***/
		},

		/***/ 85227: /***/ (module) => {
			'use strict'

			module.exports = locate

			function locate(value, fromIndex) {
				var asterisk = value.indexOf('*', fromIndex)
				var underscore = value.indexOf('_', fromIndex)

				if (underscore === -1) {
					return asterisk
				}

				if (asterisk === -1) {
					return underscore
				}

				return underscore < asterisk ? underscore : asterisk
			}

			/***/
		},

		/***/ 84330: /***/ (module) => {
			'use strict'

			module.exports = locate

			function locate(value, fromIndex) {
				return value.indexOf('\\', fromIndex)
			}

			/***/
		},

		/***/ 8241: /***/ (module) => {
			'use strict'

			module.exports = locate

			function locate(value, fromIndex) {
				var link = value.indexOf('[', fromIndex)
				var image = value.indexOf('![', fromIndex)

				if (image === -1) {
					return link
				}

				// Link can never be `-1` if an image is found, so we dont need to check
				// for that :)
				return link < image ? link : image
			}

			/***/
		},

		/***/ 21322: /***/ (module) => {
			'use strict'

			module.exports = locate

			function locate(value, fromIndex) {
				var asterisk = value.indexOf('**', fromIndex)
				var underscore = value.indexOf('__', fromIndex)

				if (underscore === -1) {
					return asterisk
				}

				if (asterisk === -1) {
					return underscore
				}

				return underscore < asterisk ? underscore : asterisk
			}

			/***/
		},

		/***/ 4225: /***/ (module) => {
			'use strict'

			module.exports = locate

			function locate(value, fromIndex) {
				return value.indexOf('<', fromIndex)
			}

			/***/
		},

		/***/ 82644: /***/ (module) => {
			'use strict'

			module.exports = locate

			var values = ['www.', 'http://', 'https://']

			function locate(value, fromIndex) {
				var min = -1
				var index
				var length
				var position

				if (!this.options.gfm) {
					return min
				}

				length = values.length
				index = -1

				while (++index < length) {
					position = value.indexOf(values[index], fromIndex)

					if (position !== -1 && (min === -1 || position < min)) {
						min = position
					}
				}

				return min
			}

			/***/
		},

		/***/ 3385: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var xtend = __nccwpck_require__(80869)
			var removePosition = __nccwpck_require__(10617)

			module.exports = parse

			var lineFeed = '\n'
			var lineBreaksExpression = /\r\n|\r/g

			// Parse the bound file.
			function parse() {
				var self = this
				var value = String(self.file)
				var start = { line: 1, column: 1, offset: 0 }
				var content = xtend(start)
				var node

				// Clean non-unix newlines: `\r\n` and `\r` are all changed to `\n`.
				// This should not affect positional information.
				value = value.replace(lineBreaksExpression, lineFeed)

				// BOM.
				if (value.charCodeAt(0) === 0xfeff) {
					value = value.slice(1)

					content.column++
					content.offset++
				}

				node = {
					type: 'root',
					children: self.tokenizeBlock(value, content),
					position: { start: start, end: self.eof || xtend(start) },
				}

				if (!self.options.position) {
					removePosition(node, true)
				}

				return node
			}

			/***/
		},

		/***/ 39651: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var xtend = __nccwpck_require__(80869)
			var toggle = __nccwpck_require__(33600)
			var vfileLocation = __nccwpck_require__(34808)
			var unescape = __nccwpck_require__(57468)
			var decode = __nccwpck_require__(18934)
			var tokenizer = __nccwpck_require__(31975)

			module.exports = Parser

			function Parser(doc, file) {
				this.file = file
				this.offset = {}
				this.options = xtend(this.options)
				this.setOptions({})

				this.inList = false
				this.inBlock = false
				this.inLink = false
				this.atStart = true

				this.toOffset = vfileLocation(file).toOffset
				this.unescape = unescape(this, 'escape')
				this.decode = decode(this)
			}

			var proto = Parser.prototype

			// Expose core.
			proto.setOptions = __nccwpck_require__(3701)
			proto.parse = __nccwpck_require__(3385)

			// Expose `defaults`.
			proto.options = __nccwpck_require__(96206)

			// Enter and exit helpers.
			proto.exitStart = toggle('atStart', true)
			proto.enterList = toggle('inList', false)
			proto.enterLink = toggle('inLink', false)
			proto.enterBlock = toggle('inBlock', false)

			// Nodes that can interupt a paragraph:
			//
			// ```markdown
			// A paragraph, followed by a thematic break.
			// ___
			// ```
			//
			// In the above example, the thematic break interupts the paragraph.
			proto.interruptParagraph = [
				['thematicBreak'],
				['list'],
				['atxHeading'],
				['fencedCode'],
				['blockquote'],
				['html'],
				['setextHeading', { commonmark: false }],
				['definition', { commonmark: false }],
			]

			// Nodes that can interupt a list:
			//
			// ```markdown
			// - One
			// ___
			// ```
			//
			// In the above example, the thematic break interupts the list.
			proto.interruptList = [
				['atxHeading', { pedantic: false }],
				['fencedCode', { pedantic: false }],
				['thematicBreak', { pedantic: false }],
				['definition', { commonmark: false }],
			]

			// Nodes that can interupt a blockquote:
			//
			// ```markdown
			// > A paragraph.
			// ___
			// ```
			//
			// In the above example, the thematic break interupts the blockquote.
			proto.interruptBlockquote = [
				['indentedCode', { commonmark: true }],
				['fencedCode', { commonmark: true }],
				['atxHeading', { commonmark: true }],
				['setextHeading', { commonmark: true }],
				['thematicBreak', { commonmark: true }],
				['html', { commonmark: true }],
				['list', { commonmark: true }],
				['definition', { commonmark: false }],
			]

			// Handlers.
			proto.blockTokenizers = {
				blankLine: __nccwpck_require__(93391),
				indentedCode: __nccwpck_require__(44969),
				fencedCode: __nccwpck_require__(48365),
				blockquote: __nccwpck_require__(69539),
				atxHeading: __nccwpck_require__(50542),
				thematicBreak: __nccwpck_require__(4757),
				list: __nccwpck_require__(30460),
				setextHeading: __nccwpck_require__(87106),
				html: __nccwpck_require__(68725),
				definition: __nccwpck_require__(56901),
				table: __nccwpck_require__(80930),
				paragraph: __nccwpck_require__(3272),
			}

			proto.inlineTokenizers = {
				escape: __nccwpck_require__(31943),
				autoLink: __nccwpck_require__(45396),
				url: __nccwpck_require__(91063),
				email: __nccwpck_require__(58038),
				html: __nccwpck_require__(29923),
				link: __nccwpck_require__(22144),
				reference: __nccwpck_require__(94419),
				strong: __nccwpck_require__(79359),
				emphasis: __nccwpck_require__(15698),
				deletion: __nccwpck_require__(21483),
				code: __nccwpck_require__(97671),
				break: __nccwpck_require__(94845),
				text: __nccwpck_require__(10631),
			}

			// Expose precedence.
			proto.blockMethods = keys(proto.blockTokenizers)
			proto.inlineMethods = keys(proto.inlineTokenizers)

			// Tokenizers.
			proto.tokenizeBlock = tokenizer('block')
			proto.tokenizeInline = tokenizer('inline')
			proto.tokenizeFactory = tokenizer

			// Get all keys in `value`.
			function keys(value) {
				var result = []
				var key

				for (key in value) {
					result.push(key)
				}

				return result
			}

			/***/
		},

		/***/ 3701: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var xtend = __nccwpck_require__(80869)
			var escapes = __nccwpck_require__(80872)
			var defaults = __nccwpck_require__(96206)

			module.exports = setOptions

			function setOptions(options) {
				var self = this
				var current = self.options
				var key
				var value

				if (options == null) {
					options = {}
				} else if (typeof options === 'object') {
					options = xtend(options)
				} else {
					throw new Error(
						'Invalid value `' + options + '` for setting `options`',
					)
				}

				for (key in defaults) {
					value = options[key]

					if (value == null) {
						value = current[key]
					}

					if (
						(key !== 'blocks' && typeof value !== 'boolean') ||
						(key === 'blocks' && typeof value !== 'object')
					) {
						throw new Error(
							'Invalid value `' + value + '` for setting `options.' + key + '`',
						)
					}

					options[key] = value
				}

				self.options = options
				self.escape = escapes(options)

				return self
			}

			/***/
		},

		/***/ 45396: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var whitespace = __nccwpck_require__(96472)
			var decode = __nccwpck_require__(75165)
			var locate = __nccwpck_require__(4225)

			module.exports = autoLink
			autoLink.locator = locate
			autoLink.notInLink = true

			var lessThan = '<'
			var greaterThan = '>'
			var atSign = '@'
			var slash = '/'
			var mailto = 'mailto:'
			var mailtoLength = mailto.length

			function autoLink(eat, value, silent) {
				var self = this
				var subvalue = ''
				var length = value.length
				var index = 0
				var queue = ''
				var hasAtCharacter = false
				var link = ''
				var character
				var now
				var content
				var tokenizers
				var exit

				if (value.charAt(0) !== lessThan) {
					return
				}

				index++
				subvalue = lessThan

				while (index < length) {
					character = value.charAt(index)

					if (
						whitespace(character) ||
						character === greaterThan ||
						character === atSign ||
						(character === ':' && value.charAt(index + 1) === slash)
					) {
						break
					}

					queue += character
					index++
				}

				if (!queue) {
					return
				}

				link += queue
				queue = ''

				character = value.charAt(index)
				link += character
				index++

				if (character === atSign) {
					hasAtCharacter = true
				} else {
					if (character !== ':' || value.charAt(index + 1) !== slash) {
						return
					}

					link += slash
					index++
				}

				while (index < length) {
					character = value.charAt(index)

					if (whitespace(character) || character === greaterThan) {
						break
					}

					queue += character
					index++
				}

				character = value.charAt(index)

				if (!queue || character !== greaterThan) {
					return
				}

				/* istanbul ignore if - never used (yet) */
				if (silent) {
					return true
				}

				link += queue
				content = link
				subvalue += link + character
				now = eat.now()
				now.column++
				now.offset++

				if (hasAtCharacter) {
					if (link.slice(0, mailtoLength).toLowerCase() === mailto) {
						content = content.slice(mailtoLength)
						now.column += mailtoLength
						now.offset += mailtoLength
					} else {
						link = mailto + link
					}
				}

				// Temporarily remove all tokenizers except text in autolinks.
				tokenizers = self.inlineTokenizers
				self.inlineTokenizers = { text: tokenizers.text }

				exit = self.enterLink()

				content = self.tokenizeInline(content, now)

				self.inlineTokenizers = tokenizers
				exit()

				return eat(subvalue)({
					type: 'link',
					title: null,
					url: decode(link, { nonTerminated: false }),
					children: content,
				})
			}

			/***/
		},

		/***/ 93391: /***/ (module) => {
			'use strict'

			// A line containing no characters, or a line containing only spaces (U+0020) or
			// tabs (U+0009), is called a blank line.
			// See <https://spec.commonmark.org/0.29/#blank-line>.
			var reBlankLine = /^[ \t]*(\n|$)/

			// Note that though blank lines play a special role in lists to determine
			// whether the list is tight or loose
			// (<https://spec.commonmark.org/0.29/#blank-lines>), its done by the list
			// tokenizer and this blank line tokenizer does not have to be responsible for
			// that.
			// Therefore, configs such as `blankLine.notInList` do not have to be set here.
			module.exports = blankLine

			function blankLine(eat, value, silent) {
				var match
				var subvalue = ''
				var index = 0
				var length = value.length

				while (index < length) {
					match = reBlankLine.exec(value.slice(index))

					if (match == null) {
						break
					}

					index += match[0].length
					subvalue += match[0]
				}

				if (subvalue === '') {
					return
				}

				/* istanbul ignore if - never used (yet) */
				if (silent) {
					return true
				}

				eat(subvalue)
			}

			/***/
		},

		/***/ 69539: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var trim = __nccwpck_require__(15464)
			var interrupt = __nccwpck_require__(93808)

			module.exports = blockquote

			var lineFeed = '\n'
			var tab = '\t'
			var space = ' '
			var greaterThan = '>'

			function blockquote(eat, value, silent) {
				var self = this
				var offsets = self.offset
				var tokenizers = self.blockTokenizers
				var interruptors = self.interruptBlockquote
				var now = eat.now()
				var currentLine = now.line
				var length = value.length
				var values = []
				var contents = []
				var indents = []
				var add
				var index = 0
				var character
				var rest
				var nextIndex
				var content
				var line
				var startIndex
				var prefixed
				var exit

				while (index < length) {
					character = value.charAt(index)

					if (character !== space && character !== tab) {
						break
					}

					index++
				}

				if (value.charAt(index) !== greaterThan) {
					return
				}

				if (silent) {
					return true
				}

				index = 0

				while (index < length) {
					nextIndex = value.indexOf(lineFeed, index)
					startIndex = index
					prefixed = false

					if (nextIndex === -1) {
						nextIndex = length
					}

					while (index < length) {
						character = value.charAt(index)

						if (character !== space && character !== tab) {
							break
						}

						index++
					}

					if (value.charAt(index) === greaterThan) {
						index++
						prefixed = true

						if (value.charAt(index) === space) {
							index++
						}
					} else {
						index = startIndex
					}

					content = value.slice(index, nextIndex)

					if (!prefixed && !trim(content)) {
						index = startIndex
						break
					}

					if (!prefixed) {
						rest = value.slice(index)

						// Check if the following code contains a possible block.
						if (interrupt(interruptors, tokenizers, self, [eat, rest, true])) {
							break
						}
					}

					line =
						startIndex === index ? content : value.slice(startIndex, nextIndex)

					indents.push(index - startIndex)
					values.push(line)
					contents.push(content)

					index = nextIndex + 1
				}

				index = -1
				length = indents.length
				add = eat(values.join(lineFeed))

				while (++index < length) {
					offsets[currentLine] = (offsets[currentLine] || 0) + indents[index]
					currentLine++
				}

				exit = self.enterBlock()
				contents = self.tokenizeBlock(contents.join(lineFeed), now)
				exit()

				return add({ type: 'blockquote', children: contents })
			}

			/***/
		},

		/***/ 94845: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var locate = __nccwpck_require__(91702)

			module.exports = hardBreak
			hardBreak.locator = locate

			var space = ' '
			var lineFeed = '\n'
			var minBreakLength = 2

			function hardBreak(eat, value, silent) {
				var length = value.length
				var index = -1
				var queue = ''
				var character

				while (++index < length) {
					character = value.charAt(index)

					if (character === lineFeed) {
						if (index < minBreakLength) {
							return
						}

						/* istanbul ignore if - never used (yet) */
						if (silent) {
							return true
						}

						queue += character

						return eat(queue)({ type: 'break' })
					}

					if (character !== space) {
						return
					}

					queue += character
				}
			}

			/***/
		},

		/***/ 48365: /***/ (module) => {
			'use strict'

			module.exports = fencedCode

			var lineFeed = '\n'
			var tab = '\t'
			var space = ' '
			var tilde = '~'
			var graveAccent = '`'

			var minFenceCount = 3
			var tabSize = 4

			function fencedCode(eat, value, silent) {
				var self = this
				var gfm = self.options.gfm
				var length = value.length + 1
				var index = 0
				var subvalue = ''
				var fenceCount
				var marker
				var character
				var flag
				var lang
				var meta
				var queue
				var content
				var exdentedContent
				var closing
				var exdentedClosing
				var indent
				var now

				if (!gfm) {
					return
				}

				// Eat initial spacing.
				while (index < length) {
					character = value.charAt(index)

					if (character !== space && character !== tab) {
						break
					}

					subvalue += character
					index++
				}

				indent = index

				// Eat the fence.
				character = value.charAt(index)

				if (character !== tilde && character !== graveAccent) {
					return
				}

				index++
				marker = character
				fenceCount = 1
				subvalue += character

				while (index < length) {
					character = value.charAt(index)

					if (character !== marker) {
						break
					}

					subvalue += character
					fenceCount++
					index++
				}

				if (fenceCount < minFenceCount) {
					return
				}

				// Eat spacing before flag.
				while (index < length) {
					character = value.charAt(index)

					if (character !== space && character !== tab) {
						break
					}

					subvalue += character
					index++
				}

				// Eat flag.
				flag = ''
				queue = ''

				while (index < length) {
					character = value.charAt(index)

					if (
						character === lineFeed ||
						(marker === graveAccent && character === marker)
					) {
						break
					}

					if (character === space || character === tab) {
						queue += character
					} else {
						flag += queue + character
						queue = ''
					}

					index++
				}

				character = value.charAt(index)

				if (character && character !== lineFeed) {
					return
				}

				if (silent) {
					return true
				}

				now = eat.now()
				now.column += subvalue.length
				now.offset += subvalue.length

				subvalue += flag
				flag = self.decode.raw(self.unescape(flag), now)

				if (queue) {
					subvalue += queue
				}

				queue = ''
				closing = ''
				exdentedClosing = ''
				content = ''
				exdentedContent = ''
				var skip = true

				// Eat content.
				while (index < length) {
					character = value.charAt(index)
					content += closing
					exdentedContent += exdentedClosing
					closing = ''
					exdentedClosing = ''

					if (character !== lineFeed) {
						content += character
						exdentedClosing += character
						index++
						continue
					}

					// The first line feed is ignored. Others arent.
					if (skip) {
						subvalue += character
						skip = false
					} else {
						closing += character
						exdentedClosing += character
					}

					queue = ''
					index++

					while (index < length) {
						character = value.charAt(index)

						if (character !== space) {
							break
						}

						queue += character
						index++
					}

					closing += queue
					exdentedClosing += queue.slice(indent)

					if (queue.length >= tabSize) {
						continue
					}

					queue = ''

					while (index < length) {
						character = value.charAt(index)

						if (character !== marker) {
							break
						}

						queue += character
						index++
					}

					closing += queue
					exdentedClosing += queue

					if (queue.length < fenceCount) {
						continue
					}

					queue = ''

					while (index < length) {
						character = value.charAt(index)

						if (character !== space && character !== tab) {
							break
						}

						closing += character
						exdentedClosing += character
						index++
					}

					if (!character || character === lineFeed) {
						break
					}
				}

				subvalue += content + closing

				// Get lang and meta from the flag.
				index = -1
				length = flag.length

				while (++index < length) {
					character = flag.charAt(index)

					if (character === space || character === tab) {
						if (!lang) {
							lang = flag.slice(0, index)
						}
					} else if (lang) {
						meta = flag.slice(index)
						break
					}
				}

				return eat(subvalue)({
					type: 'code',
					lang: lang || flag || null,
					meta: meta || null,
					value: exdentedContent,
				})
			}

			/***/
		},

		/***/ 44969: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var repeat = __nccwpck_require__(40471)
			var trim = __nccwpck_require__(75937)

			module.exports = indentedCode

			var lineFeed = '\n'
			var tab = '\t'
			var space = ' '

			var tabSize = 4
			var codeIndent = repeat(space, tabSize)

			function indentedCode(eat, value, silent) {
				var index = -1
				var length = value.length
				var subvalue = ''
				var content = ''
				var subvalueQueue = ''
				var contentQueue = ''
				var character
				var blankQueue
				var indent

				while (++index < length) {
					character = value.charAt(index)

					if (indent) {
						indent = false

						subvalue += subvalueQueue
						content += contentQueue
						subvalueQueue = ''
						contentQueue = ''

						if (character === lineFeed) {
							subvalueQueue = character
							contentQueue = character
						} else {
							subvalue += character
							content += character

							while (++index < length) {
								character = value.charAt(index)

								if (!character || character === lineFeed) {
									contentQueue = character
									subvalueQueue = character
									break
								}

								subvalue += character
								content += character
							}
						}
					} else if (
						character === space &&
						value.charAt(index + 1) === character &&
						value.charAt(index + 2) === character &&
						value.charAt(index + 3) === character
					) {
						subvalueQueue += codeIndent
						index += 3
						indent = true
					} else if (character === tab) {
						subvalueQueue += character
						indent = true
					} else {
						blankQueue = ''

						while (character === tab || character === space) {
							blankQueue += character
							character = value.charAt(++index)
						}

						if (character !== lineFeed) {
							break
						}

						subvalueQueue += blankQueue + character
						contentQueue += character
					}
				}

				if (content) {
					if (silent) {
						return true
					}

					return eat(subvalue)({
						type: 'code',
						lang: null,
						meta: null,
						value: trim(content),
					})
				}
			}

			/***/
		},

		/***/ 97671: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var locate = __nccwpck_require__(99740)

			module.exports = inlineCode
			inlineCode.locator = locate

			var lineFeed = 10 //  '\n'
			var space = 32 // ' '
			var graveAccent = 96 //  '`'

			function inlineCode(eat, value, silent) {
				var length = value.length
				var index = 0
				var openingFenceEnd
				var closingFenceStart
				var closingFenceEnd
				var code
				var next
				var found

				while (index < length) {
					if (value.charCodeAt(index) !== graveAccent) {
						break
					}

					index++
				}

				if (index === 0 || index === length) {
					return
				}

				openingFenceEnd = index
				next = value.charCodeAt(index)

				while (index < length) {
					code = next
					next = value.charCodeAt(index + 1)

					if (code === graveAccent) {
						if (closingFenceStart === undefined) {
							closingFenceStart = index
						}

						closingFenceEnd = index + 1

						if (
							next !== graveAccent &&
							closingFenceEnd - closingFenceStart === openingFenceEnd
						) {
							found = true
							break
						}
					} else if (closingFenceStart !== undefined) {
						closingFenceStart = undefined
						closingFenceEnd = undefined
					}

					index++
				}

				if (!found) {
					return
				}

				/* istanbul ignore if - never used (yet) */
				if (silent) {
					return true
				}

				// Remove the initial and final space (or line feed), iff they exist and there
				// are non-space characters in the content.
				index = openingFenceEnd
				length = closingFenceStart
				code = value.charCodeAt(index)
				next = value.charCodeAt(length - 1)
				found = false

				if (
					length - index > 2 &&
					(code === space || code === lineFeed) &&
					(next === space || next === lineFeed)
				) {
					index++
					length--

					while (index < length) {
						code = value.charCodeAt(index)

						if (code !== space && code !== lineFeed) {
							found = true
							break
						}

						index++
					}

					if (found === true) {
						openingFenceEnd++
						closingFenceStart--
					}
				}

				return eat(value.slice(0, closingFenceEnd))({
					type: 'inlineCode',
					value: value.slice(openingFenceEnd, closingFenceStart),
				})
			}

			/***/
		},

		/***/ 56901: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var whitespace = __nccwpck_require__(96472)
			var normalize = __nccwpck_require__(99880)

			module.exports = definition

			var quotationMark = '"'
			var apostrophe = "'"
			var backslash = '\\'
			var lineFeed = '\n'
			var tab = '\t'
			var space = ' '
			var leftSquareBracket = '['
			var rightSquareBracket = ']'
			var leftParenthesis = '('
			var rightParenthesis = ')'
			var colon = ':'
			var lessThan = '<'
			var greaterThan = '>'

			function definition(eat, value, silent) {
				var self = this
				var commonmark = self.options.commonmark
				var index = 0
				var length = value.length
				var subvalue = ''
				var beforeURL
				var beforeTitle
				var queue
				var character
				var test
				var identifier
				var url
				var title

				while (index < length) {
					character = value.charAt(index)

					if (character !== space && character !== tab) {
						break
					}

					subvalue += character
					index++
				}

				character = value.charAt(index)

				if (character !== leftSquareBracket) {
					return
				}

				index++
				subvalue += character
				queue = ''

				while (index < length) {
					character = value.charAt(index)

					if (character === rightSquareBracket) {
						break
					} else if (character === backslash) {
						queue += character
						index++
						character = value.charAt(index)
					}

					queue += character
					index++
				}

				if (
					!queue ||
					value.charAt(index) !== rightSquareBracket ||
					value.charAt(index + 1) !== colon
				) {
					return
				}

				identifier = queue
				subvalue += queue + rightSquareBracket + colon
				index = subvalue.length
				queue = ''

				while (index < length) {
					character = value.charAt(index)

					if (
						character !== tab &&
						character !== space &&
						character !== lineFeed
					) {
						break
					}

					subvalue += character
					index++
				}

				character = value.charAt(index)
				queue = ''
				beforeURL = subvalue

				if (character === lessThan) {
					index++

					while (index < length) {
						character = value.charAt(index)

						if (!isEnclosedURLCharacter(character)) {
							break
						}

						queue += character
						index++
					}

					character = value.charAt(index)

					if (character === isEnclosedURLCharacter.delimiter) {
						subvalue += lessThan + queue + character
						index++
					} else {
						if (commonmark) {
							return
						}

						index -= queue.length + 1
						queue = ''
					}
				}

				if (!queue) {
					while (index < length) {
						character = value.charAt(index)

						if (!isUnclosedURLCharacter(character)) {
							break
						}

						queue += character
						index++
					}

					subvalue += queue
				}

				if (!queue) {
					return
				}

				url = queue
				queue = ''

				while (index < length) {
					character = value.charAt(index)

					if (
						character !== tab &&
						character !== space &&
						character !== lineFeed
					) {
						break
					}

					queue += character
					index++
				}

				character = value.charAt(index)
				test = null

				if (character === quotationMark) {
					test = quotationMark
				} else if (character === apostrophe) {
					test = apostrophe
				} else if (character === leftParenthesis) {
					test = rightParenthesis
				}

				if (!test) {
					queue = ''
					index = subvalue.length
				} else if (queue) {
					subvalue += queue + character
					index = subvalue.length
					queue = ''

					while (index < length) {
						character = value.charAt(index)

						if (character === test) {
							break
						}

						if (character === lineFeed) {
							index++
							character = value.charAt(index)

							if (character === lineFeed || character === test) {
								return
							}

							queue += lineFeed
						}

						queue += character
						index++
					}

					character = value.charAt(index)

					if (character !== test) {
						return
					}

					beforeTitle = subvalue
					subvalue += queue + character
					index++
					title = queue
					queue = ''
				} else {
					return
				}

				while (index < length) {
					character = value.charAt(index)

					if (character !== tab && character !== space) {
						break
					}

					subvalue += character
					index++
				}

				character = value.charAt(index)

				if (!character || character === lineFeed) {
					if (silent) {
						return true
					}

					beforeURL = eat(beforeURL).test().end
					url = self.decode.raw(self.unescape(url), beforeURL, {
						nonTerminated: false,
					})

					if (title) {
						beforeTitle = eat(beforeTitle).test().end
						title = self.decode.raw(self.unescape(title), beforeTitle)
					}

					return eat(subvalue)({
						type: 'definition',
						identifier: normalize(identifier),
						label: identifier,
						title: title || null,
						url: url,
					})
				}
			}

			// Check if `character` can be inside an enclosed URI.
			function isEnclosedURLCharacter(character) {
				return (
					character !== greaterThan &&
					character !== leftSquareBracket &&
					character !== rightSquareBracket
				)
			}

			isEnclosedURLCharacter.delimiter = greaterThan

			// Check if `character` can be inside an unclosed URI.
			function isUnclosedURLCharacter(character) {
				return (
					character !== leftSquareBracket &&
					character !== rightSquareBracket &&
					!whitespace(character)
				)
			}

			/***/
		},

		/***/ 21483: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var whitespace = __nccwpck_require__(96472)
			var locate = __nccwpck_require__(49250)

			module.exports = strikethrough
			strikethrough.locator = locate

			var tilde = '~'
			var fence = '~~'

			function strikethrough(eat, value, silent) {
				var self = this
				var character = ''
				var previous = ''
				var preceding = ''
				var subvalue = ''
				var index
				var length
				var now

				if (
					!self.options.gfm ||
					value.charAt(0) !== tilde ||
					value.charAt(1) !== tilde ||
					whitespace(value.charAt(2))
				) {
					return
				}

				index = 1
				length = value.length
				now = eat.now()
				now.column += 2
				now.offset += 2

				while (++index < length) {
					character = value.charAt(index)

					if (
						character === tilde &&
						previous === tilde &&
						(!preceding || !whitespace(preceding))
					) {
						/* istanbul ignore if - never used (yet) */
						if (silent) {
							return true
						}

						return eat(fence + subvalue + fence)({
							type: 'delete',
							children: self.tokenizeInline(subvalue, now),
						})
					}

					subvalue += previous
					preceding = previous
					previous = character
				}
			}

			/***/
		},

		/***/ 58038: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var decode = __nccwpck_require__(75165)
			var decimal = __nccwpck_require__(96734)
			var alphabetical = __nccwpck_require__(59201)
			var locate = __nccwpck_require__(22637)

			module.exports = email
			email.locator = locate
			email.notInLink = true

			var plusSign = 43 // '+'
			var dash = 45 // '-'
			var dot = 46 // '.'
			var atSign = 64 // '@'
			var underscore = 95 // '_'

			function email(eat, value, silent) {
				var self = this
				var gfm = self.options.gfm
				var tokenizers = self.inlineTokenizers
				var index = 0
				var length = value.length
				var firstDot = -1
				var code
				var content
				var children
				var exit

				if (!gfm) {
					return
				}

				code = value.charCodeAt(index)

				while (
					decimal(code) ||
					alphabetical(code) ||
					code === plusSign ||
					code === dash ||
					code === dot ||
					code === underscore
				) {
					code = value.charCodeAt(++index)
				}

				if (index === 0) {
					return
				}

				if (code !== atSign) {
					return
				}

				index++

				while (index < length) {
					code = value.charCodeAt(index)

					if (
						decimal(code) ||
						alphabetical(code) ||
						code === dash ||
						code === dot ||
						code === underscore
					) {
						index++

						if (firstDot === -1 && code === dot) {
							firstDot = index
						}

						continue
					}

					break
				}

				if (
					firstDot === -1 ||
					firstDot === index ||
					code === dash ||
					code === underscore
				) {
					return
				}

				if (code === dot) {
					index--
				}

				content = value.slice(0, index)

				/* istanbul ignore if - never used (yet) */
				if (silent) {
					return true
				}

				exit = self.enterLink()

				// Temporarily remove all tokenizers except text in url.
				self.inlineTokenizers = { text: tokenizers.text }
				children = self.tokenizeInline(content, eat.now())
				self.inlineTokenizers = tokenizers

				exit()

				return eat(content)({
					type: 'link',
					title: null,
					url: 'mailto:' + decode(content, { nonTerminated: false }),
					children: children,
				})
			}

			/***/
		},

		/***/ 15698: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var trim = __nccwpck_require__(15464)
			var word = __nccwpck_require__(70009)
			var whitespace = __nccwpck_require__(96472)
			var locate = __nccwpck_require__(85227)

			module.exports = emphasis
			emphasis.locator = locate

			var asterisk = '*'
			var underscore = '_'
			var backslash = '\\'

			function emphasis(eat, value, silent) {
				var self = this
				var index = 0
				var character = value.charAt(index)
				var now
				var pedantic
				var marker
				var queue
				var subvalue
				var length
				var previous

				if (character !== asterisk && character !== underscore) {
					return
				}

				pedantic = self.options.pedantic
				subvalue = character
				marker = character
				length = value.length
				index++
				queue = ''
				character = ''

				if (pedantic && whitespace(value.charAt(index))) {
					return
				}

				while (index < length) {
					previous = character
					character = value.charAt(index)

					if (character === marker && (!pedantic || !whitespace(previous))) {
						character = value.charAt(++index)

						if (character !== marker) {
							if (!trim(queue) || previous === marker) {
								return
							}

							if (!pedantic && marker === underscore && word(character)) {
								queue += marker
								continue
							}

							/* istanbul ignore if - never used (yet) */
							if (silent) {
								return true
							}

							now = eat.now()
							now.column++
							now.offset++

							return eat(subvalue + queue + marker)({
								type: 'emphasis',
								children: self.tokenizeInline(queue, now),
							})
						}

						queue += marker
					}

					if (!pedantic && character === backslash) {
						queue += character
						character = value.charAt(++index)
					}

					queue += character
					index++
				}
			}

			/***/
		},

		/***/ 31943: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var locate = __nccwpck_require__(84330)

			module.exports = escape
			escape.locator = locate

			var lineFeed = '\n'
			var backslash = '\\'

			function escape(eat, value, silent) {
				var self = this
				var character
				var node

				if (value.charAt(0) === backslash) {
					character = value.charAt(1)

					if (self.escape.indexOf(character) !== -1) {
						/* istanbul ignore if - never used (yet) */
						if (silent) {
							return true
						}

						if (character === lineFeed) {
							node = { type: 'break' }
						} else {
							node = { type: 'text', value: character }
						}

						return eat(backslash + character)(node)
					}
				}
			}

			/***/
		},

		/***/ 50542: /***/ (module) => {
			'use strict'

			module.exports = atxHeading

			var lineFeed = '\n'
			var tab = '\t'
			var space = ' '
			var numberSign = '#'

			var maxFenceCount = 6

			function atxHeading(eat, value, silent) {
				var self = this
				var pedantic = self.options.pedantic
				var length = value.length + 1
				var index = -1
				var now = eat.now()
				var subvalue = ''
				var content = ''
				var character
				var queue
				var depth

				// Eat initial spacing.
				while (++index < length) {
					character = value.charAt(index)

					if (character !== space && character !== tab) {
						index--
						break
					}

					subvalue += character
				}

				// Eat hashes.
				depth = 0

				while (++index <= length) {
					character = value.charAt(index)

					if (character !== numberSign) {
						index--
						break
					}

					subvalue += character
					depth++
				}

				if (depth > maxFenceCount) {
					return
				}

				if (!depth || (!pedantic && value.charAt(index + 1) === numberSign)) {
					return
				}

				length = value.length + 1

				// Eat intermediate white-space.
				queue = ''

				while (++index < length) {
					character = value.charAt(index)

					if (character !== space && character !== tab) {
						index--
						break
					}

					queue += character
				}

				// Exit when not in pedantic mode without spacing.
				if (
					!pedantic &&
					queue.length === 0 &&
					character &&
					character !== lineFeed
				) {
					return
				}

				if (silent) {
					return true
				}

				// Eat content.
				subvalue += queue
				queue = ''
				content = ''

				while (++index < length) {
					character = value.charAt(index)

					if (!character || character === lineFeed) {
						break
					}

					if (
						character !== space &&
						character !== tab &&
						character !== numberSign
					) {
						content += queue + character
						queue = ''
						continue
					}

					while (character === space || character === tab) {
						queue += character
						character = value.charAt(++index)
					}

					// `#` without a queue is part of the content.
					if (!pedantic && content && !queue && character === numberSign) {
						content += character
						continue
					}

					while (character === numberSign) {
						queue += character
						character = value.charAt(++index)
					}

					while (character === space || character === tab) {
						queue += character
						character = value.charAt(++index)
					}

					index--
				}

				now.column += subvalue.length
				now.offset += subvalue.length
				subvalue += content + queue

				return eat(subvalue)({
					type: 'heading',
					depth: depth,
					children: self.tokenizeInline(content, now),
				})
			}

			/***/
		},

		/***/ 87106: /***/ (module) => {
			'use strict'

			module.exports = setextHeading

			var lineFeed = '\n'
			var tab = '\t'
			var space = ' '
			var equalsTo = '='
			var dash = '-'

			var maxIndent = 3

			var equalsToDepth = 1
			var dashDepth = 2

			function setextHeading(eat, value, silent) {
				var self = this
				var now = eat.now()
				var length = value.length
				var index = -1
				var subvalue = ''
				var content
				var queue
				var character
				var marker
				var depth

				// Eat initial indentation.
				while (++index < length) {
					character = value.charAt(index)

					if (character !== space || index >= maxIndent) {
						index--
						break
					}

					subvalue += character
				}

				// Eat content.
				content = ''
				queue = ''

				while (++index < length) {
					character = value.charAt(index)

					if (character === lineFeed) {
						index--
						break
					}

					if (character === space || character === tab) {
						queue += character
					} else {
						content += queue + character
						queue = ''
					}
				}

				now.column += subvalue.length
				now.offset += subvalue.length
				subvalue += content + queue

				// Ensure the content is followed by a newline and a valid marker.
				character = value.charAt(++index)
				marker = value.charAt(++index)

				if (
					character !== lineFeed ||
					(marker !== equalsTo && marker !== dash)
				) {
					return
				}

				subvalue += character

				// Eat Setext-line.
				queue = marker
				depth = marker === equalsTo ? equalsToDepth : dashDepth

				while (++index < length) {
					character = value.charAt(index)

					if (character !== marker) {
						if (character !== lineFeed) {
							return
						}

						index--
						break
					}

					queue += character
				}

				if (silent) {
					return true
				}

				return eat(subvalue + queue)({
					type: 'heading',
					depth: depth,
					children: self.tokenizeInline(content, now),
				})
			}

			/***/
		},

		/***/ 68725: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var openCloseTag = __nccwpck_require__(76774) /* .openCloseTag */.X

			module.exports = blockHtml

			var tab = '\t'
			var space = ' '
			var lineFeed = '\n'
			var lessThan = '<'

			var rawOpenExpression = /^<(script|pre|style)(?=(\s|>|$))/i
			var rawCloseExpression = /<\/(script|pre|style)>/i
			var commentOpenExpression = /^<!--/
			var commentCloseExpression = /-->/
			var instructionOpenExpression = /^<\?/
			var instructionCloseExpression = /\?>/
			var directiveOpenExpression = /^<![A-Za-z]/
			var directiveCloseExpression = />/
			var cdataOpenExpression = /^<!\[CDATA\[/
			var cdataCloseExpression = /]]>/
			var elementCloseExpression = /^$/
			var otherElementOpenExpression = new RegExp(openCloseTag.source + '\\s*$')

			function blockHtml(eat, value, silent) {
				var self = this
				var blocks = self.options.blocks.join('|')
				var elementOpenExpression = new RegExp(
					'^</?(' + blocks + ')(?=(\\s|/?>|$))',
					'i',
				)
				var length = value.length
				var index = 0
				var next
				var line
				var offset
				var character
				var count
				var sequence
				var subvalue

				var sequences = [
					[rawOpenExpression, rawCloseExpression, true],
					[commentOpenExpression, commentCloseExpression, true],
					[instructionOpenExpression, instructionCloseExpression, true],
					[directiveOpenExpression, directiveCloseExpression, true],
					[cdataOpenExpression, cdataCloseExpression, true],
					[elementOpenExpression, elementCloseExpression, true],
					[otherElementOpenExpression, elementCloseExpression, false],
				]

				// Eat initial spacing.
				while (index < length) {
					character = value.charAt(index)

					if (character !== tab && character !== space) {
						break
					}

					index++
				}

				if (value.charAt(index) !== lessThan) {
					return
				}

				next = value.indexOf(lineFeed, index + 1)
				next = next === -1 ? length : next
				line = value.slice(index, next)
				offset = -1
				count = sequences.length

				while (++offset < count) {
					if (sequences[offset][0].test(line)) {
						sequence = sequences[offset]
						break
					}
				}

				if (!sequence) {
					return
				}

				if (silent) {
					return sequence[2]
				}

				index = next

				if (!sequence[1].test(line)) {
					while (index < length) {
						next = value.indexOf(lineFeed, index + 1)
						next = next === -1 ? length : next
						line = value.slice(index + 1, next)

						if (sequence[1].test(line)) {
							if (line) {
								index = next
							}

							break
						}

						index = next
					}
				}

				subvalue = value.slice(0, index)

				return eat(subvalue)({ type: 'html', value: subvalue })
			}

			/***/
		},

		/***/ 29923: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var alphabetical = __nccwpck_require__(59201)
			var locate = __nccwpck_require__(4225)
			var tag = __nccwpck_require__(76774) /* .tag */.T

			module.exports = inlineHTML
			inlineHTML.locator = locate

			var lessThan = '<'
			var questionMark = '?'
			var exclamationMark = '!'
			var slash = '/'

			var htmlLinkOpenExpression = /^<a /i
			var htmlLinkCloseExpression = /^<\/a>/i

			function inlineHTML(eat, value, silent) {
				var self = this
				var length = value.length
				var character
				var subvalue

				if (value.charAt(0) !== lessThan || length < 3) {
					return
				}

				character = value.charAt(1)

				if (
					!alphabetical(character) &&
					character !== questionMark &&
					character !== exclamationMark &&
					character !== slash
				) {
					return
				}

				subvalue = value.match(tag)

				if (!subvalue) {
					return
				}

				/* istanbul ignore if - not used yet. */
				if (silent) {
					return true
				}

				subvalue = subvalue[0]

				if (!self.inLink && htmlLinkOpenExpression.test(subvalue)) {
					self.inLink = true
				} else if (self.inLink && htmlLinkCloseExpression.test(subvalue)) {
					self.inLink = false
				}

				return eat(subvalue)({ type: 'html', value: subvalue })
			}

			/***/
		},

		/***/ 22144: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var whitespace = __nccwpck_require__(96472)
			var locate = __nccwpck_require__(8241)

			module.exports = link
			link.locator = locate

			var lineFeed = '\n'
			var exclamationMark = '!'
			var quotationMark = '"'
			var apostrophe = "'"
			var leftParenthesis = '('
			var rightParenthesis = ')'
			var lessThan = '<'
			var greaterThan = '>'
			var leftSquareBracket = '['
			var backslash = '\\'
			var rightSquareBracket = ']'
			var graveAccent = '`'

			function link(eat, value, silent) {
				var self = this
				var subvalue = ''
				var index = 0
				var character = value.charAt(0)
				var pedantic = self.options.pedantic
				var commonmark = self.options.commonmark
				var gfm = self.options.gfm
				var closed
				var count
				var opening
				var beforeURL
				var beforeTitle
				var subqueue
				var hasMarker
				var isImage
				var content
				var marker
				var length
				var title
				var depth
				var queue
				var url
				var now
				var exit
				var node

				// Detect whether this is an image.
				if (character === exclamationMark) {
					isImage = true
					subvalue = character
					character = value.charAt(++index)
				}

				// Eat the opening.
				if (character !== leftSquareBracket) {
					return
				}

				// Exit when this is a link and were already inside a link.
				if (!isImage && self.inLink) {
					return
				}

				subvalue += character
				queue = ''
				index++

				// Eat the content.
				length = value.length
				now = eat.now()
				depth = 0

				now.column += index
				now.offset += index

				while (index < length) {
					character = value.charAt(index)
					subqueue = character

					if (character === graveAccent) {
						// Inline-code in link content.
						count = 1

						while (value.charAt(index + 1) === graveAccent) {
							subqueue += character
							index++
							count++
						}

						if (!opening) {
							opening = count
						} else if (count >= opening) {
							opening = 0
						}
					} else if (character === backslash) {
						// Allow brackets to be escaped.
						index++
						subqueue += value.charAt(index)
					} else if ((!opening || gfm) && character === leftSquareBracket) {
						// In GFM mode, brackets in code still count.  In all other modes,
						// they dont.
						depth++
					} else if ((!opening || gfm) && character === rightSquareBracket) {
						if (depth) {
							depth--
						} else {
							if (value.charAt(index + 1) !== leftParenthesis) {
								return
							}

							subqueue += leftParenthesis
							closed = true
							index++

							break
						}
					}

					queue += subqueue
					subqueue = ''
					index++
				}

				// Eat the content closing.
				if (!closed) {
					return
				}

				content = queue
				subvalue += queue + subqueue
				index++

				// Eat white-space.
				while (index < length) {
					character = value.charAt(index)

					if (!whitespace(character)) {
						break
					}

					subvalue += character
					index++
				}

				// Eat the URL.
				character = value.charAt(index)
				queue = ''
				beforeURL = subvalue

				if (character === lessThan) {
					index++
					beforeURL += lessThan

					while (index < length) {
						character = value.charAt(index)

						if (character === greaterThan) {
							break
						}

						if (commonmark && character === lineFeed) {
							return
						}

						queue += character
						index++
					}

					if (value.charAt(index) !== greaterThan) {
						return
					}

					subvalue += lessThan + queue + greaterThan
					url = queue
					index++
				} else {
					character = null
					subqueue = ''

					while (index < length) {
						character = value.charAt(index)

						if (
							subqueue &&
							(character === quotationMark ||
								character === apostrophe ||
								(commonmark && character === leftParenthesis))
						) {
							break
						}

						if (whitespace(character)) {
							if (!pedantic) {
								break
							}

							subqueue += character
						} else {
							if (character === leftParenthesis) {
								depth++
							} else if (character === rightParenthesis) {
								if (depth === 0) {
									break
								}

								depth--
							}

							queue += subqueue
							subqueue = ''

							if (character === backslash) {
								queue += backslash
								character = value.charAt(++index)
							}

							queue += character
						}

						index++
					}

					subvalue += queue
					url = queue
					index = subvalue.length
				}

				// Eat white-space.
				queue = ''

				while (index < length) {
					character = value.charAt(index)

					if (!whitespace(character)) {
						break
					}

					queue += character
					index++
				}

				character = value.charAt(index)
				subvalue += queue

				// Eat the title.
				if (
					queue &&
					(character === quotationMark ||
						character === apostrophe ||
						(commonmark && character === leftParenthesis))
				) {
					index++
					subvalue += character
					queue = ''
					marker = character === leftParenthesis ? rightParenthesis : character
					beforeTitle = subvalue

					// In commonmark-mode, things are pretty easy: the marker cannot occur
					// inside the title.  Non-commonmark does, however, support nested
					// delimiters.
					if (commonmark) {
						while (index < length) {
							character = value.charAt(index)

							if (character === marker) {
								break
							}

							if (character === backslash) {
								queue += backslash
								character = value.charAt(++index)
							}

							index++
							queue += character
						}

						character = value.charAt(index)

						if (character !== marker) {
							return
						}

						title = queue
						subvalue += queue + character
						index++

						while (index < length) {
							character = value.charAt(index)

							if (!whitespace(character)) {
								break
							}

							subvalue += character
							index++
						}
					} else {
						subqueue = ''

						while (index < length) {
							character = value.charAt(index)

							if (character === marker) {
								if (hasMarker) {
									queue += marker + subqueue
									subqueue = ''
								}

								hasMarker = true
							} else if (!hasMarker) {
								queue += character
							} else if (character === rightParenthesis) {
								subvalue += queue + marker + subqueue
								title = queue
								break
							} else if (whitespace(character)) {
								subqueue += character
							} else {
								queue += marker + subqueue + character
								subqueue = ''
								hasMarker = false
							}

							index++
						}
					}
				}

				if (value.charAt(index) !== rightParenthesis) {
					return
				}

				/* istanbul ignore if - never used (yet) */
				if (silent) {
					return true
				}

				subvalue += rightParenthesis

				url = self.decode.raw(self.unescape(url), eat(beforeURL).test().end, {
					nonTerminated: false,
				})

				if (title) {
					beforeTitle = eat(beforeTitle).test().end
					title = self.decode.raw(self.unescape(title), beforeTitle)
				}

				node = {
					type: isImage ? 'image' : 'link',
					title: title || null,
					url: url,
				}

				if (isImage) {
					node.alt = self.decode.raw(self.unescape(content), now) || null
				} else {
					exit = self.enterLink()
					node.children = self.tokenizeInline(content, now)
					exit()
				}

				return eat(subvalue)(node)
			}

			/***/
		},

		/***/ 30460: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var trim = __nccwpck_require__(15464)
			var repeat = __nccwpck_require__(40471)
			var decimal = __nccwpck_require__(96734)
			var getIndent = __nccwpck_require__(19245)
			var removeIndent = __nccwpck_require__(39729)
			var interrupt = __nccwpck_require__(93808)

			module.exports = list

			var asterisk = '*'
			var underscore = '_'
			var plusSign = '+'
			var dash = '-'
			var dot = '.'
			var space = ' '
			var lineFeed = '\n'
			var tab = '\t'
			var rightParenthesis = ')'
			var lowercaseX = 'x'

			var tabSize = 4
			var looseListItemExpression = /\n\n(?!\s*$)/
			var taskItemExpression = /^\[([ X\tx])][ \t]/
			var bulletExpression =
				/^([ \t]*)([*+-]|\d+[.)])( {1,4}(?! )| |\t|$|(?=\n))([^\n]*)/
			var pedanticBulletExpression = /^([ \t]*)([*+-]|\d+[.)])([ \t]+)/
			var initialIndentExpression = /^( {1,4}|\t)?/gm

			function list(eat, value, silent) {
				var self = this
				var commonmark = self.options.commonmark
				var pedantic = self.options.pedantic
				var tokenizers = self.blockTokenizers
				var interuptors = self.interruptList
				var index = 0
				var length = value.length
				var start = null
				var size
				var queue
				var ordered
				var character
				var marker
				var nextIndex
				var startIndex
				var prefixed
				var currentMarker
				var content
				var line
				var previousEmpty
				var empty
				var items
				var allLines
				var emptyLines
				var item
				var enterTop
				var exitBlockquote
				var spread = false
				var node
				var now
				var end
				var indented

				while (index < length) {
					character = value.charAt(index)

					if (character !== tab && character !== space) {
						break
					}

					index++
				}

				character = value.charAt(index)

				if (
					character === asterisk ||
					character === plusSign ||
					character === dash
				) {
					marker = character
					ordered = false
				} else {
					ordered = true
					queue = ''

					while (index < length) {
						character = value.charAt(index)

						if (!decimal(character)) {
							break
						}

						queue += character
						index++
					}

					character = value.charAt(index)

					if (
						!queue ||
						!(
							character === dot ||
							(commonmark && character === rightParenthesis)
						)
					) {
						return
					}

					/* Slightly abusing `silent` mode, whose goal is to make interrupting
					 * paragraphs work.
					 * Well, thats exactly what we want to do here: dont interrupt:
					 * 2. here, because the list doesnt start with `1`. */
					if (silent && queue !== '1') {
						return
					}

					start = parseInt(queue, 10)
					marker = character
				}

				character = value.charAt(++index)

				if (
					character !== space &&
					character !== tab &&
					(pedantic || (character !== lineFeed && character !== ''))
				) {
					return
				}

				if (silent) {
					return true
				}

				index = 0
				items = []
				allLines = []
				emptyLines = []

				while (index < length) {
					nextIndex = value.indexOf(lineFeed, index)
					startIndex = index
					prefixed = false
					indented = false

					if (nextIndex === -1) {
						nextIndex = length
					}

					size = 0

					while (index < length) {
						character = value.charAt(index)

						if (character === tab) {
							size += tabSize - (size % tabSize)
						} else if (character === space) {
							size++
						} else {
							break
						}

						index++
					}

					if (item && size >= item.indent) {
						indented = true
					}

					character = value.charAt(index)
					currentMarker = null

					if (!indented) {
						if (
							character === asterisk ||
							character === plusSign ||
							character === dash
						) {
							currentMarker = character
							index++
							size++
						} else {
							queue = ''

							while (index < length) {
								character = value.charAt(index)

								if (!decimal(character)) {
									break
								}

								queue += character
								index++
							}

							character = value.charAt(index)
							index++

							if (
								queue &&
								(character === dot ||
									(commonmark && character === rightParenthesis))
							) {
								currentMarker = character
								size += queue.length + 1
							}
						}

						if (currentMarker) {
							character = value.charAt(index)

							if (character === tab) {
								size += tabSize - (size % tabSize)
								index++
							} else if (character === space) {
								end = index + tabSize

								while (index < end) {
									if (value.charAt(index) !== space) {
										break
									}

									index++
									size++
								}

								if (index === end && value.charAt(index) === space) {
									index -= tabSize - 1
									size -= tabSize - 1
								}
							} else if (character !== lineFeed && character !== '') {
								currentMarker = null
							}
						}
					}

					if (currentMarker) {
						if (!pedantic && marker !== currentMarker) {
							break
						}

						prefixed = true
					} else {
						if (
							!commonmark &&
							!indented &&
							value.charAt(startIndex) === space
						) {
							indented = true
						} else if (commonmark && item) {
							indented = size >= item.indent || size > tabSize
						}

						prefixed = false
						index = startIndex
					}

					line = value.slice(startIndex, nextIndex)
					content = startIndex === index ? line : value.slice(index, nextIndex)

					if (
						currentMarker === asterisk ||
						currentMarker === underscore ||
						currentMarker === dash
					) {
						if (tokenizers.thematicBreak.call(self, eat, line, true)) {
							break
						}
					}

					previousEmpty = empty
					empty = !prefixed && !trim(content).length

					if (indented && item) {
						item.value = item.value.concat(emptyLines, line)
						allLines = allLines.concat(emptyLines, line)
						emptyLines = []
					} else if (prefixed) {
						if (emptyLines.length !== 0) {
							spread = true
							item.value.push('')
							item.trail = emptyLines.concat()
						}

						item = {
							value: [line],
							indent: size,
							trail: [],
						}

						items.push(item)
						allLines = allLines.concat(emptyLines, line)
						emptyLines = []
					} else if (empty) {
						if (previousEmpty && !commonmark) {
							break
						}

						emptyLines.push(line)
					} else {
						if (previousEmpty) {
							break
						}

						if (interrupt(interuptors, tokenizers, self, [eat, line, true])) {
							break
						}

						item.value = item.value.concat(emptyLines, line)
						allLines = allLines.concat(emptyLines, line)
						emptyLines = []
					}

					index = nextIndex + 1
				}

				node = eat(allLines.join(lineFeed)).reset({
					type: 'list',
					ordered: ordered,
					start: start,
					spread: spread,
					children: [],
				})

				enterTop = self.enterList()
				exitBlockquote = self.enterBlock()
				index = -1
				length = items.length

				while (++index < length) {
					item = items[index].value.join(lineFeed)
					now = eat.now()

					eat(item)(listItem(self, item, now), node)

					item = items[index].trail.join(lineFeed)

					if (index !== length - 1) {
						item += lineFeed
					}

					eat(item)
				}

				enterTop()
				exitBlockquote()

				return node
			}

			function listItem(ctx, value, position) {
				var offsets = ctx.offset
				var fn = ctx.options.pedantic ? pedanticListItem : normalListItem
				var checked = null
				var task
				var indent

				value = fn.apply(null, arguments)

				if (ctx.options.gfm) {
					task = value.match(taskItemExpression)

					if (task) {
						indent = task[0].length
						checked = task[1].toLowerCase() === lowercaseX
						offsets[position.line] += indent
						value = value.slice(indent)
					}
				}

				return {
					type: 'listItem',
					spread: looseListItemExpression.test(value),
					checked: checked,
					children: ctx.tokenizeBlock(value, position),
				}
			}

			// Create a list-item using overly simple mechanics.
			function pedanticListItem(ctx, value, position) {
				var offsets = ctx.offset
				var line = position.line

				// Remove the list-items bullet.
				value = value.replace(pedanticBulletExpression, replacer)

				// The initial line was also matched by the below, so we reset the `line`.
				line = position.line

				return value.replace(initialIndentExpression, replacer)

				// A simple replacer which removed all matches, and adds their length to
				// `offset`.
				function replacer($0) {
					offsets[line] = (offsets[line] || 0) + $0.length
					line++

					return ''
				}
			}

			// Create a list-item using sane mechanics.
			function normalListItem(ctx, value, position) {
				var offsets = ctx.offset
				var line = position.line
				var max
				var bullet
				var rest
				var lines
				var trimmedLines
				var index
				var length

				// Remove the list-items bullet.
				value = value.replace(bulletExpression, replacer)

				lines = value.split(lineFeed)

				trimmedLines = removeIndent(value, getIndent(max).indent).split(
					lineFeed,
				)

				// We replaced the initial bullet with something else above, which was used
				// to trick `removeIndentation` into removing some more characters when
				// possible.  However, that could result in the initial line to be stripped
				// more than it should be.
				trimmedLines[0] = rest

				offsets[line] = (offsets[line] || 0) + bullet.length
				line++

				index = 0
				length = lines.length

				while (++index < length) {
					offsets[line] =
						(offsets[line] || 0) +
						lines[index].length -
						trimmedLines[index].length
					line++
				}

				return trimmedLines.join(lineFeed)

				/* eslint-disable-next-line max-params */
				function replacer($0, $1, $2, $3, $4) {
					bullet = $1 + $2 + $3
					rest = $4

					// Make sure that the first nine numbered list items can indent with an
					// extra space.  That is, when the bullet did not receive an extra final
					// space.
					if (Number($2) < 10 && bullet.length % 2 === 1) {
						$2 = space + $2
					}

					max = $1 + repeat(space, $2.length) + $3

					return max + rest
				}
			}

			/***/
		},

		/***/ 3272: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var trim = __nccwpck_require__(15464)
			var trimTrailingLines = __nccwpck_require__(75937)
			var interrupt = __nccwpck_require__(93808)

			module.exports = paragraph

			var tab = '\t'
			var lineFeed = '\n'
			var space = ' '

			var tabSize = 4

			// Tokenise paragraph.
			function paragraph(eat, value, silent) {
				var self = this
				var settings = self.options
				var commonmark = settings.commonmark
				var tokenizers = self.blockTokenizers
				var interruptors = self.interruptParagraph
				var index = value.indexOf(lineFeed)
				var length = value.length
				var position
				var subvalue
				var character
				var size
				var now

				while (index < length) {
					// Eat everything if theres no following newline.
					if (index === -1) {
						index = length
						break
					}

					// Stop if the next character is NEWLINE.
					if (value.charAt(index + 1) === lineFeed) {
						break
					}

					// In commonmark-mode, following indented lines are part of the paragraph.
					if (commonmark) {
						size = 0
						position = index + 1

						while (position < length) {
							character = value.charAt(position)

							if (character === tab) {
								size = tabSize
								break
							} else if (character === space) {
								size++
							} else {
								break
							}

							position++
						}

						if (size >= tabSize && character !== lineFeed) {
							index = value.indexOf(lineFeed, index + 1)
							continue
						}
					}

					subvalue = value.slice(index + 1)

					// Check if the following code contains a possible block.
					if (
						interrupt(interruptors, tokenizers, self, [eat, subvalue, true])
					) {
						break
					}

					position = index
					index = value.indexOf(lineFeed, index + 1)

					if (index !== -1 && trim(value.slice(position, index)) === '') {
						index = position
						break
					}
				}

				subvalue = value.slice(0, index)

				/* istanbul ignore if - never used (yet) */
				if (silent) {
					return true
				}

				now = eat.now()
				subvalue = trimTrailingLines(subvalue)

				return eat(subvalue)({
					type: 'paragraph',
					children: self.tokenizeInline(subvalue, now),
				})
			}

			/***/
		},

		/***/ 94419: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var whitespace = __nccwpck_require__(96472)
			var locate = __nccwpck_require__(8241)
			var normalize = __nccwpck_require__(99880)

			module.exports = reference
			reference.locator = locate

			var link = 'link'
			var image = 'image'
			var shortcut = 'shortcut'
			var collapsed = 'collapsed'
			var full = 'full'
			var exclamationMark = '!'
			var leftSquareBracket = '['
			var backslash = '\\'
			var rightSquareBracket = ']'

			function reference(eat, value, silent) {
				var self = this
				var commonmark = self.options.commonmark
				var character = value.charAt(0)
				var index = 0
				var length = value.length
				var subvalue = ''
				var intro = ''
				var type = link
				var referenceType = shortcut
				var content
				var identifier
				var now
				var node
				var exit
				var queue
				var bracketed
				var depth

				// Check whether were eating an image.
				if (character === exclamationMark) {
					type = image
					intro = character
					character = value.charAt(++index)
				}

				if (character !== leftSquareBracket) {
					return
				}

				index++
				intro += character
				queue = ''

				// Eat the text.
				depth = 0

				while (index < length) {
					character = value.charAt(index)

					if (character === leftSquareBracket) {
						bracketed = true
						depth++
					} else if (character === rightSquareBracket) {
						if (!depth) {
							break
						}

						depth--
					}

					if (character === backslash) {
						queue += backslash
						character = value.charAt(++index)
					}

					queue += character
					index++
				}

				subvalue = queue
				content = queue
				character = value.charAt(index)

				if (character !== rightSquareBracket) {
					return
				}

				index++
				subvalue += character
				queue = ''

				if (!commonmark) {
					// The original markdown syntax definition explicitly allows for whitespace
					// between the link text and link label; commonmark departs from this, in
					// part to improve support for shortcut reference links
					while (index < length) {
						character = value.charAt(index)

						if (!whitespace(character)) {
							break
						}

						queue += character
						index++
					}
				}

				character = value.charAt(index)

				if (character === leftSquareBracket) {
					identifier = ''
					queue += character
					index++

					while (index < length) {
						character = value.charAt(index)

						if (
							character === leftSquareBracket ||
							character === rightSquareBracket
						) {
							break
						}

						if (character === backslash) {
							identifier += backslash
							character = value.charAt(++index)
						}

						identifier += character
						index++
					}

					character = value.charAt(index)

					if (character === rightSquareBracket) {
						referenceType = identifier ? full : collapsed
						queue += identifier + character
						index++
					} else {
						identifier = ''
					}

					subvalue += queue
					queue = ''
				} else {
					if (!content) {
						return
					}

					identifier = content
				}

				// Brackets cannot be inside the identifier.
				if (referenceType !== full && bracketed) {
					return
				}

				subvalue = intro + subvalue

				if (type === link && self.inLink) {
					return null
				}

				/* istanbul ignore if - never used (yet) */
				if (silent) {
					return true
				}

				now = eat.now()
				now.column += intro.length
				now.offset += intro.length
				identifier = referenceType === full ? identifier : content

				node = {
					type: type + 'Reference',
					identifier: normalize(identifier),
					label: identifier,
					referenceType: referenceType,
				}

				if (type === link) {
					exit = self.enterLink()
					node.children = self.tokenizeInline(content, now)
					exit()
				} else {
					node.alt = self.decode.raw(self.unescape(content), now) || null
				}

				return eat(subvalue)(node)
			}

			/***/
		},

		/***/ 79359: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var trim = __nccwpck_require__(15464)
			var whitespace = __nccwpck_require__(96472)
			var locate = __nccwpck_require__(21322)

			module.exports = strong
			strong.locator = locate

			var backslash = '\\'
			var asterisk = '*'
			var underscore = '_'

			function strong(eat, value, silent) {
				var self = this
				var index = 0
				var character = value.charAt(index)
				var now
				var pedantic
				var marker
				var queue
				var subvalue
				var length
				var previous

				if (
					(character !== asterisk && character !== underscore) ||
					value.charAt(++index) !== character
				) {
					return
				}

				pedantic = self.options.pedantic
				marker = character
				subvalue = marker + marker
				length = value.length
				index++
				queue = ''
				character = ''

				if (pedantic && whitespace(value.charAt(index))) {
					return
				}

				while (index < length) {
					previous = character
					character = value.charAt(index)

					if (
						character === marker &&
						value.charAt(index + 1) === marker &&
						(!pedantic || !whitespace(previous))
					) {
						character = value.charAt(index + 2)

						if (character !== marker) {
							if (!trim(queue)) {
								return
							}

							/* istanbul ignore if - never used (yet) */
							if (silent) {
								return true
							}

							now = eat.now()
							now.column += 2
							now.offset += 2

							return eat(subvalue + queue + subvalue)({
								type: 'strong',
								children: self.tokenizeInline(queue, now),
							})
						}
					}

					if (!pedantic && character === backslash) {
						queue += character
						character = value.charAt(++index)
					}

					queue += character
					index++
				}
			}

			/***/
		},

		/***/ 80930: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var whitespace = __nccwpck_require__(96472)

			module.exports = table

			var tab = '\t'
			var lineFeed = '\n'
			var space = ' '
			var dash = '-'
			var colon = ':'
			var backslash = '\\'
			var verticalBar = '|'

			var minColumns = 1
			var minRows = 2

			var left = 'left'
			var center = 'center'
			var right = 'right'

			function table(eat, value, silent) {
				var self = this
				var index
				var alignments
				var alignment
				var subvalue
				var row
				var length
				var lines
				var queue
				var character
				var hasDash
				var align
				var cell
				var preamble
				var now
				var position
				var lineCount
				var line
				var rows
				var table
				var lineIndex
				var pipeIndex
				var first

				// Exit when not in gfm-mode.
				if (!self.options.gfm) {
					return
				}

				// Get the rows.
				// Detecting tables soon is hard, so there are some checks for performance
				// here, such as the minimum number of rows, and allowed characters in the
				// alignment row.
				index = 0
				lineCount = 0
				length = value.length + 1
				lines = []

				while (index < length) {
					lineIndex = value.indexOf(lineFeed, index)
					pipeIndex = value.indexOf(verticalBar, index + 1)

					if (lineIndex === -1) {
						lineIndex = value.length
					}

					if (pipeIndex === -1 || pipeIndex > lineIndex) {
						if (lineCount < minRows) {
							return
						}

						break
					}

					lines.push(value.slice(index, lineIndex))
					lineCount++
					index = lineIndex + 1
				}

				// Parse the alignment row.
				subvalue = lines.join(lineFeed)
				alignments = lines.splice(1, 1)[0] || []
				index = 0
				length = alignments.length
				lineCount--
				alignment = false
				align = []

				while (index < length) {
					character = alignments.charAt(index)

					if (character === verticalBar) {
						hasDash = null

						if (alignment === false) {
							if (first === false) {
								return
							}
						} else {
							align.push(alignment)
							alignment = false
						}

						first = false
					} else if (character === dash) {
						hasDash = true
						alignment = alignment || null
					} else if (character === colon) {
						if (alignment === left) {
							alignment = center
						} else if (hasDash && alignment === null) {
							alignment = right
						} else {
							alignment = left
						}
					} else if (!whitespace(character)) {
						return
					}

					index++
				}

				if (alignment !== false) {
					align.push(alignment)
				}

				// Exit when without enough columns.
				if (align.length < minColumns) {
					return
				}

				/* istanbul ignore if - never used (yet) */
				if (silent) {
					return true
				}

				// Parse the rows.
				position = -1
				rows = []

				table = eat(subvalue).reset({
					type: 'table',
					align: align,
					children: rows,
				})

				while (++position < lineCount) {
					line = lines[position]
					row = { type: 'tableRow', children: [] }

					// Eat a newline character when this is not the first row.
					if (position) {
						eat(lineFeed)
					}

					// Eat the row.
					eat(line).reset(row, table)

					length = line.length + 1
					index = 0
					queue = ''
					cell = ''
					preamble = true

					while (index < length) {
						character = line.charAt(index)

						if (character === tab || character === space) {
							if (cell) {
								queue += character
							} else {
								eat(character)
							}

							index++
							continue
						}

						if (character === '' || character === verticalBar) {
							if (preamble) {
								eat(character)
							} else {
								if ((cell || character) && !preamble) {
									subvalue = cell

									if (queue.length > 1) {
										if (character) {
											subvalue += queue.slice(0, -1)
											queue = queue.charAt(queue.length - 1)
										} else {
											subvalue += queue
											queue = ''
										}
									}

									now = eat.now()

									eat(subvalue)(
										{
											type: 'tableCell',
											children: self.tokenizeInline(cell, now),
										},
										row,
									)
								}

								eat(queue + character)

								queue = ''
								cell = ''
							}
						} else {
							if (queue) {
								cell += queue
								queue = ''
							}

							cell += character

							if (character === backslash && index !== length - 2) {
								cell += line.charAt(index + 1)
								index++
							}
						}

						preamble = false
						index++
					}

					// Eat the alignment row.
					if (!position) {
						eat(lineFeed + alignments)
					}
				}

				return table
			}

			/***/
		},

		/***/ 10631: /***/ (module) => {
			'use strict'

			module.exports = text

			function text(eat, value, silent) {
				var self = this
				var methods
				var tokenizers
				var index
				var length
				var subvalue
				var position
				var tokenizer
				var name
				var min
				var now

				/* istanbul ignore if - never used (yet) */
				if (silent) {
					return true
				}

				methods = self.inlineMethods
				length = methods.length
				tokenizers = self.inlineTokenizers
				index = -1
				min = value.length

				while (++index < length) {
					name = methods[index]

					if (name === 'text' || !tokenizers[name]) {
						continue
					}

					tokenizer = tokenizers[name].locator

					if (!tokenizer) {
						eat.file.fail('Missing locator: `' + name + '`')
					}

					position = tokenizer.call(self, value, 1)

					if (position !== -1 && position < min) {
						min = position
					}
				}

				subvalue = value.slice(0, min)
				now = eat.now()

				self.decode(subvalue, now, handler)

				function handler(content, position, source) {
					eat(source || content)({ type: 'text', value: content })
				}
			}

			/***/
		},

		/***/ 4757: /***/ (module) => {
			'use strict'

			module.exports = thematicBreak

			var tab = '\t'
			var lineFeed = '\n'
			var space = ' '
			var asterisk = '*'
			var dash = '-'
			var underscore = '_'

			var maxCount = 3

			function thematicBreak(eat, value, silent) {
				var index = -1
				var length = value.length + 1
				var subvalue = ''
				var character
				var marker
				var markerCount
				var queue

				while (++index < length) {
					character = value.charAt(index)

					if (character !== tab && character !== space) {
						break
					}

					subvalue += character
				}

				if (
					character !== asterisk &&
					character !== dash &&
					character !== underscore
				) {
					return
				}

				marker = character
				subvalue += character
				markerCount = 1
				queue = ''

				while (++index < length) {
					character = value.charAt(index)

					if (character === marker) {
						markerCount++
						subvalue += queue + marker
						queue = ''
					} else if (character === space) {
						queue += character
					} else if (
						markerCount >= maxCount &&
						(!character || character === lineFeed)
					) {
						subvalue += queue

						if (silent) {
							return true
						}

						return eat(subvalue)({ type: 'thematicBreak' })
					} else {
						return
					}
				}
			}

			/***/
		},

		/***/ 91063: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var ccount = __nccwpck_require__(83076)
			var decode = __nccwpck_require__(75165)
			var decimal = __nccwpck_require__(96734)
			var alphabetical = __nccwpck_require__(59201)
			var whitespace = __nccwpck_require__(96472)
			var locate = __nccwpck_require__(82644)

			module.exports = url
			url.locator = locate
			url.notInLink = true

			var exclamationMark = 33 // '!'
			var ampersand = 38 // '&'
			var rightParenthesis = 41 // ')'
			var asterisk = 42 // '*'
			var comma = 44 // ','
			var dash = 45 // '-'
			var dot = 46 // '.'
			var colon = 58 // ':'
			var semicolon = 59 // ';'
			var questionMark = 63 // '?'
			var lessThan = 60 // '<'
			var underscore = 95 // '_'
			var tilde = 126 // '~'

			var leftParenthesisCharacter = '('
			var rightParenthesisCharacter = ')'

			function url(eat, value, silent) {
				var self = this
				var gfm = self.options.gfm
				var tokenizers = self.inlineTokenizers
				var length = value.length
				var previousDot = -1
				var protocolless = false
				var dots
				var lastTwoPartsStart
				var start
				var index
				var pathStart
				var path
				var code
				var end
				var leftCount
				var rightCount
				var content
				var children
				var url
				var exit

				if (!gfm) {
					return
				}

				// `WWW.` doesnt work.
				if (value.slice(0, 4) === 'www.') {
					protocolless = true
					index = 4
				} else if (value.slice(0, 7).toLowerCase() === 'http://') {
					index = 7
				} else if (value.slice(0, 8).toLowerCase() === 'https://') {
					index = 8
				} else {
					return
				}

				// Act as if the starting boundary is a dot.
				previousDot = index - 1

				// Parse a valid domain.
				start = index
				dots = []

				while (index < length) {
					code = value.charCodeAt(index)

					if (code === dot) {
						// Dots may not appear after each other.
						if (previousDot === index - 1) {
							break
						}

						dots.push(index)
						previousDot = index
						index++
						continue
					}

					if (
						decimal(code) ||
						alphabetical(code) ||
						code === dash ||
						code === underscore
					) {
						index++
						continue
					}

					break
				}

				// Ignore a final dot:
				if (code === dot) {
					dots.pop()
					index--
				}

				// If there are not dots, exit.
				if (dots[0] === undefined) {
					return
				}

				// If there is an underscore in the last two domain parts, exit:
				// `www.example.c_m` and `www.ex_ample.com` are not OK, but
				// `www.sub_domain.example.com` is.
				lastTwoPartsStart = dots.length < 2 ? start : dots[dots.length - 2] + 1

				if (value.slice(lastTwoPartsStart, index).indexOf('_') !== -1) {
					return
				}

				/* istanbul ignore if - never used (yet) */
				if (silent) {
					return true
				}

				end = index
				pathStart = index

				// Parse a path.
				while (index < length) {
					code = value.charCodeAt(index)

					if (whitespace(code) || code === lessThan) {
						break
					}

					index++

					if (
						code === exclamationMark ||
						code === asterisk ||
						code === comma ||
						code === dot ||
						code === colon ||
						code === questionMark ||
						code === underscore ||
						code === tilde
					) {
						// Empty
					} else {
						end = index
					}
				}

				index = end

				// If the path ends in a closing paren, and the count of closing parens is
				// higher than the opening count, then remove the supefluous closing parens.
				if (value.charCodeAt(index - 1) === rightParenthesis) {
					path = value.slice(pathStart, index)
					leftCount = ccount(path, leftParenthesisCharacter)
					rightCount = ccount(path, rightParenthesisCharacter)

					while (rightCount > leftCount) {
						index = pathStart + path.lastIndexOf(rightParenthesisCharacter)
						path = value.slice(pathStart, index)
						rightCount--
					}
				}

				if (value.charCodeAt(index - 1) === semicolon) {
					// GitHub doesnt document this, but final semicolons arent paret of the
					// URL either.
					index--

					// // If the path ends in what looks like an entity, its not part of the path.
					if (alphabetical(value.charCodeAt(index - 1))) {
						end = index - 2

						while (alphabetical(value.charCodeAt(end))) {
							end--
						}

						if (value.charCodeAt(end) === ampersand) {
							index = end
						}
					}
				}

				content = value.slice(0, index)
				url = decode(content, { nonTerminated: false })

				if (protocolless) {
					url = 'http://' + url
				}

				exit = self.enterLink()

				// Temporarily remove all tokenizers except text in url.
				self.inlineTokenizers = { text: tokenizers.text }
				children = self.tokenizeInline(content, eat.now())
				self.inlineTokenizers = tokenizers

				exit()

				return eat(content)({
					type: 'link',
					title: null,
					url: url,
					children: children,
				})
			}

			/***/
		},

		/***/ 31975: /***/ (module) => {
			'use strict'

			module.exports = factory

			// Construct a tokenizer.  This creates both `tokenizeInline` and `tokenizeBlock`.
			function factory(type) {
				return tokenize

				// Tokenizer for a bound `type`.
				function tokenize(value, location) {
					var self = this
					var offset = self.offset
					var tokens = []
					var methods = self[type + 'Methods']
					var tokenizers = self[type + 'Tokenizers']
					var line = location.line
					var column = location.column
					var index
					var length
					var method
					var name
					var matched
					var valueLength

					// Trim white space only lines.
					if (!value) {
						return tokens
					}

					// Expose on `eat`.
					eat.now = now
					eat.file = self.file

					// Sync initial offset.
					updatePosition('')

					// Iterate over `value`, and iterate over all tokenizers.  When one eats
					// something, re-iterate with the remaining value.  If no tokenizer eats,
					// something failed (should not happen) and an exception is thrown.
					while (value) {
						index = -1
						length = methods.length
						matched = false

						while (++index < length) {
							name = methods[index]
							method = tokenizers[name]

							// Previously, we had constructs such as footnotes and YAML that used
							// these properties.
							// Those are now external (plus there are userland extensions), that may
							// still use them.
							if (
								method &&
								/* istanbul ignore next */ (!method.onlyAtStart ||
									self.atStart) &&
								/* istanbul ignore next */ (!method.notInList ||
									!self.inList) &&
								/* istanbul ignore next */ (!method.notInBlock ||
									!self.inBlock) &&
								(!method.notInLink || !self.inLink)
							) {
								valueLength = value.length

								method.apply(self, [eat, value])

								matched = valueLength !== value.length

								if (matched) {
									break
								}
							}
						}

						/* istanbul ignore if */
						if (!matched) {
							self.file.fail(new Error('Infinite loop'), eat.now())
						}
					}

					self.eof = now()

					return tokens

					// Update line, column, and offset based on `value`.
					function updatePosition(subvalue) {
						var lastIndex = -1
						var index = subvalue.indexOf('\n')

						while (index !== -1) {
							line++
							lastIndex = index
							index = subvalue.indexOf('\n', index + 1)
						}

						if (lastIndex === -1) {
							column += subvalue.length
						} else {
							column = subvalue.length - lastIndex
						}

						if (line in offset) {
							if (lastIndex !== -1) {
								column += offset[line]
							} else if (column <= offset[line]) {
								column = offset[line] + 1
							}
						}
					}

					// Get offset.  Called before the first character is eaten to retrieve the
					// ranges offsets.
					function getOffset() {
						var indentation = []
						var pos = line + 1

						// Done.  Called when the last character is eaten to retrieve the ranges
						// offsets.
						return function () {
							var last = line + 1

							while (pos < last) {
								indentation.push((offset[pos] || 0) + 1)

								pos++
							}

							return indentation
						}
					}

					// Get the current position.
					function now() {
						var pos = { line: line, column: column }

						pos.offset = self.toOffset(pos)

						return pos
					}

					// Store position information for a node.
					function Position(start) {
						this.start = start
						this.end = now()
					}

					// Throw when a value is incorrectly eaten.  This shouldnt happen but will
					// throw on new, incorrect rules.
					function validateEat(subvalue) {
						/* istanbul ignore if */
						if (value.slice(0, subvalue.length) !== subvalue) {
							// Capture stack-trace.
							self.file.fail(
								new Error(
									'Incorrectly eaten value: please report this warning on https://git.io/vg5Ft',
								),
								now(),
							)
						}
					}

					// Mark position and patch `node.position`.
					function position() {
						var before = now()

						return update

						// Add the position to a node.
						function update(node, indent) {
							var previous = node.position
							var start = previous ? previous.start : before
							var combined = []
							var n = previous && previous.end.line
							var l = before.line

							node.position = new Position(start)

							// If there was already a `position`, this node was merged.  Fixing
							// `start` wasnt hard, but the indent is different.  Especially
							// because some information, the indent between `n` and `l` wasnt
							// tracked.  Luckily, that space is (should be?) empty, so we can
							// safely check for it now.
							if (previous && indent && previous.indent) {
								combined = previous.indent

								if (n < l) {
									while (++n < l) {
										combined.push((offset[n] || 0) + 1)
									}

									combined.push(before.column)
								}

								indent = combined.concat(indent)
							}

							node.position.indent = indent || []

							return node
						}
					}

					// Add `node` to `parent`s children or to `tokens`.  Performs merges where
					// possible.
					function add(node, parent) {
						var children = parent ? parent.children : tokens
						var previous = children[children.length - 1]
						var fn

						if (
							previous &&
							node.type === previous.type &&
							(node.type === 'text' || node.type === 'blockquote') &&
							mergeable(previous) &&
							mergeable(node)
						) {
							fn = node.type === 'text' ? mergeText : mergeBlockquote
							node = fn.call(self, previous, node)
						}

						if (node !== previous) {
							children.push(node)
						}

						if (self.atStart && tokens.length !== 0) {
							self.exitStart()
						}

						return node
					}

					// Remove `subvalue` from `value`.  `subvalue` must be at the start of
					// `value`.
					function eat(subvalue) {
						var indent = getOffset()
						var pos = position()
						var current = now()

						validateEat(subvalue)

						apply.reset = reset
						reset.test = test
						apply.test = test

						value = value.slice(subvalue.length)

						updatePosition(subvalue)

						indent = indent()

						return apply

						// Add the given arguments, add `position` to the returned node, and
						// return the node.
						function apply(node, parent) {
							return pos(add(pos(node), parent), indent)
						}

						// Functions just like apply, but resets the content: the line and
						// column are reversed, and the eaten value is re-added.   This is
						// useful for nodes with a single type of content, such as lists and
						// tables.  See `apply` above for what parameters are expected.
						function reset() {
							var node = apply.apply(null, arguments)

							line = current.line
							column = current.column
							value = subvalue + value

							return node
						}

						// Test the position, after eating, and reverse to a not-eaten state.
						function test() {
							var result = pos({})

							line = current.line
							column = current.column
							value = subvalue + value

							return result.position
						}
					}
				}
			}

			// Check whether a node is mergeable with adjacent nodes.
			function mergeable(node) {
				var start
				var end

				if (node.type !== 'text' || !node.position) {
					return true
				}

				start = node.position.start
				end = node.position.end

				// Only merge nodes which occupy the same size as their `value`.
				return (
					start.line !== end.line ||
					end.column - start.column === node.value.length
				)
			}

			// Merge two text nodes: `node` into `prev`.
			function mergeText(previous, node) {
				previous.value += node.value

				return previous
			}

			// Merge two blockquotes: `node` into `prev`, unless in CommonMark or gfm modes.
			function mergeBlockquote(previous, node) {
				if (this.options.commonmark || this.options.gfm) {
					return node
				}

				previous.children = previous.children.concat(node.children)

				return previous
			}

			/***/
		},

		/***/ 57468: /***/ (module) => {
			'use strict'

			module.exports = factory

			var backslash = '\\'

			// Factory to de-escape a value, based on a list at `key` in `ctx`.
			function factory(ctx, key) {
				return unescape

				// De-escape a string using the expression at `key` in `ctx`.
				function unescape(value) {
					var previous = 0
					var index = value.indexOf(backslash)
					var escape = ctx[key]
					var queue = []
					var character

					while (index !== -1) {
						queue.push(value.slice(previous, index))
						previous = index + 1
						character = value.charAt(previous)

						// If the following character is not a valid escape, add the slash.
						if (!character || escape.indexOf(character) === -1) {
							queue.push(backslash)
						}

						index = value.indexOf(backslash, previous + 1)
					}

					queue.push(value.slice(previous))

					return queue.join('')
				}
			}

			/***/
		},

		/***/ 19245: /***/ (module) => {
			'use strict'

			module.exports = indentation

			var tab = '\t'
			var space = ' '

			var spaceSize = 1
			var tabSize = 4

			// Gets indentation information for a line.
			function indentation(value) {
				var index = 0
				var indent = 0
				var character = value.charAt(index)
				var stops = {}
				var size
				var lastIndent = 0

				while (character === tab || character === space) {
					size = character === tab ? tabSize : spaceSize

					indent += size

					if (size > 1) {
						indent = Math.floor(indent / size) * size
					}

					while (lastIndent < indent) {
						stops[++lastIndent] = index
					}

					character = value.charAt(++index)
				}

				return { indent: indent, stops: stops }
			}

			/***/
		},

		/***/ 76774: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			var attributeName = '[a-zA-Z_:][a-zA-Z0-9:._-]*'
			var unquoted = '[^"\'=<>`\\u0000-\\u0020]+'
			var singleQuoted = "'[^']*'"
			var doubleQuoted = '"[^"]*"'
			var attributeValue =
				'(?:' + unquoted + '|' + singleQuoted + '|' + doubleQuoted + ')'
			var attribute =
				'(?:\\s+' + attributeName + '(?:\\s*=\\s*' + attributeValue + ')?)'
			var openTag = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>'
			var closeTag = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>'
			var comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->'
			var processing = '<[?].*?[?]>'
			var declaration = '<![A-Za-z]+\\s+[^>]*>'
			var cdata = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>'

			exports.X = new RegExp('^(?:' + openTag + '|' + closeTag + ')')

			exports.T = new RegExp(
				'^(?:' +
					openTag +
					'|' +
					closeTag +
					'|' +
					comment +
					'|' +
					processing +
					'|' +
					declaration +
					'|' +
					cdata +
					')',
			)

			/***/
		},

		/***/ 93808: /***/ (module) => {
			'use strict'

			module.exports = interrupt

			function interrupt(interruptors, tokenizers, ctx, parameters) {
				var length = interruptors.length
				var index = -1
				var interruptor
				var config

				while (++index < length) {
					interruptor = interruptors[index]
					config = interruptor[1] || {}

					if (
						config.pedantic !== undefined &&
						config.pedantic !== ctx.options.pedantic
					) {
						continue
					}

					if (
						config.commonmark !== undefined &&
						config.commonmark !== ctx.options.commonmark
					) {
						continue
					}

					if (tokenizers[interruptor[0]].apply(ctx, parameters)) {
						return true
					}
				}

				return false
			}

			/***/
		},

		/***/ 99880: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var collapseWhiteSpace = __nccwpck_require__(37352)

			module.exports = normalize

			// Normalize an identifier.  Collapses multiple white space characters into a
			// single space, and removes casing.
			function normalize(value) {
				return collapseWhiteSpace(value).toLowerCase()
			}

			/***/
		},

		/***/ 39729: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var trim = __nccwpck_require__(15464)
			var repeat = __nccwpck_require__(40471)
			var getIndent = __nccwpck_require__(19245)

			module.exports = indentation

			var lineFeed = '\n'
			var space = ' '
			var exclamationMark = '!'

			// Remove the minimum indent from every line in `value`.  Supports both tab,
			// spaced, and mixed indentation (as well as possible).
			function indentation(value, maximum) {
				var values = value.split(lineFeed)
				var position = values.length + 1
				var minIndent = Infinity
				var matrix = []
				var index
				var indentation
				var stops

				values.unshift(repeat(space, maximum) + exclamationMark)

				while (position--) {
					indentation = getIndent(values[position])

					matrix[position] = indentation.stops

					if (trim(values[position]).length === 0) {
						continue
					}

					if (indentation.indent) {
						if (indentation.indent > 0 && indentation.indent < minIndent) {
							minIndent = indentation.indent
						}
					} else {
						minIndent = Infinity

						break
					}
				}

				if (minIndent !== Infinity) {
					position = values.length

					while (position--) {
						stops = matrix[position]
						index = minIndent

						while (index && !(index in stops)) {
							index--
						}

						values[position] = values[position].slice(stops[index] + 1)
					}
				}

				values.shift()

				return values.join(lineFeed)
			}

			/***/
		},

		/***/ 32780: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var unherit = __nccwpck_require__(25351)
			var xtend = __nccwpck_require__(80869)
			var Compiler = __nccwpck_require__(68275)

			module.exports = stringify
			stringify.Compiler = Compiler

			function stringify(options) {
				var Local = unherit(Compiler)
				Local.prototype.options = xtend(
					Local.prototype.options,
					this.data('settings'),
					options,
				)
				this.Compiler = Local
			}

			/***/
		},

		/***/ 68275: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var xtend = __nccwpck_require__(80869)
			var toggle = __nccwpck_require__(33600)

			module.exports = Compiler

			// Construct a new compiler.
			function Compiler(tree, file) {
				this.inLink = false
				this.inTable = false
				this.tree = tree
				this.file = file
				this.options = xtend(this.options)
				this.setOptions({})
			}

			var proto = Compiler.prototype

			// Enter and exit helpers. */
			proto.enterLink = toggle('inLink', false)
			proto.enterTable = toggle('inTable', false)
			proto.enterLinkReference = __nccwpck_require__(15912)

			// Configuration.
			proto.options = __nccwpck_require__(58236)
			proto.setOptions = __nccwpck_require__(14179)

			proto.compile = __nccwpck_require__(68882)
			proto.visit = __nccwpck_require__(14327)
			proto.all = __nccwpck_require__(57524)
			proto.block = __nccwpck_require__(65590)
			proto.visitOrderedItems = __nccwpck_require__(60859)
			proto.visitUnorderedItems = __nccwpck_require__(41250)

			// Expose visitors.
			proto.visitors = {
				root: __nccwpck_require__(55900),
				text: __nccwpck_require__(49739),
				heading: __nccwpck_require__(71124),
				paragraph: __nccwpck_require__(71940),
				blockquote: __nccwpck_require__(1647),
				list: __nccwpck_require__(71656),
				listItem: __nccwpck_require__(43138),
				inlineCode: __nccwpck_require__(67163),
				code: __nccwpck_require__(47149),
				html: __nccwpck_require__(37209),
				thematicBreak: __nccwpck_require__(73345),
				strong: __nccwpck_require__(86747),
				emphasis: __nccwpck_require__(61822),
				break: __nccwpck_require__(83129),
				delete: __nccwpck_require__(50455),
				link: __nccwpck_require__(10892),
				linkReference: __nccwpck_require__(15536),
				imageReference: __nccwpck_require__(24147),
				definition: __nccwpck_require__(16921),
				image: __nccwpck_require__(63423),
				table: __nccwpck_require__(17518),
				tableCell: __nccwpck_require__(40955),
			}

			/***/
		},

		/***/ 58236: /***/ (module) => {
			'use strict'

			module.exports = {
				gfm: true,
				commonmark: false,
				pedantic: false,
				entities: 'false',
				setext: false,
				closeAtx: false,
				tableCellPadding: true,
				tablePipeAlign: true,
				stringLength: stringLength,
				incrementListMarker: true,
				tightDefinitions: false,
				fences: false,
				fence: '`',
				bullet: '-',
				listItemIndent: 'tab',
				rule: '*',
				ruleSpaces: true,
				ruleRepetition: 3,
				strong: '*',
				emphasis: '_',
			}

			function stringLength(value) {
				return value.length
			}

			/***/
		},

		/***/ 25193: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var decimal = __nccwpck_require__(96734)
			var alphanumeric = __nccwpck_require__(99624)
			var whitespace = __nccwpck_require__(96472)
			var escapes = __nccwpck_require__(80872)
			var prefix = __nccwpck_require__(12140)

			module.exports = factory

			var tab = '\t'
			var lineFeed = '\n'
			var space = ' '
			var numberSign = '#'
			var ampersand = '&'
			var leftParenthesis = '('
			var rightParenthesis = ')'
			var asterisk = '*'
			var plusSign = '+'
			var dash = '-'
			var dot = '.'
			var colon = ':'
			var lessThan = '<'
			var greaterThan = '>'
			var leftSquareBracket = '['
			var backslash = '\\'
			var rightSquareBracket = ']'
			var underscore = '_'
			var graveAccent = '`'
			var verticalBar = '|'
			var tilde = '~'
			var exclamationMark = '!'

			var entities = {
				'<': '&lt;',
				':': '&#x3A;',
				'&': '&amp;',
				'|': '&#x7C;',
				'~': '&#x7E;',
			}

			var shortcut = 'shortcut'
			var mailto = 'mailto'
			var https = 'https'
			var http = 'http'

			var blankExpression = /\n\s*$/

			// Factory to escape characters.
			function factory(options) {
				return escape

				// Escape punctuation characters in a nodes value.
				function escape(value, node, parent) {
					var self = this
					var gfm = options.gfm
					var commonmark = options.commonmark
					var pedantic = options.pedantic
					var markers = commonmark ? [dot, rightParenthesis] : [dot]
					var siblings = parent && parent.children
					var index = siblings && siblings.indexOf(node)
					var previous = siblings && siblings[index - 1]
					var next = siblings && siblings[index + 1]
					var length = value.length
					var escapable = escapes(options)
					var position = -1
					var queue = []
					var escaped = queue
					var afterNewLine
					var character
					var wordCharBefore
					var wordCharAfter
					var offset
					var replace

					if (previous) {
						afterNewLine =
							text(previous) && blankExpression.test(previous.value)
					} else {
						afterNewLine =
							!parent || parent.type === 'root' || parent.type === 'paragraph'
					}

					while (++position < length) {
						character = value.charAt(position)
						replace = false

						if (character === '\n') {
							afterNewLine = true
						} else if (
							character === backslash ||
							character === graveAccent ||
							character === asterisk ||
							character === leftSquareBracket ||
							character === lessThan ||
							(character === ampersand && prefix(value.slice(position)) > 0) ||
							(character === rightSquareBracket && self.inLink) ||
							(gfm &&
								character === tilde &&
								value.charAt(position + 1) === tilde) ||
							(gfm &&
								character === verticalBar &&
								(self.inTable || alignment(value, position))) ||
							(character === underscore &&
								// Delegate leading/trailing underscores to the multinode version below.
								position > 0 &&
								position < length - 1 &&
								(pedantic ||
									!alphanumeric(value.charAt(position - 1)) ||
									!alphanumeric(value.charAt(position + 1)))) ||
							(gfm &&
								!self.inLink &&
								character === colon &&
								protocol(queue.join('')))
						) {
							replace = true
						} else if (afterNewLine) {
							if (
								character === greaterThan ||
								character === numberSign ||
								character === asterisk ||
								character === dash ||
								character === plusSign
							) {
								replace = true
							} else if (decimal(character)) {
								offset = position + 1

								while (offset < length) {
									if (!decimal(value.charAt(offset))) {
										break
									}

									offset++
								}

								if (markers.indexOf(value.charAt(offset)) !== -1) {
									next = value.charAt(offset + 1)

									if (
										!next ||
										next === space ||
										next === tab ||
										next === lineFeed
									) {
										queue.push(value.slice(position, offset))
										position = offset
										character = value.charAt(position)
										replace = true
									}
								}
							}
						}

						if (afterNewLine && !whitespace(character)) {
							afterNewLine = false
						}

						queue.push(replace ? one(character) : character)
					}

					// Multi-node versions.
					if (siblings && text(node)) {
						// Check for an opening parentheses after a link-reference (which can be
						// joined by white-space).
						if (previous && previous.referenceType === shortcut) {
							position = -1
							length = escaped.length

							while (++position < length) {
								character = escaped[position]

								if (character === space || character === tab) {
									continue
								}

								if (character === leftParenthesis || character === colon) {
									escaped[position] = one(character)
								}

								break
							}

							// If the current node is all spaces / tabs, preceded by a shortcut,
							// and followed by a text starting with `(`, escape it.
							if (
								text(next) &&
								position === length &&
								next.value.charAt(0) === leftParenthesis
							) {
								escaped.push(backslash)
							}
						}

						// Ensure non-auto-links are not seen as links.  This pattern needs to
						// check the preceding nodes too.
						if (
							gfm &&
							!self.inLink &&
							text(previous) &&
							value.charAt(0) === colon &&
							protocol(previous.value.slice(-6))
						) {
							escaped[0] = one(colon)
						}

						// Escape ampersand if it would otherwise start an entity.
						if (
							text(next) &&
							value.charAt(length - 1) === ampersand &&
							prefix(ampersand + next.value) !== 0
						) {
							escaped[escaped.length - 1] = one(ampersand)
						}

						// Escape exclamation marks immediately followed by links.
						if (
							next &&
							next.type === 'link' &&
							value.charAt(length - 1) === exclamationMark
						) {
							escaped[escaped.length - 1] = one(exclamationMark)
						}

						// Escape double tildes in GFM.
						if (
							gfm &&
							text(next) &&
							value.charAt(length - 1) === tilde &&
							next.value.charAt(0) === tilde
						) {
							escaped.splice(-1, 0, backslash)
						}

						// Escape underscores, but not mid-word (unless in pedantic mode).
						wordCharBefore =
							text(previous) && alphanumeric(previous.value.slice(-1))
						wordCharAfter = text(next) && alphanumeric(next.value.charAt(0))

						if (length === 1) {
							if (
								value === underscore &&
								(pedantic || !wordCharBefore || !wordCharAfter)
							) {
								escaped.unshift(backslash)
							}
						} else {
							if (
								value.charAt(0) === underscore &&
								(pedantic || !wordCharBefore || !alphanumeric(value.charAt(1)))
							) {
								escaped.unshift(backslash)
							}

							if (
								value.charAt(length - 1) === underscore &&
								(pedantic ||
									!wordCharAfter ||
									!alphanumeric(value.charAt(length - 2)))
							) {
								escaped.splice(-1, 0, backslash)
							}
						}
					}

					return escaped.join('')

					function one(character) {
						return escapable.indexOf(character) === -1
							? entities[character]
							: backslash + character
					}
				}
			}

			// Check if `index` in `value` is inside an alignment row.
			function alignment(value, index) {
				var start = value.lastIndexOf(lineFeed, index)
				var end = value.indexOf(lineFeed, index)
				var char

				end = end === -1 ? value.length : end

				while (++start < end) {
					char = value.charAt(start)

					if (
						char !== colon &&
						char !== dash &&
						char !== space &&
						char !== verticalBar
					) {
						return false
					}
				}

				return true
			}

			// Check if `node` is a text node.
			function text(node) {
				return node && node.type === 'text'
			}

			// Check if `value` ends in a protocol.
			function protocol(value) {
				var tail = value.slice(-6).toLowerCase()
				return (
					tail === mailto || tail.slice(-5) === https || tail.slice(-4) === http
				)
			}

			/***/
		},

		/***/ 57524: /***/ (module) => {
			'use strict'

			module.exports = all

			// Visit all children of `parent`.
			function all(parent) {
				var self = this
				var children = parent.children
				var length = children.length
				var results = []
				var index = -1

				while (++index < length) {
					results[index] = self.visit(children[index], parent)
				}

				return results
			}

			/***/
		},

		/***/ 65590: /***/ (module) => {
			'use strict'

			module.exports = block

			var lineFeed = '\n'

			var blank = lineFeed + lineFeed
			var triple = blank + lineFeed
			var comment = blank + '<!---->' + blank

			// Stringify a block node with block children (e.g., `root` or `blockquote`).
			// Knows about code following a list, or adjacent lists with similar bullets,
			// and places an extra line feed between them.
			function block(node) {
				var self = this
				var options = self.options
				var fences = options.fences
				var gap = options.commonmark ? comment : triple
				var definitionGap = options.tightDefinitions ? lineFeed : blank
				var values = []
				var children = node.children
				var length = children.length
				var index = -1
				var previous
				var child

				while (++index < length) {
					previous = child
					child = children[index]

					if (previous) {
						// A list preceding another list that are equally ordered, or a
						// list preceding an indented code block, need a gap between them,
						// so as not to see them as one list, or content of the list,
						// respectively.
						//
						// In commonmark, only something that breaks both up can do that,
						// so we opt for an empty, invisible comment.  In other flavours,
						// two blank lines are fine.
						if (
							previous.type === 'list' &&
							((child.type === 'list' && previous.ordered === child.ordered) ||
								(child.type === 'code' && !child.lang && !fences))
						) {
							values.push(gap)
						} else if (
							previous.type === 'definition' &&
							child.type === 'definition'
						) {
							values.push(definitionGap)
						} else {
							values.push(blank)
						}
					}

					values.push(self.visit(child, node))
				}

				return values.join('')
			}

			/***/
		},

		/***/ 68882: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var compact = __nccwpck_require__(56558)

			module.exports = compile

			// Stringify the given tree.
			function compile() {
				return this.visit(compact(this.tree, this.options.commonmark))
			}

			/***/
		},

		/***/ 14327: /***/ (module) => {
			'use strict'

			module.exports = one

			function one(node, parent) {
				var self = this
				var visitors = self.visitors

				// Fail on unknown nodes.
				if (typeof visitors[node.type] !== 'function') {
					self.file.fail(
						new Error(
							'Missing compiler for node of type `' +
								node.type +
								'`: `' +
								node +
								'`',
						),
						node,
					)
				}

				return visitors[node.type].call(self, node, parent)
			}

			/***/
		},

		/***/ 60859: /***/ (module) => {
			'use strict'

			module.exports = orderedItems

			var lineFeed = '\n'
			var dot = '.'

			var blank = lineFeed + lineFeed

			// Visit ordered list items.
			//
			// Starts the list with
			// `node.start` and increments each following list item
			// bullet by one:
			//
			//     2. foo
			//     3. bar
			//
			// In `incrementListMarker: false` mode, does not increment
			// each marker and stays on `node.start`:
			//
			//     1. foo
			//     1. bar
			function orderedItems(node) {
				var self = this
				var fn = self.visitors.listItem
				var increment = self.options.incrementListMarker
				var values = []
				var start = node.start
				var children = node.children
				var length = children.length
				var index = -1
				var bullet

				start = start == null ? 1 : start

				while (++index < length) {
					bullet = (increment ? start + index : start) + dot
					values[index] = fn.call(self, children[index], node, index, bullet)
				}

				return values.join(node.spread ? blank : lineFeed)
			}

			/***/
		},

		/***/ 41250: /***/ (module) => {
			'use strict'

			module.exports = unorderedItems

			var lineFeed = '\n'

			var blank = lineFeed + lineFeed

			// Visit unordered list items.  Uses `options.bullet` as each items bullet.
			function unorderedItems(node) {
				var self = this
				var bullet = self.options.bullet
				var fn = self.visitors.listItem
				var children = node.children
				var length = children.length
				var index = -1
				var values = []

				while (++index < length) {
					values[index] = fn.call(self, children[index], node, index, bullet)
				}

				return values.join(node.spread ? blank : lineFeed)
			}

			/***/
		},

		/***/ 14179: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var xtend = __nccwpck_require__(80869)
			var encode = __nccwpck_require__(55655)
			var defaults = __nccwpck_require__(58236)
			var escapeFactory = __nccwpck_require__(25193)
			var identity = __nccwpck_require__(73983)

			module.exports = setOptions

			// Map of applicable enums.
			var maps = {
				entities: { true: true, false: true, numbers: true, escape: true },
				bullet: { '*': true, '-': true, '+': true },
				rule: { '-': true, _: true, '*': true },
				listItemIndent: { tab: true, mixed: true, 1: true },
				emphasis: { _: true, '*': true },
				strong: { _: true, '*': true },
				fence: { '`': true, '~': true },
			}

			// Expose `validate`.
			var validate = {
				boolean: validateBoolean,
				string: validateString,
				number: validateNumber,
				function: validateFunction,
			}

			// Set options.  Does not overwrite previously set options.
			function setOptions(options) {
				var self = this
				var current = self.options
				var ruleRepetition
				var key

				if (options == null) {
					options = {}
				} else if (typeof options === 'object') {
					options = xtend(options)
				} else {
					throw new Error(
						'Invalid value `' + options + '` for setting `options`',
					)
				}

				for (key in defaults) {
					validate[typeof defaults[key]](options, key, current[key], maps[key])
				}

				ruleRepetition = options.ruleRepetition

				if (ruleRepetition && ruleRepetition < 3) {
					raise(ruleRepetition, 'options.ruleRepetition')
				}

				self.encode = encodeFactory(String(options.entities))
				self.escape = escapeFactory(options)

				self.options = options

				return self
			}

			// Validate a value to be boolean. Defaults to `def`.  Raises an exception with
			// `context[name]` when not a boolean.
			function validateBoolean(context, name, def) {
				var value = context[name]

				if (value == null) {
					value = def
				}

				if (typeof value !== 'boolean') {
					raise(value, 'options.' + name)
				}

				context[name] = value
			}

			// Validate a value to be boolean. Defaults to `def`.  Raises an exception with
			// `context[name]` when not a boolean.
			function validateNumber(context, name, def) {
				var value = context[name]

				if (value == null) {
					value = def
				}

				if (isNaN(value)) {
					raise(value, 'options.' + name)
				}

				context[name] = value
			}

			// Validate a value to be in `map`. Defaults to `def`.  Raises an exception
			// with `context[name]` when not in `map`.
			function validateString(context, name, def, map) {
				var value = context[name]

				if (value == null) {
					value = def
				}

				value = String(value)

				if (!(value in map)) {
					raise(value, 'options.' + name)
				}

				context[name] = value
			}

			// Validate a value to be function. Defaults to `def`.  Raises an exception
			// with `context[name]` when not a function.
			function validateFunction(context, name, def) {
				var value = context[name]

				if (value == null) {
					value = def
				}

				if (typeof value !== 'function') {
					raise(value, 'options.' + name)
				}

				context[name] = value
			}

			// Factory to encode HTML entities.  Creates a no-operation function when
			// `type` is `'false'`, a function which encodes using named references when
			// `type` is `'true'`, and a function which encodes using numbered references
			// when `type` is `'numbers'`.
			function encodeFactory(type) {
				var options = {}

				if (type === 'false') {
					return identity
				}

				if (type === 'true') {
					options.useNamedReferences = true
				}

				if (type === 'escape') {
					options.escapeOnly = true
					options.useNamedReferences = true
				}

				return wrapped

				// Encode HTML entities using the bound options.
				function wrapped(value) {
					return encode(value, options)
				}
			}

			// Throw an exception with in its `message` `value` and `name`.
			function raise(value, name) {
				throw new Error(
					'Invalid value `' + value + '` for setting `' + name + '`',
				)
			}

			/***/
		},

		/***/ 65118: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var entityPrefixLength = __nccwpck_require__(12140)

			module.exports = copy

			var ampersand = '&'

			var punctuationExppresion = /[-!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~_]/

			// For shortcut and collapsed reference links, the contents is also an
			// identifier, so we need to restore the original encoding and escaping
			// that were present in the source string.
			//
			// This function takes the unescaped & unencoded value from shortcuts
			// child nodes and the identifier and encodes the former according to
			// the latter.
			function copy(value, identifier) {
				var length = value.length
				var count = identifier.length
				var result = []
				var position = 0
				var index = 0
				var start

				while (index < length) {
					// Take next non-punctuation characters from `value`.
					start = index

					while (
						index < length &&
						!punctuationExppresion.test(value.charAt(index))
					) {
						index += 1
					}

					result.push(value.slice(start, index))

					// Advance `position` to the next punctuation character.
					while (
						position < count &&
						!punctuationExppresion.test(identifier.charAt(position))
					) {
						position += 1
					}

					// Take next punctuation characters from `identifier`.
					start = position

					while (
						position < count &&
						punctuationExppresion.test(identifier.charAt(position))
					) {
						if (identifier.charAt(position) === ampersand) {
							position += entityPrefixLength(identifier.slice(position))
						}

						position += 1
					}

					result.push(identifier.slice(start, position))

					// Advance `index` to the next non-punctuation character.
					while (
						index < length &&
						punctuationExppresion.test(value.charAt(index))
					) {
						index += 1
					}
				}

				return result.join('')
			}

			/***/
		},

		/***/ 2679: /***/ (module) => {
			'use strict'

			module.exports = enclose

			var quotationMark = '"'
			var apostrophe = "'"

			// There is currently no way to support nested delimiters across Markdown.pl,
			// CommonMark, and GitHub (RedCarpet).  The following code supports Markdown.pl
			// and GitHub.
			// CommonMark is not supported when mixing double- and single quotes inside a
			// title.
			function enclose(title) {
				var delimiter =
					title.indexOf(quotationMark) === -1 ? quotationMark : apostrophe
				return delimiter + title + delimiter
			}

			/***/
		},

		/***/ 83287: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var count = __nccwpck_require__(83076)

			module.exports = enclose

			var leftParenthesis = '('
			var rightParenthesis = ')'
			var lessThan = '<'
			var greaterThan = '>'

			var expression = /\s/

			// Wrap `url` in angle brackets when needed, or when
			// forced.
			// In links, images, and definitions, the URL part needs
			// to be enclosed when it:
			//
			// - has a length of `0`
			// - contains white-space
			// - has more or less opening than closing parentheses
			function enclose(uri, always) {
				if (
					always ||
					uri.length === 0 ||
					expression.test(uri) ||
					count(uri, leftParenthesis) !== count(uri, rightParenthesis)
				) {
					return lessThan + uri + greaterThan
				}

				return uri
			}

			/***/
		},

		/***/ 15912: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var identity = __nccwpck_require__(73983)

			module.exports = enter

			// Shortcut and collapsed link references need no escaping and encoding during
			// the processing of child nodes (it must be implied from identifier).
			//
			// This toggler turns encoding and escaping off for shortcut and collapsed
			// references.
			//
			// Implies `enterLink`.
			function enter(compiler, node) {
				var encode = compiler.encode
				var escape = compiler.escape
				var exitLink = compiler.enterLink()

				if (
					node.referenceType !== 'shortcut' &&
					node.referenceType !== 'collapsed'
				) {
					return exitLink
				}

				compiler.escape = identity
				compiler.encode = identity

				return exit

				function exit() {
					compiler.encode = encode
					compiler.escape = escape
					exitLink()
				}
			}

			/***/
		},

		/***/ 12140: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var decode = __nccwpck_require__(75165)

			module.exports = length

			var ampersand = '&'

			// Returns the length of HTML entity that is a prefix of the given string
			// (excluding the ampersand), 0 if it does not start with an entity.
			function length(value) {
				var prefix

				/* istanbul ignore if - Currently also tested for at implemention, but we
				 * keep it here because thats proper. */
				if (value.charAt(0) !== ampersand) {
					return 0
				}

				prefix = value.split(ampersand, 2).join(ampersand)

				return prefix.length - decode(prefix).length
			}

			/***/
		},

		/***/ 73983: /***/ (module) => {
			'use strict'

			module.exports = identity

			function identity(value) {
				return value
			}

			/***/
		},

		/***/ 37815: /***/ (module) => {
			'use strict'

			module.exports = label

			var leftSquareBracket = '['
			var rightSquareBracket = ']'

			var shortcut = 'shortcut'
			var collapsed = 'collapsed'

			// Stringify a reference label.
			// Because link references are easily, mistakingly, created (for example,
			// `[foo]`), reference nodes have an extra property depicting how it looked in
			// the original document, so stringification can cause minimal changes.
			function label(node) {
				var type = node.referenceType

				if (type === shortcut) {
					return ''
				}

				return (
					leftSquareBracket +
					(type === collapsed ? '' : node.label || node.identifier) +
					rightSquareBracket
				)
			}

			/***/
		},

		/***/ 21128: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var repeat = __nccwpck_require__(40471)

			module.exports = pad

			var lineFeed = '\n'
			var space = ' '

			var tabSize = 4

			// Pad `value` with `level * tabSize` spaces.  Respects lines.  Ignores empty
			// lines.
			function pad(value, level) {
				var values = value.split(lineFeed)
				var index = values.length
				var padding = repeat(space, level * tabSize)

				while (index--) {
					if (values[index].length !== 0) {
						values[index] = padding + values[index]
					}
				}

				return values.join(lineFeed)
			}

			/***/
		},

		/***/ 1647: /***/ (module) => {
			'use strict'

			module.exports = blockquote

			var lineFeed = '\n'
			var space = ' '
			var greaterThan = '>'

			function blockquote(node) {
				var values = this.block(node).split(lineFeed)
				var result = []
				var length = values.length
				var index = -1
				var value

				while (++index < length) {
					value = values[index]
					result[index] = (value ? space : '') + value
				}

				return greaterThan + result.join(lineFeed + greaterThan)
			}

			/***/
		},

		/***/ 83129: /***/ (module) => {
			'use strict'

			module.exports = lineBreak

			var backslash = '\\'
			var lineFeed = '\n'
			var space = ' '

			var commonmark = backslash + lineFeed
			var normal = space + space + lineFeed

			function lineBreak() {
				return this.options.commonmark ? commonmark : normal
			}

			/***/
		},

		/***/ 47149: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var streak = __nccwpck_require__(86863)
			var repeat = __nccwpck_require__(40471)
			var pad = __nccwpck_require__(21128)

			module.exports = code

			var lineFeed = '\n'
			var space = ' '
			var tilde = '~'
			var graveAccent = '`'

			// Stringify code.
			// Creates indented code when:
			//
			// - No language tag exists
			// - Not in `fences: true` mode
			// - A non-empty value exists
			//
			// Otherwise, GFM fenced code is created:
			//
			// ````markdown
			// ```js
			// foo();
			// ```
			// ````
			//
			// When in ``fence: `~` `` mode, uses tildes as fences:
			//
			// ```markdown
			// ~~~js
			// foo();
			// ~~~
			// ```
			//
			// Knows about internal fences:
			//
			// `````markdown
			// ````markdown
			// ```javascript
			// foo();
			// ```
			// ````
			// `````
			function code(node, parent) {
				var self = this
				var value = node.value
				var options = self.options
				var marker = options.fence
				var info = node.lang || ''
				var fence

				if (info && node.meta) {
					info += space + node.meta
				}

				info = self.encode(self.escape(info, node))

				// Without (needed) fences.
				if (
					!info &&
					!options.fences &&
					value &&
					value.charAt(0) !== lineFeed &&
					value.charAt(value.length - 1) !== lineFeed
				) {
					// Throw when pedantic, in a list item which isnt compiled using a tab.
					if (
						parent &&
						parent.type === 'listItem' &&
						options.listItemIndent !== 'tab' &&
						options.pedantic
					) {
						self.file.fail(
							'Cannot indent code properly. See https://git.io/fxKR8',
							node.position,
						)
					}

					return pad(value, 1)
				}

				// Backticks in the info string dont work with backtick fenced code.
				// Backticks (and tildes) are fine in tilde fenced code.
				if (marker === graveAccent && info.indexOf(graveAccent) !== -1) {
					marker = tilde
				}

				fence = repeat(marker, Math.max(streak(value, marker) + 1, 3))

				return fence + info + lineFeed + value + lineFeed + fence
			}

			/***/
		},

		/***/ 16921: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var uri = __nccwpck_require__(83287)
			var title = __nccwpck_require__(2679)

			module.exports = definition

			var space = ' '
			var colon = ':'
			var leftSquareBracket = '['
			var rightSquareBracket = ']'

			// Stringify an URL definition.
			//
			// Is smart about enclosing `url` (see `encloseURI()`) and `title` (see
			// `encloseTitle()`).
			//
			// ```markdown
			// [foo]: <foo at bar dot com> 'An "example" e-mail'
			// ```
			function definition(node) {
				var content = uri(node.url)

				if (node.title) {
					content += space + title(node.title)
				}

				return (
					leftSquareBracket +
					(node.label || node.identifier) +
					rightSquareBracket +
					colon +
					space +
					content
				)
			}

			/***/
		},

		/***/ 50455: /***/ (module) => {
			'use strict'

			module.exports = strikethrough

			var tilde = '~'

			var fence = tilde + tilde

			function strikethrough(node) {
				return fence + this.all(node).join('') + fence
			}

			/***/
		},

		/***/ 61822: /***/ (module) => {
			'use strict'

			module.exports = emphasis

			var underscore = '_'
			var asterisk = '*'

			// Stringify an `emphasis`.
			//
			// The marker used is configurable through `emphasis`, which defaults to an
			// underscore (`'_'`) but also accepts an asterisk (`'*'`):
			//
			// ```markdown
			// *foo*
			// ```
			//
			// In `pedantic` mode, text which itself contains an underscore will cause the
			// marker to default to an asterisk instead:
			//
			// ```markdown
			// *foo_bar*
			// ```
			function emphasis(node) {
				var marker = this.options.emphasis
				var content = this.all(node).join('')

				// When in pedantic mode, prevent using underscore as the marker when there
				// are underscores in the content.
				if (
					this.options.pedantic &&
					marker === underscore &&
					content.indexOf(marker) !== -1
				) {
					marker = asterisk
				}

				return marker + content + marker
			}

			/***/
		},

		/***/ 71124: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var repeat = __nccwpck_require__(40471)

			module.exports = heading

			var lineFeed = '\n'
			var space = ' '
			var numberSign = '#'
			var dash = '-'
			var equalsTo = '='

			// Stringify a heading.
			//
			// In `setext: true` mode and when `depth` is smaller than three, creates a
			// setext header:
			//
			// ```markdown
			// Foo
			// ===
			// ```
			//
			// Otherwise, an ATX header is generated:
			//
			// ```markdown
			// ### Foo
			// ```
			//
			// In `closeAtx: true` mode, the header is closed with hashes:
			//
			// ```markdown
			// ### Foo ###
			// ```
			function heading(node) {
				var self = this
				var depth = node.depth
				var setext = self.options.setext
				var closeAtx = self.options.closeAtx
				var content = self.all(node).join('')
				var prefix

				if (setext && depth < 3) {
					return (
						content +
						lineFeed +
						repeat(depth === 1 ? equalsTo : dash, content.length)
					)
				}

				prefix = repeat(numberSign, node.depth)

				return prefix + space + content + (closeAtx ? space + prefix : '')
			}

			/***/
		},

		/***/ 37209: /***/ (module) => {
			'use strict'

			module.exports = html

			function html(node) {
				return node.value
			}

			/***/
		},

		/***/ 24147: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var label = __nccwpck_require__(37815)

			module.exports = imageReference

			var leftSquareBracket = '['
			var rightSquareBracket = ']'
			var exclamationMark = '!'

			function imageReference(node) {
				return (
					exclamationMark +
					leftSquareBracket +
					(this.encode(node.alt, node) || '') +
					rightSquareBracket +
					label(node)
				)
			}

			/***/
		},

		/***/ 63423: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var uri = __nccwpck_require__(83287)
			var title = __nccwpck_require__(2679)

			module.exports = image

			var space = ' '
			var leftParenthesis = '('
			var rightParenthesis = ')'
			var leftSquareBracket = '['
			var rightSquareBracket = ']'
			var exclamationMark = '!'

			// Stringify an image.
			//
			// Is smart about enclosing `url` (see `encloseURI()`) and `title` (see
			// `encloseTitle()`).
			//
			// ```markdown
			// ![foo](</fav icon.png> 'My "favourite" icon')
			// ```
			//
			// Supports named entities in `url`, `alt`, and `title` when in
			// `settings.encode` mode.
			function image(node) {
				var self = this
				var content = uri(self.encode(node.url || '', node))
				var exit = self.enterLink()
				var alt = self.encode(self.escape(node.alt || '', node))

				exit()

				if (node.title) {
					content += space + title(self.encode(node.title, node))
				}

				return (
					exclamationMark +
					leftSquareBracket +
					alt +
					rightSquareBracket +
					leftParenthesis +
					content +
					rightParenthesis
				)
			}

			/***/
		},

		/***/ 67163: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var streak = __nccwpck_require__(86863)
			var repeat = __nccwpck_require__(40471)

			module.exports = inlineCode

			var graveAccentChar = '`'
			var lineFeed = 10 //  '\n'
			var space = 32 // ' '
			var graveAccent = 96 //  '`'

			// Stringify inline code.
			//
			// Knows about internal ticks (`\``), and ensures one more tick is used to
			// enclose the inline code:
			//
			// ````markdown
			// ```foo ``bar`` baz```
			// ````
			//
			// Even knows about inital and final ticks:
			//
			// ``markdown
			// `` `foo ``
			// `` foo` ``
			// ```
			function inlineCode(node) {
				var value = node.value
				var ticks = repeat(graveAccentChar, streak(value, graveAccentChar) + 1)
				var start = ticks
				var end = ticks
				var head = value.charCodeAt(0)
				var tail = value.charCodeAt(value.length - 1)
				var wrap = false
				var index
				var length

				if (head === graveAccent || tail === graveAccent) {
					wrap = true
				} else if (value.length > 2 && ws(head) && ws(tail)) {
					index = 1
					length = value.length - 1

					while (++index < length) {
						if (!ws(value.charCodeAt(index))) {
							wrap = true
							break
						}
					}
				}

				if (wrap) {
					start += ' '
					end = ' ' + end
				}

				return start + value + end
			}

			function ws(code) {
				return code === lineFeed || code === space
			}

			/***/
		},

		/***/ 15536: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var copy = __nccwpck_require__(65118)
			var label = __nccwpck_require__(37815)

			module.exports = linkReference

			var leftSquareBracket = '['
			var rightSquareBracket = ']'

			var shortcut = 'shortcut'
			var collapsed = 'collapsed'

			function linkReference(node) {
				var self = this
				var type = node.referenceType
				var exit = self.enterLinkReference(self, node)
				var value = self.all(node).join('')

				exit()

				if (type === shortcut || type === collapsed) {
					value = copy(value, node.label || node.identifier)
				}

				return leftSquareBracket + value + rightSquareBracket + label(node)
			}

			/***/
		},

		/***/ 10892: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var uri = __nccwpck_require__(83287)
			var title = __nccwpck_require__(2679)

			module.exports = link

			var space = ' '
			var leftSquareBracket = '['
			var rightSquareBracket = ']'
			var leftParenthesis = '('
			var rightParenthesis = ')'

			// Expression for a protocol:
			// See <https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Generic_syntax>.
			var protocol = /^[a-z][a-z+.-]+:\/?/i

			// Stringify a link.
			//
			// When no title exists, the compiled `children` equal `url`, and `url` starts
			// with a protocol, an auto link is created:
			//
			// ```markdown
			// <http://example.com>
			// ```
			//
			// Otherwise, is smart about enclosing `url` (see `encloseURI()`) and `title`
			// (see `encloseTitle()`).
			// ```
			//
			// ```markdown
			// [foo](<foo at bar dot com> 'An "example" e-mail')
			// ```
			//
			// Supports named entities in the `url` and `title` when in `settings.encode`
			// mode.
			function link(node) {
				var self = this
				var content = self.encode(node.url || '', node)
				var exit = self.enterLink()
				var escaped = self.encode(self.escape(node.url || '', node))
				var value = self.all(node).join('')

				exit()

				if (node.title == null && protocol.test(content) && escaped === value) {
					// Backslash escapes do not work in autolinks, so we do not escape.
					return uri(self.encode(node.url), true)
				}

				content = uri(content)

				if (node.title) {
					content +=
						space + title(self.encode(self.escape(node.title, node), node))
				}

				return (
					leftSquareBracket +
					value +
					rightSquareBracket +
					leftParenthesis +
					content +
					rightParenthesis
				)
			}

			/***/
		},

		/***/ 43138: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var repeat = __nccwpck_require__(40471)
			var pad = __nccwpck_require__(21128)

			module.exports = listItem

			var lineFeed = '\n'
			var space = ' '
			var leftSquareBracket = '['
			var rightSquareBracket = ']'
			var lowercaseX = 'x'

			var ceil = Math.ceil
			var blank = lineFeed + lineFeed

			var tabSize = 4

			// Stringify a list item.
			//
			// Prefixes the content with a checked checkbox when `checked: true`:
			//
			// ```markdown
			// [x] foo
			// ```
			//
			// Prefixes the content with an unchecked checkbox when `checked: false`:
			//
			// ```markdown
			// [ ] foo
			// ```
			function listItem(node, parent, position, bullet) {
				var self = this
				var style = self.options.listItemIndent
				var marker = bullet || self.options.bullet
				var spread = node.spread == null ? true : node.spread
				var checked = node.checked
				var children = node.children
				var length = children.length
				var values = []
				var index = -1
				var value
				var indent
				var spacing

				while (++index < length) {
					values[index] = self.visit(children[index], node)
				}

				value = values.join(spread ? blank : lineFeed)

				if (typeof checked === 'boolean') {
					// Note: Id like to be able to only add the space between the check and
					// the value, but unfortunately github does not support empty list-items
					// with a checkbox :(
					value =
						leftSquareBracket +
						(checked ? lowercaseX : space) +
						rightSquareBracket +
						space +
						value
				}

				if (
					style === '1' ||
					(style === 'mixed' && value.indexOf(lineFeed) === -1)
				) {
					indent = marker.length + 1
					spacing = space
				} else {
					indent = ceil((marker.length + 1) / tabSize) * tabSize
					spacing = repeat(space, indent - marker.length)
				}

				return value
					? marker + spacing + pad(value, indent / tabSize).slice(indent)
					: marker
			}

			/***/
		},

		/***/ 71656: /***/ (module) => {
			'use strict'

			module.exports = list

			function list(node) {
				var fn = node.ordered
					? this.visitOrderedItems
					: this.visitUnorderedItems
				return fn.call(this, node)
			}

			/***/
		},

		/***/ 71940: /***/ (module) => {
			'use strict'

			module.exports = paragraph

			function paragraph(node) {
				return this.all(node).join('')
			}

			/***/
		},

		/***/ 55900: /***/ (module) => {
			'use strict'

			module.exports = root

			var lineFeed = '\n'

			// Stringify a root.
			// Adds a final newline to ensure valid POSIX files. */
			function root(node) {
				var doc = this.block(node)

				if (doc.charAt(doc.length - 1) !== lineFeed) {
					doc += lineFeed
				}

				return doc
			}

			/***/
		},

		/***/ 86747: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var repeat = __nccwpck_require__(40471)

			module.exports = strong

			// Stringify a `strong`.
			//
			// The marker used is configurable by `strong`, which defaults to an asterisk
			// (`'*'`) but also accepts an underscore (`'_'`):
			//
			// ```markdown
			// __foo__
			// ```
			function strong(node) {
				var marker = repeat(this.options.strong, 2)
				return marker + this.all(node).join('') + marker
			}

			/***/
		},

		/***/ 40955: /***/ (module) => {
			'use strict'

			module.exports = tableCell

			var lineFeed = /\r?\n/g

			function tableCell(node) {
				return this.all(node).join('').replace(lineFeed, ' ')
			}

			/***/
		},

		/***/ 17518: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var markdownTable = __nccwpck_require__(56144)

			module.exports = table

			// Stringify table.
			//
			// Creates a fenced table.
			// The table has aligned delimiters by default, but not in
			// `tablePipeAlign: false`:
			//
			// ```markdown
			// | Header 1 | Header 2 |
			// | :-: | - |
			// | Alpha | Bravo |
			// ```
			//
			// The table is spaced by default, but not in `tableCellPadding: false`:
			//
			// ```markdown
			// |Foo|Bar|
			// |:-:|---|
			// |Baz|Qux|
			// ```
			function table(node) {
				var self = this
				var options = self.options
				var padding = options.tableCellPadding
				var alignDelimiters = options.tablePipeAlign
				var stringLength = options.stringLength
				var rows = node.children
				var index = rows.length
				var exit = self.enterTable()
				var result = []

				while (index--) {
					result[index] = self.all(rows[index])
				}

				exit()

				return markdownTable(result, {
					align: node.align,
					alignDelimiters: alignDelimiters,
					padding: padding,
					stringLength: stringLength,
				})
			}

			/***/
		},

		/***/ 49739: /***/ (module) => {
			'use strict'

			module.exports = text

			// Stringify text.
			// Supports named entities in `settings.encode: true` mode:
			//
			// ```markdown
			// AT&amp;T
			// ```
			//
			// Supports numbered entities in `settings.encode: numbers` mode:
			//
			// ```markdown
			// AT&#x26;T
			// ```
			function text(node, parent) {
				return this.encode(this.escape(node.value, node, parent), node)
			}

			/***/
		},

		/***/ 73345: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var repeat = __nccwpck_require__(40471)

			module.exports = thematic

			var space = ' '

			// Stringify a `thematic-break`.
			// The character used is configurable through `rule`: (`'_'`):
			//
			// ```markdown
			// ___
			// ```
			//
			// The number of repititions is defined through `ruleRepetition` (`6`):
			//
			// ```markdown
			// ******
			// ```
			//
			// Whether spaces delimit each character, is configured through `ruleSpaces`
			// (`true`):
			// ```markdown
			// * * *
			// ```
			function thematic() {
				var options = this.options
				var rule = repeat(options.rule, options.ruleRepetition)
				return options.ruleSpaces ? rule.split('').join(space) : rule
			}

			/***/
		},

		/***/ 56144: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var repeat = __nccwpck_require__(40471)

			module.exports = markdownTable

			var trailingWhitespace = / +$/

			// Characters.
			var space = ' '
			var lineFeed = '\n'
			var dash = '-'
			var colon = ':'
			var verticalBar = '|'

			var x = 0
			var C = 67
			var L = 76
			var R = 82
			var c = 99
			var l = 108
			var r = 114

			// Create a table from a matrix of strings.
			function markdownTable(table, options) {
				var settings = options || {}
				var padding = settings.padding !== false
				var start = settings.delimiterStart !== false
				var end = settings.delimiterEnd !== false
				var align = (settings.align || []).concat()
				var alignDelimiters = settings.alignDelimiters !== false
				var alignments = []
				var stringLength = settings.stringLength || defaultStringLength
				var rowIndex = -1
				var rowLength = table.length
				var cellMatrix = []
				var sizeMatrix = []
				var row = []
				var sizes = []
				var longestCellByColumn = []
				var mostCellsPerRow = 0
				var cells
				var columnIndex
				var columnLength
				var largest
				var size
				var cell
				var lines
				var line
				var before
				var after
				var code

				// This is a superfluous loop if we dont align delimiters, but otherwise wed
				// do superfluous work when aligning, so optimize for aligning.
				while (++rowIndex < rowLength) {
					cells = table[rowIndex]
					columnIndex = -1
					columnLength = cells.length
					row = []
					sizes = []

					if (columnLength > mostCellsPerRow) {
						mostCellsPerRow = columnLength
					}

					while (++columnIndex < columnLength) {
						cell = serialize(cells[columnIndex])

						if (alignDelimiters === true) {
							size = stringLength(cell)
							sizes[columnIndex] = size

							largest = longestCellByColumn[columnIndex]

							if (largest === undefined || size > largest) {
								longestCellByColumn[columnIndex] = size
							}
						}

						row.push(cell)
					}

					cellMatrix[rowIndex] = row
					sizeMatrix[rowIndex] = sizes
				}

				// Figure out which alignments to use.
				columnIndex = -1
				columnLength = mostCellsPerRow

				if (typeof align === 'object' && 'length' in align) {
					while (++columnIndex < columnLength) {
						alignments[columnIndex] = toAlignment(align[columnIndex])
					}
				} else {
					code = toAlignment(align)

					while (++columnIndex < columnLength) {
						alignments[columnIndex] = code
					}
				}

				// Inject the alignment row.
				columnIndex = -1
				columnLength = mostCellsPerRow
				row = []
				sizes = []

				while (++columnIndex < columnLength) {
					code = alignments[columnIndex]
					before = ''
					after = ''

					if (code === l) {
						before = colon
					} else if (code === r) {
						after = colon
					} else if (code === c) {
						before = colon
						after = colon
					}

					// There *must* be at least one hyphen-minus in each alignment cell.
					size = alignDelimiters
						? Math.max(
								1,
								longestCellByColumn[columnIndex] - before.length - after.length,
							)
						: 1

					cell = before + repeat(dash, size) + after

					if (alignDelimiters === true) {
						size = before.length + size + after.length

						if (size > longestCellByColumn[columnIndex]) {
							longestCellByColumn[columnIndex] = size
						}

						sizes[columnIndex] = size
					}

					row[columnIndex] = cell
				}

				// Inject the alignment row.
				cellMatrix.splice(1, 0, row)
				sizeMatrix.splice(1, 0, sizes)

				rowIndex = -1
				rowLength = cellMatrix.length
				lines = []

				while (++rowIndex < rowLength) {
					row = cellMatrix[rowIndex]
					sizes = sizeMatrix[rowIndex]
					columnIndex = -1
					columnLength = mostCellsPerRow
					line = []

					while (++columnIndex < columnLength) {
						cell = row[columnIndex] || ''
						before = ''
						after = ''

						if (alignDelimiters === true) {
							size =
								longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0)
							code = alignments[columnIndex]

							if (code === r) {
								before = repeat(space, size)
							} else if (code === c) {
								if (size % 2 === 0) {
									before = repeat(space, size / 2)
									after = before
								} else {
									before = repeat(space, size / 2 + 0.5)
									after = repeat(space, size / 2 - 0.5)
								}
							} else {
								after = repeat(space, size)
							}
						}

						if (start === true && columnIndex === 0) {
							line.push(verticalBar)
						}

						if (
							padding === true &&
							// Dont add the opening space if were not aligning and the cell is
							// empty: there will be a closing space.
							!(alignDelimiters === false && cell === '') &&
							(start === true || columnIndex !== 0)
						) {
							line.push(space)
						}

						if (alignDelimiters === true) {
							line.push(before)
						}

						line.push(cell)

						if (alignDelimiters === true) {
							line.push(after)
						}

						if (padding === true) {
							line.push(space)
						}

						if (end === true || columnIndex !== columnLength - 1) {
							line.push(verticalBar)
						}
					}

					line = line.join('')

					if (end === false) {
						line = line.replace(trailingWhitespace, '')
					}

					lines.push(line)
				}

				return lines.join(lineFeed)
			}

			function serialize(value) {
				return value === null || value === undefined ? '' : String(value)
			}

			function defaultStringLength(value) {
				return value.length
			}

			function toAlignment(value) {
				var code = typeof value === 'string' ? value.charCodeAt(0) : x

				return code === L || code === l
					? l
					: code === R || code === r
						? r
						: code === C || code === c
							? c
							: x
			}

			/***/
		},

		/***/ 11112: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var unified = __nccwpck_require__(23578)
			var parse = __nccwpck_require__(24982)
			var stringify = __nccwpck_require__(32780)

			module.exports = unified().use(parse).use(stringify).freeze()

			/***/
		},

		/***/ 33708: /***/ (module) => {
			'use strict'

			module.exports = bail

			function bail(err) {
				if (err) {
					throw err
				}
			}

			/***/
		},

		/***/ 79857: /***/ (module) => {
			/*!
			 * Determine if an object is a Buffer
			 *
			 * @author   Feross Aboukhadijeh <https://feross.org>
			 * @license  MIT
			 */

			module.exports = function isBuffer(obj) {
				return (
					obj != null &&
					obj.constructor != null &&
					typeof obj.constructor.isBuffer === 'function' &&
					obj.constructor.isBuffer(obj)
				)
			}

			/***/
		},

		/***/ 14805: /***/ (module) => {
			'use strict'

			module.exports = (value) => {
				if (Object.prototype.toString.call(value) !== '[object Object]') {
					return false
				}

				const prototype = Object.getPrototypeOf(value)
				return prototype === null || prototype === Object.prototype
			}

			/***/
		},

		/***/ 39693: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var wrap = __nccwpck_require__(96285)

			module.exports = trough

			trough.wrap = wrap

			var slice = [].slice

			// Create new middleware.
			function trough() {
				var fns = []
				var middleware = {}

				middleware.run = run
				middleware.use = use

				return middleware

				// Run `fns`.  Last argument must be a completion handler.
				function run() {
					var index = -1
					var input = slice.call(arguments, 0, -1)
					var done = arguments[arguments.length - 1]

					if (typeof done !== 'function') {
						throw new Error('Expected function as last argument, not ' + done)
					}

					next.apply(null, [null].concat(input))

					// Run the next `fn`, if any.
					function next(err) {
						var fn = fns[++index]
						var params = slice.call(arguments, 0)
						var values = params.slice(1)
						var length = input.length
						var pos = -1

						if (err) {
							done(err)
							return
						}

						// Copy non-nully input into values.
						while (++pos < length) {
							if (values[pos] === null || values[pos] === undefined) {
								values[pos] = input[pos]
							}
						}

						input = values

						// Next or done.
						if (fn) {
							wrap(fn, next).apply(null, input)
						} else {
							done.apply(null, [null].concat(input))
						}
					}
				}

				// Add `fn` to the list.
				function use(fn) {
					if (typeof fn !== 'function') {
						throw new Error('Expected `fn` to be a function, not ' + fn)
					}

					fns.push(fn)

					return middleware
				}
			}

			/***/
		},

		/***/ 96285: /***/ (module) => {
			'use strict'

			var slice = [].slice

			module.exports = wrap

			// Wrap `fn`.
			// Can be sync or async; return a promise, receive a completion handler, return
			// new values and errors.
			function wrap(fn, callback) {
				var invoked

				return wrapped

				function wrapped() {
					var params = slice.call(arguments, 0)
					var callback = fn.length > params.length
					var result

					if (callback) {
						params.push(done)
					}

					try {
						result = fn.apply(null, params)
					} catch (error) {
						// Well, this is quite the pickle.
						// `fn` received a callback and invoked it (thus continuing the pipeline),
						// but later also threw an error.
						// Were not about to restart the pipeline again, so the only thing left
						// to do is to throw the thing instead.
						if (callback && invoked) {
							throw error
						}

						return done(error)
					}

					if (!callback) {
						if (result && typeof result.then === 'function') {
							result.then(then, done)
						} else if (result instanceof Error) {
							done(result)
						} else {
							then(result)
						}
					}
				}

				// Invoke `next`, only once.
				function done() {
					if (!invoked) {
						invoked = true

						callback.apply(null, arguments)
					}
				}

				// Invoke `done` with one value.
				// Tracks if an error is passed, too.
				function then(value) {
					done(null, value)
				}
			}

			/***/
		},

		/***/ 23578: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var bail = __nccwpck_require__(33708)
			var buffer = __nccwpck_require__(79857)
			var extend = __nccwpck_require__(23860)
			var plain = __nccwpck_require__(14805)
			var trough = __nccwpck_require__(39693)
			var vfile = __nccwpck_require__(61952)

			// Expose a frozen processor.
			module.exports = unified().freeze()

			var slice = [].slice
			var own = {}.hasOwnProperty

			// Process pipeline.
			var pipeline = trough()
				.use(pipelineParse)
				.use(pipelineRun)
				.use(pipelineStringify)

			function pipelineParse(p, ctx) {
				ctx.tree = p.parse(ctx.file)
			}

			function pipelineRun(p, ctx, next) {
				p.run(ctx.tree, ctx.file, done)

				function done(error, tree, file) {
					if (error) {
						next(error)
					} else {
						ctx.tree = tree
						ctx.file = file
						next()
					}
				}
			}

			function pipelineStringify(p, ctx) {
				var result = p.stringify(ctx.tree, ctx.file)

				if (result === undefined || result === null) {
					// Empty.
				} else if (typeof result === 'string' || buffer(result)) {
					if ('value' in ctx.file) {
						ctx.file.value = result
					}

					ctx.file.contents = result
				} else {
					ctx.file.result = result
				}
			}

			// Function to create the first processor.
			function unified() {
				var attachers = []
				var transformers = trough()
				var namespace = {}
				var freezeIndex = -1
				var frozen

				// Data management.
				processor.data = data

				// Lock.
				processor.freeze = freeze

				// Plugins.
				processor.attachers = attachers
				processor.use = use

				// API.
				processor.parse = parse
				processor.stringify = stringify
				processor.run = run
				processor.runSync = runSync
				processor.process = process
				processor.processSync = processSync

				// Expose.
				return processor

				// Create a new processor based on the processor in the current scope.
				function processor() {
					var destination = unified()
					var index = -1

					while (++index < attachers.length) {
						destination.use.apply(null, attachers[index])
					}

					destination.data(extend(true, {}, namespace))

					return destination
				}

				// Freeze: used to signal a processor that has finished configuration.
				//
				// For example, take unified itself: its frozen.
				// Plugins should not be added to it.
				// Rather, it should be extended, by invoking it, before modifying it.
				//
				// In essence, always invoke this when exporting a processor.
				function freeze() {
					var values
					var transformer

					if (frozen) {
						return processor
					}

					while (++freezeIndex < attachers.length) {
						values = attachers[freezeIndex]

						if (values[1] === false) {
							continue
						}

						if (values[1] === true) {
							values[1] = undefined
						}

						transformer = values[0].apply(processor, values.slice(1))

						if (typeof transformer === 'function') {
							transformers.use(transformer)
						}
					}

					frozen = true
					freezeIndex = Infinity

					return processor
				}

				// Data management.
				// Getter / setter for processor-specific informtion.
				function data(key, value) {
					if (typeof key === 'string') {
						// Set `key`.
						if (arguments.length === 2) {
							assertUnfrozen('data', frozen)
							namespace[key] = value
							return processor
						}

						// Get `key`.
						return (own.call(namespace, key) && namespace[key]) || null
					}

					// Set space.
					if (key) {
						assertUnfrozen('data', frozen)
						namespace = key
						return processor
					}

					// Get space.
					return namespace
				}

				// Plugin management.
				//
				// Pass it:
				// *   an attacher and options,
				// *   a preset,
				// *   a list of presets, attachers, and arguments (list of attachers and
				//     options).
				function use(value) {
					var settings

					assertUnfrozen('use', frozen)

					if (value === null || value === undefined) {
						// Empty.
					} else if (typeof value === 'function') {
						addPlugin.apply(null, arguments)
					} else if (typeof value === 'object') {
						if ('length' in value) {
							addList(value)
						} else {
							addPreset(value)
						}
					} else {
						throw new Error('Expected usable value, not `' + value + '`')
					}

					if (settings) {
						namespace.settings = extend(namespace.settings || {}, settings)
					}

					return processor

					function addPreset(result) {
						addList(result.plugins)

						if (result.settings) {
							settings = extend(settings || {}, result.settings)
						}
					}

					function add(value) {
						if (typeof value === 'function') {
							addPlugin(value)
						} else if (typeof value === 'object') {
							if ('length' in value) {
								addPlugin.apply(null, value)
							} else {
								addPreset(value)
							}
						} else {
							throw new Error('Expected usable value, not `' + value + '`')
						}
					}

					function addList(plugins) {
						var index = -1

						if (plugins === null || plugins === undefined) {
							// Empty.
						} else if (typeof plugins === 'object' && 'length' in plugins) {
							while (++index < plugins.length) {
								add(plugins[index])
							}
						} else {
							throw new Error(
								'Expected a list of plugins, not `' + plugins + '`',
							)
						}
					}

					function addPlugin(plugin, value) {
						var entry = find(plugin)

						if (entry) {
							if (plain(entry[1]) && plain(value)) {
								value = extend(true, entry[1], value)
							}

							entry[1] = value
						} else {
							attachers.push(slice.call(arguments))
						}
					}
				}

				function find(plugin) {
					var index = -1

					while (++index < attachers.length) {
						if (attachers[index][0] === plugin) {
							return attachers[index]
						}
					}
				}

				// Parse a file (in string or vfile representation) into a unist node using
				// the `Parser` on the processor.
				function parse(doc) {
					var file = vfile(doc)
					var Parser

					freeze()
					Parser = processor.Parser
					assertParser('parse', Parser)

					if (newable(Parser, 'parse')) {
						return new Parser(String(file), file).parse()
					}

					return Parser(String(file), file) // eslint-disable-line new-cap
				}

				// Run transforms on a unist node representation of a file (in string or
				// vfile representation), async.
				function run(node, file, cb) {
					assertNode(node)
					freeze()

					if (!cb && typeof file === 'function') {
						cb = file
						file = null
					}

					if (!cb) {
						return new Promise(executor)
					}

					executor(null, cb)

					function executor(resolve, reject) {
						transformers.run(node, vfile(file), done)

						function done(error, tree, file) {
							tree = tree || node
							if (error) {
								reject(error)
							} else if (resolve) {
								resolve(tree)
							} else {
								cb(null, tree, file)
							}
						}
					}
				}

				// Run transforms on a unist node representation of a file (in string or
				// vfile representation), sync.
				function runSync(node, file) {
					var result
					var complete

					run(node, file, done)

					assertDone('runSync', 'run', complete)

					return result

					function done(error, tree) {
						complete = true
						result = tree
						bail(error)
					}
				}

				// Stringify a unist node representation of a file (in string or vfile
				// representation) into a string using the `Compiler` on the processor.
				function stringify(node, doc) {
					var file = vfile(doc)
					var Compiler

					freeze()
					Compiler = processor.Compiler
					assertCompiler('stringify', Compiler)
					assertNode(node)

					if (newable(Compiler, 'compile')) {
						return new Compiler(node, file).compile()
					}

					return Compiler(node, file) // eslint-disable-line new-cap
				}

				// Parse a file (in string or vfile representation) into a unist node using
				// the `Parser` on the processor, then run transforms on that node, and
				// compile the resulting node using the `Compiler` on the processor, and
				// store that result on the vfile.
				function process(doc, cb) {
					freeze()
					assertParser('process', processor.Parser)
					assertCompiler('process', processor.Compiler)

					if (!cb) {
						return new Promise(executor)
					}

					executor(null, cb)

					function executor(resolve, reject) {
						var file = vfile(doc)

						pipeline.run(processor, { file: file }, done)

						function done(error) {
							if (error) {
								reject(error)
							} else if (resolve) {
								resolve(file)
							} else {
								cb(null, file)
							}
						}
					}
				}

				// Process the given document (in string or vfile representation), sync.
				function processSync(doc) {
					var file
					var complete

					freeze()
					assertParser('processSync', processor.Parser)
					assertCompiler('processSync', processor.Compiler)
					file = vfile(doc)

					process(file, done)

					assertDone('processSync', 'process', complete)

					return file

					function done(error) {
						complete = true
						bail(error)
					}
				}
			}

			// Check if `value` is a constructor.
			function newable(value, name) {
				return (
					typeof value === 'function' &&
					value.prototype &&
					// A function with keys in its prototype is probably a constructor.
					// Classes prototype methods are not enumerable, so we check if some value
					// exists in the prototype.
					(keys(value.prototype) || name in value.prototype)
				)
			}

			// Check if `value` is an object with keys.
			function keys(value) {
				var key
				for (key in value) {
					return true
				}

				return false
			}

			// Assert a parser is available.
			function assertParser(name, Parser) {
				if (typeof Parser !== 'function') {
					throw new Error('Cannot `' + name + '` without `Parser`')
				}
			}

			// Assert a compiler is available.
			function assertCompiler(name, Compiler) {
				if (typeof Compiler !== 'function') {
					throw new Error('Cannot `' + name + '` without `Compiler`')
				}
			}

			// Assert the processor is not frozen.
			function assertUnfrozen(name, frozen) {
				if (frozen) {
					throw new Error(
						'Cannot invoke `' +
							name +
							'` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.',
					)
				}
			}

			// Assert `node` is a unist node.
			function assertNode(node) {
				if (!node || typeof node.type !== 'string') {
					throw new Error('Expected node, got `' + node + '`')
				}
			}

			// Assert that `complete` is `true`.
			function assertDone(name, asyncName, complete) {
				if (!complete) {
					throw new Error(
						'`' + name + '` finished async. Use `' + asyncName + '` instead',
					)
				}
			}

			/***/
		},

		/***/ 11340: /***/ (module) => {
			'use strict'

			var own = {}.hasOwnProperty

			module.exports = stringify

			function stringify(value) {
				// Nothing.
				if (!value || typeof value !== 'object') {
					return ''
				}

				// Node.
				if (own.call(value, 'position') || own.call(value, 'type')) {
					return position(value.position)
				}

				// Position.
				if (own.call(value, 'start') || own.call(value, 'end')) {
					return position(value)
				}

				// Point.
				if (own.call(value, 'line') || own.call(value, 'column')) {
					return point(value)
				}

				// ?
				return ''
			}

			function point(point) {
				if (!point || typeof point !== 'object') {
					point = {}
				}

				return index(point.line) + ':' + index(point.column)
			}

			function position(pos) {
				if (!pos || typeof pos !== 'object') {
					pos = {}
				}

				return point(pos.start) + '-' + point(pos.end)
			}

			function index(value) {
				return value && typeof value === 'number' ? value : 1
			}

			/***/
		},

		/***/ 63594: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var stringify = __nccwpck_require__(11340)

			module.exports = VMessage

			// Inherit from `Error#`.
			function VMessagePrototype() {}
			VMessagePrototype.prototype = Error.prototype
			VMessage.prototype = new VMessagePrototype()

			// Message properties.
			var proto = VMessage.prototype

			proto.file = ''
			proto.name = ''
			proto.reason = ''
			proto.message = ''
			proto.stack = ''
			proto.fatal = null
			proto.column = null
			proto.line = null

			// Construct a new VMessage.
			//
			// Note: We cannot invoke `Error` on the created context, as that adds readonly
			// `line` and `column` attributes on Safari 9, thus throwing and failing the
			// data.
			function VMessage(reason, position, origin) {
				var parts
				var range
				var location

				if (typeof position === 'string') {
					origin = position
					position = null
				}

				parts = parseOrigin(origin)
				range = stringify(position) || '1:1'

				location = {
					start: { line: null, column: null },
					end: { line: null, column: null },
				}

				// Node.
				if (position && position.position) {
					position = position.position
				}

				if (position) {
					// Position.
					if (position.start) {
						location = position
						position = position.start
					} else {
						// Point.
						location.start = position
					}
				}

				if (reason.stack) {
					this.stack = reason.stack
					reason = reason.message
				}

				this.message = reason
				this.name = range
				this.reason = reason
				this.line = position ? position.line : null
				this.column = position ? position.column : null
				this.location = location
				this.source = parts[0]
				this.ruleId = parts[1]
			}

			function parseOrigin(origin) {
				var result = [null, null]
				var index

				if (typeof origin === 'string') {
					index = origin.indexOf(':')

					if (index === -1) {
						result[1] = origin
					} else {
						result[0] = origin.slice(0, index)
						result[1] = origin.slice(index + 1)
					}
				}

				return result
			}

			/***/
		},

		/***/ 61952: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			module.exports = __nccwpck_require__(13484)

			/***/
		},

		/***/ 51669: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var p = __nccwpck_require__(2715)
			var proc = __nccwpck_require__(43584)
			var buffer = __nccwpck_require__(79857)

			module.exports = VFile

			var own = {}.hasOwnProperty

			// Order of setting (least specific to most), we need this because otherwise
			// `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a
			// stem can be set.
			var order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname']

			VFile.prototype.toString = toString

			// Access full path (`~/index.min.js`).
			Object.defineProperty(VFile.prototype, 'path', {
				get: getPath,
				set: setPath,
			})

			// Access parent path (`~`).
			Object.defineProperty(VFile.prototype, 'dirname', {
				get: getDirname,
				set: setDirname,
			})

			// Access basename (`index.min.js`).
			Object.defineProperty(VFile.prototype, 'basename', {
				get: getBasename,
				set: setBasename,
			})

			// Access extname (`.js`).
			Object.defineProperty(VFile.prototype, 'extname', {
				get: getExtname,
				set: setExtname,
			})

			// Access stem (`index.min`).
			Object.defineProperty(VFile.prototype, 'stem', {
				get: getStem,
				set: setStem,
			})

			// Construct a new file.
			function VFile(options) {
				var prop
				var index

				if (!options) {
					options = {}
				} else if (typeof options === 'string' || buffer(options)) {
					options = { contents: options }
				} else if ('message' in options && 'messages' in options) {
					return options
				}

				if (!(this instanceof VFile)) {
					return new VFile(options)
				}

				this.data = {}
				this.messages = []
				this.history = []
				this.cwd = proc.cwd()

				// Set path related properties in the correct order.
				index = -1

				while (++index < order.length) {
					prop = order[index]

					if (own.call(options, prop)) {
						this[prop] = options[prop]
					}
				}

				// Set non-path related properties.
				for (prop in options) {
					if (order.indexOf(prop) < 0) {
						this[prop] = options[prop]
					}
				}
			}

			function getPath() {
				return this.history[this.history.length - 1]
			}

			function setPath(path) {
				assertNonEmpty(path, 'path')

				if (this.path !== path) {
					this.history.push(path)
				}
			}

			function getDirname() {
				return typeof this.path === 'string' ? p.dirname(this.path) : undefined
			}

			function setDirname(dirname) {
				assertPath(this.path, 'dirname')
				this.path = p.join(dirname || '', this.basename)
			}

			function getBasename() {
				return typeof this.path === 'string' ? p.basename(this.path) : undefined
			}

			function setBasename(basename) {
				assertNonEmpty(basename, 'basename')
				assertPart(basename, 'basename')
				this.path = p.join(this.dirname || '', basename)
			}

			function getExtname() {
				return typeof this.path === 'string' ? p.extname(this.path) : undefined
			}

			function setExtname(extname) {
				assertPart(extname, 'extname')
				assertPath(this.path, 'extname')

				if (extname) {
					if (extname.charCodeAt(0) !== 46 /* `.` */) {
						throw new Error('`extname` must start with `.`')
					}

					if (extname.indexOf('.', 1) > -1) {
						throw new Error('`extname` cannot contain multiple dots')
					}
				}

				this.path = p.join(this.dirname, this.stem + (extname || ''))
			}

			function getStem() {
				return typeof this.path === 'string'
					? p.basename(this.path, this.extname)
					: undefined
			}

			function setStem(stem) {
				assertNonEmpty(stem, 'stem')
				assertPart(stem, 'stem')
				this.path = p.join(this.dirname || '', stem + (this.extname || ''))
			}

			// Get the value of the file.
			function toString(encoding) {
				return (this.contents || '').toString(encoding)
			}

			// Assert that `part` is not a path (i.e., does not contain `p.sep`).
			function assertPart(part, name) {
				if (part && part.indexOf(p.sep) > -1) {
					throw new Error(
						'`' + name + '` cannot be a path: did not expect `' + p.sep + '`',
					)
				}
			}

			// Assert that `part` is not empty.
			function assertNonEmpty(part, name) {
				if (!part) {
					throw new Error('`' + name + '` cannot be empty')
				}
			}

			// Assert `path` exists.
			function assertPath(path, name) {
				if (!path) {
					throw new Error(
						'Setting `' + name + '` requires `path` to be set too',
					)
				}
			}

			/***/
		},

		/***/ 13484: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var VMessage = __nccwpck_require__(63594)
			var VFile = __nccwpck_require__(51669)

			module.exports = VFile

			VFile.prototype.message = message
			VFile.prototype.info = info
			VFile.prototype.fail = fail

			// Create a message with `reason` at `position`.
			// When an error is passed in as `reason`, copies the stack.
			function message(reason, position, origin) {
				var message = new VMessage(reason, position, origin)

				if (this.path) {
					message.name = this.path + ':' + message.name
					message.file = this.path
				}

				message.fatal = false

				this.messages.push(message)

				return message
			}

			// Fail: creates a vmessage, associates it with the file, and throws it.
			function fail() {
				var message = this.message.apply(this, arguments)

				message.fatal = true

				throw message
			}

			// Info: creates a vmessage, associates it with the file, and marks the fatality
			// as null.
			function info() {
				var message = this.message.apply(this, arguments)

				message.fatal = null

				return message
			}

			/***/
		},

		/***/ 2715: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			module.exports = __nccwpck_require__(16928)

			/***/
		},

		/***/ 43584: /***/ (module) => {
			'use strict'

			module.exports = process

			/***/
		},

		/***/ 40471: /***/ (module) => {
			'use strict'
			/*!
			 * repeat-string <https://github.com/jonschlinkert/repeat-string>
			 *
			 * Copyright (c) 2014-2015, Jon Schlinkert.
			 * Licensed under the MIT License.
			 */

			/**
			 * Results cache
			 */

			var res = ''
			var cache

			/**
			 * Expose `repeat`
			 */

			module.exports = repeat

			/**
			 * Repeat the given `string` the specified `number`
			 * of times.
			 *
			 * **Example:**
			 *
			 * ```js
			 * var repeat = require('repeat-string');
			 * repeat('A', 5);
			 * //=> AAAAA
			 * ```
			 *
			 * @param {String} `string` The string to repeat
			 * @param {Number} `number` The number of times to repeat the string
			 * @return {String} Repeated string
			 * @api public
			 */

			function repeat(str, num) {
				if (typeof str !== 'string') {
					throw new TypeError('expected a string')
				}

				// cover common, quick use cases
				if (num === 1) return str
				if (num === 2) return str + str

				var max = str.length * num
				if (cache !== str || typeof cache === 'undefined') {
					cache = str
					res = ''
				} else if (res.length >= max) {
					return res.substr(0, max)
				}

				while (max > res.length && num > 1) {
					if (num & 1) {
						res += str
					}

					num >>= 1
					str += str
				}

				res += str
				res = res.substr(0, max)
				return res
			}

			/***/
		},

		/***/ 92312: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var async = __nccwpck_require__(56912)
			async.core = __nccwpck_require__(12333)
			async.isCore = __nccwpck_require__(54040)
			async.sync = __nccwpck_require__(70225)

			module.exports = async

			/***/
		},

		/***/ 56912: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var fs = __nccwpck_require__(79896)
			var getHomedir = __nccwpck_require__(22282)
			var path = __nccwpck_require__(16928)
			var caller = __nccwpck_require__(87481)
			var nodeModulesPaths = __nccwpck_require__(9411)
			var normalizeOptions = __nccwpck_require__(29496)
			var isCore = __nccwpck_require__(65223)

			var realpathFS =
				process.platform !== 'win32' &&
				fs.realpath &&
				typeof fs.realpath.native === 'function'
					? fs.realpath.native
					: fs.realpath

			var homedir = getHomedir()
			var defaultPaths = function () {
				return [
					path.join(homedir, '.node_modules'),
					path.join(homedir, '.node_libraries'),
				]
			}

			var defaultIsFile = function isFile(file, cb) {
				fs.stat(file, function (err, stat) {
					if (!err) {
						return cb(null, stat.isFile() || stat.isFIFO())
					}
					if (err.code === 'ENOENT' || err.code === 'ENOTDIR')
						return cb(null, false)
					return cb(err)
				})
			}

			var defaultIsDir = function isDirectory(dir, cb) {
				fs.stat(dir, function (err, stat) {
					if (!err) {
						return cb(null, stat.isDirectory())
					}
					if (err.code === 'ENOENT' || err.code === 'ENOTDIR')
						return cb(null, false)
					return cb(err)
				})
			}

			var defaultRealpath = function realpath(x, cb) {
				realpathFS(x, function (realpathErr, realPath) {
					if (realpathErr && realpathErr.code !== 'ENOENT') cb(realpathErr)
					else cb(null, realpathErr ? x : realPath)
				})
			}

			var maybeRealpath = function maybeRealpath(realpath, x, opts, cb) {
				if (opts && opts.preserveSymlinks === false) {
					realpath(x, cb)
				} else {
					cb(null, x)
				}
			}

			var defaultReadPackage = function defaultReadPackage(
				readFile,
				pkgfile,
				cb,
			) {
				readFile(pkgfile, function (readFileErr, body) {
					if (readFileErr) cb(readFileErr)
					else {
						try {
							var pkg = JSON.parse(body)
							cb(null, pkg)
						} catch (jsonErr) {
							cb(null)
						}
					}
				})
			}

			var getPackageCandidates = function getPackageCandidates(x, start, opts) {
				var dirs = nodeModulesPaths(start, opts, x)
				for (var i = 0; i < dirs.length; i++) {
					dirs[i] = path.join(dirs[i], x)
				}
				return dirs
			}

			module.exports = function resolve(x, options, callback) {
				var cb = callback
				var opts = options
				if (typeof options === 'function') {
					cb = opts
					opts = {}
				}
				if (typeof x !== 'string') {
					var err = new TypeError('Path must be a string.')
					return process.nextTick(function () {
						cb(err)
					})
				}

				opts = normalizeOptions(x, opts)

				var isFile = opts.isFile || defaultIsFile
				var isDirectory = opts.isDirectory || defaultIsDir
				var readFile = opts.readFile || fs.readFile
				var realpath = opts.realpath || defaultRealpath
				var readPackage = opts.readPackage || defaultReadPackage
				if (opts.readFile && opts.readPackage) {
					var conflictErr = new TypeError(
						'`readFile` and `readPackage` are mutually exclusive.',
					)
					return process.nextTick(function () {
						cb(conflictErr)
					})
				}
				var packageIterator = opts.packageIterator

				var extensions = opts.extensions || ['.js']
				var includeCoreModules = opts.includeCoreModules !== false
				var basedir = opts.basedir || path.dirname(caller())
				var parent = opts.filename || basedir

				opts.paths = opts.paths || defaultPaths()

				// ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
				var absoluteStart = path.resolve(basedir)

				maybeRealpath(realpath, absoluteStart, opts, function (err, realStart) {
					if (err) cb(err)
					else init(realStart)
				})

				var res
				function init(basedir) {
					if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
						res = path.resolve(basedir, x)
						if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/'
						if (/\/$/.test(x) && res === basedir) {
							loadAsDirectory(res, opts.package, onfile)
						} else loadAsFile(res, opts.package, onfile)
					} else if (includeCoreModules && isCore(x)) {
						return cb(null, x)
					} else
						loadNodeModules(x, basedir, function (err, n, pkg) {
							if (err) cb(err)
							else if (n) {
								return maybeRealpath(realpath, n, opts, function (err, realN) {
									if (err) {
										cb(err)
									} else {
										cb(null, realN, pkg)
									}
								})
							} else {
								var moduleError = new Error(
									"Cannot find module '" + x + "' from '" + parent + "'",
								)
								moduleError.code = 'MODULE_NOT_FOUND'
								cb(moduleError)
							}
						})
				}

				function onfile(err, m, pkg) {
					if (err) cb(err)
					else if (m) cb(null, m, pkg)
					else
						loadAsDirectory(res, function (err, d, pkg) {
							if (err) cb(err)
							else if (d) {
								maybeRealpath(realpath, d, opts, function (err, realD) {
									if (err) {
										cb(err)
									} else {
										cb(null, realD, pkg)
									}
								})
							} else {
								var moduleError = new Error(
									"Cannot find module '" + x + "' from '" + parent + "'",
								)
								moduleError.code = 'MODULE_NOT_FOUND'
								cb(moduleError)
							}
						})
				}

				function loadAsFile(x, thePackage, callback) {
					var loadAsFilePackage = thePackage
					var cb = callback
					if (typeof loadAsFilePackage === 'function') {
						cb = loadAsFilePackage
						loadAsFilePackage = undefined
					}

					var exts = [''].concat(extensions)
					load(exts, x, loadAsFilePackage)

					function load(exts, x, loadPackage) {
						if (exts.length === 0) return cb(null, undefined, loadPackage)
						var file = x + exts[0]

						var pkg = loadPackage
						if (pkg) onpkg(null, pkg)
						else loadpkg(path.dirname(file), onpkg)

						function onpkg(err, pkg_, dir) {
							pkg = pkg_
							if (err) return cb(err)
							if (dir && pkg && opts.pathFilter) {
								var rfile = path.relative(dir, file)
								var rel = rfile.slice(0, rfile.length - exts[0].length)
								var r = opts.pathFilter(pkg, x, rel)
								if (r)
									return load(
										[''].concat(extensions.slice()),
										path.resolve(dir, r),
										pkg,
									)
							}
							isFile(file, onex)
						}
						function onex(err, ex) {
							if (err) return cb(err)
							if (ex) return cb(null, file, pkg)
							load(exts.slice(1), x, pkg)
						}
					}
				}

				function loadpkg(dir, cb) {
					if (dir === '' || dir === '/') return cb(null)
					if (process.platform === 'win32' && /^\w:[/\\]*$/.test(dir)) {
						return cb(null)
					}
					if (/[/\\]node_modules[/\\]*$/.test(dir)) return cb(null)

					maybeRealpath(realpath, dir, opts, function (unwrapErr, pkgdir) {
						if (unwrapErr) return loadpkg(path.dirname(dir), cb)
						var pkgfile = path.join(pkgdir, 'package.json')
						isFile(pkgfile, function (err, ex) {
							// on err, ex is false
							if (!ex) return loadpkg(path.dirname(dir), cb)

							readPackage(readFile, pkgfile, function (err, pkgParam) {
								if (err) cb(err)

								var pkg = pkgParam

								if (pkg && opts.packageFilter) {
									pkg = opts.packageFilter(pkg, pkgfile)
								}
								cb(null, pkg, dir)
							})
						})
					})
				}

				function loadAsDirectory(x, loadAsDirectoryPackage, callback) {
					var cb = callback
					var fpkg = loadAsDirectoryPackage
					if (typeof fpkg === 'function') {
						cb = fpkg
						fpkg = opts.package
					}

					maybeRealpath(realpath, x, opts, function (unwrapErr, pkgdir) {
						if (unwrapErr) return cb(unwrapErr)
						var pkgfile = path.join(pkgdir, 'package.json')
						isFile(pkgfile, function (err, ex) {
							if (err) return cb(err)
							if (!ex) return loadAsFile(path.join(x, 'index'), fpkg, cb)

							readPackage(readFile, pkgfile, function (err, pkgParam) {
								if (err) return cb(err)

								var pkg = pkgParam

								if (pkg && opts.packageFilter) {
									pkg = opts.packageFilter(pkg, pkgfile)
								}

								if (pkg && pkg.main) {
									if (typeof pkg.main !== 'string') {
										var mainError = new TypeError(
											'package ' + pkg.name + ' `main` must be a string',
										)
										mainError.code = 'INVALID_PACKAGE_MAIN'
										return cb(mainError)
									}
									if (pkg.main === '.' || pkg.main === './') {
										pkg.main = 'index'
									}
									loadAsFile(
										path.resolve(x, pkg.main),
										pkg,
										function (err, m, pkg) {
											if (err) return cb(err)
											if (m) return cb(null, m, pkg)
											if (!pkg)
												return loadAsFile(path.join(x, 'index'), pkg, cb)

											var dir = path.resolve(x, pkg.main)
											loadAsDirectory(dir, pkg, function (err, n, pkg) {
												if (err) return cb(err)
												if (n) return cb(null, n, pkg)
												loadAsFile(path.join(x, 'index'), pkg, cb)
											})
										},
									)
									return
								}

								loadAsFile(path.join(x, '/index'), pkg, cb)
							})
						})
					})
				}

				function processDirs(cb, dirs) {
					if (dirs.length === 0) return cb(null, undefined)
					var dir = dirs[0]

					isDirectory(path.dirname(dir), isdir)

					function isdir(err, isdir) {
						if (err) return cb(err)
						if (!isdir) return processDirs(cb, dirs.slice(1))
						loadAsFile(dir, opts.package, onfile)
					}

					function onfile(err, m, pkg) {
						if (err) return cb(err)
						if (m) return cb(null, m, pkg)
						loadAsDirectory(dir, opts.package, ondir)
					}

					function ondir(err, n, pkg) {
						if (err) return cb(err)
						if (n) return cb(null, n, pkg)
						processDirs(cb, dirs.slice(1))
					}
				}
				function loadNodeModules(x, start, cb) {
					var thunk = function () {
						return getPackageCandidates(x, start, opts)
					}
					processDirs(
						cb,
						packageIterator ? packageIterator(x, start, thunk, opts) : thunk(),
					)
				}
			}

			/***/
		},

		/***/ 87481: /***/ (module) => {
			module.exports = function () {
				// see https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
				var origPrepareStackTrace = Error.prepareStackTrace
				Error.prepareStackTrace = function (_, stack) {
					return stack
				}
				var stack = new Error().stack
				Error.prepareStackTrace = origPrepareStackTrace
				return stack[2].getFileName()
			}

			/***/
		},

		/***/ 12333: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var isCoreModule = __nccwpck_require__(65223)
			var data = __nccwpck_require__(62035)

			var core = {}
			for (var mod in data) {
				// eslint-disable-line no-restricted-syntax
				if (Object.prototype.hasOwnProperty.call(data, mod)) {
					core[mod] = isCoreModule(mod)
				}
			}
			module.exports = core

			/***/
		},

		/***/ 22282: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var os = __nccwpck_require__(70857)

			// adapted from https://github.com/sindresorhus/os-homedir/blob/11e089f4754db38bb535e5a8416320c4446e8cfd/index.js

			module.exports =
				os.homedir ||
				function homedir() {
					var home = process.env.HOME
					var user =
						process.env.LOGNAME ||
						process.env.USER ||
						process.env.LNAME ||
						process.env.USERNAME

					if (process.platform === 'win32') {
						return (
							process.env.USERPROFILE ||
							process.env.HOMEDRIVE + process.env.HOMEPATH ||
							home ||
							null
						)
					}

					if (process.platform === 'darwin') {
						return home || (user ? '/Users/' + user : null)
					}

					if (process.platform === 'linux') {
						return (
							home ||
							(process.getuid() === 0 ? '/root' : user ? '/home/' + user : null)
						) // eslint-disable-line no-extra-parens
					}

					return home || null
				}

			/***/
		},

		/***/ 54040: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var isCoreModule = __nccwpck_require__(65223)

			module.exports = function isCore(x) {
				return isCoreModule(x)
			}

			/***/
		},

		/***/ 9411: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var path = __nccwpck_require__(16928)
			var parse = path.parse || __nccwpck_require__(33269) // eslint-disable-line global-require

			var getNodeModulesDirs = function getNodeModulesDirs(
				absoluteStart,
				modules,
			) {
				var prefix = '/'
				if (/^([A-Za-z]:)/.test(absoluteStart)) {
					prefix = ''
				} else if (/^\\\\/.test(absoluteStart)) {
					prefix = '\\\\'
				}

				var paths = [absoluteStart]
				var parsed = parse(absoluteStart)
				while (parsed.dir !== paths[paths.length - 1]) {
					paths.push(parsed.dir)
					parsed = parse(parsed.dir)
				}

				return paths.reduce(function (dirs, aPath) {
					return dirs.concat(
						modules.map(function (moduleDir) {
							return path.resolve(prefix, aPath, moduleDir)
						}),
					)
				}, [])
			}

			module.exports = function nodeModulesPaths(start, opts, request) {
				var modules =
					opts && opts.moduleDirectory
						? [].concat(opts.moduleDirectory)
						: ['node_modules']

				if (opts && typeof opts.paths === 'function') {
					return opts.paths(
						request,
						start,
						function () {
							return getNodeModulesDirs(start, modules)
						},
						opts,
					)
				}

				var dirs = getNodeModulesDirs(start, modules)
				return opts && opts.paths ? dirs.concat(opts.paths) : dirs
			}

			/***/
		},

		/***/ 29496: /***/ (module) => {
			module.exports = function (x, opts) {
				/**
				 * This file is purposefully a passthrough. It's expected that third-party
				 * environments will override it at runtime in order to inject special logic
				 * into `resolve` (by manipulating the options). One such example is the PnP
				 * code path in Yarn.
				 */

				return opts || {}
			}

			/***/
		},

		/***/ 70225: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var isCore = __nccwpck_require__(65223)
			var fs = __nccwpck_require__(79896)
			var path = __nccwpck_require__(16928)
			var getHomedir = __nccwpck_require__(22282)
			var caller = __nccwpck_require__(87481)
			var nodeModulesPaths = __nccwpck_require__(9411)
			var normalizeOptions = __nccwpck_require__(29496)

			var realpathFS =
				process.platform !== 'win32' &&
				fs.realpathSync &&
				typeof fs.realpathSync.native === 'function'
					? fs.realpathSync.native
					: fs.realpathSync

			var homedir = getHomedir()
			var defaultPaths = function () {
				return [
					path.join(homedir, '.node_modules'),
					path.join(homedir, '.node_libraries'),
				]
			}

			var defaultIsFile = function isFile(file) {
				try {
					var stat = fs.statSync(file, { throwIfNoEntry: false })
				} catch (e) {
					if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false
					throw e
				}
				return !!stat && (stat.isFile() || stat.isFIFO())
			}

			var defaultIsDir = function isDirectory(dir) {
				try {
					var stat = fs.statSync(dir, { throwIfNoEntry: false })
				} catch (e) {
					if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false
					throw e
				}
				return !!stat && stat.isDirectory()
			}

			var defaultRealpathSync = function realpathSync(x) {
				try {
					return realpathFS(x)
				} catch (realpathErr) {
					if (realpathErr.code !== 'ENOENT') {
						throw realpathErr
					}
				}
				return x
			}

			var maybeRealpathSync = function maybeRealpathSync(
				realpathSync,
				x,
				opts,
			) {
				if (opts && opts.preserveSymlinks === false) {
					return realpathSync(x)
				}
				return x
			}

			var defaultReadPackageSync = function defaultReadPackageSync(
				readFileSync,
				pkgfile,
			) {
				var body = readFileSync(pkgfile)
				try {
					var pkg = JSON.parse(body)
					return pkg
				} catch (jsonErr) {}
			}

			var getPackageCandidates = function getPackageCandidates(x, start, opts) {
				var dirs = nodeModulesPaths(start, opts, x)
				for (var i = 0; i < dirs.length; i++) {
					dirs[i] = path.join(dirs[i], x)
				}
				return dirs
			}

			module.exports = function resolveSync(x, options) {
				if (typeof x !== 'string') {
					throw new TypeError('Path must be a string.')
				}
				var opts = normalizeOptions(x, options)

				var isFile = opts.isFile || defaultIsFile
				var readFileSync = opts.readFileSync || fs.readFileSync
				var isDirectory = opts.isDirectory || defaultIsDir
				var realpathSync = opts.realpathSync || defaultRealpathSync
				var readPackageSync = opts.readPackageSync || defaultReadPackageSync
				if (opts.readFileSync && opts.readPackageSync) {
					throw new TypeError(
						'`readFileSync` and `readPackageSync` are mutually exclusive.',
					)
				}
				var packageIterator = opts.packageIterator

				var extensions = opts.extensions || ['.js']
				var includeCoreModules = opts.includeCoreModules !== false
				var basedir = opts.basedir || path.dirname(caller())
				var parent = opts.filename || basedir

				opts.paths = opts.paths || defaultPaths()

				// ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
				var absoluteStart = maybeRealpathSync(
					realpathSync,
					path.resolve(basedir),
					opts,
				)

				if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
					var res = path.resolve(absoluteStart, x)
					if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/'
					var m = loadAsFileSync(res) || loadAsDirectorySync(res)
					if (m) return maybeRealpathSync(realpathSync, m, opts)
				} else if (includeCoreModules && isCore(x)) {
					return x
				} else {
					var n = loadNodeModulesSync(x, absoluteStart)
					if (n) return maybeRealpathSync(realpathSync, n, opts)
				}

				var err = new Error(
					"Cannot find module '" + x + "' from '" + parent + "'",
				)
				err.code = 'MODULE_NOT_FOUND'
				throw err

				function loadAsFileSync(x) {
					var pkg = loadpkg(path.dirname(x))

					if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
						var rfile = path.relative(pkg.dir, x)
						var r = opts.pathFilter(pkg.pkg, x, rfile)
						if (r) {
							x = path.resolve(pkg.dir, r) // eslint-disable-line no-param-reassign
						}
					}

					if (isFile(x)) {
						return x
					}

					for (var i = 0; i < extensions.length; i++) {
						var file = x + extensions[i]
						if (isFile(file)) {
							return file
						}
					}
				}

				function loadpkg(dir) {
					if (dir === '' || dir === '/') return
					if (process.platform === 'win32' && /^\w:[/\\]*$/.test(dir)) {
						return
					}
					if (/[/\\]node_modules[/\\]*$/.test(dir)) return

					var pkgfile = path.join(
						maybeRealpathSync(realpathSync, dir, opts),
						'package.json',
					)

					if (!isFile(pkgfile)) {
						return loadpkg(path.dirname(dir))
					}

					var pkg = readPackageSync(readFileSync, pkgfile)

					if (pkg && opts.packageFilter) {
						// v2 will pass pkgfile
						pkg = opts.packageFilter(pkg, /*pkgfile,*/ dir) // eslint-disable-line spaced-comment
					}

					return { pkg: pkg, dir: dir }
				}

				function loadAsDirectorySync(x) {
					var pkgfile = path.join(
						maybeRealpathSync(realpathSync, x, opts),
						'/package.json',
					)
					if (isFile(pkgfile)) {
						try {
							var pkg = readPackageSync(readFileSync, pkgfile)
						} catch (e) {}

						if (pkg && opts.packageFilter) {
							// v2 will pass pkgfile
							pkg = opts.packageFilter(pkg, /*pkgfile,*/ x) // eslint-disable-line spaced-comment
						}

						if (pkg && pkg.main) {
							if (typeof pkg.main !== 'string') {
								var mainError = new TypeError(
									'package ' + pkg.name + ' `main` must be a string',
								)
								mainError.code = 'INVALID_PACKAGE_MAIN'
								throw mainError
							}
							if (pkg.main === '.' || pkg.main === './') {
								pkg.main = 'index'
							}
							try {
								var m = loadAsFileSync(path.resolve(x, pkg.main))
								if (m) return m
								var n = loadAsDirectorySync(path.resolve(x, pkg.main))
								if (n) return n
							} catch (e) {}
						}
					}

					return loadAsFileSync(path.join(x, '/index'))
				}

				function loadNodeModulesSync(x, start) {
					var thunk = function () {
						return getPackageCandidates(x, start, opts)
					}
					var dirs = packageIterator
						? packageIterator(x, start, thunk, opts)
						: thunk()

					for (var i = 0; i < dirs.length; i++) {
						var dir = dirs[i]
						if (isDirectory(path.dirname(dir))) {
							var m = loadAsFileSync(dir)
							if (m) return m
							var n = loadAsDirectorySync(dir)
							if (n) return n
						}
					}
				}
			}

			/***/
		},

		/***/ 89495: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var typeOf = __nccwpck_require__(5140)
			var extend = __nccwpck_require__(48905)

			/**
			 * Parse sections in `input` with the given `options`.
			 *
			 * ```js
			 * var sections = require('{%= name %}');
			 * var result = sections(input, options);
			 * // { content: 'Content before sections', sections: [] }
			 * ```
			 * @param {String|Buffer|Object} `input` If input is an object, it's `content` property must be a string or buffer.
			 * @param {Object} options
			 * @return {Object} Returns an object with a `content` string and an array of `sections` objects.
			 * @api public
			 */

			module.exports = function (input, options) {
				if (typeof options === 'function') {
					options = { parse: options }
				}

				var file = toObject(input)
				var defaults = { section_delimiter: '---', parse: identity }
				var opts = extend({}, defaults, options)
				var delim = opts.section_delimiter
				var lines = file.content.split(/\r?\n/)
				var sections = null
				var section = createSection()
				var content = []
				var stack = []

				function initSections(val) {
					file.content = val
					sections = []
					content = []
				}

				function closeSection(val) {
					if (stack.length) {
						section.key = getKey(stack[0], delim)
						section.content = val
						opts.parse(section, sections)
						sections.push(section)
						section = createSection()
						content = []
						stack = []
					}
				}

				for (var i = 0; i < lines.length; i++) {
					var line = lines[i]
					var len = stack.length
					var ln = line.trim()

					if (isDelimiter(ln, delim)) {
						if (ln.length === 3 && i !== 0) {
							if (len === 0 || len === 2) {
								content.push(line)
								continue
							}
							stack.push(ln)
							section.data = content.join('\n')
							content = []
							continue
						}

						if (sections === null) {
							initSections(content.join('\n'))
						}

						if (len === 2) {
							closeSection(content.join('\n'))
						}

						stack.push(ln)
						continue
					}

					content.push(line)
				}

				if (sections === null) {
					initSections(content.join('\n'))
				} else {
					closeSection(content.join('\n'))
				}

				file.sections = sections
				return file
			}

			function isDelimiter(line, delim) {
				if (line.slice(0, delim.length) !== delim) {
					return false
				}
				if (line.charAt(delim.length + 1) === delim.slice(-1)) {
					return false
				}
				return true
			}

			function toObject(input) {
				if (typeOf(input) !== 'object') {
					input = { content: input }
				}

				if (typeof input.content !== 'string' && !isBuffer(input.content)) {
					throw new TypeError('expected a buffer or string')
				}

				input.content = input.content.toString()
				input.sections = []
				return input
			}

			function getKey(val, delim) {
				return val ? val.slice(delim.length).trim() : ''
			}

			function createSection() {
				return { key: '', data: '', content: '' }
			}

			function identity(val) {
				return val
			}

			function isBuffer(val) {
				if (
					val &&
					val.constructor &&
					typeof val.constructor.isBuffer === 'function'
				) {
					return val.constructor.isBuffer(val)
				}
				return false
			}

			/***/
		},

		/***/ 39318: /***/ (module, exports) => {
			exports = module.exports = SemVer

			var debug
			/* istanbul ignore next */
			if (
				typeof process === 'object' &&
				process.env &&
				process.env.NODE_DEBUG &&
				/\bsemver\b/i.test(process.env.NODE_DEBUG)
			) {
				debug = function () {
					var args = Array.prototype.slice.call(arguments, 0)
					args.unshift('SEMVER')
					console.log.apply(console, args)
				}
			} else {
				debug = function () {}
			}

			// Note: this is the semver.org version of the spec that it implements
			// Not necessarily the package version of this code.
			exports.SEMVER_SPEC_VERSION = '2.0.0'

			var MAX_LENGTH = 256
			var MAX_SAFE_INTEGER =
				Number.MAX_SAFE_INTEGER || /* istanbul ignore next */ 9007199254740991

			// Max safe segment length for coercion.
			var MAX_SAFE_COMPONENT_LENGTH = 16

			var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6

			// The actual regexps go on exports.re
			var re = (exports.re = [])
			var safeRe = (exports.safeRe = [])
			var src = (exports.src = [])
			var R = 0

			var LETTERDASHNUMBER = '[a-zA-Z0-9-]'

			// Replace some greedy regex tokens to prevent regex dos issues. These regex are
			// used internally via the safeRe object since all inputs in this library get
			// normalized first to trim and collapse all extra whitespace. The original
			// regexes are exported for userland consumption and lower level usage. A
			// future breaking change could export the safer regex only with a note that
			// all input should have extra whitespace removed.
			var safeRegexReplacements = [
				['\\s', 1],
				['\\d', MAX_LENGTH],
				[LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
			]

			function makeSafeRe(value) {
				for (var i = 0; i < safeRegexReplacements.length; i++) {
					var token = safeRegexReplacements[i][0]
					var max = safeRegexReplacements[i][1]
					value = value
						.split(token + '*')
						.join(token + '{0,' + max + '}')
						.split(token + '+')
						.join(token + '{1,' + max + '}')
				}
				return value
			}

			// The following Regular Expressions can be used for tokenizing,
			// validating, and parsing SemVer version strings.

			// ## Numeric Identifier
			// A single `0`, or a non-zero digit followed by zero or more digits.

			var NUMERICIDENTIFIER = R++
			src[NUMERICIDENTIFIER] = '0|[1-9]\\d*'
			var NUMERICIDENTIFIERLOOSE = R++
			src[NUMERICIDENTIFIERLOOSE] = '\\d+'

			// ## Non-numeric Identifier
			// Zero or more digits, followed by a letter or hyphen, and then zero or
			// more letters, digits, or hyphens.

			var NONNUMERICIDENTIFIER = R++
			src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-]' + LETTERDASHNUMBER + '*'

			// ## Main Version
			// Three dot-separated numeric identifiers.

			var MAINVERSION = R++
			src[MAINVERSION] =
				'(' +
				src[NUMERICIDENTIFIER] +
				')\\.' +
				'(' +
				src[NUMERICIDENTIFIER] +
				')\\.' +
				'(' +
				src[NUMERICIDENTIFIER] +
				')'

			var MAINVERSIONLOOSE = R++
			src[MAINVERSIONLOOSE] =
				'(' +
				src[NUMERICIDENTIFIERLOOSE] +
				')\\.' +
				'(' +
				src[NUMERICIDENTIFIERLOOSE] +
				')\\.' +
				'(' +
				src[NUMERICIDENTIFIERLOOSE] +
				')'

			// ## Pre-release Version Identifier
			// A numeric identifier, or a non-numeric identifier.

			var PRERELEASEIDENTIFIER = R++
			src[PRERELEASEIDENTIFIER] =
				'(?:' + src[NUMERICIDENTIFIER] + '|' + src[NONNUMERICIDENTIFIER] + ')'

			var PRERELEASEIDENTIFIERLOOSE = R++
			src[PRERELEASEIDENTIFIERLOOSE] =
				'(?:' +
				src[NUMERICIDENTIFIERLOOSE] +
				'|' +
				src[NONNUMERICIDENTIFIER] +
				')'

			// ## Pre-release Version
			// Hyphen, followed by one or more dot-separated pre-release version
			// identifiers.

			var PRERELEASE = R++
			src[PRERELEASE] =
				'(?:-(' +
				src[PRERELEASEIDENTIFIER] +
				'(?:\\.' +
				src[PRERELEASEIDENTIFIER] +
				')*))'

			var PRERELEASELOOSE = R++
			src[PRERELEASELOOSE] =
				'(?:-?(' +
				src[PRERELEASEIDENTIFIERLOOSE] +
				'(?:\\.' +
				src[PRERELEASEIDENTIFIERLOOSE] +
				')*))'

			// ## Build Metadata Identifier
			// Any combination of digits, letters, or hyphens.

			var BUILDIDENTIFIER = R++
			src[BUILDIDENTIFIER] = LETTERDASHNUMBER + '+'

			// ## Build Metadata
			// Plus sign, followed by one or more period-separated build metadata
			// identifiers.

			var BUILD = R++
			src[BUILD] =
				'(?:\\+(' +
				src[BUILDIDENTIFIER] +
				'(?:\\.' +
				src[BUILDIDENTIFIER] +
				')*))'

			// ## Full Version String
			// A main version, followed optionally by a pre-release version and
			// build metadata.

			// Note that the only major, minor, patch, and pre-release sections of
			// the version string are capturing groups.  The build metadata is not a
			// capturing group, because it should not ever be used in version
			// comparison.

			var FULL = R++
			var FULLPLAIN =
				'v?' + src[MAINVERSION] + src[PRERELEASE] + '?' + src[BUILD] + '?'

			src[FULL] = '^' + FULLPLAIN + '$'

			// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
			// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
			// common in the npm registry.
			var LOOSEPLAIN =
				'[v=\\s]*' +
				src[MAINVERSIONLOOSE] +
				src[PRERELEASELOOSE] +
				'?' +
				src[BUILD] +
				'?'

			var LOOSE = R++
			src[LOOSE] = '^' + LOOSEPLAIN + '$'

			var GTLT = R++
			src[GTLT] = '((?:<|>)?=?)'

			// Something like "2.*" or "1.2.x".
			// Note that "x.x" is a valid xRange identifer, meaning "any version"
			// Only the first item is strictly required.
			var XRANGEIDENTIFIERLOOSE = R++
			src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
			var XRANGEIDENTIFIER = R++
			src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*'

			var XRANGEPLAIN = R++
			src[XRANGEPLAIN] =
				'[v=\\s]*(' +
				src[XRANGEIDENTIFIER] +
				')' +
				'(?:\\.(' +
				src[XRANGEIDENTIFIER] +
				')' +
				'(?:\\.(' +
				src[XRANGEIDENTIFIER] +
				')' +
				'(?:' +
				src[PRERELEASE] +
				')?' +
				src[BUILD] +
				'?' +
				')?)?'

			var XRANGEPLAINLOOSE = R++
			src[XRANGEPLAINLOOSE] =
				'[v=\\s]*(' +
				src[XRANGEIDENTIFIERLOOSE] +
				')' +
				'(?:\\.(' +
				src[XRANGEIDENTIFIERLOOSE] +
				')' +
				'(?:\\.(' +
				src[XRANGEIDENTIFIERLOOSE] +
				')' +
				'(?:' +
				src[PRERELEASELOOSE] +
				')?' +
				src[BUILD] +
				'?' +
				')?)?'

			var XRANGE = R++
			src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$'
			var XRANGELOOSE = R++
			src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$'

			// Coercion.
			// Extract anything that could conceivably be a part of a valid semver
			var COERCE = R++
			src[COERCE] =
				'(?:^|[^\\d])' +
				'(\\d{1,' +
				MAX_SAFE_COMPONENT_LENGTH +
				'})' +
				'(?:\\.(\\d{1,' +
				MAX_SAFE_COMPONENT_LENGTH +
				'}))?' +
				'(?:\\.(\\d{1,' +
				MAX_SAFE_COMPONENT_LENGTH +
				'}))?' +
				'(?:$|[^\\d])'

			// Tilde ranges.
			// Meaning is "reasonably at or greater than"
			var LONETILDE = R++
			src[LONETILDE] = '(?:~>?)'

			var TILDETRIM = R++
			src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+'
			re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g')
			safeRe[TILDETRIM] = new RegExp(makeSafeRe(src[TILDETRIM]), 'g')
			var tildeTrimReplace = '$1~'

			var TILDE = R++
			src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$'
			var TILDELOOSE = R++
			src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'

			// Caret ranges.
			// Meaning is "at least and backwards compatible with"
			var LONECARET = R++
			src[LONECARET] = '(?:\\^)'

			var CARETTRIM = R++
			src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+'
			re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g')
			safeRe[CARETTRIM] = new RegExp(makeSafeRe(src[CARETTRIM]), 'g')
			var caretTrimReplace = '$1^'

			var CARET = R++
			src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$'
			var CARETLOOSE = R++
			src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'

			// A simple gt/lt/eq thing, or just "" to indicate "any version"
			var COMPARATORLOOSE = R++
			src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$'
			var COMPARATOR = R++
			src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$'

			// An expression to strip any whitespace between the gtlt and the thing
			// it modifies, so that `> 1.2.3` ==> `>1.2.3`
			var COMPARATORTRIM = R++
			src[COMPARATORTRIM] =
				'(\\s*)' +
				src[GTLT] +
				'\\s*(' +
				LOOSEPLAIN +
				'|' +
				src[XRANGEPLAIN] +
				')'

			// this one has to use the /g flag
			re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g')
			safeRe[COMPARATORTRIM] = new RegExp(makeSafeRe(src[COMPARATORTRIM]), 'g')
			var comparatorTrimReplace = '$1$2$3'

			// Something like `1.2.3 - 1.2.4`
			// Note that these all use the loose form, because they'll be
			// checked against either the strict or loose comparator form
			// later.
			var HYPHENRANGE = R++
			src[HYPHENRANGE] =
				'^\\s*(' +
				src[XRANGEPLAIN] +
				')' +
				'\\s+-\\s+' +
				'(' +
				src[XRANGEPLAIN] +
				')' +
				'\\s*$'

			var HYPHENRANGELOOSE = R++
			src[HYPHENRANGELOOSE] =
				'^\\s*(' +
				src[XRANGEPLAINLOOSE] +
				')' +
				'\\s+-\\s+' +
				'(' +
				src[XRANGEPLAINLOOSE] +
				')' +
				'\\s*$'

			// Star ranges basically just allow anything at all.
			var STAR = R++
			src[STAR] = '(<|>)?=?\\s*\\*'

			// Compile to actual regexp objects.
			// All are flag-free, unless they were created above with a flag.
			for (var i = 0; i < R; i++) {
				debug(i, src[i])
				if (!re[i]) {
					re[i] = new RegExp(src[i])

					// Replace all greedy whitespace to prevent regex dos issues. These regex are
					// used internally via the safeRe object since all inputs in this library get
					// normalized first to trim and collapse all extra whitespace. The original
					// regexes are exported for userland consumption and lower level usage. A
					// future breaking change could export the safer regex only with a note that
					// all input should have extra whitespace removed.
					safeRe[i] = new RegExp(makeSafeRe(src[i]))
				}
			}

			exports.parse = parse
			function parse(version, options) {
				if (!options || typeof options !== 'object') {
					options = {
						loose: !!options,
						includePrerelease: false,
					}
				}

				if (version instanceof SemVer) {
					return version
				}

				if (typeof version !== 'string') {
					return null
				}

				if (version.length > MAX_LENGTH) {
					return null
				}

				var r = options.loose ? safeRe[LOOSE] : safeRe[FULL]
				if (!r.test(version)) {
					return null
				}

				try {
					return new SemVer(version, options)
				} catch (er) {
					return null
				}
			}

			exports.valid = valid
			function valid(version, options) {
				var v = parse(version, options)
				return v ? v.version : null
			}

			exports.clean = clean
			function clean(version, options) {
				var s = parse(version.trim().replace(/^[=v]+/, ''), options)
				return s ? s.version : null
			}

			exports.SemVer = SemVer

			function SemVer(version, options) {
				if (!options || typeof options !== 'object') {
					options = {
						loose: !!options,
						includePrerelease: false,
					}
				}
				if (version instanceof SemVer) {
					if (version.loose === options.loose) {
						return version
					} else {
						version = version.version
					}
				} else if (typeof version !== 'string') {
					throw new TypeError('Invalid Version: ' + version)
				}

				if (version.length > MAX_LENGTH) {
					throw new TypeError(
						'version is longer than ' + MAX_LENGTH + ' characters',
					)
				}

				if (!(this instanceof SemVer)) {
					return new SemVer(version, options)
				}

				debug('SemVer', version, options)
				this.options = options
				this.loose = !!options.loose

				var m = version
					.trim()
					.match(options.loose ? safeRe[LOOSE] : safeRe[FULL])

				if (!m) {
					throw new TypeError('Invalid Version: ' + version)
				}

				this.raw = version

				// these are actually numbers
				this.major = +m[1]
				this.minor = +m[2]
				this.patch = +m[3]

				if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
					throw new TypeError('Invalid major version')
				}

				if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
					throw new TypeError('Invalid minor version')
				}

				if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
					throw new TypeError('Invalid patch version')
				}

				// numberify any prerelease numeric ids
				if (!m[4]) {
					this.prerelease = []
				} else {
					this.prerelease = m[4].split('.').map(function (id) {
						if (/^[0-9]+$/.test(id)) {
							var num = +id
							if (num >= 0 && num < MAX_SAFE_INTEGER) {
								return num
							}
						}
						return id
					})
				}

				this.build = m[5] ? m[5].split('.') : []
				this.format()
			}

			SemVer.prototype.format = function () {
				this.version = this.major + '.' + this.minor + '.' + this.patch
				if (this.prerelease.length) {
					this.version += '-' + this.prerelease.join('.')
				}
				return this.version
			}

			SemVer.prototype.toString = function () {
				return this.version
			}

			SemVer.prototype.compare = function (other) {
				debug('SemVer.compare', this.version, this.options, other)
				if (!(other instanceof SemVer)) {
					other = new SemVer(other, this.options)
				}

				return this.compareMain(other) || this.comparePre(other)
			}

			SemVer.prototype.compareMain = function (other) {
				if (!(other instanceof SemVer)) {
					other = new SemVer(other, this.options)
				}

				return (
					compareIdentifiers(this.major, other.major) ||
					compareIdentifiers(this.minor, other.minor) ||
					compareIdentifiers(this.patch, other.patch)
				)
			}

			SemVer.prototype.comparePre = function (other) {
				if (!(other instanceof SemVer)) {
					other = new SemVer(other, this.options)
				}

				// NOT having a prerelease is > having one
				if (this.prerelease.length && !other.prerelease.length) {
					return -1
				} else if (!this.prerelease.length && other.prerelease.length) {
					return 1
				} else if (!this.prerelease.length && !other.prerelease.length) {
					return 0
				}

				var i = 0
				do {
					var a = this.prerelease[i]
					var b = other.prerelease[i]
					debug('prerelease compare', i, a, b)
					if (a === undefined && b === undefined) {
						return 0
					} else if (b === undefined) {
						return 1
					} else if (a === undefined) {
						return -1
					} else if (a === b) {
						continue
					} else {
						return compareIdentifiers(a, b)
					}
				} while (++i)
			}

			// preminor will bump the version up to the next minor release, and immediately
			// down to pre-release. premajor and prepatch work the same way.
			SemVer.prototype.inc = function (release, identifier) {
				switch (release) {
					case 'premajor':
						this.prerelease.length = 0
						this.patch = 0
						this.minor = 0
						this.major++
						this.inc('pre', identifier)
						break
					case 'preminor':
						this.prerelease.length = 0
						this.patch = 0
						this.minor++
						this.inc('pre', identifier)
						break
					case 'prepatch':
						// If this is already a prerelease, it will bump to the next version
						// drop any prereleases that might already exist, since they are not
						// relevant at this point.
						this.prerelease.length = 0
						this.inc('patch', identifier)
						this.inc('pre', identifier)
						break
					// If the input is a non-prerelease version, this acts the same as
					// prepatch.
					case 'prerelease':
						if (this.prerelease.length === 0) {
							this.inc('patch', identifier)
						}
						this.inc('pre', identifier)
						break

					case 'major':
						// If this is a pre-major version, bump up to the same major version.
						// Otherwise increment major.
						// 1.0.0-5 bumps to 1.0.0
						// 1.1.0 bumps to 2.0.0
						if (
							this.minor !== 0 ||
							this.patch !== 0 ||
							this.prerelease.length === 0
						) {
							this.major++
						}
						this.minor = 0
						this.patch = 0
						this.prerelease = []
						break
					case 'minor':
						// If this is a pre-minor version, bump up to the same minor version.
						// Otherwise increment minor.
						// 1.2.0-5 bumps to 1.2.0
						// 1.2.1 bumps to 1.3.0
						if (this.patch !== 0 || this.prerelease.length === 0) {
							this.minor++
						}
						this.patch = 0
						this.prerelease = []
						break
					case 'patch':
						// If this is not a pre-release version, it will increment the patch.
						// If it is a pre-release it will bump up to the same patch version.
						// 1.2.0-5 patches to 1.2.0
						// 1.2.0 patches to 1.2.1
						if (this.prerelease.length === 0) {
							this.patch++
						}
						this.prerelease = []
						break
					// This probably shouldn't be used publicly.
					// 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
					case 'pre':
						if (this.prerelease.length === 0) {
							this.prerelease = [0]
						} else {
							var i = this.prerelease.length
							while (--i >= 0) {
								if (typeof this.prerelease[i] === 'number') {
									this.prerelease[i]++
									i = -2
								}
							}
							if (i === -1) {
								// didn't increment anything
								this.prerelease.push(0)
							}
						}
						if (identifier) {
							// 1.2.0-beta.1 bumps to 1.2.0-beta.2,
							// 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
							if (this.prerelease[0] === identifier) {
								if (isNaN(this.prerelease[1])) {
									this.prerelease = [identifier, 0]
								}
							} else {
								this.prerelease = [identifier, 0]
							}
						}
						break

					default:
						throw new Error('invalid increment argument: ' + release)
				}
				this.format()
				this.raw = this.version
				return this
			}

			exports.inc = inc
			function inc(version, release, loose, identifier) {
				if (typeof loose === 'string') {
					identifier = loose
					loose = undefined
				}

				try {
					return new SemVer(version, loose).inc(release, identifier).version
				} catch (er) {
					return null
				}
			}

			exports.diff = diff
			function diff(version1, version2) {
				if (eq(version1, version2)) {
					return null
				} else {
					var v1 = parse(version1)
					var v2 = parse(version2)
					var prefix = ''
					if (v1.prerelease.length || v2.prerelease.length) {
						prefix = 'pre'
						var defaultResult = 'prerelease'
					}
					for (var key in v1) {
						if (key === 'major' || key === 'minor' || key === 'patch') {
							if (v1[key] !== v2[key]) {
								return prefix + key
							}
						}
					}
					return defaultResult // may be undefined
				}
			}

			exports.compareIdentifiers = compareIdentifiers

			var numeric = /^[0-9]+$/
			function compareIdentifiers(a, b) {
				var anum = numeric.test(a)
				var bnum = numeric.test(b)

				if (anum && bnum) {
					a = +a
					b = +b
				}

				return a === b
					? 0
					: anum && !bnum
						? -1
						: bnum && !anum
							? 1
							: a < b
								? -1
								: 1
			}

			exports.rcompareIdentifiers = rcompareIdentifiers
			function rcompareIdentifiers(a, b) {
				return compareIdentifiers(b, a)
			}

			exports.major = major
			function major(a, loose) {
				return new SemVer(a, loose).major
			}

			exports.minor = minor
			function minor(a, loose) {
				return new SemVer(a, loose).minor
			}

			exports.patch = patch
			function patch(a, loose) {
				return new SemVer(a, loose).patch
			}

			exports.compare = compare
			function compare(a, b, loose) {
				return new SemVer(a, loose).compare(new SemVer(b, loose))
			}

			exports.compareLoose = compareLoose
			function compareLoose(a, b) {
				return compare(a, b, true)
			}

			exports.rcompare = rcompare
			function rcompare(a, b, loose) {
				return compare(b, a, loose)
			}

			exports.sort = sort
			function sort(list, loose) {
				return list.sort(function (a, b) {
					return exports.compare(a, b, loose)
				})
			}

			exports.rsort = rsort
			function rsort(list, loose) {
				return list.sort(function (a, b) {
					return exports.rcompare(a, b, loose)
				})
			}

			exports.gt = gt
			function gt(a, b, loose) {
				return compare(a, b, loose) > 0
			}

			exports.lt = lt
			function lt(a, b, loose) {
				return compare(a, b, loose) < 0
			}

			exports.eq = eq
			function eq(a, b, loose) {
				return compare(a, b, loose) === 0
			}

			exports.neq = neq
			function neq(a, b, loose) {
				return compare(a, b, loose) !== 0
			}

			exports.gte = gte
			function gte(a, b, loose) {
				return compare(a, b, loose) >= 0
			}

			exports.lte = lte
			function lte(a, b, loose) {
				return compare(a, b, loose) <= 0
			}

			exports.cmp = cmp
			function cmp(a, op, b, loose) {
				switch (op) {
					case '===':
						if (typeof a === 'object') a = a.version
						if (typeof b === 'object') b = b.version
						return a === b

					case '!==':
						if (typeof a === 'object') a = a.version
						if (typeof b === 'object') b = b.version
						return a !== b

					case '':
					case '=':
					case '==':
						return eq(a, b, loose)

					case '!=':
						return neq(a, b, loose)

					case '>':
						return gt(a, b, loose)

					case '>=':
						return gte(a, b, loose)

					case '<':
						return lt(a, b, loose)

					case '<=':
						return lte(a, b, loose)

					default:
						throw new TypeError('Invalid operator: ' + op)
				}
			}

			exports.Comparator = Comparator
			function Comparator(comp, options) {
				if (!options || typeof options !== 'object') {
					options = {
						loose: !!options,
						includePrerelease: false,
					}
				}

				if (comp instanceof Comparator) {
					if (comp.loose === !!options.loose) {
						return comp
					} else {
						comp = comp.value
					}
				}

				if (!(this instanceof Comparator)) {
					return new Comparator(comp, options)
				}

				comp = comp.trim().split(/\s+/).join(' ')
				debug('comparator', comp, options)
				this.options = options
				this.loose = !!options.loose
				this.parse(comp)

				if (this.semver === ANY) {
					this.value = ''
				} else {
					this.value = this.operator + this.semver.version
				}

				debug('comp', this)
			}

			var ANY = {}
			Comparator.prototype.parse = function (comp) {
				var r = this.options.loose
					? safeRe[COMPARATORLOOSE]
					: safeRe[COMPARATOR]
				var m = comp.match(r)

				if (!m) {
					throw new TypeError('Invalid comparator: ' + comp)
				}

				this.operator = m[1]
				if (this.operator === '=') {
					this.operator = ''
				}

				// if it literally is just '>' or '' then allow anything.
				if (!m[2]) {
					this.semver = ANY
				} else {
					this.semver = new SemVer(m[2], this.options.loose)
				}
			}

			Comparator.prototype.toString = function () {
				return this.value
			}

			Comparator.prototype.test = function (version) {
				debug('Comparator.test', version, this.options.loose)

				if (this.semver === ANY) {
					return true
				}

				if (typeof version === 'string') {
					version = new SemVer(version, this.options)
				}

				return cmp(version, this.operator, this.semver, this.options)
			}

			Comparator.prototype.intersects = function (comp, options) {
				if (!(comp instanceof Comparator)) {
					throw new TypeError('a Comparator is required')
				}

				if (!options || typeof options !== 'object') {
					options = {
						loose: !!options,
						includePrerelease: false,
					}
				}

				var rangeTmp

				if (this.operator === '') {
					rangeTmp = new Range(comp.value, options)
					return satisfies(this.value, rangeTmp, options)
				} else if (comp.operator === '') {
					rangeTmp = new Range(this.value, options)
					return satisfies(comp.semver, rangeTmp, options)
				}

				var sameDirectionIncreasing =
					(this.operator === '>=' || this.operator === '>') &&
					(comp.operator === '>=' || comp.operator === '>')
				var sameDirectionDecreasing =
					(this.operator === '<=' || this.operator === '<') &&
					(comp.operator === '<=' || comp.operator === '<')
				var sameSemVer = this.semver.version === comp.semver.version
				var differentDirectionsInclusive =
					(this.operator === '>=' || this.operator === '<=') &&
					(comp.operator === '>=' || comp.operator === '<=')
				var oppositeDirectionsLessThan =
					cmp(this.semver, '<', comp.semver, options) &&
					(this.operator === '>=' || this.operator === '>') &&
					(comp.operator === '<=' || comp.operator === '<')
				var oppositeDirectionsGreaterThan =
					cmp(this.semver, '>', comp.semver, options) &&
					(this.operator === '<=' || this.operator === '<') &&
					(comp.operator === '>=' || comp.operator === '>')

				return (
					sameDirectionIncreasing ||
					sameDirectionDecreasing ||
					(sameSemVer && differentDirectionsInclusive) ||
					oppositeDirectionsLessThan ||
					oppositeDirectionsGreaterThan
				)
			}

			exports.Range = Range
			function Range(range, options) {
				if (!options || typeof options !== 'object') {
					options = {
						loose: !!options,
						includePrerelease: false,
					}
				}

				if (range instanceof Range) {
					if (
						range.loose === !!options.loose &&
						range.includePrerelease === !!options.includePrerelease
					) {
						return range
					} else {
						return new Range(range.raw, options)
					}
				}

				if (range instanceof Comparator) {
					return new Range(range.value, options)
				}

				if (!(this instanceof Range)) {
					return new Range(range, options)
				}

				this.options = options
				this.loose = !!options.loose
				this.includePrerelease = !!options.includePrerelease

				// First reduce all whitespace as much as possible so we do not have to rely
				// on potentially slow regexes like \s*. This is then stored and used for
				// future error messages as well.
				this.raw = range.trim().split(/\s+/).join(' ')

				// First, split based on boolean or ||
				this.set = this.raw
					.split('||')
					.map(function (range) {
						return this.parseRange(range.trim())
					}, this)
					.filter(function (c) {
						// throw out any that are not relevant for whatever reason
						return c.length
					})

				if (!this.set.length) {
					throw new TypeError('Invalid SemVer Range: ' + this.raw)
				}

				this.format()
			}

			Range.prototype.format = function () {
				this.range = this.set
					.map(function (comps) {
						return comps.join(' ').trim()
					})
					.join('||')
					.trim()
				return this.range
			}

			Range.prototype.toString = function () {
				return this.range
			}

			Range.prototype.parseRange = function (range) {
				var loose = this.options.loose
				// `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
				var hr = loose ? safeRe[HYPHENRANGELOOSE] : safeRe[HYPHENRANGE]
				range = range.replace(hr, hyphenReplace)
				debug('hyphen replace', range)
				// `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
				range = range.replace(safeRe[COMPARATORTRIM], comparatorTrimReplace)
				debug('comparator trim', range, safeRe[COMPARATORTRIM])

				// `~ 1.2.3` => `~1.2.3`
				range = range.replace(safeRe[TILDETRIM], tildeTrimReplace)

				// `^ 1.2.3` => `^1.2.3`
				range = range.replace(safeRe[CARETTRIM], caretTrimReplace)

				// At this point, the range is completely trimmed and
				// ready to be split into comparators.
				var compRe = loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR]
				var set = range
					.split(' ')
					.map(function (comp) {
						return parseComparator(comp, this.options)
					}, this)
					.join(' ')
					.split(/\s+/)
				if (this.options.loose) {
					// in loose mode, throw out any that are not valid comparators
					set = set.filter(function (comp) {
						return !!comp.match(compRe)
					})
				}
				set = set.map(function (comp) {
					return new Comparator(comp, this.options)
				}, this)

				return set
			}

			Range.prototype.intersects = function (range, options) {
				if (!(range instanceof Range)) {
					throw new TypeError('a Range is required')
				}

				return this.set.some(function (thisComparators) {
					return thisComparators.every(function (thisComparator) {
						return range.set.some(function (rangeComparators) {
							return rangeComparators.every(function (rangeComparator) {
								return thisComparator.intersects(rangeComparator, options)
							})
						})
					})
				})
			}

			// Mostly just for testing and legacy API reasons
			exports.toComparators = toComparators
			function toComparators(range, options) {
				return new Range(range, options).set.map(function (comp) {
					return comp
						.map(function (c) {
							return c.value
						})
						.join(' ')
						.trim()
						.split(' ')
				})
			}

			// comprised of xranges, tildes, stars, and gtlt's at this point.
			// already replaced the hyphen ranges
			// turn into a set of JUST comparators.
			function parseComparator(comp, options) {
				debug('comp', comp, options)
				comp = replaceCarets(comp, options)
				debug('caret', comp)
				comp = replaceTildes(comp, options)
				debug('tildes', comp)
				comp = replaceXRanges(comp, options)
				debug('xrange', comp)
				comp = replaceStars(comp, options)
				debug('stars', comp)
				return comp
			}

			function isX(id) {
				return !id || id.toLowerCase() === 'x' || id === '*'
			}

			// ~, ~> --> * (any, kinda silly)
			// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
			// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
			// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
			// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
			// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
			function replaceTildes(comp, options) {
				return comp
					.trim()
					.split(/\s+/)
					.map(function (comp) {
						return replaceTilde(comp, options)
					})
					.join(' ')
			}

			function replaceTilde(comp, options) {
				var r = options.loose ? safeRe[TILDELOOSE] : safeRe[TILDE]
				return comp.replace(r, function (_, M, m, p, pr) {
					debug('tilde', comp, _, M, m, p, pr)
					var ret

					if (isX(M)) {
						ret = ''
					} else if (isX(m)) {
						ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
					} else if (isX(p)) {
						// ~1.2 == >=1.2.0 <1.3.0
						ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
					} else if (pr) {
						debug('replaceTilde pr', pr)
						ret =
							'>=' +
							M +
							'.' +
							m +
							'.' +
							p +
							'-' +
							pr +
							' <' +
							M +
							'.' +
							(+m + 1) +
							'.0'
					} else {
						// ~1.2.3 == >=1.2.3 <1.3.0
						ret =
							'>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0'
					}

					debug('tilde return', ret)
					return ret
				})
			}

			// ^ --> * (any, kinda silly)
			// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
			// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
			// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
			// ^1.2.3 --> >=1.2.3 <2.0.0
			// ^1.2.0 --> >=1.2.0 <2.0.0
			function replaceCarets(comp, options) {
				return comp
					.trim()
					.split(/\s+/)
					.map(function (comp) {
						return replaceCaret(comp, options)
					})
					.join(' ')
			}

			function replaceCaret(comp, options) {
				debug('caret', comp, options)
				var r = options.loose ? safeRe[CARETLOOSE] : safeRe[CARET]
				return comp.replace(r, function (_, M, m, p, pr) {
					debug('caret', comp, _, M, m, p, pr)
					var ret

					if (isX(M)) {
						ret = ''
					} else if (isX(m)) {
						ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
					} else if (isX(p)) {
						if (M === '0') {
							ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
						} else {
							ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
						}
					} else if (pr) {
						debug('replaceCaret pr', pr)
						if (M === '0') {
							if (m === '0') {
								ret =
									'>=' +
									M +
									'.' +
									m +
									'.' +
									p +
									'-' +
									pr +
									' <' +
									M +
									'.' +
									m +
									'.' +
									(+p + 1)
							} else {
								ret =
									'>=' +
									M +
									'.' +
									m +
									'.' +
									p +
									'-' +
									pr +
									' <' +
									M +
									'.' +
									(+m + 1) +
									'.0'
							}
						} else {
							ret =
								'>=' +
								M +
								'.' +
								m +
								'.' +
								p +
								'-' +
								pr +
								' <' +
								(+M + 1) +
								'.0.0'
						}
					} else {
						debug('no pr')
						if (M === '0') {
							if (m === '0') {
								ret =
									'>=' +
									M +
									'.' +
									m +
									'.' +
									p +
									' <' +
									M +
									'.' +
									m +
									'.' +
									(+p + 1)
							} else {
								ret =
									'>=' +
									M +
									'.' +
									m +
									'.' +
									p +
									' <' +
									M +
									'.' +
									(+m + 1) +
									'.0'
							}
						} else {
							ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0'
						}
					}

					debug('caret return', ret)
					return ret
				})
			}

			function replaceXRanges(comp, options) {
				debug('replaceXRanges', comp, options)
				return comp
					.split(/\s+/)
					.map(function (comp) {
						return replaceXRange(comp, options)
					})
					.join(' ')
			}

			function replaceXRange(comp, options) {
				comp = comp.trim()
				var r = options.loose ? safeRe[XRANGELOOSE] : safeRe[XRANGE]
				return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
					debug('xRange', comp, ret, gtlt, M, m, p, pr)
					var xM = isX(M)
					var xm = xM || isX(m)
					var xp = xm || isX(p)
					var anyX = xp

					if (gtlt === '=' && anyX) {
						gtlt = ''
					}

					if (xM) {
						if (gtlt === '>' || gtlt === '<') {
							// nothing is allowed
							ret = '<0.0.0'
						} else {
							// nothing is forbidden
							ret = '*'
						}
					} else if (gtlt && anyX) {
						// we know patch is an x, because we have any x at all.
						// replace X with 0
						if (xm) {
							m = 0
						}
						p = 0

						if (gtlt === '>') {
							// >1 => >=2.0.0
							// >1.2 => >=1.3.0
							// >1.2.3 => >= 1.2.4
							gtlt = '>='
							if (xm) {
								M = +M + 1
								m = 0
								p = 0
							} else {
								m = +m + 1
								p = 0
							}
						} else if (gtlt === '<=') {
							// <=0.7.x is actually <0.8.0, since any 0.7.x should
							// pass.  Similarly, <=7.x is actually <8.0.0, etc.
							gtlt = '<'
							if (xm) {
								M = +M + 1
							} else {
								m = +m + 1
							}
						}

						ret = gtlt + M + '.' + m + '.' + p
					} else if (xm) {
						ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
					} else if (xp) {
						ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
					}

					debug('xRange return', ret)

					return ret
				})
			}

			// Because * is AND-ed with everything else in the comparator,
			// and '' means "any version", just remove the *s entirely.
			function replaceStars(comp, options) {
				debug('replaceStars', comp, options)
				// Looseness is ignored here.  star is always as loose as it gets!
				return comp.trim().replace(safeRe[STAR], '')
			}

			// This function is passed to string.replace(safeRe[HYPHENRANGE])
			// M, m, patch, prerelease, build
			// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
			// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
			// 1.2 - 3.4 => >=1.2.0 <3.5.0
			function hyphenReplace(
				$0,
				from,
				fM,
				fm,
				fp,
				fpr,
				fb,
				to,
				tM,
				tm,
				tp,
				tpr,
				tb,
			) {
				if (isX(fM)) {
					from = ''
				} else if (isX(fm)) {
					from = '>=' + fM + '.0.0'
				} else if (isX(fp)) {
					from = '>=' + fM + '.' + fm + '.0'
				} else {
					from = '>=' + from
				}

				if (isX(tM)) {
					to = ''
				} else if (isX(tm)) {
					to = '<' + (+tM + 1) + '.0.0'
				} else if (isX(tp)) {
					to = '<' + tM + '.' + (+tm + 1) + '.0'
				} else if (tpr) {
					to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
				} else {
					to = '<=' + to
				}

				return (from + ' ' + to).trim()
			}

			// if ANY of the sets match ALL of its comparators, then pass
			Range.prototype.test = function (version) {
				if (!version) {
					return false
				}

				if (typeof version === 'string') {
					version = new SemVer(version, this.options)
				}

				for (var i = 0; i < this.set.length; i++) {
					if (testSet(this.set[i], version, this.options)) {
						return true
					}
				}
				return false
			}

			function testSet(set, version, options) {
				for (var i = 0; i < set.length; i++) {
					if (!set[i].test(version)) {
						return false
					}
				}

				if (version.prerelease.length && !options.includePrerelease) {
					// Find the set of versions that are allowed to have prereleases
					// For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
					// That should allow `1.2.3-pr.2` to pass.
					// However, `1.2.4-alpha.notready` should NOT be allowed,
					// even though it's within the range set by the comparators.
					for (i = 0; i < set.length; i++) {
						debug(set[i].semver)
						if (set[i].semver === ANY) {
							continue
						}

						if (set[i].semver.prerelease.length > 0) {
							var allowed = set[i].semver
							if (
								allowed.major === version.major &&
								allowed.minor === version.minor &&
								allowed.patch === version.patch
							) {
								return true
							}
						}
					}

					// Version has a -pre, but it's not one of the ones we like.
					return false
				}

				return true
			}

			exports.satisfies = satisfies
			function satisfies(version, range, options) {
				try {
					range = new Range(range, options)
				} catch (er) {
					return false
				}
				return range.test(version)
			}

			exports.maxSatisfying = maxSatisfying
			function maxSatisfying(versions, range, options) {
				var max = null
				var maxSV = null
				try {
					var rangeObj = new Range(range, options)
				} catch (er) {
					return null
				}
				versions.forEach(function (v) {
					if (rangeObj.test(v)) {
						// satisfies(v, range, options)
						if (!max || maxSV.compare(v) === -1) {
							// compare(max, v, true)
							max = v
							maxSV = new SemVer(max, options)
						}
					}
				})
				return max
			}

			exports.minSatisfying = minSatisfying
			function minSatisfying(versions, range, options) {
				var min = null
				var minSV = null
				try {
					var rangeObj = new Range(range, options)
				} catch (er) {
					return null
				}
				versions.forEach(function (v) {
					if (rangeObj.test(v)) {
						// satisfies(v, range, options)
						if (!min || minSV.compare(v) === 1) {
							// compare(min, v, true)
							min = v
							minSV = new SemVer(min, options)
						}
					}
				})
				return min
			}

			exports.minVersion = minVersion
			function minVersion(range, loose) {
				range = new Range(range, loose)

				var minver = new SemVer('0.0.0')
				if (range.test(minver)) {
					return minver
				}

				minver = new SemVer('0.0.0-0')
				if (range.test(minver)) {
					return minver
				}

				minver = null
				for (var i = 0; i < range.set.length; ++i) {
					var comparators = range.set[i]

					comparators.forEach(function (comparator) {
						// Clone to avoid manipulating the comparator's semver object.
						var compver = new SemVer(comparator.semver.version)
						switch (comparator.operator) {
							case '>':
								if (compver.prerelease.length === 0) {
									compver.patch++
								} else {
									compver.prerelease.push(0)
								}
								compver.raw = compver.format()
							/* fallthrough */
							case '':
							case '>=':
								if (!minver || gt(minver, compver)) {
									minver = compver
								}
								break
							case '<':
							case '<=':
								/* Ignore maximum versions */
								break
							/* istanbul ignore next */
							default:
								throw new Error('Unexpected operation: ' + comparator.operator)
						}
					})
				}

				if (minver && range.test(minver)) {
					return minver
				}

				return null
			}

			exports.validRange = validRange
			function validRange(range, options) {
				try {
					// Return '*' instead of '' so that truthiness works.
					// This will throw if it's invalid anyway
					return new Range(range, options).range || '*'
				} catch (er) {
					return null
				}
			}

			// Determine if version is less than all the versions possible in the range
			exports.ltr = ltr
			function ltr(version, range, options) {
				return outside(version, range, '<', options)
			}

			// Determine if version is greater than all the versions possible in the range.
			exports.gtr = gtr
			function gtr(version, range, options) {
				return outside(version, range, '>', options)
			}

			exports.outside = outside
			function outside(version, range, hilo, options) {
				version = new SemVer(version, options)
				range = new Range(range, options)

				var gtfn, ltefn, ltfn, comp, ecomp
				switch (hilo) {
					case '>':
						gtfn = gt
						ltefn = lte
						ltfn = lt
						comp = '>'
						ecomp = '>='
						break
					case '<':
						gtfn = lt
						ltefn = gte
						ltfn = gt
						comp = '<'
						ecomp = '<='
						break
					default:
						throw new TypeError('Must provide a hilo val of "<" or ">"')
				}

				// If it satisifes the range it is not outside
				if (satisfies(version, range, options)) {
					return false
				}

				// From now on, variable terms are as if we're in "gtr" mode.
				// but note that everything is flipped for the "ltr" function.

				for (var i = 0; i < range.set.length; ++i) {
					var comparators = range.set[i]

					var high = null
					var low = null

					comparators.forEach(function (comparator) {
						if (comparator.semver === ANY) {
							comparator = new Comparator('>=0.0.0')
						}
						high = high || comparator
						low = low || comparator
						if (gtfn(comparator.semver, high.semver, options)) {
							high = comparator
						} else if (ltfn(comparator.semver, low.semver, options)) {
							low = comparator
						}
					})

					// If the edge version comparator has a operator then our version
					// isn't outside it
					if (high.operator === comp || high.operator === ecomp) {
						return false
					}

					// If the lowest version comparator has an operator and our version
					// is less than it then it isn't higher than the range
					if (
						(!low.operator || low.operator === comp) &&
						ltefn(version, low.semver)
					) {
						return false
					} else if (low.operator === ecomp && ltfn(version, low.semver)) {
						return false
					}
				}
				return true
			}

			exports.prerelease = prerelease
			function prerelease(version, options) {
				var parsed = parse(version, options)
				return parsed && parsed.prerelease.length ? parsed.prerelease : null
			}

			exports.intersects = intersects
			function intersects(r1, r2, options) {
				r1 = new Range(r1, options)
				r2 = new Range(r2, options)
				return r1.intersects(r2)
			}

			exports.coerce = coerce
			function coerce(version) {
				if (version instanceof SemVer) {
					return version
				}

				if (typeof version !== 'string') {
					return null
				}

				var match = version.match(safeRe[COERCE])

				if (match == null) {
					return null
				}

				return parse(
					match[1] + '.' + (match[2] || '0') + '.' + (match[3] || '0'),
				)
			}

			/***/
		},

		/***/ 76934: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			/* -*- Mode: js; js-indent-level: 2; -*- */
			/*
			 * Copyright 2011 Mozilla Foundation and contributors
			 * Licensed under the New BSD license. See LICENSE or:
			 * http://opensource.org/licenses/BSD-3-Clause
			 */

			var util = __nccwpck_require__(62492)
			var has = Object.prototype.hasOwnProperty
			var hasNativeMap = typeof Map !== 'undefined'

			/**
			 * A data structure which is a combination of an array and a set. Adding a new
			 * member is O(1), testing for membership is O(1), and finding the index of an
			 * element is O(1). Removing elements from the set is not supported. Only
			 * strings are supported for membership.
			 */
			function ArraySet() {
				this._array = []
				this._set = hasNativeMap ? new Map() : Object.create(null)
			}

			/**
			 * Static method for creating ArraySet instances from an existing array.
			 */
			ArraySet.fromArray = function ArraySet_fromArray(
				aArray,
				aAllowDuplicates,
			) {
				var set = new ArraySet()
				for (var i = 0, len = aArray.length; i < len; i++) {
					set.add(aArray[i], aAllowDuplicates)
				}
				return set
			}

			/**
			 * Return how many unique items are in this ArraySet. If duplicates have been
			 * added, than those do not count towards the size.
			 *
			 * @returns Number
			 */
			ArraySet.prototype.size = function ArraySet_size() {
				return hasNativeMap
					? this._set.size
					: Object.getOwnPropertyNames(this._set).length
			}

			/**
			 * Add the given string to this set.
			 *
			 * @param String aStr
			 */
			ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
				var sStr = hasNativeMap ? aStr : util.toSetString(aStr)
				var isDuplicate = hasNativeMap
					? this.has(aStr)
					: has.call(this._set, sStr)
				var idx = this._array.length
				if (!isDuplicate || aAllowDuplicates) {
					this._array.push(aStr)
				}
				if (!isDuplicate) {
					if (hasNativeMap) {
						this._set.set(aStr, idx)
					} else {
						this._set[sStr] = idx
					}
				}
			}

			/**
			 * Is the given string a member of this set?
			 *
			 * @param String aStr
			 */
			ArraySet.prototype.has = function ArraySet_has(aStr) {
				if (hasNativeMap) {
					return this._set.has(aStr)
				} else {
					var sStr = util.toSetString(aStr)
					return has.call(this._set, sStr)
				}
			}

			/**
			 * What is the index of the given string in the array?
			 *
			 * @param String aStr
			 */
			ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
				if (hasNativeMap) {
					var idx = this._set.get(aStr)
					if (idx >= 0) {
						return idx
					}
				} else {
					var sStr = util.toSetString(aStr)
					if (has.call(this._set, sStr)) {
						return this._set[sStr]
					}
				}

				throw new Error('"' + aStr + '" is not in the set.')
			}

			/**
			 * What is the element at the given index?
			 *
			 * @param Number aIdx
			 */
			ArraySet.prototype.at = function ArraySet_at(aIdx) {
				if (aIdx >= 0 && aIdx < this._array.length) {
					return this._array[aIdx]
				}
				throw new Error('No element indexed by ' + aIdx)
			}

			/**
			 * Returns the array representation of this set (which has the proper indices
			 * indicated by indexOf). Note that this is a copy of the internal array used
			 * for storing the members so that no one can mess with internal state.
			 */
			ArraySet.prototype.toArray = function ArraySet_toArray() {
				return this._array.slice()
			}

			exports.C = ArraySet

			/***/
		},

		/***/ 27935: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			/* -*- Mode: js; js-indent-level: 2; -*- */
			/*
			 * Copyright 2011 Mozilla Foundation and contributors
			 * Licensed under the New BSD license. See LICENSE or:
			 * http://opensource.org/licenses/BSD-3-Clause
			 *
			 * Based on the Base 64 VLQ implementation in Closure Compiler:
			 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
			 *
			 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
			 * Redistribution and use in source and binary forms, with or without
			 * modification, are permitted provided that the following conditions are
			 * met:
			 *
			 *  * Redistributions of source code must retain the above copyright
			 *    notice, this list of conditions and the following disclaimer.
			 *  * Redistributions in binary form must reproduce the above
			 *    copyright notice, this list of conditions and the following
			 *    disclaimer in the documentation and/or other materials provided
			 *    with the distribution.
			 *  * Neither the name of Google Inc. nor the names of its
			 *    contributors may be used to endorse or promote products derived
			 *    from this software without specific prior written permission.
			 *
			 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
			 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
			 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
			 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
			 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
			 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
			 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
			 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
			 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
			 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
			 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
			 */

			var base64 = __nccwpck_require__(691)

			// A single base 64 digit can contain 6 bits of data. For the base 64 variable
			// length quantities we use in the source map spec, the first bit is the sign,
			// the next four bits are the actual value, and the 6th bit is the
			// continuation bit. The continuation bit tells us whether there are more
			// digits in this value following this digit.
			//
			//   Continuation
			//   |    Sign
			//   |    |
			//   V    V
			//   101011

			var VLQ_BASE_SHIFT = 5

			// binary: 100000
			var VLQ_BASE = 1 << VLQ_BASE_SHIFT

			// binary: 011111
			var VLQ_BASE_MASK = VLQ_BASE - 1

			// binary: 100000
			var VLQ_CONTINUATION_BIT = VLQ_BASE

			/**
			 * Converts from a two-complement value to a value where the sign bit is
			 * placed in the least significant bit.  For example, as decimals:
			 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
			 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
			 */
			function toVLQSigned(aValue) {
				return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0
			}

			/**
			 * Converts to a two-complement value from a value where the sign bit is
			 * placed in the least significant bit.  For example, as decimals:
			 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
			 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
			 */
			function fromVLQSigned(aValue) {
				var isNegative = (aValue & 1) === 1
				var shifted = aValue >> 1
				return isNegative ? -shifted : shifted
			}

			/**
			 * Returns the base 64 VLQ encoded value.
			 */
			exports.encode = function base64VLQ_encode(aValue) {
				var encoded = ''
				var digit

				var vlq = toVLQSigned(aValue)

				do {
					digit = vlq & VLQ_BASE_MASK
					vlq >>>= VLQ_BASE_SHIFT
					if (vlq > 0) {
						// There are still more digits in this value, so we must make sure the
						// continuation bit is marked.
						digit |= VLQ_CONTINUATION_BIT
					}
					encoded += base64.encode(digit)
				} while (vlq > 0)

				return encoded
			}

			/**
			 * Decodes the next base 64 VLQ value from the given string and returns the
			 * value and the rest of the string via the out parameter.
			 */
			exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
				var strLen = aStr.length
				var result = 0
				var shift = 0
				var continuation, digit

				do {
					if (aIndex >= strLen) {
						throw new Error('Expected more digits in base 64 VLQ value.')
					}

					digit = base64.decode(aStr.charCodeAt(aIndex++))
					if (digit === -1) {
						throw new Error('Invalid base64 digit: ' + aStr.charAt(aIndex - 1))
					}

					continuation = !!(digit & VLQ_CONTINUATION_BIT)
					digit &= VLQ_BASE_MASK
					result = result + (digit << shift)
					shift += VLQ_BASE_SHIFT
				} while (continuation)

				aOutParam.value = fromVLQSigned(result)
				aOutParam.rest = aIndex
			}

			/***/
		},

		/***/ 691: /***/ (__unused_webpack_module, exports) => {
			/* -*- Mode: js; js-indent-level: 2; -*- */
			/*
			 * Copyright 2011 Mozilla Foundation and contributors
			 * Licensed under the New BSD license. See LICENSE or:
			 * http://opensource.org/licenses/BSD-3-Clause
			 */

			var intToCharMap =
				'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split(
					'',
				)

			/**
			 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
			 */
			exports.encode = function (number) {
				if (0 <= number && number < intToCharMap.length) {
					return intToCharMap[number]
				}
				throw new TypeError('Must be between 0 and 63: ' + number)
			}

			/**
			 * Decode a single base 64 character code digit to an integer. Returns -1 on
			 * failure.
			 */
			exports.decode = function (charCode) {
				var bigA = 65 // 'A'
				var bigZ = 90 // 'Z'

				var littleA = 97 // 'a'
				var littleZ = 122 // 'z'

				var zero = 48 // '0'
				var nine = 57 // '9'

				var plus = 43 // '+'
				var slash = 47 // '/'

				var littleOffset = 26
				var numberOffset = 52

				// 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
				if (bigA <= charCode && charCode <= bigZ) {
					return charCode - bigA
				}

				// 26 - 51: abcdefghijklmnopqrstuvwxyz
				if (littleA <= charCode && charCode <= littleZ) {
					return charCode - littleA + littleOffset
				}

				// 52 - 61: 0123456789
				if (zero <= charCode && charCode <= nine) {
					return charCode - zero + numberOffset
				}

				// 62: +
				if (charCode == plus) {
					return 62
				}

				// 63: /
				if (charCode == slash) {
					return 63
				}

				// Invalid base64 digit.
				return -1
			}

			/***/
		},

		/***/ 72326: /***/ (__unused_webpack_module, exports) => {
			/* -*- Mode: js; js-indent-level: 2; -*- */
			/*
			 * Copyright 2011 Mozilla Foundation and contributors
			 * Licensed under the New BSD license. See LICENSE or:
			 * http://opensource.org/licenses/BSD-3-Clause
			 */

			exports.GREATEST_LOWER_BOUND = 1
			exports.LEAST_UPPER_BOUND = 2

			/**
			 * Recursive implementation of binary search.
			 *
			 * @param aLow Indices here and lower do not contain the needle.
			 * @param aHigh Indices here and higher do not contain the needle.
			 * @param aNeedle The element being searched for.
			 * @param aHaystack The non-empty array being searched.
			 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
			 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
			 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
			 *     closest element that is smaller than or greater than the one we are
			 *     searching for, respectively, if the exact element cannot be found.
			 */
			function recursiveSearch(
				aLow,
				aHigh,
				aNeedle,
				aHaystack,
				aCompare,
				aBias,
			) {
				// This function terminates when one of the following is true:
				//
				//   1. We find the exact element we are looking for.
				//
				//   2. We did not find the exact element, but we can return the index of
				//      the next-closest element.
				//
				//   3. We did not find the exact element, and there is no next-closest
				//      element than the one we are searching for, so we return -1.
				var mid = Math.floor((aHigh - aLow) / 2) + aLow
				var cmp = aCompare(aNeedle, aHaystack[mid], true)
				if (cmp === 0) {
					// Found the element we are looking for.
					return mid
				} else if (cmp > 0) {
					// Our needle is greater than aHaystack[mid].
					if (aHigh - mid > 1) {
						// The element is in the upper half.
						return recursiveSearch(
							mid,
							aHigh,
							aNeedle,
							aHaystack,
							aCompare,
							aBias,
						)
					}

					// The exact needle element was not found in this haystack. Determine if
					// we are in termination case (3) or (2) and return the appropriate thing.
					if (aBias == exports.LEAST_UPPER_BOUND) {
						return aHigh < aHaystack.length ? aHigh : -1
					} else {
						return mid
					}
				} else {
					// Our needle is less than aHaystack[mid].
					if (mid - aLow > 1) {
						// The element is in the lower half.
						return recursiveSearch(
							aLow,
							mid,
							aNeedle,
							aHaystack,
							aCompare,
							aBias,
						)
					}

					// we are in termination case (3) or (2) and return the appropriate thing.
					if (aBias == exports.LEAST_UPPER_BOUND) {
						return mid
					} else {
						return aLow < 0 ? -1 : aLow
					}
				}
			}

			/**
			 * This is an implementation of binary search which will always try and return
			 * the index of the closest element if there is no exact hit. This is because
			 * mappings between original and generated line/col pairs are single points,
			 * and there is an implicit region between each of them, so a miss just means
			 * that you aren't on the very start of a region.
			 *
			 * @param aNeedle The element you are looking for.
			 * @param aHaystack The array that is being searched.
			 * @param aCompare A function which takes the needle and an element in the
			 *     array and returns -1, 0, or 1 depending on whether the needle is less
			 *     than, equal to, or greater than the element, respectively.
			 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
			 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
			 *     closest element that is smaller than or greater than the one we are
			 *     searching for, respectively, if the exact element cannot be found.
			 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
			 */
			exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
				if (aHaystack.length === 0) {
					return -1
				}

				var index = recursiveSearch(
					-1,
					aHaystack.length,
					aNeedle,
					aHaystack,
					aCompare,
					aBias || exports.GREATEST_LOWER_BOUND,
				)
				if (index < 0) {
					return -1
				}

				// We have found either the exact element, or the next-closest element than
				// the one we are searching for. However, there may be more than one such
				// element. Make sure we always return the smallest of these.
				while (index - 1 >= 0) {
					if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
						break
					}
					--index
				}

				return index
			}

			/***/
		},

		/***/ 12861: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			/* -*- Mode: js; js-indent-level: 2; -*- */
			/*
			 * Copyright 2014 Mozilla Foundation and contributors
			 * Licensed under the New BSD license. See LICENSE or:
			 * http://opensource.org/licenses/BSD-3-Clause
			 */

			var util = __nccwpck_require__(62492)

			/**
			 * Determine whether mappingB is after mappingA with respect to generated
			 * position.
			 */
			function generatedPositionAfter(mappingA, mappingB) {
				// Optimized for most common case
				var lineA = mappingA.generatedLine
				var lineB = mappingB.generatedLine
				var columnA = mappingA.generatedColumn
				var columnB = mappingB.generatedColumn
				return (
					lineB > lineA ||
					(lineB == lineA && columnB >= columnA) ||
					util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0
				)
			}

			/**
			 * A data structure to provide a sorted view of accumulated mappings in a
			 * performance conscious manner. It trades a neglibable overhead in general
			 * case for a large speedup in case of mappings being added in order.
			 */
			function MappingList() {
				this._array = []
				this._sorted = true
				// Serves as infimum
				this._last = { generatedLine: -1, generatedColumn: 0 }
			}

			/**
			 * Iterate through internal items. This method takes the same arguments that
			 * `Array.prototype.forEach` takes.
			 *
			 * NOTE: The order of the mappings is NOT guaranteed.
			 */
			MappingList.prototype.unsortedForEach = function MappingList_forEach(
				aCallback,
				aThisArg,
			) {
				this._array.forEach(aCallback, aThisArg)
			}

			/**
			 * Add the given source mapping.
			 *
			 * @param Object aMapping
			 */
			MappingList.prototype.add = function MappingList_add(aMapping) {
				if (generatedPositionAfter(this._last, aMapping)) {
					this._last = aMapping
					this._array.push(aMapping)
				} else {
					this._sorted = false
					this._array.push(aMapping)
				}
			}

			/**
			 * Returns the flat, sorted array of mappings. The mappings are sorted by
			 * generated position.
			 *
			 * WARNING: This method returns internal data without copying, for
			 * performance. The return value must NOT be mutated, and should be treated as
			 * an immutable borrow. If you want to take ownership, you must make your own
			 * copy.
			 */
			MappingList.prototype.toArray = function MappingList_toArray() {
				if (!this._sorted) {
					this._array.sort(util.compareByGeneratedPositionsInflated)
					this._sorted = true
				}
				return this._array
			}

			exports.P = MappingList

			/***/
		},

		/***/ 9598: /***/ (__unused_webpack_module, exports) => {
			/* -*- Mode: js; js-indent-level: 2; -*- */
			/*
			 * Copyright 2011 Mozilla Foundation and contributors
			 * Licensed under the New BSD license. See LICENSE or:
			 * http://opensource.org/licenses/BSD-3-Clause
			 */

			// It turns out that some (most?) JavaScript engines don't self-host
			// `Array.prototype.sort`. This makes sense because C++ will likely remain
			// faster than JS when doing raw CPU-intensive sorting. However, when using a
			// custom comparator function, calling back and forth between the VM's C++ and
			// JIT'd JS is rather slow *and* loses JIT type information, resulting in
			// worse generated code for the comparator function than would be optimal. In
			// fact, when sorting with a comparator, these costs outweigh the benefits of
			// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
			// a ~3500ms mean speed-up in `bench/bench.html`.

			/**
			 * Swap the elements indexed by `x` and `y` in the array `ary`.
			 *
			 * @param {Array} ary
			 *        The array.
			 * @param {Number} x
			 *        The index of the first item.
			 * @param {Number} y
			 *        The index of the second item.
			 */
			function swap(ary, x, y) {
				var temp = ary[x]
				ary[x] = ary[y]
				ary[y] = temp
			}

			/**
			 * Returns a random integer within the range `low .. high` inclusive.
			 *
			 * @param {Number} low
			 *        The lower bound on the range.
			 * @param {Number} high
			 *        The upper bound on the range.
			 */
			function randomIntInRange(low, high) {
				return Math.round(low + Math.random() * (high - low))
			}

			/**
			 * The Quick Sort algorithm.
			 *
			 * @param {Array} ary
			 *        An array to sort.
			 * @param {function} comparator
			 *        Function to use to compare two items.
			 * @param {Number} p
			 *        Start index of the array
			 * @param {Number} r
			 *        End index of the array
			 */
			function doQuickSort(ary, comparator, p, r) {
				// If our lower bound is less than our upper bound, we (1) partition the
				// array into two pieces and (2) recurse on each half. If it is not, this is
				// the empty array and our base case.

				if (p < r) {
					// (1) Partitioning.
					//
					// The partitioning chooses a pivot between `p` and `r` and moves all
					// elements that are less than or equal to the pivot to the before it, and
					// all the elements that are greater than it after it. The effect is that
					// once partition is done, the pivot is in the exact place it will be when
					// the array is put in sorted order, and it will not need to be moved
					// again. This runs in O(n) time.

					// Always choose a random pivot so that an input array which is reverse
					// sorted does not cause O(n^2) running time.
					var pivotIndex = randomIntInRange(p, r)
					var i = p - 1

					swap(ary, pivotIndex, r)
					var pivot = ary[r]

					// Immediately after `j` is incremented in this loop, the following hold
					// true:
					//
					//   * Every element in `ary[p .. i]` is less than or equal to the pivot.
					//
					//   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
					for (var j = p; j < r; j++) {
						if (comparator(ary[j], pivot) <= 0) {
							i += 1
							swap(ary, i, j)
						}
					}

					swap(ary, i + 1, j)
					var q = i + 1

					// (2) Recurse on each half.

					doQuickSort(ary, comparator, p, q - 1)
					doQuickSort(ary, comparator, q + 1, r)
				}
			}

			/**
			 * Sort the given array in-place with the given comparator function.
			 *
			 * @param {Array} ary
			 *        An array to sort.
			 * @param {function} comparator
			 *        Function to use to compare two items.
			 */
			exports.g = function (ary, comparator) {
				doQuickSort(ary, comparator, 0, ary.length - 1)
			}

			/***/
		},

		/***/ 79907: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			var __webpack_unused_export__
			/* -*- Mode: js; js-indent-level: 2; -*- */
			/*
			 * Copyright 2011 Mozilla Foundation and contributors
			 * Licensed under the New BSD license. See LICENSE or:
			 * http://opensource.org/licenses/BSD-3-Clause
			 */

			var util = __nccwpck_require__(62492)
			var binarySearch = __nccwpck_require__(72326)
			var ArraySet = __nccwpck_require__(76934) /* .ArraySet */.C
			var base64VLQ = __nccwpck_require__(27935)
			var quickSort = __nccwpck_require__(9598) /* .quickSort */.g

			function SourceMapConsumer(aSourceMap) {
				var sourceMap = aSourceMap
				if (typeof aSourceMap === 'string') {
					sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''))
				}

				return sourceMap.sections != null
					? new IndexedSourceMapConsumer(sourceMap)
					: new BasicSourceMapConsumer(sourceMap)
			}

			SourceMapConsumer.fromSourceMap = function (aSourceMap) {
				return BasicSourceMapConsumer.fromSourceMap(aSourceMap)
			}

			/**
			 * The version of the source mapping spec that we are consuming.
			 */
			SourceMapConsumer.prototype._version = 3

			// `__generatedMappings` and `__originalMappings` are arrays that hold the
			// parsed mapping coordinates from the source map's "mappings" attribute. They
			// are lazily instantiated, accessed via the `_generatedMappings` and
			// `_originalMappings` getters respectively, and we only parse the mappings
			// and create these arrays once queried for a source location. We jump through
			// these hoops because there can be many thousands of mappings, and parsing
			// them is expensive, so we only want to do it if we must.
			//
			// Each object in the arrays is of the form:
			//
			//     {
			//       generatedLine: The line number in the generated code,
			//       generatedColumn: The column number in the generated code,
			//       source: The path to the original source file that generated this
			//               chunk of code,
			//       originalLine: The line number in the original source that
			//                     corresponds to this chunk of generated code,
			//       originalColumn: The column number in the original source that
			//                       corresponds to this chunk of generated code,
			//       name: The name of the original symbol which generated this chunk of
			//             code.
			//     }
			//
			// All properties except for `generatedLine` and `generatedColumn` can be
			// `null`.
			//
			// `_generatedMappings` is ordered by the generated positions.
			//
			// `_originalMappings` is ordered by the original positions.

			SourceMapConsumer.prototype.__generatedMappings = null
			Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
				get: function () {
					if (!this.__generatedMappings) {
						this._parseMappings(this._mappings, this.sourceRoot)
					}

					return this.__generatedMappings
				},
			})

			SourceMapConsumer.prototype.__originalMappings = null
			Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
				get: function () {
					if (!this.__originalMappings) {
						this._parseMappings(this._mappings, this.sourceRoot)
					}

					return this.__originalMappings
				},
			})

			SourceMapConsumer.prototype._charIsMappingSeparator =
				function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
					var c = aStr.charAt(index)
					return c === ';' || c === ','
				}

			/**
			 * Parse the mappings in a string in to a data structure which we can easily
			 * query (the ordered arrays in the `this.__generatedMappings` and
			 * `this.__originalMappings` properties).
			 */
			SourceMapConsumer.prototype._parseMappings =
				function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
					throw new Error('Subclasses must implement _parseMappings')
				}

			SourceMapConsumer.GENERATED_ORDER = 1
			SourceMapConsumer.ORIGINAL_ORDER = 2

			SourceMapConsumer.GREATEST_LOWER_BOUND = 1
			SourceMapConsumer.LEAST_UPPER_BOUND = 2

			/**
			 * Iterate over each mapping between an original source/line/column and a
			 * generated line/column in this source map.
			 *
			 * @param Function aCallback
			 *        The function that is called with each mapping.
			 * @param Object aContext
			 *        Optional. If specified, this object will be the value of `this` every
			 *        time that `aCallback` is called.
			 * @param aOrder
			 *        Either `SourceMapConsumer.GENERATED_ORDER` or
			 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
			 *        iterate over the mappings sorted by the generated file's line/column
			 *        order or the original's source/line/column order, respectively. Defaults to
			 *        `SourceMapConsumer.GENERATED_ORDER`.
			 */
			SourceMapConsumer.prototype.eachMapping =
				function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
					var context = aContext || null
					var order = aOrder || SourceMapConsumer.GENERATED_ORDER

					var mappings
					switch (order) {
						case SourceMapConsumer.GENERATED_ORDER:
							mappings = this._generatedMappings
							break
						case SourceMapConsumer.ORIGINAL_ORDER:
							mappings = this._originalMappings
							break
						default:
							throw new Error('Unknown order of iteration.')
					}

					var sourceRoot = this.sourceRoot
					mappings
						.map(function (mapping) {
							var source =
								mapping.source === null
									? null
									: this._sources.at(mapping.source)
							if (source != null && sourceRoot != null) {
								source = util.join(sourceRoot, source)
							}
							return {
								source: source,
								generatedLine: mapping.generatedLine,
								generatedColumn: mapping.generatedColumn,
								originalLine: mapping.originalLine,
								originalColumn: mapping.originalColumn,
								name:
									mapping.name === null ? null : this._names.at(mapping.name),
							}
						}, this)
						.forEach(aCallback, context)
				}

			/**
			 * Returns all generated line and column information for the original source,
			 * line, and column provided. If no column is provided, returns all mappings
			 * corresponding to a either the line we are searching for or the next
			 * closest line that has any mappings. Otherwise, returns all mappings
			 * corresponding to the given line and either the column we are searching for
			 * or the next closest column that has any offsets.
			 *
			 * The only argument is an object with the following properties:
			 *
			 *   - source: The filename of the original source.
			 *   - line: The line number in the original source.
			 *   - column: Optional. the column number in the original source.
			 *
			 * and an array of objects is returned, each with the following properties:
			 *
			 *   - line: The line number in the generated source, or null.
			 *   - column: The column number in the generated source, or null.
			 */
			SourceMapConsumer.prototype.allGeneratedPositionsFor =
				function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
					var line = util.getArg(aArgs, 'line')

					// When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
					// returns the index of the closest mapping less than the needle. By
					// setting needle.originalColumn to 0, we thus find the last mapping for
					// the given line, provided such a mapping exists.
					var needle = {
						source: util.getArg(aArgs, 'source'),
						originalLine: line,
						originalColumn: util.getArg(aArgs, 'column', 0),
					}

					if (this.sourceRoot != null) {
						needle.source = util.relative(this.sourceRoot, needle.source)
					}
					if (!this._sources.has(needle.source)) {
						return []
					}
					needle.source = this._sources.indexOf(needle.source)

					var mappings = []

					var index = this._findMapping(
						needle,
						this._originalMappings,
						'originalLine',
						'originalColumn',
						util.compareByOriginalPositions,
						binarySearch.LEAST_UPPER_BOUND,
					)
					if (index >= 0) {
						var mapping = this._originalMappings[index]

						if (aArgs.column === undefined) {
							var originalLine = mapping.originalLine

							// Iterate until either we run out of mappings, or we run into
							// a mapping for a different line than the one we found. Since
							// mappings are sorted, this is guaranteed to find all mappings for
							// the line we found.
							while (mapping && mapping.originalLine === originalLine) {
								mappings.push({
									line: util.getArg(mapping, 'generatedLine', null),
									column: util.getArg(mapping, 'generatedColumn', null),
									lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null),
								})

								mapping = this._originalMappings[++index]
							}
						} else {
							var originalColumn = mapping.originalColumn

							// Iterate until either we run out of mappings, or we run into
							// a mapping for a different line than the one we were searching for.
							// Since mappings are sorted, this is guaranteed to find all mappings for
							// the line we are searching for.
							while (
								mapping &&
								mapping.originalLine === line &&
								mapping.originalColumn == originalColumn
							) {
								mappings.push({
									line: util.getArg(mapping, 'generatedLine', null),
									column: util.getArg(mapping, 'generatedColumn', null),
									lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null),
								})

								mapping = this._originalMappings[++index]
							}
						}
					}

					return mappings
				}

			exports.SourceMapConsumer = SourceMapConsumer

			/**
			 * A BasicSourceMapConsumer instance represents a parsed source map which we can
			 * query for information about the original file positions by giving it a file
			 * position in the generated source.
			 *
			 * The only parameter is the raw source map (either as a JSON string, or
			 * already parsed to an object). According to the spec, source maps have the
			 * following attributes:
			 *
			 *   - version: Which version of the source map spec this map is following.
			 *   - sources: An array of URLs to the original source files.
			 *   - names: An array of identifiers which can be referrenced by individual mappings.
			 *   - sourceRoot: Optional. The URL root from which all sources are relative.
			 *   - sourcesContent: Optional. An array of contents of the original source files.
			 *   - mappings: A string of base64 VLQs which contain the actual mappings.
			 *   - file: Optional. The generated file this source map is associated with.
			 *
			 * Here is an example source map, taken from the source map spec[0]:
			 *
			 *     {
			 *       version : 3,
			 *       file: "out.js",
			 *       sourceRoot : "",
			 *       sources: ["foo.js", "bar.js"],
			 *       names: ["src", "maps", "are", "fun"],
			 *       mappings: "AA,AB;;ABCDE;"
			 *     }
			 *
			 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
			 */
			function BasicSourceMapConsumer(aSourceMap) {
				var sourceMap = aSourceMap
				if (typeof aSourceMap === 'string') {
					sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''))
				}

				var version = util.getArg(sourceMap, 'version')
				var sources = util.getArg(sourceMap, 'sources')
				// Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
				// requires the array) to play nice here.
				var names = util.getArg(sourceMap, 'names', [])
				var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null)
				var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null)
				var mappings = util.getArg(sourceMap, 'mappings')
				var file = util.getArg(sourceMap, 'file', null)

				// Once again, Sass deviates from the spec and supplies the version as a
				// string rather than a number, so we use loose equality checking here.
				if (version != this._version) {
					throw new Error('Unsupported version: ' + version)
				}

				sources = sources
					.map(String)
					// Some source maps produce relative source paths like "./foo.js" instead of
					// "foo.js".  Normalize these first so that future comparisons will succeed.
					// See bugzil.la/1090768.
					.map(util.normalize)
					// Always ensure that absolute sources are internally stored relative to
					// the source root, if the source root is absolute. Not doing this would
					// be particularly problematic when the source root is a prefix of the
					// source (valid, but why??). See github issue #199 and bugzil.la/1188982.
					.map(function (source) {
						return sourceRoot &&
							util.isAbsolute(sourceRoot) &&
							util.isAbsolute(source)
							? util.relative(sourceRoot, source)
							: source
					})

				// Pass `true` below to allow duplicate names and sources. While source maps
				// are intended to be compressed and deduplicated, the TypeScript compiler
				// sometimes generates source maps with duplicates in them. See Github issue
				// #72 and bugzil.la/889492.
				this._names = ArraySet.fromArray(names.map(String), true)
				this._sources = ArraySet.fromArray(sources, true)

				this.sourceRoot = sourceRoot
				this.sourcesContent = sourcesContent
				this._mappings = mappings
				this.file = file
			}

			BasicSourceMapConsumer.prototype = Object.create(
				SourceMapConsumer.prototype,
			)
			BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer

			/**
			 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
			 *
			 * @param SourceMapGenerator aSourceMap
			 *        The source map that will be consumed.
			 * @returns BasicSourceMapConsumer
			 */
			BasicSourceMapConsumer.fromSourceMap =
				function SourceMapConsumer_fromSourceMap(aSourceMap) {
					var smc = Object.create(BasicSourceMapConsumer.prototype)

					var names = (smc._names = ArraySet.fromArray(
						aSourceMap._names.toArray(),
						true,
					))
					var sources = (smc._sources = ArraySet.fromArray(
						aSourceMap._sources.toArray(),
						true,
					))
					smc.sourceRoot = aSourceMap._sourceRoot
					smc.sourcesContent = aSourceMap._generateSourcesContent(
						smc._sources.toArray(),
						smc.sourceRoot,
					)
					smc.file = aSourceMap._file

					// Because we are modifying the entries (by converting string sources and
					// names to indices into the sources and names ArraySets), we have to make
					// a copy of the entry or else bad things happen. Shared mutable state
					// strikes again! See github issue #191.

					var generatedMappings = aSourceMap._mappings.toArray().slice()
					var destGeneratedMappings = (smc.__generatedMappings = [])
					var destOriginalMappings = (smc.__originalMappings = [])

					for (var i = 0, length = generatedMappings.length; i < length; i++) {
						var srcMapping = generatedMappings[i]
						var destMapping = new Mapping()
						destMapping.generatedLine = srcMapping.generatedLine
						destMapping.generatedColumn = srcMapping.generatedColumn

						if (srcMapping.source) {
							destMapping.source = sources.indexOf(srcMapping.source)
							destMapping.originalLine = srcMapping.originalLine
							destMapping.originalColumn = srcMapping.originalColumn

							if (srcMapping.name) {
								destMapping.name = names.indexOf(srcMapping.name)
							}

							destOriginalMappings.push(destMapping)
						}

						destGeneratedMappings.push(destMapping)
					}

					quickSort(smc.__originalMappings, util.compareByOriginalPositions)

					return smc
				}

			/**
			 * The version of the source mapping spec that we are consuming.
			 */
			BasicSourceMapConsumer.prototype._version = 3

			/**
			 * The list of original sources.
			 */
			Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
				get: function () {
					return this._sources.toArray().map(function (s) {
						return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s
					}, this)
				},
			})

			/**
			 * Provide the JIT with a nice shape / hidden class.
			 */
			function Mapping() {
				this.generatedLine = 0
				this.generatedColumn = 0
				this.source = null
				this.originalLine = null
				this.originalColumn = null
				this.name = null
			}

			/**
			 * Parse the mappings in a string in to a data structure which we can easily
			 * query (the ordered arrays in the `this.__generatedMappings` and
			 * `this.__originalMappings` properties).
			 */
			BasicSourceMapConsumer.prototype._parseMappings =
				function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
					var generatedLine = 1
					var previousGeneratedColumn = 0
					var previousOriginalLine = 0
					var previousOriginalColumn = 0
					var previousSource = 0
					var previousName = 0
					var length = aStr.length
					var index = 0
					var cachedSegments = {}
					var temp = {}
					var originalMappings = []
					var generatedMappings = []
					var mapping, str, segment, end, value

					while (index < length) {
						if (aStr.charAt(index) === ';') {
							generatedLine++
							index++
							previousGeneratedColumn = 0
						} else if (aStr.charAt(index) === ',') {
							index++
						} else {
							mapping = new Mapping()
							mapping.generatedLine = generatedLine

							// Because each offset is encoded relative to the previous one,
							// many segments often have the same encoding. We can exploit this
							// fact by caching the parsed variable length fields of each segment,
							// allowing us to avoid a second parse if we encounter the same
							// segment again.
							for (end = index; end < length; end++) {
								if (this._charIsMappingSeparator(aStr, end)) {
									break
								}
							}
							str = aStr.slice(index, end)

							segment = cachedSegments[str]
							if (segment) {
								index += str.length
							} else {
								segment = []
								while (index < end) {
									base64VLQ.decode(aStr, index, temp)
									value = temp.value
									index = temp.rest
									segment.push(value)
								}

								if (segment.length === 2) {
									throw new Error('Found a source, but no line and column')
								}

								if (segment.length === 3) {
									throw new Error('Found a source and line, but no column')
								}

								cachedSegments[str] = segment
							}

							// Generated column.
							mapping.generatedColumn = previousGeneratedColumn + segment[0]
							previousGeneratedColumn = mapping.generatedColumn

							if (segment.length > 1) {
								// Original source.
								mapping.source = previousSource + segment[1]
								previousSource += segment[1]

								// Original line.
								mapping.originalLine = previousOriginalLine + segment[2]
								previousOriginalLine = mapping.originalLine
								// Lines are stored 0-based
								mapping.originalLine += 1

								// Original column.
								mapping.originalColumn = previousOriginalColumn + segment[3]
								previousOriginalColumn = mapping.originalColumn

								if (segment.length > 4) {
									// Original name.
									mapping.name = previousName + segment[4]
									previousName += segment[4]
								}
							}

							generatedMappings.push(mapping)
							if (typeof mapping.originalLine === 'number') {
								originalMappings.push(mapping)
							}
						}
					}

					quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated)
					this.__generatedMappings = generatedMappings

					quickSort(originalMappings, util.compareByOriginalPositions)
					this.__originalMappings = originalMappings
				}

			/**
			 * Find the mapping that best matches the hypothetical "needle" mapping that
			 * we are searching for in the given "haystack" of mappings.
			 */
			BasicSourceMapConsumer.prototype._findMapping =
				function SourceMapConsumer_findMapping(
					aNeedle,
					aMappings,
					aLineName,
					aColumnName,
					aComparator,
					aBias,
				) {
					// To return the position we are searching for, we must first find the
					// mapping for the given position and then return the opposite position it
					// points to. Because the mappings are sorted, we can use binary search to
					// find the best mapping.

					if (aNeedle[aLineName] <= 0) {
						throw new TypeError(
							'Line must be greater than or equal to 1, got ' +
								aNeedle[aLineName],
						)
					}
					if (aNeedle[aColumnName] < 0) {
						throw new TypeError(
							'Column must be greater than or equal to 0, got ' +
								aNeedle[aColumnName],
						)
					}

					return binarySearch.search(aNeedle, aMappings, aComparator, aBias)
				}

			/**
			 * Compute the last column for each generated mapping. The last column is
			 * inclusive.
			 */
			BasicSourceMapConsumer.prototype.computeColumnSpans =
				function SourceMapConsumer_computeColumnSpans() {
					for (var index = 0; index < this._generatedMappings.length; ++index) {
						var mapping = this._generatedMappings[index]

						// Mappings do not contain a field for the last generated columnt. We
						// can come up with an optimistic estimate, however, by assuming that
						// mappings are contiguous (i.e. given two consecutive mappings, the
						// first mapping ends where the second one starts).
						if (index + 1 < this._generatedMappings.length) {
							var nextMapping = this._generatedMappings[index + 1]

							if (mapping.generatedLine === nextMapping.generatedLine) {
								mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1
								continue
							}
						}

						// The last mapping for each line spans the entire line.
						mapping.lastGeneratedColumn = Infinity
					}
				}

			/**
			 * Returns the original source, line, and column information for the generated
			 * source's line and column positions provided. The only argument is an object
			 * with the following properties:
			 *
			 *   - line: The line number in the generated source.
			 *   - column: The column number in the generated source.
			 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
			 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
			 *     closest element that is smaller than or greater than the one we are
			 *     searching for, respectively, if the exact element cannot be found.
			 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
			 *
			 * and an object is returned with the following properties:
			 *
			 *   - source: The original source file, or null.
			 *   - line: The line number in the original source, or null.
			 *   - column: The column number in the original source, or null.
			 *   - name: The original identifier, or null.
			 */
			BasicSourceMapConsumer.prototype.originalPositionFor =
				function SourceMapConsumer_originalPositionFor(aArgs) {
					var needle = {
						generatedLine: util.getArg(aArgs, 'line'),
						generatedColumn: util.getArg(aArgs, 'column'),
					}

					var index = this._findMapping(
						needle,
						this._generatedMappings,
						'generatedLine',
						'generatedColumn',
						util.compareByGeneratedPositionsDeflated,
						util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND),
					)

					if (index >= 0) {
						var mapping = this._generatedMappings[index]

						if (mapping.generatedLine === needle.generatedLine) {
							var source = util.getArg(mapping, 'source', null)
							if (source !== null) {
								source = this._sources.at(source)
								if (this.sourceRoot != null) {
									source = util.join(this.sourceRoot, source)
								}
							}
							var name = util.getArg(mapping, 'name', null)
							if (name !== null) {
								name = this._names.at(name)
							}
							return {
								source: source,
								line: util.getArg(mapping, 'originalLine', null),
								column: util.getArg(mapping, 'originalColumn', null),
								name: name,
							}
						}
					}

					return {
						source: null,
						line: null,
						column: null,
						name: null,
					}
				}

			/**
			 * Return true if we have the source content for every source in the source
			 * map, false otherwise.
			 */
			BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
				function BasicSourceMapConsumer_hasContentsOfAllSources() {
					if (!this.sourcesContent) {
						return false
					}
					return (
						this.sourcesContent.length >= this._sources.size() &&
						!this.sourcesContent.some(function (sc) {
							return sc == null
						})
					)
				}

			/**
			 * Returns the original source content. The only argument is the url of the
			 * original source file. Returns null if no original source content is
			 * available.
			 */
			BasicSourceMapConsumer.prototype.sourceContentFor =
				function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
					if (!this.sourcesContent) {
						return null
					}

					if (this.sourceRoot != null) {
						aSource = util.relative(this.sourceRoot, aSource)
					}

					if (this._sources.has(aSource)) {
						return this.sourcesContent[this._sources.indexOf(aSource)]
					}

					var url
					if (
						this.sourceRoot != null &&
						(url = util.urlParse(this.sourceRoot))
					) {
						// XXX: file:// URIs and absolute paths lead to unexpected behavior for
						// many users. We can help them out when they expect file:// URIs to
						// behave like it would if they were running a local HTTP server. See
						// https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
						var fileUriAbsPath = aSource.replace(/^file:\/\//, '')
						if (url.scheme == 'file' && this._sources.has(fileUriAbsPath)) {
							return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
						}

						if (
							(!url.path || url.path == '/') &&
							this._sources.has('/' + aSource)
						) {
							return this.sourcesContent[this._sources.indexOf('/' + aSource)]
						}
					}

					// This function is used recursively from
					// IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
					// don't want to throw if we can't find the source - we just want to
					// return null, so we provide a flag to exit gracefully.
					if (nullOnMissing) {
						return null
					} else {
						throw new Error('"' + aSource + '" is not in the SourceMap.')
					}
				}

			/**
			 * Returns the generated line and column information for the original source,
			 * line, and column positions provided. The only argument is an object with
			 * the following properties:
			 *
			 *   - source: The filename of the original source.
			 *   - line: The line number in the original source.
			 *   - column: The column number in the original source.
			 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
			 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
			 *     closest element that is smaller than or greater than the one we are
			 *     searching for, respectively, if the exact element cannot be found.
			 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
			 *
			 * and an object is returned with the following properties:
			 *
			 *   - line: The line number in the generated source, or null.
			 *   - column: The column number in the generated source, or null.
			 */
			BasicSourceMapConsumer.prototype.generatedPositionFor =
				function SourceMapConsumer_generatedPositionFor(aArgs) {
					var source = util.getArg(aArgs, 'source')
					if (this.sourceRoot != null) {
						source = util.relative(this.sourceRoot, source)
					}
					if (!this._sources.has(source)) {
						return {
							line: null,
							column: null,
							lastColumn: null,
						}
					}
					source = this._sources.indexOf(source)

					var needle = {
						source: source,
						originalLine: util.getArg(aArgs, 'line'),
						originalColumn: util.getArg(aArgs, 'column'),
					}

					var index = this._findMapping(
						needle,
						this._originalMappings,
						'originalLine',
						'originalColumn',
						util.compareByOriginalPositions,
						util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND),
					)

					if (index >= 0) {
						var mapping = this._originalMappings[index]

						if (mapping.source === needle.source) {
							return {
								line: util.getArg(mapping, 'generatedLine', null),
								column: util.getArg(mapping, 'generatedColumn', null),
								lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null),
							}
						}
					}

					return {
						line: null,
						column: null,
						lastColumn: null,
					}
				}

			__webpack_unused_export__ = BasicSourceMapConsumer

			/**
			 * An IndexedSourceMapConsumer instance represents a parsed source map which
			 * we can query for information. It differs from BasicSourceMapConsumer in
			 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
			 * input.
			 *
			 * The only parameter is a raw source map (either as a JSON string, or already
			 * parsed to an object). According to the spec for indexed source maps, they
			 * have the following attributes:
			 *
			 *   - version: Which version of the source map spec this map is following.
			 *   - file: Optional. The generated file this source map is associated with.
			 *   - sections: A list of section definitions.
			 *
			 * Each value under the "sections" field has two fields:
			 *   - offset: The offset into the original specified at which this section
			 *       begins to apply, defined as an object with a "line" and "column"
			 *       field.
			 *   - map: A source map definition. This source map could also be indexed,
			 *       but doesn't have to be.
			 *
			 * Instead of the "map" field, it's also possible to have a "url" field
			 * specifying a URL to retrieve a source map from, but that's currently
			 * unsupported.
			 *
			 * Here's an example source map, taken from the source map spec[0], but
			 * modified to omit a section which uses the "url" field.
			 *
			 *  {
			 *    version : 3,
			 *    file: "app.js",
			 *    sections: [{
			 *      offset: {line:100, column:10},
			 *      map: {
			 *        version : 3,
			 *        file: "section.js",
			 *        sources: ["foo.js", "bar.js"],
			 *        names: ["src", "maps", "are", "fun"],
			 *        mappings: "AAAA,E;;ABCDE;"
			 *      }
			 *    }],
			 *  }
			 *
			 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
			 */
			function IndexedSourceMapConsumer(aSourceMap) {
				var sourceMap = aSourceMap
				if (typeof aSourceMap === 'string') {
					sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''))
				}

				var version = util.getArg(sourceMap, 'version')
				var sections = util.getArg(sourceMap, 'sections')

				if (version != this._version) {
					throw new Error('Unsupported version: ' + version)
				}

				this._sources = new ArraySet()
				this._names = new ArraySet()

				var lastOffset = {
					line: -1,
					column: 0,
				}
				this._sections = sections.map(function (s) {
					if (s.url) {
						// The url field will require support for asynchronicity.
						// See https://github.com/mozilla/source-map/issues/16
						throw new Error(
							'Support for url field in sections not implemented.',
						)
					}
					var offset = util.getArg(s, 'offset')
					var offsetLine = util.getArg(offset, 'line')
					var offsetColumn = util.getArg(offset, 'column')

					if (
						offsetLine < lastOffset.line ||
						(offsetLine === lastOffset.line && offsetColumn < lastOffset.column)
					) {
						throw new Error(
							'Section offsets must be ordered and non-overlapping.',
						)
					}
					lastOffset = offset

					return {
						generatedOffset: {
							// The offset fields are 0-based, but we use 1-based indices when
							// encoding/decoding from VLQ.
							generatedLine: offsetLine + 1,
							generatedColumn: offsetColumn + 1,
						},
						consumer: new SourceMapConsumer(util.getArg(s, 'map')),
					}
				})
			}

			IndexedSourceMapConsumer.prototype = Object.create(
				SourceMapConsumer.prototype,
			)
			IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer

			/**
			 * The version of the source mapping spec that we are consuming.
			 */
			IndexedSourceMapConsumer.prototype._version = 3

			/**
			 * The list of original sources.
			 */
			Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
				get: function () {
					var sources = []
					for (var i = 0; i < this._sections.length; i++) {
						for (
							var j = 0;
							j < this._sections[i].consumer.sources.length;
							j++
						) {
							sources.push(this._sections[i].consumer.sources[j])
						}
					}
					return sources
				},
			})

			/**
			 * Returns the original source, line, and column information for the generated
			 * source's line and column positions provided. The only argument is an object
			 * with the following properties:
			 *
			 *   - line: The line number in the generated source.
			 *   - column: The column number in the generated source.
			 *
			 * and an object is returned with the following properties:
			 *
			 *   - source: The original source file, or null.
			 *   - line: The line number in the original source, or null.
			 *   - column: The column number in the original source, or null.
			 *   - name: The original identifier, or null.
			 */
			IndexedSourceMapConsumer.prototype.originalPositionFor =
				function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
					var needle = {
						generatedLine: util.getArg(aArgs, 'line'),
						generatedColumn: util.getArg(aArgs, 'column'),
					}

					// Find the section containing the generated position we're trying to map
					// to an original position.
					var sectionIndex = binarySearch.search(
						needle,
						this._sections,
						function (needle, section) {
							var cmp =
								needle.generatedLine - section.generatedOffset.generatedLine
							if (cmp) {
								return cmp
							}

							return (
								needle.generatedColumn - section.generatedOffset.generatedColumn
							)
						},
					)
					var section = this._sections[sectionIndex]

					if (!section) {
						return {
							source: null,
							line: null,
							column: null,
							name: null,
						}
					}

					return section.consumer.originalPositionFor({
						line:
							needle.generatedLine -
							(section.generatedOffset.generatedLine - 1),
						column:
							needle.generatedColumn -
							(section.generatedOffset.generatedLine === needle.generatedLine
								? section.generatedOffset.generatedColumn - 1
								: 0),
						bias: aArgs.bias,
					})
				}

			/**
			 * Return true if we have the source content for every source in the source
			 * map, false otherwise.
			 */
			IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
				function IndexedSourceMapConsumer_hasContentsOfAllSources() {
					return this._sections.every(function (s) {
						return s.consumer.hasContentsOfAllSources()
					})
				}

			/**
			 * Returns the original source content. The only argument is the url of the
			 * original source file. Returns null if no original source content is
			 * available.
			 */
			IndexedSourceMapConsumer.prototype.sourceContentFor =
				function IndexedSourceMapConsumer_sourceContentFor(
					aSource,
					nullOnMissing,
				) {
					for (var i = 0; i < this._sections.length; i++) {
						var section = this._sections[i]

						var content = section.consumer.sourceContentFor(aSource, true)
						if (content) {
							return content
						}
					}
					if (nullOnMissing) {
						return null
					} else {
						throw new Error('"' + aSource + '" is not in the SourceMap.')
					}
				}

			/**
			 * Returns the generated line and column information for the original source,
			 * line, and column positions provided. The only argument is an object with
			 * the following properties:
			 *
			 *   - source: The filename of the original source.
			 *   - line: The line number in the original source.
			 *   - column: The column number in the original source.
			 *
			 * and an object is returned with the following properties:
			 *
			 *   - line: The line number in the generated source, or null.
			 *   - column: The column number in the generated source, or null.
			 */
			IndexedSourceMapConsumer.prototype.generatedPositionFor =
				function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
					for (var i = 0; i < this._sections.length; i++) {
						var section = this._sections[i]

						// Only consider this section if the requested source is in the list of
						// sources of the consumer.
						if (
							section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) ===
							-1
						) {
							continue
						}
						var generatedPosition = section.consumer.generatedPositionFor(aArgs)
						if (generatedPosition) {
							var ret = {
								line:
									generatedPosition.line +
									(section.generatedOffset.generatedLine - 1),
								column:
									generatedPosition.column +
									(section.generatedOffset.generatedLine ===
									generatedPosition.line
										? section.generatedOffset.generatedColumn - 1
										: 0),
							}
							return ret
						}
					}

					return {
						line: null,
						column: null,
					}
				}

			/**
			 * Parse the mappings in a string in to a data structure which we can easily
			 * query (the ordered arrays in the `this.__generatedMappings` and
			 * `this.__originalMappings` properties).
			 */
			IndexedSourceMapConsumer.prototype._parseMappings =
				function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
					this.__generatedMappings = []
					this.__originalMappings = []
					for (var i = 0; i < this._sections.length; i++) {
						var section = this._sections[i]
						var sectionMappings = section.consumer._generatedMappings
						for (var j = 0; j < sectionMappings.length; j++) {
							var mapping = sectionMappings[j]

							var source = section.consumer._sources.at(mapping.source)
							if (section.consumer.sourceRoot !== null) {
								source = util.join(section.consumer.sourceRoot, source)
							}
							this._sources.add(source)
							source = this._sources.indexOf(source)

							var name = section.consumer._names.at(mapping.name)
							this._names.add(name)
							name = this._names.indexOf(name)

							// The mappings coming from the consumer for the section have
							// generated positions relative to the start of the section, so we
							// need to offset them to be relative to the start of the concatenated
							// generated file.
							var adjustedMapping = {
								source: source,
								generatedLine:
									mapping.generatedLine +
									(section.generatedOffset.generatedLine - 1),
								generatedColumn:
									mapping.generatedColumn +
									(section.generatedOffset.generatedLine ===
									mapping.generatedLine
										? section.generatedOffset.generatedColumn - 1
										: 0),
								originalLine: mapping.originalLine,
								originalColumn: mapping.originalColumn,
								name: name,
							}

							this.__generatedMappings.push(adjustedMapping)
							if (typeof adjustedMapping.originalLine === 'number') {
								this.__originalMappings.push(adjustedMapping)
							}
						}
					}

					quickSort(
						this.__generatedMappings,
						util.compareByGeneratedPositionsDeflated,
					)
					quickSort(this.__originalMappings, util.compareByOriginalPositions)
				}

			__webpack_unused_export__ = IndexedSourceMapConsumer

			/***/
		},

		/***/ 62574: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			/* -*- Mode: js; js-indent-level: 2; -*- */
			/*
			 * Copyright 2011 Mozilla Foundation and contributors
			 * Licensed under the New BSD license. See LICENSE or:
			 * http://opensource.org/licenses/BSD-3-Clause
			 */

			var base64VLQ = __nccwpck_require__(27935)
			var util = __nccwpck_require__(62492)
			var ArraySet = __nccwpck_require__(76934) /* .ArraySet */.C
			var MappingList = __nccwpck_require__(12861) /* .MappingList */.P

			/**
			 * An instance of the SourceMapGenerator represents a source map which is
			 * being built incrementally. You may pass an object with the following
			 * properties:
			 *
			 *   - file: The filename of the generated source.
			 *   - sourceRoot: A root for all relative URLs in this source map.
			 */
			function SourceMapGenerator(aArgs) {
				if (!aArgs) {
					aArgs = {}
				}
				this._file = util.getArg(aArgs, 'file', null)
				this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null)
				this._skipValidation = util.getArg(aArgs, 'skipValidation', false)
				this._sources = new ArraySet()
				this._names = new ArraySet()
				this._mappings = new MappingList()
				this._sourcesContents = null
			}

			SourceMapGenerator.prototype._version = 3

			/**
			 * Creates a new SourceMapGenerator based on a SourceMapConsumer
			 *
			 * @param aSourceMapConsumer The SourceMap.
			 */
			SourceMapGenerator.fromSourceMap =
				function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
					var sourceRoot = aSourceMapConsumer.sourceRoot
					var generator = new SourceMapGenerator({
						file: aSourceMapConsumer.file,
						sourceRoot: sourceRoot,
					})
					aSourceMapConsumer.eachMapping(function (mapping) {
						var newMapping = {
							generated: {
								line: mapping.generatedLine,
								column: mapping.generatedColumn,
							},
						}

						if (mapping.source != null) {
							newMapping.source = mapping.source
							if (sourceRoot != null) {
								newMapping.source = util.relative(sourceRoot, newMapping.source)
							}

							newMapping.original = {
								line: mapping.originalLine,
								column: mapping.originalColumn,
							}

							if (mapping.name != null) {
								newMapping.name = mapping.name
							}
						}

						generator.addMapping(newMapping)
					})
					aSourceMapConsumer.sources.forEach(function (sourceFile) {
						var content = aSourceMapConsumer.sourceContentFor(sourceFile)
						if (content != null) {
							generator.setSourceContent(sourceFile, content)
						}
					})
					return generator
				}

			/**
			 * Add a single mapping from original source line and column to the generated
			 * source's line and column for this source map being created. The mapping
			 * object should have the following properties:
			 *
			 *   - generated: An object with the generated line and column positions.
			 *   - original: An object with the original line and column positions.
			 *   - source: The original source file (relative to the sourceRoot).
			 *   - name: An optional original token name for this mapping.
			 */
			SourceMapGenerator.prototype.addMapping =
				function SourceMapGenerator_addMapping(aArgs) {
					var generated = util.getArg(aArgs, 'generated')
					var original = util.getArg(aArgs, 'original', null)
					var source = util.getArg(aArgs, 'source', null)
					var name = util.getArg(aArgs, 'name', null)

					if (!this._skipValidation) {
						this._validateMapping(generated, original, source, name)
					}

					if (source != null) {
						source = String(source)
						if (!this._sources.has(source)) {
							this._sources.add(source)
						}
					}

					if (name != null) {
						name = String(name)
						if (!this._names.has(name)) {
							this._names.add(name)
						}
					}

					this._mappings.add({
						generatedLine: generated.line,
						generatedColumn: generated.column,
						originalLine: original != null && original.line,
						originalColumn: original != null && original.column,
						source: source,
						name: name,
					})
				}

			/**
			 * Set the source content for a source file.
			 */
			SourceMapGenerator.prototype.setSourceContent =
				function SourceMapGenerator_setSourceContent(
					aSourceFile,
					aSourceContent,
				) {
					var source = aSourceFile
					if (this._sourceRoot != null) {
						source = util.relative(this._sourceRoot, source)
					}

					if (aSourceContent != null) {
						// Add the source content to the _sourcesContents map.
						// Create a new _sourcesContents map if the property is null.
						if (!this._sourcesContents) {
							this._sourcesContents = Object.create(null)
						}
						this._sourcesContents[util.toSetString(source)] = aSourceContent
					} else if (this._sourcesContents) {
						// Remove the source file from the _sourcesContents map.
						// If the _sourcesContents map is empty, set the property to null.
						delete this._sourcesContents[util.toSetString(source)]
						if (Object.keys(this._sourcesContents).length === 0) {
							this._sourcesContents = null
						}
					}
				}

			/**
			 * Applies the mappings of a sub-source-map for a specific source file to the
			 * source map being generated. Each mapping to the supplied source file is
			 * rewritten using the supplied source map. Note: The resolution for the
			 * resulting mappings is the minimium of this map and the supplied map.
			 *
			 * @param aSourceMapConsumer The source map to be applied.
			 * @param aSourceFile Optional. The filename of the source file.
			 *        If omitted, SourceMapConsumer's file property will be used.
			 * @param aSourceMapPath Optional. The dirname of the path to the source map
			 *        to be applied. If relative, it is relative to the SourceMapConsumer.
			 *        This parameter is needed when the two source maps aren't in the same
			 *        directory, and the source map to be applied contains relative source
			 *        paths. If so, those relative source paths need to be rewritten
			 *        relative to the SourceMapGenerator.
			 */
			SourceMapGenerator.prototype.applySourceMap =
				function SourceMapGenerator_applySourceMap(
					aSourceMapConsumer,
					aSourceFile,
					aSourceMapPath,
				) {
					var sourceFile = aSourceFile
					// If aSourceFile is omitted, we will use the file property of the SourceMap
					if (aSourceFile == null) {
						if (aSourceMapConsumer.file == null) {
							throw new Error(
								'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
									'or the source map\'s "file" property. Both were omitted.',
							)
						}
						sourceFile = aSourceMapConsumer.file
					}
					var sourceRoot = this._sourceRoot
					// Make "sourceFile" relative if an absolute Url is passed.
					if (sourceRoot != null) {
						sourceFile = util.relative(sourceRoot, sourceFile)
					}
					// Applying the SourceMap can add and remove items from the sources and
					// the names array.
					var newSources = new ArraySet()
					var newNames = new ArraySet()

					// Find mappings for the "sourceFile"
					this._mappings.unsortedForEach(function (mapping) {
						if (mapping.source === sourceFile && mapping.originalLine != null) {
							// Check if it can be mapped by the source map, then update the mapping.
							var original = aSourceMapConsumer.originalPositionFor({
								line: mapping.originalLine,
								column: mapping.originalColumn,
							})
							if (original.source != null) {
								// Copy mapping
								mapping.source = original.source
								if (aSourceMapPath != null) {
									mapping.source = util.join(aSourceMapPath, mapping.source)
								}
								if (sourceRoot != null) {
									mapping.source = util.relative(sourceRoot, mapping.source)
								}
								mapping.originalLine = original.line
								mapping.originalColumn = original.column
								if (original.name != null) {
									mapping.name = original.name
								}
							}
						}

						var source = mapping.source
						if (source != null && !newSources.has(source)) {
							newSources.add(source)
						}

						var name = mapping.name
						if (name != null && !newNames.has(name)) {
							newNames.add(name)
						}
					}, this)
					this._sources = newSources
					this._names = newNames

					// Copy sourcesContents of applied map.
					aSourceMapConsumer.sources.forEach(function (sourceFile) {
						var content = aSourceMapConsumer.sourceContentFor(sourceFile)
						if (content != null) {
							if (aSourceMapPath != null) {
								sourceFile = util.join(aSourceMapPath, sourceFile)
							}
							if (sourceRoot != null) {
								sourceFile = util.relative(sourceRoot, sourceFile)
							}
							this.setSourceContent(sourceFile, content)
						}
					}, this)
				}

			/**
			 * A mapping can have one of the three levels of data:
			 *
			 *   1. Just the generated position.
			 *   2. The Generated position, original position, and original source.
			 *   3. Generated and original position, original source, as well as a name
			 *      token.
			 *
			 * To maintain consistency, we validate that any new mapping being added falls
			 * in to one of these categories.
			 */
			SourceMapGenerator.prototype._validateMapping =
				function SourceMapGenerator_validateMapping(
					aGenerated,
					aOriginal,
					aSource,
					aName,
				) {
					// When aOriginal is truthy but has empty values for .line and .column,
					// it is most likely a programmer error. In this case we throw a very
					// specific error message to try to guide them the right way.
					// For example: https://github.com/Polymer/polymer-bundler/pull/519
					if (
						aOriginal &&
						typeof aOriginal.line !== 'number' &&
						typeof aOriginal.column !== 'number'
					) {
						throw new Error(
							'original.line and original.column are not numbers -- you probably meant to omit ' +
								'the original mapping entirely and only map the generated position. If so, pass ' +
								'null for the original mapping instead of an object with empty or null values.',
						)
					}

					if (
						aGenerated &&
						'line' in aGenerated &&
						'column' in aGenerated &&
						aGenerated.line > 0 &&
						aGenerated.column >= 0 &&
						!aOriginal &&
						!aSource &&
						!aName
					) {
						// Case 1.
						return
					} else if (
						aGenerated &&
						'line' in aGenerated &&
						'column' in aGenerated &&
						aOriginal &&
						'line' in aOriginal &&
						'column' in aOriginal &&
						aGenerated.line > 0 &&
						aGenerated.column >= 0 &&
						aOriginal.line > 0 &&
						aOriginal.column >= 0 &&
						aSource
					) {
						// Cases 2 and 3.
						return
					} else {
						throw new Error(
							'Invalid mapping: ' +
								JSON.stringify({
									generated: aGenerated,
									source: aSource,
									original: aOriginal,
									name: aName,
								}),
						)
					}
				}

			/**
			 * Serialize the accumulated mappings in to the stream of base 64 VLQs
			 * specified by the source map format.
			 */
			SourceMapGenerator.prototype._serializeMappings =
				function SourceMapGenerator_serializeMappings() {
					var previousGeneratedColumn = 0
					var previousGeneratedLine = 1
					var previousOriginalColumn = 0
					var previousOriginalLine = 0
					var previousName = 0
					var previousSource = 0
					var result = ''
					var next
					var mapping
					var nameIdx
					var sourceIdx

					var mappings = this._mappings.toArray()
					for (var i = 0, len = mappings.length; i < len; i++) {
						mapping = mappings[i]
						next = ''

						if (mapping.generatedLine !== previousGeneratedLine) {
							previousGeneratedColumn = 0
							while (mapping.generatedLine !== previousGeneratedLine) {
								next += ';'
								previousGeneratedLine++
							}
						} else {
							if (i > 0) {
								if (
									!util.compareByGeneratedPositionsInflated(
										mapping,
										mappings[i - 1],
									)
								) {
									continue
								}
								next += ','
							}
						}

						next += base64VLQ.encode(
							mapping.generatedColumn - previousGeneratedColumn,
						)
						previousGeneratedColumn = mapping.generatedColumn

						if (mapping.source != null) {
							sourceIdx = this._sources.indexOf(mapping.source)
							next += base64VLQ.encode(sourceIdx - previousSource)
							previousSource = sourceIdx

							// lines are stored 0-based in SourceMap spec version 3
							next += base64VLQ.encode(
								mapping.originalLine - 1 - previousOriginalLine,
							)
							previousOriginalLine = mapping.originalLine - 1

							next += base64VLQ.encode(
								mapping.originalColumn - previousOriginalColumn,
							)
							previousOriginalColumn = mapping.originalColumn

							if (mapping.name != null) {
								nameIdx = this._names.indexOf(mapping.name)
								next += base64VLQ.encode(nameIdx - previousName)
								previousName = nameIdx
							}
						}

						result += next
					}

					return result
				}

			SourceMapGenerator.prototype._generateSourcesContent =
				function SourceMapGenerator_generateSourcesContent(
					aSources,
					aSourceRoot,
				) {
					return aSources.map(function (source) {
						if (!this._sourcesContents) {
							return null
						}
						if (aSourceRoot != null) {
							source = util.relative(aSourceRoot, source)
						}
						var key = util.toSetString(source)
						return Object.prototype.hasOwnProperty.call(
							this._sourcesContents,
							key,
						)
							? this._sourcesContents[key]
							: null
					}, this)
				}

			/**
			 * Externalize the source map.
			 */
			SourceMapGenerator.prototype.toJSON =
				function SourceMapGenerator_toJSON() {
					var map = {
						version: this._version,
						sources: this._sources.toArray(),
						names: this._names.toArray(),
						mappings: this._serializeMappings(),
					}
					if (this._file != null) {
						map.file = this._file
					}
					if (this._sourceRoot != null) {
						map.sourceRoot = this._sourceRoot
					}
					if (this._sourcesContents) {
						map.sourcesContent = this._generateSourcesContent(
							map.sources,
							map.sourceRoot,
						)
					}

					return map
				}

			/**
			 * Render the source map being generated to a string.
			 */
			SourceMapGenerator.prototype.toString =
				function SourceMapGenerator_toString() {
					return JSON.stringify(this.toJSON())
				}

			exports.SourceMapGenerator = SourceMapGenerator

			/***/
		},

		/***/ 49706: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			/* -*- Mode: js; js-indent-level: 2; -*- */
			/*
			 * Copyright 2011 Mozilla Foundation and contributors
			 * Licensed under the New BSD license. See LICENSE or:
			 * http://opensource.org/licenses/BSD-3-Clause
			 */

			var SourceMapGenerator = __nccwpck_require__(62574).SourceMapGenerator
			var util = __nccwpck_require__(62492)

			// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
			// operating systems these days (capturing the result).
			var REGEX_NEWLINE = /(\r?\n)/

			// Newline character code for charCodeAt() comparisons
			var NEWLINE_CODE = 10

			// Private symbol for identifying `SourceNode`s when multiple versions of
			// the source-map library are loaded. This MUST NOT CHANGE across
			// versions!
			var isSourceNode = '$$$isSourceNode$$$'

			/**
			 * SourceNodes provide a way to abstract over interpolating/concatenating
			 * snippets of generated JavaScript source code while maintaining the line and
			 * column information associated with the original source code.
			 *
			 * @param aLine The original line number.
			 * @param aColumn The original column number.
			 * @param aSource The original source's filename.
			 * @param aChunks Optional. An array of strings which are snippets of
			 *        generated JS, or other SourceNodes.
			 * @param aName The original identifier.
			 */
			function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
				this.children = []
				this.sourceContents = {}
				this.line = aLine == null ? null : aLine
				this.column = aColumn == null ? null : aColumn
				this.source = aSource == null ? null : aSource
				this.name = aName == null ? null : aName
				this[isSourceNode] = true
				if (aChunks != null) this.add(aChunks)
			}

			/**
			 * Creates a SourceNode from generated code and a SourceMapConsumer.
			 *
			 * @param aGeneratedCode The generated code
			 * @param aSourceMapConsumer The SourceMap for the generated code
			 * @param aRelativePath Optional. The path that relative sources in the
			 *        SourceMapConsumer should be relative to.
			 */
			SourceNode.fromStringWithSourceMap =
				function SourceNode_fromStringWithSourceMap(
					aGeneratedCode,
					aSourceMapConsumer,
					aRelativePath,
				) {
					// The SourceNode we want to fill with the generated code
					// and the SourceMap
					var node = new SourceNode()

					// All even indices of this array are one line of the generated code,
					// while all odd indices are the newlines between two adjacent lines
					// (since `REGEX_NEWLINE` captures its match).
					// Processed fragments are accessed by calling `shiftNextLine`.
					var remainingLines = aGeneratedCode.split(REGEX_NEWLINE)
					var remainingLinesIndex = 0
					var shiftNextLine = function () {
						var lineContents = getNextLine()
						// The last line of a file might not have a newline.
						var newLine = getNextLine() || ''
						return lineContents + newLine

						function getNextLine() {
							return remainingLinesIndex < remainingLines.length
								? remainingLines[remainingLinesIndex++]
								: undefined
						}
					}

					// We need to remember the position of "remainingLines"
					var lastGeneratedLine = 1,
						lastGeneratedColumn = 0

					// The generate SourceNodes we need a code range.
					// To extract it current and last mapping is used.
					// Here we store the last mapping.
					var lastMapping = null

					aSourceMapConsumer.eachMapping(function (mapping) {
						if (lastMapping !== null) {
							// We add the code from "lastMapping" to "mapping":
							// First check if there is a new line in between.
							if (lastGeneratedLine < mapping.generatedLine) {
								// Associate first line with "lastMapping"
								addMappingWithCode(lastMapping, shiftNextLine())
								lastGeneratedLine++
								lastGeneratedColumn = 0
								// The remaining code is added without mapping
							} else {
								// There is no new line in between.
								// Associate the code between "lastGeneratedColumn" and
								// "mapping.generatedColumn" with "lastMapping"
								var nextLine = remainingLines[remainingLinesIndex]
								var code = nextLine.substr(
									0,
									mapping.generatedColumn - lastGeneratedColumn,
								)
								remainingLines[remainingLinesIndex] = nextLine.substr(
									mapping.generatedColumn - lastGeneratedColumn,
								)
								lastGeneratedColumn = mapping.generatedColumn
								addMappingWithCode(lastMapping, code)
								// No more remaining code, continue
								lastMapping = mapping
								return
							}
						}
						// We add the generated code until the first mapping
						// to the SourceNode without any mapping.
						// Each line is added as separate string.
						while (lastGeneratedLine < mapping.generatedLine) {
							node.add(shiftNextLine())
							lastGeneratedLine++
						}
						if (lastGeneratedColumn < mapping.generatedColumn) {
							var nextLine = remainingLines[remainingLinesIndex]
							node.add(nextLine.substr(0, mapping.generatedColumn))
							remainingLines[remainingLinesIndex] = nextLine.substr(
								mapping.generatedColumn,
							)
							lastGeneratedColumn = mapping.generatedColumn
						}
						lastMapping = mapping
					}, this)
					// We have processed all mappings.
					if (remainingLinesIndex < remainingLines.length) {
						if (lastMapping) {
							// Associate the remaining code in the current line with "lastMapping"
							addMappingWithCode(lastMapping, shiftNextLine())
						}
						// and add the remaining lines without any mapping
						node.add(remainingLines.splice(remainingLinesIndex).join(''))
					}

					// Copy sourcesContent into SourceNode
					aSourceMapConsumer.sources.forEach(function (sourceFile) {
						var content = aSourceMapConsumer.sourceContentFor(sourceFile)
						if (content != null) {
							if (aRelativePath != null) {
								sourceFile = util.join(aRelativePath, sourceFile)
							}
							node.setSourceContent(sourceFile, content)
						}
					})

					return node

					function addMappingWithCode(mapping, code) {
						if (mapping === null || mapping.source === undefined) {
							node.add(code)
						} else {
							var source = aRelativePath
								? util.join(aRelativePath, mapping.source)
								: mapping.source
							node.add(
								new SourceNode(
									mapping.originalLine,
									mapping.originalColumn,
									source,
									code,
									mapping.name,
								),
							)
						}
					}
				}

			/**
			 * Add a chunk of generated JS to this source node.
			 *
			 * @param aChunk A string snippet of generated JS code, another instance of
			 *        SourceNode, or an array where each member is one of those things.
			 */
			SourceNode.prototype.add = function SourceNode_add(aChunk) {
				if (Array.isArray(aChunk)) {
					aChunk.forEach(function (chunk) {
						this.add(chunk)
					}, this)
				} else if (aChunk[isSourceNode] || typeof aChunk === 'string') {
					if (aChunk) {
						this.children.push(aChunk)
					}
				} else {
					throw new TypeError(
						'Expected a SourceNode, string, or an array of SourceNodes and strings. Got ' +
							aChunk,
					)
				}
				return this
			}

			/**
			 * Add a chunk of generated JS to the beginning of this source node.
			 *
			 * @param aChunk A string snippet of generated JS code, another instance of
			 *        SourceNode, or an array where each member is one of those things.
			 */
			SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
				if (Array.isArray(aChunk)) {
					for (var i = aChunk.length - 1; i >= 0; i--) {
						this.prepend(aChunk[i])
					}
				} else if (aChunk[isSourceNode] || typeof aChunk === 'string') {
					this.children.unshift(aChunk)
				} else {
					throw new TypeError(
						'Expected a SourceNode, string, or an array of SourceNodes and strings. Got ' +
							aChunk,
					)
				}
				return this
			}

			/**
			 * Walk over the tree of JS snippets in this node and its children. The
			 * walking function is called once for each snippet of JS and is passed that
			 * snippet and the its original associated source's line/column location.
			 *
			 * @param aFn The traversal function.
			 */
			SourceNode.prototype.walk = function SourceNode_walk(aFn) {
				var chunk
				for (var i = 0, len = this.children.length; i < len; i++) {
					chunk = this.children[i]
					if (chunk[isSourceNode]) {
						chunk.walk(aFn)
					} else {
						if (chunk !== '') {
							aFn(chunk, {
								source: this.source,
								line: this.line,
								column: this.column,
								name: this.name,
							})
						}
					}
				}
			}

			/**
			 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
			 * each of `this.children`.
			 *
			 * @param aSep The separator.
			 */
			SourceNode.prototype.join = function SourceNode_join(aSep) {
				var newChildren
				var i
				var len = this.children.length
				if (len > 0) {
					newChildren = []
					for (i = 0; i < len - 1; i++) {
						newChildren.push(this.children[i])
						newChildren.push(aSep)
					}
					newChildren.push(this.children[i])
					this.children = newChildren
				}
				return this
			}

			/**
			 * Call String.prototype.replace on the very right-most source snippet. Useful
			 * for trimming whitespace from the end of a source node, etc.
			 *
			 * @param aPattern The pattern to replace.
			 * @param aReplacement The thing to replace the pattern with.
			 */
			SourceNode.prototype.replaceRight = function SourceNode_replaceRight(
				aPattern,
				aReplacement,
			) {
				var lastChild = this.children[this.children.length - 1]
				if (lastChild[isSourceNode]) {
					lastChild.replaceRight(aPattern, aReplacement)
				} else if (typeof lastChild === 'string') {
					this.children[this.children.length - 1] = lastChild.replace(
						aPattern,
						aReplacement,
					)
				} else {
					this.children.push(''.replace(aPattern, aReplacement))
				}
				return this
			}

			/**
			 * Set the source content for a source file. This will be added to the SourceMapGenerator
			 * in the sourcesContent field.
			 *
			 * @param aSourceFile The filename of the source file
			 * @param aSourceContent The content of the source file
			 */
			SourceNode.prototype.setSourceContent =
				function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
					this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent
				}

			/**
			 * Walk over the tree of SourceNodes. The walking function is called for each
			 * source file content and is passed the filename and source content.
			 *
			 * @param aFn The traversal function.
			 */
			SourceNode.prototype.walkSourceContents =
				function SourceNode_walkSourceContents(aFn) {
					for (var i = 0, len = this.children.length; i < len; i++) {
						if (this.children[i][isSourceNode]) {
							this.children[i].walkSourceContents(aFn)
						}
					}

					var sources = Object.keys(this.sourceContents)
					for (var i = 0, len = sources.length; i < len; i++) {
						aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]])
					}
				}

			/**
			 * Return the string representation of this source node. Walks over the tree
			 * and concatenates all the various snippets together to one string.
			 */
			SourceNode.prototype.toString = function SourceNode_toString() {
				var str = ''
				this.walk(function (chunk) {
					str += chunk
				})
				return str
			}

			/**
			 * Returns the string representation of this source node along with a source
			 * map.
			 */
			SourceNode.prototype.toStringWithSourceMap =
				function SourceNode_toStringWithSourceMap(aArgs) {
					var generated = {
						code: '',
						line: 1,
						column: 0,
					}
					var map = new SourceMapGenerator(aArgs)
					var sourceMappingActive = false
					var lastOriginalSource = null
					var lastOriginalLine = null
					var lastOriginalColumn = null
					var lastOriginalName = null
					this.walk(function (chunk, original) {
						generated.code += chunk
						if (
							original.source !== null &&
							original.line !== null &&
							original.column !== null
						) {
							if (
								lastOriginalSource !== original.source ||
								lastOriginalLine !== original.line ||
								lastOriginalColumn !== original.column ||
								lastOriginalName !== original.name
							) {
								map.addMapping({
									source: original.source,
									original: {
										line: original.line,
										column: original.column,
									},
									generated: {
										line: generated.line,
										column: generated.column,
									},
									name: original.name,
								})
							}
							lastOriginalSource = original.source
							lastOriginalLine = original.line
							lastOriginalColumn = original.column
							lastOriginalName = original.name
							sourceMappingActive = true
						} else if (sourceMappingActive) {
							map.addMapping({
								generated: {
									line: generated.line,
									column: generated.column,
								},
							})
							lastOriginalSource = null
							sourceMappingActive = false
						}
						for (var idx = 0, length = chunk.length; idx < length; idx++) {
							if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
								generated.line++
								generated.column = 0
								// Mappings end at eol
								if (idx + 1 === length) {
									lastOriginalSource = null
									sourceMappingActive = false
								} else if (sourceMappingActive) {
									map.addMapping({
										source: original.source,
										original: {
											line: original.line,
											column: original.column,
										},
										generated: {
											line: generated.line,
											column: generated.column,
										},
										name: original.name,
									})
								}
							} else {
								generated.column++
							}
						}
					})
					this.walkSourceContents(function (sourceFile, sourceContent) {
						map.setSourceContent(sourceFile, sourceContent)
					})

					return { code: generated.code, map: map }
				}

			exports.SourceNode = SourceNode

			/***/
		},

		/***/ 62492: /***/ (__unused_webpack_module, exports) => {
			/* -*- Mode: js; js-indent-level: 2; -*- */
			/*
			 * Copyright 2011 Mozilla Foundation and contributors
			 * Licensed under the New BSD license. See LICENSE or:
			 * http://opensource.org/licenses/BSD-3-Clause
			 */

			/**
			 * This is a helper function for getting values from parameter/options
			 * objects.
			 *
			 * @param args The object we are extracting values from
			 * @param name The name of the property we are getting.
			 * @param defaultValue An optional value to return if the property is missing
			 * from the object. If this is not specified and the property is missing, an
			 * error will be thrown.
			 */
			function getArg(aArgs, aName, aDefaultValue) {
				if (aName in aArgs) {
					return aArgs[aName]
				} else if (arguments.length === 3) {
					return aDefaultValue
				} else {
					throw new Error('"' + aName + '" is a required argument.')
				}
			}
			exports.getArg = getArg

			var urlRegexp =
				/^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/
			var dataUrlRegexp = /^data:.+\,.+$/

			function urlParse(aUrl) {
				var match = aUrl.match(urlRegexp)
				if (!match) {
					return null
				}
				return {
					scheme: match[1],
					auth: match[2],
					host: match[3],
					port: match[4],
					path: match[5],
				}
			}
			exports.urlParse = urlParse

			function urlGenerate(aParsedUrl) {
				var url = ''
				if (aParsedUrl.scheme) {
					url += aParsedUrl.scheme + ':'
				}
				url += '//'
				if (aParsedUrl.auth) {
					url += aParsedUrl.auth + '@'
				}
				if (aParsedUrl.host) {
					url += aParsedUrl.host
				}
				if (aParsedUrl.port) {
					url += ':' + aParsedUrl.port
				}
				if (aParsedUrl.path) {
					url += aParsedUrl.path
				}
				return url
			}
			exports.urlGenerate = urlGenerate

			/**
			 * Normalizes a path, or the path portion of a URL:
			 *
			 * - Replaces consecutive slashes with one slash.
			 * - Removes unnecessary '.' parts.
			 * - Removes unnecessary '<dir>/..' parts.
			 *
			 * Based on code in the Node.js 'path' core module.
			 *
			 * @param aPath The path or url to normalize.
			 */
			function normalize(aPath) {
				var path = aPath
				var url = urlParse(aPath)
				if (url) {
					if (!url.path) {
						return aPath
					}
					path = url.path
				}
				var isAbsolute = exports.isAbsolute(path)

				var parts = path.split(/\/+/)
				for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
					part = parts[i]
					if (part === '.') {
						parts.splice(i, 1)
					} else if (part === '..') {
						up++
					} else if (up > 0) {
						if (part === '') {
							// The first part is blank if the path is absolute. Trying to go
							// above the root is a no-op. Therefore we can remove all '..' parts
							// directly after the root.
							parts.splice(i + 1, up)
							up = 0
						} else {
							parts.splice(i, 2)
							up--
						}
					}
				}
				path = parts.join('/')

				if (path === '') {
					path = isAbsolute ? '/' : '.'
				}

				if (url) {
					url.path = path
					return urlGenerate(url)
				}
				return path
			}
			exports.normalize = normalize

			/**
			 * Joins two paths/URLs.
			 *
			 * @param aRoot The root path or URL.
			 * @param aPath The path or URL to be joined with the root.
			 *
			 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
			 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
			 *   first.
			 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
			 *   is updated with the result and aRoot is returned. Otherwise the result
			 *   is returned.
			 *   - If aPath is absolute, the result is aPath.
			 *   - Otherwise the two paths are joined with a slash.
			 * - Joining for example 'http://' and 'www.example.com' is also supported.
			 */
			function join(aRoot, aPath) {
				if (aRoot === '') {
					aRoot = '.'
				}
				if (aPath === '') {
					aPath = '.'
				}
				var aPathUrl = urlParse(aPath)
				var aRootUrl = urlParse(aRoot)
				if (aRootUrl) {
					aRoot = aRootUrl.path || '/'
				}

				// `join(foo, '//www.example.org')`
				if (aPathUrl && !aPathUrl.scheme) {
					if (aRootUrl) {
						aPathUrl.scheme = aRootUrl.scheme
					}
					return urlGenerate(aPathUrl)
				}

				if (aPathUrl || aPath.match(dataUrlRegexp)) {
					return aPath
				}

				// `join('http://', 'www.example.com')`
				if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
					aRootUrl.host = aPath
					return urlGenerate(aRootUrl)
				}

				var joined =
					aPath.charAt(0) === '/'
						? aPath
						: normalize(aRoot.replace(/\/+$/, '') + '/' + aPath)

				if (aRootUrl) {
					aRootUrl.path = joined
					return urlGenerate(aRootUrl)
				}
				return joined
			}
			exports.join = join

			exports.isAbsolute = function (aPath) {
				return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp)
			}

			/**
			 * Make a path relative to a URL or another path.
			 *
			 * @param aRoot The root path or URL.
			 * @param aPath The path or URL to be made relative to aRoot.
			 */
			function relative(aRoot, aPath) {
				if (aRoot === '') {
					aRoot = '.'
				}

				aRoot = aRoot.replace(/\/$/, '')

				// It is possible for the path to be above the root. In this case, simply
				// checking whether the root is a prefix of the path won't work. Instead, we
				// need to remove components from the root one by one, until either we find
				// a prefix that fits, or we run out of components to remove.
				var level = 0
				while (aPath.indexOf(aRoot + '/') !== 0) {
					var index = aRoot.lastIndexOf('/')
					if (index < 0) {
						return aPath
					}

					// If the only part of the root that is left is the scheme (i.e. http://,
					// file:///, etc.), one or more slashes (/), or simply nothing at all, we
					// have exhausted all components, so the path is not relative to the root.
					aRoot = aRoot.slice(0, index)
					if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
						return aPath
					}

					++level
				}

				// Make sure we add a "../" for each component we removed from the root.
				return Array(level + 1).join('../') + aPath.substr(aRoot.length + 1)
			}
			exports.relative = relative

			var supportsNullProto = (function () {
				var obj = Object.create(null)
				return !('__proto__' in obj)
			})()

			function identity(s) {
				return s
			}

			/**
			 * Because behavior goes wacky when you set `__proto__` on objects, we
			 * have to prefix all the strings in our set with an arbitrary character.
			 *
			 * See https://github.com/mozilla/source-map/pull/31 and
			 * https://github.com/mozilla/source-map/issues/30
			 *
			 * @param String aStr
			 */
			function toSetString(aStr) {
				if (isProtoString(aStr)) {
					return '$' + aStr
				}

				return aStr
			}
			exports.toSetString = supportsNullProto ? identity : toSetString

			function fromSetString(aStr) {
				if (isProtoString(aStr)) {
					return aStr.slice(1)
				}

				return aStr
			}
			exports.fromSetString = supportsNullProto ? identity : fromSetString

			function isProtoString(s) {
				if (!s) {
					return false
				}

				var length = s.length

				if (length < 9 /* "__proto__".length */) {
					return false
				}

				if (
					s.charCodeAt(length - 1) !== 95 /* '_' */ ||
					s.charCodeAt(length - 2) !== 95 /* '_' */ ||
					s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
					s.charCodeAt(length - 4) !== 116 /* 't' */ ||
					s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
					s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
					s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
					s.charCodeAt(length - 8) !== 95 /* '_' */ ||
					s.charCodeAt(length - 9) !== 95 /* '_' */
				) {
					return false
				}

				for (var i = length - 10; i >= 0; i--) {
					if (s.charCodeAt(i) !== 36 /* '$' */) {
						return false
					}
				}

				return true
			}

			/**
			 * Comparator between two mappings where the original positions are compared.
			 *
			 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
			 * mappings with the same original source/line/column, but different generated
			 * line and column the same. Useful when searching for a mapping with a
			 * stubbed out mapping.
			 */
			function compareByOriginalPositions(
				mappingA,
				mappingB,
				onlyCompareOriginal,
			) {
				var cmp = mappingA.source - mappingB.source
				if (cmp !== 0) {
					return cmp
				}

				cmp = mappingA.originalLine - mappingB.originalLine
				if (cmp !== 0) {
					return cmp
				}

				cmp = mappingA.originalColumn - mappingB.originalColumn
				if (cmp !== 0 || onlyCompareOriginal) {
					return cmp
				}

				cmp = mappingA.generatedColumn - mappingB.generatedColumn
				if (cmp !== 0) {
					return cmp
				}

				cmp = mappingA.generatedLine - mappingB.generatedLine
				if (cmp !== 0) {
					return cmp
				}

				return mappingA.name - mappingB.name
			}
			exports.compareByOriginalPositions = compareByOriginalPositions

			/**
			 * Comparator between two mappings with deflated source and name indices where
			 * the generated positions are compared.
			 *
			 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
			 * mappings with the same generated line and column, but different
			 * source/name/original line and column the same. Useful when searching for a
			 * mapping with a stubbed out mapping.
			 */
			function compareByGeneratedPositionsDeflated(
				mappingA,
				mappingB,
				onlyCompareGenerated,
			) {
				var cmp = mappingA.generatedLine - mappingB.generatedLine
				if (cmp !== 0) {
					return cmp
				}

				cmp = mappingA.generatedColumn - mappingB.generatedColumn
				if (cmp !== 0 || onlyCompareGenerated) {
					return cmp
				}

				cmp = mappingA.source - mappingB.source
				if (cmp !== 0) {
					return cmp
				}

				cmp = mappingA.originalLine - mappingB.originalLine
				if (cmp !== 0) {
					return cmp
				}

				cmp = mappingA.originalColumn - mappingB.originalColumn
				if (cmp !== 0) {
					return cmp
				}

				return mappingA.name - mappingB.name
			}
			exports.compareByGeneratedPositionsDeflated =
				compareByGeneratedPositionsDeflated

			function strcmp(aStr1, aStr2) {
				if (aStr1 === aStr2) {
					return 0
				}

				if (aStr1 > aStr2) {
					return 1
				}

				return -1
			}

			/**
			 * Comparator between two mappings with inflated source and name strings where
			 * the generated positions are compared.
			 */
			function compareByGeneratedPositionsInflated(mappingA, mappingB) {
				var cmp = mappingA.generatedLine - mappingB.generatedLine
				if (cmp !== 0) {
					return cmp
				}

				cmp = mappingA.generatedColumn - mappingB.generatedColumn
				if (cmp !== 0) {
					return cmp
				}

				cmp = strcmp(mappingA.source, mappingB.source)
				if (cmp !== 0) {
					return cmp
				}

				cmp = mappingA.originalLine - mappingB.originalLine
				if (cmp !== 0) {
					return cmp
				}

				cmp = mappingA.originalColumn - mappingB.originalColumn
				if (cmp !== 0) {
					return cmp
				}

				return strcmp(mappingA.name, mappingB.name)
			}
			exports.compareByGeneratedPositionsInflated =
				compareByGeneratedPositionsInflated

			/***/
		},

		/***/ 62618: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			/*
			 * Copyright 2009-2011 Mozilla Foundation and contributors
			 * Licensed under the New BSD license. See LICENSE.txt or:
			 * http://opensource.org/licenses/BSD-3-Clause
			 */
			exports.SourceMapGenerator = __nccwpck_require__(62574).SourceMapGenerator
			exports.SourceMapConsumer = __nccwpck_require__(79907).SourceMapConsumer
			exports.SourceNode = __nccwpck_require__(49706).SourceNode

			/***/
		},

		/***/ 33600: /***/ (module) => {
			'use strict'

			module.exports = factory

			// Construct a state `toggler`: a function which inverses `property` in context
			// based on its current value.
			// The by `toggler` returned function restores that value.
			function factory(key, state, ctx) {
				return enter

				function enter() {
					var context = ctx || this
					var current = context[key]

					context[key] = !state

					return exit

					function exit() {
						context[key] = current
					}
				}
			}

			/***/
		},

		/***/ 55655: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			module.exports = __nccwpck_require__(22167)

			/***/
		},

		/***/ 41050: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			var entities = __nccwpck_require__(33757)

			var characters = {}
			var name

			module.exports = characters

			for (name in entities) {
				characters[entities[name]] = name
			}

			/***/
		},

		/***/ 41165: /***/ (module) => {
			module.exports = String.fromCharCode

			/***/
		},

		/***/ 12935: /***/ (module) => {
			module.exports = {}.hasOwnProperty

			/***/
		},

		/***/ 70896: /***/ (module) => {
			'use strict'

			module.exports = encode

			// Encode special characters in `value`.
			function encode(value, options) {
				value = value.replace(
					options.subset ? charactersToExpression(options.subset) : /["&'<>`]/g,
					basic,
				)

				if (options.subset || options.escapeOnly) {
					return value
				}

				return (
					value
						// Surrogate pairs.
						.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, surrogate)
						// BMP control characters (C0 except for LF, CR, SP; DEL; and some more
						// non-ASCII ones).
						.replace(
							// eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
							/[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g,
							basic,
						)
				)

				function surrogate(pair, index, all) {
					return options.format(
						(pair.charCodeAt(0) - 0xd800) * 0x400 +
							pair.charCodeAt(1) -
							0xdc00 +
							0x10000,
						all.charCodeAt(index + 2),
						options,
					)
				}

				function basic(character, index, all) {
					return options.format(
						character.charCodeAt(0),
						all.charCodeAt(index + 1),
						options,
					)
				}
			}

			function charactersToExpression(subset) {
				var groups = []
				var index = -1

				while (++index < subset.length) {
					groups.push(subset[index].replace(/[|\\{}()[\]^$+*?.]/g, '\\$&'))
				}

				return new RegExp('(?:' + groups.join('|') + ')', 'g')
			}

			/***/
		},

		/***/ 7057: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var xtend = __nccwpck_require__(80869)
			var core = __nccwpck_require__(70896)
			var smart = __nccwpck_require__(58549)

			module.exports = encode

			// Encode special characters in `value`.
			function encode(value, options) {
				// Note: Switch to `Object.assign` next major.
				return core(value, xtend(options, { format: smart }))
			}

			/***/
		},

		/***/ 94316: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var core = __nccwpck_require__(70896)
			var smart = __nccwpck_require__(58549)

			module.exports = escape

			// Shortcut to escape special characters in HTML.
			function escape(value) {
				return core(value, {
					escapeOnly: true,
					useNamedReferences: true,
					format: smart,
				})
			}

			/***/
		},

		/***/ 22167: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var encode = __nccwpck_require__(7057)
			var escape = __nccwpck_require__(94316)

			module.exports = encode
			encode.escape = escape

			/***/
		},

		/***/ 58549: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			module.exports = formatPretty

			var toHexadecimal = __nccwpck_require__(63849)
			var toDecimal = __nccwpck_require__(98653)
			var toNamed = __nccwpck_require__(89339)

			// Encode `character` according to `options`.
			function formatPretty(code, next, options) {
				var named
				var numeric
				var decimal

				if (options.useNamedReferences || options.useShortestReferences) {
					named = toNamed(
						code,
						next,
						options.omitOptionalSemicolons,
						options.attribute,
					)
				}

				if (options.useShortestReferences || !named) {
					numeric = toHexadecimal(code, next, options.omitOptionalSemicolons)

					// Use the shortest numeric reference when requested.
					// A simple algorithm would use decimal for all code points under 100, as
					// those are shorter than hexadecimal:
					//
					// * `&#99;` vs `&#x63;` (decimal shorter)
					// * `&#100;` vs `&#x64;` (equal)
					//
					// However, because we take `next` into consideration when `omit` is used,
					// And it would be possible that decimals are shorter on bigger values as
					// well if `next` is hexadecimal but not decimal, we instead compare both.
					if (options.useShortestReferences) {
						decimal = toDecimal(code, next, options.omitOptionalSemicolons)

						if (decimal.length < numeric.length) {
							numeric = decimal
						}
					}
				}

				return named &&
					(!options.useShortestReferences || named.length < numeric.length)
					? named
					: numeric
			}

			/***/
		},

		/***/ 98653: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			module.exports = toDecimalReference

			var fromCharCode = __nccwpck_require__(41165)

			// Transform `code` into a decimal character reference.
			function toDecimalReference(code, next, omit) {
				var value = '&#' + String(code)
				return omit && next && !/\d/.test(fromCharCode(next))
					? value
					: value + ';'
			}

			/***/
		},

		/***/ 63849: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			module.exports = toHexReference

			var fromCharCode = __nccwpck_require__(41165)

			// Transform `code` into a hexadecimal character reference.
			function toHexReference(code, next, omit) {
				var value = '&#x' + code.toString(16).toUpperCase()
				return omit && next && !/[\dA-Fa-f]/.test(fromCharCode(next))
					? value
					: value + ';'
			}

			/***/
		},

		/***/ 89339: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			module.exports = toNamed

			var legacy = __nccwpck_require__(82719)
			var characters = __nccwpck_require__(41050)
			var fromCharCode = __nccwpck_require__(41165)
			var own = __nccwpck_require__(12935)
			var dangerous = __nccwpck_require__(50408)

			// Transform `code` into a named character reference.
			function toNamed(code, next, omit, attribute) {
				var character = fromCharCode(code)
				var name
				var value

				if (own.call(characters, character)) {
					name = characters[character]
					value = '&' + name

					if (
						omit &&
						own.call(legacy, name) &&
						dangerous.indexOf(name) === -1 &&
						(!attribute ||
							(next &&
								next !== 61 /* `=` */ &&
								/[^\da-z]/i.test(fromCharCode(next))))
					) {
						return value
					}

					return value + ';'
				}

				return ''
			}

			/***/
		},

		/***/ 91389: /***/ (module) => {
			'use strict'
			/*!
			 * strip-bom-string <https://github.com/jonschlinkert/strip-bom-string>
			 *
			 * Copyright (c) 2015, 2017, Jon Schlinkert.
			 * Released under the MIT License.
			 */

			module.exports = function (str) {
				if (typeof str === 'string' && str.charAt(0) === '\ufeff') {
					return str.slice(1)
				}
				return str
			}

			/***/
		},

		/***/ 21450: /***/ (module) => {
			'use strict'

			var argv = process.argv

			var terminator = argv.indexOf('--')
			var hasFlag = function (flag) {
				flag = '--' + flag
				var pos = argv.indexOf(flag)
				return pos !== -1 && (terminator !== -1 ? pos < terminator : true)
			}

			module.exports = (function () {
				if ('FORCE_COLOR' in process.env) {
					return true
				}

				if (
					hasFlag('no-color') ||
					hasFlag('no-colors') ||
					hasFlag('color=false')
				) {
					return false
				}

				if (
					hasFlag('color') ||
					hasFlag('colors') ||
					hasFlag('color=true') ||
					hasFlag('color=always')
				) {
					return true
				}

				if (process.stdout && !process.stdout.isTTY) {
					return false
				}

				if (process.platform === 'win32') {
					return true
				}

				if ('COLORTERM' in process.env) {
					return true
				}

				if (process.env.TERM === 'dumb') {
					return false
				}

				if (
					/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(
						process.env.TERM,
					)
				) {
					return true
				}

				return false
			})()

			/***/
		},

		/***/ 75937: /***/ (module) => {
			'use strict'

			module.exports = trimTrailingLines

			// Remove final newline characters from `value`.
			function trimTrailingLines(value) {
				return String(value).replace(/\n+$/, '')
			}

			/***/
		},

		/***/ 15464: /***/ (module, exports) => {
			exports = module.exports = trim

			function trim(str) {
				return str.replace(/^\s*|\s*$/g, '')
			}

			exports.left = function (str) {
				return str.replace(/^\s*/, '')
			}

			exports.right = function (str) {
				return str.replace(/\s*$/, '')
			}

			/***/
		},

		/***/ 20770: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			module.exports = __nccwpck_require__(20218)

			/***/
		},

		/***/ 20218: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var net = __nccwpck_require__(69278)
			var tls = __nccwpck_require__(64756)
			var http = __nccwpck_require__(58611)
			var https = __nccwpck_require__(65692)
			var events = __nccwpck_require__(24434)
			var assert = __nccwpck_require__(42613)
			var util = __nccwpck_require__(39023)

			exports.httpOverHttp = httpOverHttp
			exports.httpsOverHttp = httpsOverHttp
			exports.httpOverHttps = httpOverHttps
			exports.httpsOverHttps = httpsOverHttps

			function httpOverHttp(options) {
				var agent = new TunnelingAgent(options)
				agent.request = http.request
				return agent
			}

			function httpsOverHttp(options) {
				var agent = new TunnelingAgent(options)
				agent.request = http.request
				agent.createSocket = createSecureSocket
				agent.defaultPort = 443
				return agent
			}

			function httpOverHttps(options) {
				var agent = new TunnelingAgent(options)
				agent.request = https.request
				return agent
			}

			function httpsOverHttps(options) {
				var agent = new TunnelingAgent(options)
				agent.request = https.request
				agent.createSocket = createSecureSocket
				agent.defaultPort = 443
				return agent
			}

			function TunnelingAgent(options) {
				var self = this
				self.options = options || {}
				self.proxyOptions = self.options.proxy || {}
				self.maxSockets =
					self.options.maxSockets || http.Agent.defaultMaxSockets
				self.requests = []
				self.sockets = []

				self.on('free', function onFree(socket, host, port, localAddress) {
					var options = toOptions(host, port, localAddress)
					for (var i = 0, len = self.requests.length; i < len; ++i) {
						var pending = self.requests[i]
						if (
							pending.host === options.host &&
							pending.port === options.port
						) {
							// Detect the request to connect same origin server,
							// reuse the connection.
							self.requests.splice(i, 1)
							pending.request.onSocket(socket)
							return
						}
					}
					socket.destroy()
					self.removeSocket(socket)
				})
			}
			util.inherits(TunnelingAgent, events.EventEmitter)

			TunnelingAgent.prototype.addRequest = function addRequest(
				req,
				host,
				port,
				localAddress,
			) {
				var self = this
				var options = mergeOptions(
					{ request: req },
					self.options,
					toOptions(host, port, localAddress),
				)

				if (self.sockets.length >= this.maxSockets) {
					// We are over limit so we'll add it to the queue.
					self.requests.push(options)
					return
				}

				// If we are under maxSockets create a new one.
				self.createSocket(options, function (socket) {
					socket.on('free', onFree)
					socket.on('close', onCloseOrRemove)
					socket.on('agentRemove', onCloseOrRemove)
					req.onSocket(socket)

					function onFree() {
						self.emit('free', socket, options)
					}

					function onCloseOrRemove(err) {
						self.removeSocket(socket)
						socket.removeListener('free', onFree)
						socket.removeListener('close', onCloseOrRemove)
						socket.removeListener('agentRemove', onCloseOrRemove)
					}
				})
			}

			TunnelingAgent.prototype.createSocket = function createSocket(
				options,
				cb,
			) {
				var self = this
				var placeholder = {}
				self.sockets.push(placeholder)

				var connectOptions = mergeOptions({}, self.proxyOptions, {
					method: 'CONNECT',
					path: options.host + ':' + options.port,
					agent: false,
					headers: {
						host: options.host + ':' + options.port,
					},
				})
				if (options.localAddress) {
					connectOptions.localAddress = options.localAddress
				}
				if (connectOptions.proxyAuth) {
					connectOptions.headers = connectOptions.headers || {}
					connectOptions.headers['Proxy-Authorization'] =
						'Basic ' + new Buffer(connectOptions.proxyAuth).toString('base64')
				}

				debug('making CONNECT request')
				var connectReq = self.request(connectOptions)
				connectReq.useChunkedEncodingByDefault = false // for v0.6
				connectReq.once('response', onResponse) // for v0.6
				connectReq.once('upgrade', onUpgrade) // for v0.6
				connectReq.once('connect', onConnect) // for v0.7 or later
				connectReq.once('error', onError)
				connectReq.end()

				function onResponse(res) {
					// Very hacky. This is necessary to avoid http-parser leaks.
					res.upgrade = true
				}

				function onUpgrade(res, socket, head) {
					// Hacky.
					process.nextTick(function () {
						onConnect(res, socket, head)
					})
				}

				function onConnect(res, socket, head) {
					connectReq.removeAllListeners()
					socket.removeAllListeners()

					if (res.statusCode !== 200) {
						debug(
							'tunneling socket could not be established, statusCode=%d',
							res.statusCode,
						)
						socket.destroy()
						var error = new Error(
							'tunneling socket could not be established, ' +
								'statusCode=' +
								res.statusCode,
						)
						error.code = 'ECONNRESET'
						options.request.emit('error', error)
						self.removeSocket(placeholder)
						return
					}
					if (head.length > 0) {
						debug('got illegal response body from proxy')
						socket.destroy()
						var error = new Error('got illegal response body from proxy')
						error.code = 'ECONNRESET'
						options.request.emit('error', error)
						self.removeSocket(placeholder)
						return
					}
					debug('tunneling connection has established')
					self.sockets[self.sockets.indexOf(placeholder)] = socket
					return cb(socket)
				}

				function onError(cause) {
					connectReq.removeAllListeners()

					debug(
						'tunneling socket could not be established, cause=%s\n',
						cause.message,
						cause.stack,
					)
					var error = new Error(
						'tunneling socket could not be established, ' +
							'cause=' +
							cause.message,
					)
					error.code = 'ECONNRESET'
					options.request.emit('error', error)
					self.removeSocket(placeholder)
				}
			}

			TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
				var pos = this.sockets.indexOf(socket)
				if (pos === -1) {
					return
				}
				this.sockets.splice(pos, 1)

				var pending = this.requests.shift()
				if (pending) {
					// If we have pending requests and a socket gets closed a new one
					// needs to be created to take over in the pool for the one that closed.
					this.createSocket(pending, function (socket) {
						pending.request.onSocket(socket)
					})
				}
			}

			function createSecureSocket(options, cb) {
				var self = this
				TunnelingAgent.prototype.createSocket.call(
					self,
					options,
					function (socket) {
						var hostHeader = options.request.getHeader('host')
						var tlsOptions = mergeOptions({}, self.options, {
							socket: socket,
							servername: hostHeader
								? hostHeader.replace(/:.*$/, '')
								: options.host,
						})

						// 0 is dummy port for v0.6
						var secureSocket = tls.connect(0, tlsOptions)
						self.sockets[self.sockets.indexOf(socket)] = secureSocket
						cb(secureSocket)
					},
				)
			}

			function toOptions(host, port, localAddress) {
				if (typeof host === 'string') {
					// since v0.10
					return {
						host: host,
						port: port,
						localAddress: localAddress,
					}
				}
				return host // for v0.11 or later
			}

			function mergeOptions(target) {
				for (var i = 1, len = arguments.length; i < len; ++i) {
					var overrides = arguments[i]
					if (typeof overrides === 'object') {
						var keys = Object.keys(overrides)
						for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
							var k = keys[j]
							if (overrides[k] !== undefined) {
								target[k] = overrides[k]
							}
						}
					}
				}
				return target
			}

			var debug
			if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
				debug = function () {
					var args = Array.prototype.slice.call(arguments)
					if (typeof args[0] === 'string') {
						args[0] = 'TUNNEL: ' + args[0]
					} else {
						args.unshift('TUNNEL:')
					}
					console.error.apply(console, args)
				}
			} else {
				debug = function () {}
			}
			exports.debug = debug // for test

			/***/
		},

		/***/ 46752: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const Client = __nccwpck_require__(86197)
			const Dispatcher = __nccwpck_require__(28611)
			const errors = __nccwpck_require__(68707)
			const Pool = __nccwpck_require__(35076)
			const BalancedPool = __nccwpck_require__(81093)
			const Agent = __nccwpck_require__(59965)
			const util = __nccwpck_require__(3440)
			const { InvalidArgumentError } = errors
			const api = __nccwpck_require__(56615)
			const buildConnector = __nccwpck_require__(59136)
			const MockClient = __nccwpck_require__(47365)
			const MockAgent = __nccwpck_require__(47501)
			const MockPool = __nccwpck_require__(94004)
			const mockErrors = __nccwpck_require__(52429)
			const ProxyAgent = __nccwpck_require__(22720)
			const RetryHandler = __nccwpck_require__(53573)
			const { getGlobalDispatcher, setGlobalDispatcher } =
				__nccwpck_require__(32581)
			const DecoratorHandler = __nccwpck_require__(78840)
			const RedirectHandler = __nccwpck_require__(48299)
			const createRedirectInterceptor = __nccwpck_require__(64415)

			let hasCrypto
			try {
				__nccwpck_require__(76982)
				hasCrypto = true
			} catch {
				hasCrypto = false
			}

			Object.assign(Dispatcher.prototype, api)

			module.exports.Dispatcher = Dispatcher
			module.exports.Client = Client
			module.exports.Pool = Pool
			module.exports.BalancedPool = BalancedPool
			module.exports.Agent = Agent
			module.exports.ProxyAgent = ProxyAgent
			module.exports.RetryHandler = RetryHandler

			module.exports.DecoratorHandler = DecoratorHandler
			module.exports.RedirectHandler = RedirectHandler
			module.exports.createRedirectInterceptor = createRedirectInterceptor

			module.exports.buildConnector = buildConnector
			module.exports.errors = errors

			function makeDispatcher(fn) {
				return (url, opts, handler) => {
					if (typeof opts === 'function') {
						handler = opts
						opts = null
					}

					if (
						!url ||
						(typeof url !== 'string' &&
							typeof url !== 'object' &&
							!(url instanceof URL))
					) {
						throw new InvalidArgumentError('invalid url')
					}

					if (opts != null && typeof opts !== 'object') {
						throw new InvalidArgumentError('invalid opts')
					}

					if (opts && opts.path != null) {
						if (typeof opts.path !== 'string') {
							throw new InvalidArgumentError('invalid opts.path')
						}

						let path = opts.path
						if (!opts.path.startsWith('/')) {
							path = `/${path}`
						}

						url = new URL(util.parseOrigin(url).origin + path)
					} else {
						if (!opts) {
							opts = typeof url === 'object' ? url : {}
						}

						url = util.parseURL(url)
					}

					const { agent, dispatcher = getGlobalDispatcher() } = opts

					if (agent) {
						throw new InvalidArgumentError(
							'unsupported opts.agent. Did you mean opts.client?',
						)
					}

					return fn.call(
						dispatcher,
						{
							...opts,
							origin: url.origin,
							path: url.search ? `${url.pathname}${url.search}` : url.pathname,
							method: opts.method || (opts.body ? 'PUT' : 'GET'),
						},
						handler,
					)
				}
			}

			module.exports.setGlobalDispatcher = setGlobalDispatcher
			module.exports.getGlobalDispatcher = getGlobalDispatcher

			if (
				util.nodeMajor > 16 ||
				(util.nodeMajor === 16 && util.nodeMinor >= 8)
			) {
				let fetchImpl = null
				module.exports.fetch = async function fetch(resource) {
					if (!fetchImpl) {
						fetchImpl = __nccwpck_require__(12315).fetch
					}

					try {
						return await fetchImpl(...arguments)
					} catch (err) {
						if (typeof err === 'object') {
							Error.captureStackTrace(err, this)
						}

						throw err
					}
				}
				module.exports.Headers = __nccwpck_require__(26349).Headers
				module.exports.Response = __nccwpck_require__(48676).Response
				module.exports.Request = __nccwpck_require__(25194).Request
				module.exports.FormData = __nccwpck_require__(43073).FormData
				module.exports.File = __nccwpck_require__(63041).File
				module.exports.FileReader = __nccwpck_require__(82160).FileReader

				const { setGlobalOrigin, getGlobalOrigin } = __nccwpck_require__(75628)

				module.exports.setGlobalOrigin = setGlobalOrigin
				module.exports.getGlobalOrigin = getGlobalOrigin

				const { CacheStorage } = __nccwpck_require__(44738)
				const { kConstruct } = __nccwpck_require__(80296)

				// Cache & CacheStorage are tightly coupled with fetch. Even if it may run
				// in an older version of Node, it doesn't have any use without fetch.
				module.exports.caches = new CacheStorage(kConstruct)
			}

			if (util.nodeMajor >= 16) {
				const { deleteCookie, getCookies, getSetCookies, setCookie } =
					__nccwpck_require__(53168)

				module.exports.deleteCookie = deleteCookie
				module.exports.getCookies = getCookies
				module.exports.getSetCookies = getSetCookies
				module.exports.setCookie = setCookie

				const { parseMIMEType, serializeAMimeType } = __nccwpck_require__(94322)

				module.exports.parseMIMEType = parseMIMEType
				module.exports.serializeAMimeType = serializeAMimeType
			}

			if (util.nodeMajor >= 18 && hasCrypto) {
				const { WebSocket } = __nccwpck_require__(55171)

				module.exports.WebSocket = WebSocket
			}

			module.exports.request = makeDispatcher(api.request)
			module.exports.stream = makeDispatcher(api.stream)
			module.exports.pipeline = makeDispatcher(api.pipeline)
			module.exports.connect = makeDispatcher(api.connect)
			module.exports.upgrade = makeDispatcher(api.upgrade)

			module.exports.MockClient = MockClient
			module.exports.MockPool = MockPool
			module.exports.MockAgent = MockAgent
			module.exports.mockErrors = mockErrors

			/***/
		},

		/***/ 59965: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { InvalidArgumentError } = __nccwpck_require__(68707)
			const { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } =
				__nccwpck_require__(36443)
			const DispatcherBase = __nccwpck_require__(50001)
			const Pool = __nccwpck_require__(35076)
			const Client = __nccwpck_require__(86197)
			const util = __nccwpck_require__(3440)
			const createRedirectInterceptor = __nccwpck_require__(64415)
			const { WeakRef, FinalizationRegistry } = __nccwpck_require__(13194)()

			const kOnConnect = Symbol('onConnect')
			const kOnDisconnect = Symbol('onDisconnect')
			const kOnConnectionError = Symbol('onConnectionError')
			const kMaxRedirections = Symbol('maxRedirections')
			const kOnDrain = Symbol('onDrain')
			const kFactory = Symbol('factory')
			const kFinalizer = Symbol('finalizer')
			const kOptions = Symbol('options')

			function defaultFactory(origin, opts) {
				return opts && opts.connections === 1
					? new Client(origin, opts)
					: new Pool(origin, opts)
			}

			class Agent extends DispatcherBase {
				constructor({
					factory = defaultFactory,
					maxRedirections = 0,
					connect,
					...options
				} = {}) {
					super()

					if (typeof factory !== 'function') {
						throw new InvalidArgumentError('factory must be a function.')
					}

					if (
						connect != null &&
						typeof connect !== 'function' &&
						typeof connect !== 'object'
					) {
						throw new InvalidArgumentError(
							'connect must be a function or an object',
						)
					}

					if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
						throw new InvalidArgumentError(
							'maxRedirections must be a positive number',
						)
					}

					if (connect && typeof connect !== 'function') {
						connect = { ...connect }
					}

					this[kInterceptors] =
						options.interceptors &&
						options.interceptors.Agent &&
						Array.isArray(options.interceptors.Agent)
							? options.interceptors.Agent
							: [createRedirectInterceptor({ maxRedirections })]

					this[kOptions] = { ...util.deepClone(options), connect }
					this[kOptions].interceptors = options.interceptors
						? { ...options.interceptors }
						: undefined
					this[kMaxRedirections] = maxRedirections
					this[kFactory] = factory
					this[kClients] = new Map()
					this[kFinalizer] = new FinalizationRegistry(
						/* istanbul ignore next: gc is undeterministic */ (key) => {
							const ref = this[kClients].get(key)
							if (ref !== undefined && ref.deref() === undefined) {
								this[kClients].delete(key)
							}
						},
					)

					const agent = this

					this[kOnDrain] = (origin, targets) => {
						agent.emit('drain', origin, [agent, ...targets])
					}

					this[kOnConnect] = (origin, targets) => {
						agent.emit('connect', origin, [agent, ...targets])
					}

					this[kOnDisconnect] = (origin, targets, err) => {
						agent.emit('disconnect', origin, [agent, ...targets], err)
					}

					this[kOnConnectionError] = (origin, targets, err) => {
						agent.emit('connectionError', origin, [agent, ...targets], err)
					}
				}

				get [kRunning]() {
					let ret = 0
					for (const ref of this[kClients].values()) {
						const client = ref.deref()
						/* istanbul ignore next: gc is undeterministic */
						if (client) {
							ret += client[kRunning]
						}
					}
					return ret
				}

				[kDispatch](opts, handler) {
					let key
					if (
						opts.origin &&
						(typeof opts.origin === 'string' || opts.origin instanceof URL)
					) {
						key = String(opts.origin)
					} else {
						throw new InvalidArgumentError(
							'opts.origin must be a non-empty string or URL.',
						)
					}

					const ref = this[kClients].get(key)

					let dispatcher = ref ? ref.deref() : null
					if (!dispatcher) {
						dispatcher = this[kFactory](opts.origin, this[kOptions])
							.on('drain', this[kOnDrain])
							.on('connect', this[kOnConnect])
							.on('disconnect', this[kOnDisconnect])
							.on('connectionError', this[kOnConnectionError])

						this[kClients].set(key, new WeakRef(dispatcher))
						this[kFinalizer].register(dispatcher, key)
					}

					return dispatcher.dispatch(opts, handler)
				}

				async [kClose]() {
					const closePromises = []
					for (const ref of this[kClients].values()) {
						const client = ref.deref()
						/* istanbul ignore else: gc is undeterministic */
						if (client) {
							closePromises.push(client.close())
						}
					}

					await Promise.all(closePromises)
				}

				async [kDestroy](err) {
					const destroyPromises = []
					for (const ref of this[kClients].values()) {
						const client = ref.deref()
						/* istanbul ignore else: gc is undeterministic */
						if (client) {
							destroyPromises.push(client.destroy(err))
						}
					}

					await Promise.all(destroyPromises)
				}
			}

			module.exports = Agent

			/***/
		},

		/***/ 80158: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			const { addAbortListener } = __nccwpck_require__(3440)
			const { RequestAbortedError } = __nccwpck_require__(68707)

			const kListener = Symbol('kListener')
			const kSignal = Symbol('kSignal')

			function abort(self) {
				if (self.abort) {
					self.abort()
				} else {
					self.onError(new RequestAbortedError())
				}
			}

			function addSignal(self, signal) {
				self[kSignal] = null
				self[kListener] = null

				if (!signal) {
					return
				}

				if (signal.aborted) {
					abort(self)
					return
				}

				self[kSignal] = signal
				self[kListener] = () => {
					abort(self)
				}

				addAbortListener(self[kSignal], self[kListener])
			}

			function removeSignal(self) {
				if (!self[kSignal]) {
					return
				}

				if ('removeEventListener' in self[kSignal]) {
					self[kSignal].removeEventListener('abort', self[kListener])
				} else {
					self[kSignal].removeListener('abort', self[kListener])
				}

				self[kSignal] = null
				self[kListener] = null
			}

			module.exports = {
				addSignal,
				removeSignal,
			}

			/***/
		},

		/***/ 34660: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { AsyncResource } = __nccwpck_require__(90290)
			const { InvalidArgumentError, RequestAbortedError, SocketError } =
				__nccwpck_require__(68707)
			const util = __nccwpck_require__(3440)
			const { addSignal, removeSignal } = __nccwpck_require__(80158)

			class ConnectHandler extends AsyncResource {
				constructor(opts, callback) {
					if (!opts || typeof opts !== 'object') {
						throw new InvalidArgumentError('invalid opts')
					}

					if (typeof callback !== 'function') {
						throw new InvalidArgumentError('invalid callback')
					}

					const { signal, opaque, responseHeaders } = opts

					if (
						signal &&
						typeof signal.on !== 'function' &&
						typeof signal.addEventListener !== 'function'
					) {
						throw new InvalidArgumentError(
							'signal must be an EventEmitter or EventTarget',
						)
					}

					super('UNDICI_CONNECT')

					this.opaque = opaque || null
					this.responseHeaders = responseHeaders || null
					this.callback = callback
					this.abort = null

					addSignal(this, signal)
				}

				onConnect(abort, context) {
					if (!this.callback) {
						throw new RequestAbortedError()
					}

					this.abort = abort
					this.context = context
				}

				onHeaders() {
					throw new SocketError('bad connect', null)
				}

				onUpgrade(statusCode, rawHeaders, socket) {
					const { callback, opaque, context } = this

					removeSignal(this)

					this.callback = null

					let headers = rawHeaders
					// Indicates is an HTTP2Session
					if (headers != null) {
						headers =
							this.responseHeaders === 'raw'
								? util.parseRawHeaders(rawHeaders)
								: util.parseHeaders(rawHeaders)
					}

					this.runInAsyncScope(callback, null, null, {
						statusCode,
						headers,
						socket,
						opaque,
						context,
					})
				}

				onError(err) {
					const { callback, opaque } = this

					removeSignal(this)

					if (callback) {
						this.callback = null
						queueMicrotask(() => {
							this.runInAsyncScope(callback, null, err, { opaque })
						})
					}
				}
			}

			function connect(opts, callback) {
				if (callback === undefined) {
					return new Promise((resolve, reject) => {
						connect.call(this, opts, (err, data) => {
							return err ? reject(err) : resolve(data)
						})
					})
				}

				try {
					const connectHandler = new ConnectHandler(opts, callback)
					this.dispatch({ ...opts, method: 'CONNECT' }, connectHandler)
				} catch (err) {
					if (typeof callback !== 'function') {
						throw err
					}
					const opaque = opts && opts.opaque
					queueMicrotask(() => callback(err, { opaque }))
				}
			}

			module.exports = connect

			/***/
		},

		/***/ 76862: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { Readable, Duplex, PassThrough } = __nccwpck_require__(2203)
			const {
				InvalidArgumentError,
				InvalidReturnValueError,
				RequestAbortedError,
			} = __nccwpck_require__(68707)
			const util = __nccwpck_require__(3440)
			const { AsyncResource } = __nccwpck_require__(90290)
			const { addSignal, removeSignal } = __nccwpck_require__(80158)
			const assert = __nccwpck_require__(42613)

			const kResume = Symbol('resume')

			class PipelineRequest extends Readable {
				constructor() {
					super({ autoDestroy: true })

					this[kResume] = null
				}

				_read() {
					const { [kResume]: resume } = this

					if (resume) {
						this[kResume] = null
						resume()
					}
				}

				_destroy(err, callback) {
					this._read()

					callback(err)
				}
			}

			class PipelineResponse extends Readable {
				constructor(resume) {
					super({ autoDestroy: true })
					this[kResume] = resume
				}

				_read() {
					this[kResume]()
				}

				_destroy(err, callback) {
					if (!err && !this._readableState.endEmitted) {
						err = new RequestAbortedError()
					}

					callback(err)
				}
			}

			class PipelineHandler extends AsyncResource {
				constructor(opts, handler) {
					if (!opts || typeof opts !== 'object') {
						throw new InvalidArgumentError('invalid opts')
					}

					if (typeof handler !== 'function') {
						throw new InvalidArgumentError('invalid handler')
					}

					const { signal, method, opaque, onInfo, responseHeaders } = opts

					if (
						signal &&
						typeof signal.on !== 'function' &&
						typeof signal.addEventListener !== 'function'
					) {
						throw new InvalidArgumentError(
							'signal must be an EventEmitter or EventTarget',
						)
					}

					if (method === 'CONNECT') {
						throw new InvalidArgumentError('invalid method')
					}

					if (onInfo && typeof onInfo !== 'function') {
						throw new InvalidArgumentError('invalid onInfo callback')
					}

					super('UNDICI_PIPELINE')

					this.opaque = opaque || null
					this.responseHeaders = responseHeaders || null
					this.handler = handler
					this.abort = null
					this.context = null
					this.onInfo = onInfo || null

					this.req = new PipelineRequest().on('error', util.nop)

					this.ret = new Duplex({
						readableObjectMode: opts.objectMode,
						autoDestroy: true,
						read: () => {
							const { body } = this

							if (body && body.resume) {
								body.resume()
							}
						},
						write: (chunk, encoding, callback) => {
							const { req } = this

							if (req.push(chunk, encoding) || req._readableState.destroyed) {
								callback()
							} else {
								req[kResume] = callback
							}
						},
						destroy: (err, callback) => {
							const { body, req, res, ret, abort } = this

							if (!err && !ret._readableState.endEmitted) {
								err = new RequestAbortedError()
							}

							if (abort && err) {
								abort()
							}

							util.destroy(body, err)
							util.destroy(req, err)
							util.destroy(res, err)

							removeSignal(this)

							callback(err)
						},
					}).on('prefinish', () => {
						const { req } = this

						// Node < 15 does not call _final in same tick.
						req.push(null)
					})

					this.res = null

					addSignal(this, signal)
				}

				onConnect(abort, context) {
					const { ret, res } = this

					assert(!res, 'pipeline cannot be retried')

					if (ret.destroyed) {
						throw new RequestAbortedError()
					}

					this.abort = abort
					this.context = context
				}

				onHeaders(statusCode, rawHeaders, resume) {
					const { opaque, handler, context } = this

					if (statusCode < 200) {
						if (this.onInfo) {
							const headers =
								this.responseHeaders === 'raw'
									? util.parseRawHeaders(rawHeaders)
									: util.parseHeaders(rawHeaders)
							this.onInfo({ statusCode, headers })
						}
						return
					}

					this.res = new PipelineResponse(resume)

					let body
					try {
						this.handler = null
						const headers =
							this.responseHeaders === 'raw'
								? util.parseRawHeaders(rawHeaders)
								: util.parseHeaders(rawHeaders)
						body = this.runInAsyncScope(handler, null, {
							statusCode,
							headers,
							opaque,
							body: this.res,
							context,
						})
					} catch (err) {
						this.res.on('error', util.nop)
						throw err
					}

					if (!body || typeof body.on !== 'function') {
						throw new InvalidReturnValueError('expected Readable')
					}

					body
						.on('data', (chunk) => {
							const { ret, body } = this

							if (!ret.push(chunk) && body.pause) {
								body.pause()
							}
						})
						.on('error', (err) => {
							const { ret } = this

							util.destroy(ret, err)
						})
						.on('end', () => {
							const { ret } = this

							ret.push(null)
						})
						.on('close', () => {
							const { ret } = this

							if (!ret._readableState.ended) {
								util.destroy(ret, new RequestAbortedError())
							}
						})

					this.body = body
				}

				onData(chunk) {
					const { res } = this
					return res.push(chunk)
				}

				onComplete(trailers) {
					const { res } = this
					res.push(null)
				}

				onError(err) {
					const { ret } = this
					this.handler = null
					util.destroy(ret, err)
				}
			}

			function pipeline(opts, handler) {
				try {
					const pipelineHandler = new PipelineHandler(opts, handler)
					this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler)
					return pipelineHandler.ret
				} catch (err) {
					return new PassThrough().destroy(err)
				}
			}

			module.exports = pipeline

			/***/
		},

		/***/ 14043: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const Readable = __nccwpck_require__(49927)
			const { InvalidArgumentError, RequestAbortedError } =
				__nccwpck_require__(68707)
			const util = __nccwpck_require__(3440)
			const { getResolveErrorBodyCallback } = __nccwpck_require__(87655)
			const { AsyncResource } = __nccwpck_require__(90290)
			const { addSignal, removeSignal } = __nccwpck_require__(80158)

			class RequestHandler extends AsyncResource {
				constructor(opts, callback) {
					if (!opts || typeof opts !== 'object') {
						throw new InvalidArgumentError('invalid opts')
					}

					const {
						signal,
						method,
						opaque,
						body,
						onInfo,
						responseHeaders,
						throwOnError,
						highWaterMark,
					} = opts

					try {
						if (typeof callback !== 'function') {
							throw new InvalidArgumentError('invalid callback')
						}

						if (
							highWaterMark &&
							(typeof highWaterMark !== 'number' || highWaterMark < 0)
						) {
							throw new InvalidArgumentError('invalid highWaterMark')
						}

						if (
							signal &&
							typeof signal.on !== 'function' &&
							typeof signal.addEventListener !== 'function'
						) {
							throw new InvalidArgumentError(
								'signal must be an EventEmitter or EventTarget',
							)
						}

						if (method === 'CONNECT') {
							throw new InvalidArgumentError('invalid method')
						}

						if (onInfo && typeof onInfo !== 'function') {
							throw new InvalidArgumentError('invalid onInfo callback')
						}

						super('UNDICI_REQUEST')
					} catch (err) {
						if (util.isStream(body)) {
							util.destroy(body.on('error', util.nop), err)
						}
						throw err
					}

					this.responseHeaders = responseHeaders || null
					this.opaque = opaque || null
					this.callback = callback
					this.res = null
					this.abort = null
					this.body = body
					this.trailers = {}
					this.context = null
					this.onInfo = onInfo || null
					this.throwOnError = throwOnError
					this.highWaterMark = highWaterMark

					if (util.isStream(body)) {
						body.on('error', (err) => {
							this.onError(err)
						})
					}

					addSignal(this, signal)
				}

				onConnect(abort, context) {
					if (!this.callback) {
						throw new RequestAbortedError()
					}

					this.abort = abort
					this.context = context
				}

				onHeaders(statusCode, rawHeaders, resume, statusMessage) {
					const {
						callback,
						opaque,
						abort,
						context,
						responseHeaders,
						highWaterMark,
					} = this

					const headers =
						responseHeaders === 'raw'
							? util.parseRawHeaders(rawHeaders)
							: util.parseHeaders(rawHeaders)

					if (statusCode < 200) {
						if (this.onInfo) {
							this.onInfo({ statusCode, headers })
						}
						return
					}

					const parsedHeaders =
						responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers
					const contentType = parsedHeaders['content-type']
					const body = new Readable({
						resume,
						abort,
						contentType,
						highWaterMark,
					})

					this.callback = null
					this.res = body
					if (callback !== null) {
						if (this.throwOnError && statusCode >= 400) {
							this.runInAsyncScope(getResolveErrorBodyCallback, null, {
								callback,
								body,
								contentType,
								statusCode,
								statusMessage,
								headers,
							})
						} else {
							this.runInAsyncScope(callback, null, null, {
								statusCode,
								headers,
								trailers: this.trailers,
								opaque,
								body,
								context,
							})
						}
					}
				}

				onData(chunk) {
					const { res } = this
					return res.push(chunk)
				}

				onComplete(trailers) {
					const { res } = this

					removeSignal(this)

					util.parseHeaders(trailers, this.trailers)

					res.push(null)
				}

				onError(err) {
					const { res, callback, body, opaque } = this

					removeSignal(this)

					if (callback) {
						// TODO: Does this need queueMicrotask?
						this.callback = null
						queueMicrotask(() => {
							this.runInAsyncScope(callback, null, err, { opaque })
						})
					}

					if (res) {
						this.res = null
						// Ensure all queued handlers are invoked before destroying res.
						queueMicrotask(() => {
							util.destroy(res, err)
						})
					}

					if (body) {
						this.body = null
						util.destroy(body, err)
					}
				}
			}

			function request(opts, callback) {
				if (callback === undefined) {
					return new Promise((resolve, reject) => {
						request.call(this, opts, (err, data) => {
							return err ? reject(err) : resolve(data)
						})
					})
				}

				try {
					this.dispatch(opts, new RequestHandler(opts, callback))
				} catch (err) {
					if (typeof callback !== 'function') {
						throw err
					}
					const opaque = opts && opts.opaque
					queueMicrotask(() => callback(err, { opaque }))
				}
			}

			module.exports = request
			module.exports.RequestHandler = RequestHandler

			/***/
		},

		/***/ 3560: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { finished, PassThrough } = __nccwpck_require__(2203)
			const {
				InvalidArgumentError,
				InvalidReturnValueError,
				RequestAbortedError,
			} = __nccwpck_require__(68707)
			const util = __nccwpck_require__(3440)
			const { getResolveErrorBodyCallback } = __nccwpck_require__(87655)
			const { AsyncResource } = __nccwpck_require__(90290)
			const { addSignal, removeSignal } = __nccwpck_require__(80158)

			class StreamHandler extends AsyncResource {
				constructor(opts, factory, callback) {
					if (!opts || typeof opts !== 'object') {
						throw new InvalidArgumentError('invalid opts')
					}

					const {
						signal,
						method,
						opaque,
						body,
						onInfo,
						responseHeaders,
						throwOnError,
					} = opts

					try {
						if (typeof callback !== 'function') {
							throw new InvalidArgumentError('invalid callback')
						}

						if (typeof factory !== 'function') {
							throw new InvalidArgumentError('invalid factory')
						}

						if (
							signal &&
							typeof signal.on !== 'function' &&
							typeof signal.addEventListener !== 'function'
						) {
							throw new InvalidArgumentError(
								'signal must be an EventEmitter or EventTarget',
							)
						}

						if (method === 'CONNECT') {
							throw new InvalidArgumentError('invalid method')
						}

						if (onInfo && typeof onInfo !== 'function') {
							throw new InvalidArgumentError('invalid onInfo callback')
						}

						super('UNDICI_STREAM')
					} catch (err) {
						if (util.isStream(body)) {
							util.destroy(body.on('error', util.nop), err)
						}
						throw err
					}

					this.responseHeaders = responseHeaders || null
					this.opaque = opaque || null
					this.factory = factory
					this.callback = callback
					this.res = null
					this.abort = null
					this.context = null
					this.trailers = null
					this.body = body
					this.onInfo = onInfo || null
					this.throwOnError = throwOnError || false

					if (util.isStream(body)) {
						body.on('error', (err) => {
							this.onError(err)
						})
					}

					addSignal(this, signal)
				}

				onConnect(abort, context) {
					if (!this.callback) {
						throw new RequestAbortedError()
					}

					this.abort = abort
					this.context = context
				}

				onHeaders(statusCode, rawHeaders, resume, statusMessage) {
					const { factory, opaque, context, callback, responseHeaders } = this

					const headers =
						responseHeaders === 'raw'
							? util.parseRawHeaders(rawHeaders)
							: util.parseHeaders(rawHeaders)

					if (statusCode < 200) {
						if (this.onInfo) {
							this.onInfo({ statusCode, headers })
						}
						return
					}

					this.factory = null

					let res

					if (this.throwOnError && statusCode >= 400) {
						const parsedHeaders =
							responseHeaders === 'raw'
								? util.parseHeaders(rawHeaders)
								: headers
						const contentType = parsedHeaders['content-type']
						res = new PassThrough()

						this.callback = null
						this.runInAsyncScope(getResolveErrorBodyCallback, null, {
							callback,
							body: res,
							contentType,
							statusCode,
							statusMessage,
							headers,
						})
					} else {
						if (factory === null) {
							return
						}

						res = this.runInAsyncScope(factory, null, {
							statusCode,
							headers,
							opaque,
							context,
						})

						if (
							!res ||
							typeof res.write !== 'function' ||
							typeof res.end !== 'function' ||
							typeof res.on !== 'function'
						) {
							throw new InvalidReturnValueError('expected Writable')
						}

						// TODO: Avoid finished. It registers an unnecessary amount of listeners.
						finished(res, { readable: false }, (err) => {
							const { callback, res, opaque, trailers, abort } = this

							this.res = null
							if (err || !res.readable) {
								util.destroy(res, err)
							}

							this.callback = null
							this.runInAsyncScope(callback, null, err || null, {
								opaque,
								trailers,
							})

							if (err) {
								abort()
							}
						})
					}

					res.on('drain', resume)

					this.res = res

					const needDrain =
						res.writableNeedDrain !== undefined
							? res.writableNeedDrain
							: res._writableState && res._writableState.needDrain

					return needDrain !== true
				}

				onData(chunk) {
					const { res } = this

					return res ? res.write(chunk) : true
				}

				onComplete(trailers) {
					const { res } = this

					removeSignal(this)

					if (!res) {
						return
					}

					this.trailers = util.parseHeaders(trailers)

					res.end()
				}

				onError(err) {
					const { res, callback, opaque, body } = this

					removeSignal(this)

					this.factory = null

					if (res) {
						this.res = null
						util.destroy(res, err)
					} else if (callback) {
						this.callback = null
						queueMicrotask(() => {
							this.runInAsyncScope(callback, null, err, { opaque })
						})
					}

					if (body) {
						this.body = null
						util.destroy(body, err)
					}
				}
			}

			function stream(opts, factory, callback) {
				if (callback === undefined) {
					return new Promise((resolve, reject) => {
						stream.call(this, opts, factory, (err, data) => {
							return err ? reject(err) : resolve(data)
						})
					})
				}

				try {
					this.dispatch(opts, new StreamHandler(opts, factory, callback))
				} catch (err) {
					if (typeof callback !== 'function') {
						throw err
					}
					const opaque = opts && opts.opaque
					queueMicrotask(() => callback(err, { opaque }))
				}
			}

			module.exports = stream

			/***/
		},

		/***/ 61882: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { InvalidArgumentError, RequestAbortedError, SocketError } =
				__nccwpck_require__(68707)
			const { AsyncResource } = __nccwpck_require__(90290)
			const util = __nccwpck_require__(3440)
			const { addSignal, removeSignal } = __nccwpck_require__(80158)
			const assert = __nccwpck_require__(42613)

			class UpgradeHandler extends AsyncResource {
				constructor(opts, callback) {
					if (!opts || typeof opts !== 'object') {
						throw new InvalidArgumentError('invalid opts')
					}

					if (typeof callback !== 'function') {
						throw new InvalidArgumentError('invalid callback')
					}

					const { signal, opaque, responseHeaders } = opts

					if (
						signal &&
						typeof signal.on !== 'function' &&
						typeof signal.addEventListener !== 'function'
					) {
						throw new InvalidArgumentError(
							'signal must be an EventEmitter or EventTarget',
						)
					}

					super('UNDICI_UPGRADE')

					this.responseHeaders = responseHeaders || null
					this.opaque = opaque || null
					this.callback = callback
					this.abort = null
					this.context = null

					addSignal(this, signal)
				}

				onConnect(abort, context) {
					if (!this.callback) {
						throw new RequestAbortedError()
					}

					this.abort = abort
					this.context = null
				}

				onHeaders() {
					throw new SocketError('bad upgrade', null)
				}

				onUpgrade(statusCode, rawHeaders, socket) {
					const { callback, opaque, context } = this

					assert.strictEqual(statusCode, 101)

					removeSignal(this)

					this.callback = null
					const headers =
						this.responseHeaders === 'raw'
							? util.parseRawHeaders(rawHeaders)
							: util.parseHeaders(rawHeaders)
					this.runInAsyncScope(callback, null, null, {
						headers,
						socket,
						opaque,
						context,
					})
				}

				onError(err) {
					const { callback, opaque } = this

					removeSignal(this)

					if (callback) {
						this.callback = null
						queueMicrotask(() => {
							this.runInAsyncScope(callback, null, err, { opaque })
						})
					}
				}
			}

			function upgrade(opts, callback) {
				if (callback === undefined) {
					return new Promise((resolve, reject) => {
						upgrade.call(this, opts, (err, data) => {
							return err ? reject(err) : resolve(data)
						})
					})
				}

				try {
					const upgradeHandler = new UpgradeHandler(opts, callback)
					this.dispatch(
						{
							...opts,
							method: opts.method || 'GET',
							upgrade: opts.protocol || 'Websocket',
						},
						upgradeHandler,
					)
				} catch (err) {
					if (typeof callback !== 'function') {
						throw err
					}
					const opaque = opts && opts.opaque
					queueMicrotask(() => callback(err, { opaque }))
				}
			}

			module.exports = upgrade

			/***/
		},

		/***/ 56615: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			module.exports.request = __nccwpck_require__(14043)
			module.exports.stream = __nccwpck_require__(3560)
			module.exports.pipeline = __nccwpck_require__(76862)
			module.exports.upgrade = __nccwpck_require__(61882)
			module.exports.connect = __nccwpck_require__(34660)

			/***/
		},

		/***/ 49927: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'
			// Ported from https://github.com/nodejs/undici/pull/907

			const assert = __nccwpck_require__(42613)
			const { Readable } = __nccwpck_require__(2203)
			const { RequestAbortedError, NotSupportedError, InvalidArgumentError } =
				__nccwpck_require__(68707)
			const util = __nccwpck_require__(3440)
			const { ReadableStreamFrom, toUSVString } = __nccwpck_require__(3440)

			let Blob

			const kConsume = Symbol('kConsume')
			const kReading = Symbol('kReading')
			const kBody = Symbol('kBody')
			const kAbort = Symbol('abort')
			const kContentType = Symbol('kContentType')

			const noop = () => {}

			module.exports = class BodyReadable extends Readable {
				constructor({
					resume,
					abort,
					contentType = '',
					highWaterMark = 64 * 1024, // Same as nodejs fs streams.
				}) {
					super({
						autoDestroy: true,
						read: resume,
						highWaterMark,
					})

					this._readableState.dataEmitted = false

					this[kAbort] = abort
					this[kConsume] = null
					this[kBody] = null
					this[kContentType] = contentType

					// Is stream being consumed through Readable API?
					// This is an optimization so that we avoid checking
					// for 'data' and 'readable' listeners in the hot path
					// inside push().
					this[kReading] = false
				}

				destroy(err) {
					if (this.destroyed) {
						// Node < 16
						return this
					}

					if (!err && !this._readableState.endEmitted) {
						err = new RequestAbortedError()
					}

					if (err) {
						this[kAbort]()
					}

					return super.destroy(err)
				}

				emit(ev, ...args) {
					if (ev === 'data') {
						// Node < 16.7
						this._readableState.dataEmitted = true
					} else if (ev === 'error') {
						// Node < 16
						this._readableState.errorEmitted = true
					}
					return super.emit(ev, ...args)
				}

				on(ev, ...args) {
					if (ev === 'data' || ev === 'readable') {
						this[kReading] = true
					}
					return super.on(ev, ...args)
				}

				addListener(ev, ...args) {
					return this.on(ev, ...args)
				}

				off(ev, ...args) {
					const ret = super.off(ev, ...args)
					if (ev === 'data' || ev === 'readable') {
						this[kReading] =
							this.listenerCount('data') > 0 ||
							this.listenerCount('readable') > 0
					}
					return ret
				}

				removeListener(ev, ...args) {
					return this.off(ev, ...args)
				}

				push(chunk) {
					if (this[kConsume] && chunk !== null && this.readableLength === 0) {
						consumePush(this[kConsume], chunk)
						return this[kReading] ? super.push(chunk) : true
					}
					return super.push(chunk)
				}

				// https://fetch.spec.whatwg.org/#dom-body-text
				async text() {
					return consume(this, 'text')
				}

				// https://fetch.spec.whatwg.org/#dom-body-json
				async json() {
					return consume(this, 'json')
				}

				// https://fetch.spec.whatwg.org/#dom-body-blob
				async blob() {
					return consume(this, 'blob')
				}

				// https://fetch.spec.whatwg.org/#dom-body-arraybuffer
				async arrayBuffer() {
					return consume(this, 'arrayBuffer')
				}

				// https://fetch.spec.whatwg.org/#dom-body-formdata
				async formData() {
					// TODO: Implement.
					throw new NotSupportedError()
				}

				// https://fetch.spec.whatwg.org/#dom-body-bodyused
				get bodyUsed() {
					return util.isDisturbed(this)
				}

				// https://fetch.spec.whatwg.org/#dom-body-body
				get body() {
					if (!this[kBody]) {
						this[kBody] = ReadableStreamFrom(this)
						if (this[kConsume]) {
							// TODO: Is this the best way to force a lock?
							this[kBody].getReader() // Ensure stream is locked.
							assert(this[kBody].locked)
						}
					}
					return this[kBody]
				}

				dump(opts) {
					let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144
					const signal = opts && opts.signal

					if (signal) {
						try {
							if (typeof signal !== 'object' || !('aborted' in signal)) {
								throw new InvalidArgumentError('signal must be an AbortSignal')
							}
							util.throwIfAborted(signal)
						} catch (err) {
							return Promise.reject(err)
						}
					}

					if (this.closed) {
						return Promise.resolve(null)
					}

					return new Promise((resolve, reject) => {
						const signalListenerCleanup = signal
							? util.addAbortListener(signal, () => {
									this.destroy()
								})
							: noop

						this.on('close', function () {
							signalListenerCleanup()
							if (signal && signal.aborted) {
								reject(
									signal.reason ||
										Object.assign(new Error('The operation was aborted'), {
											name: 'AbortError',
										}),
								)
							} else {
								resolve(null)
							}
						})
							.on('error', noop)
							.on('data', function (chunk) {
								limit -= chunk.length
								if (limit <= 0) {
									this.destroy()
								}
							})
							.resume()
					})
				}
			}

			// https://streams.spec.whatwg.org/#readablestream-locked
			function isLocked(self) {
				// Consume is an implicit lock.
				return (self[kBody] && self[kBody].locked === true) || self[kConsume]
			}

			// https://fetch.spec.whatwg.org/#body-unusable
			function isUnusable(self) {
				return util.isDisturbed(self) || isLocked(self)
			}

			async function consume(stream, type) {
				if (isUnusable(stream)) {
					throw new TypeError('unusable')
				}

				assert(!stream[kConsume])

				return new Promise((resolve, reject) => {
					stream[kConsume] = {
						type,
						stream,
						resolve,
						reject,
						length: 0,
						body: [],
					}

					stream
						.on('error', function (err) {
							consumeFinish(this[kConsume], err)
						})
						.on('close', function () {
							if (this[kConsume].body !== null) {
								consumeFinish(this[kConsume], new RequestAbortedError())
							}
						})

					process.nextTick(consumeStart, stream[kConsume])
				})
			}

			function consumeStart(consume) {
				if (consume.body === null) {
					return
				}

				const { _readableState: state } = consume.stream

				for (const chunk of state.buffer) {
					consumePush(consume, chunk)
				}

				if (state.endEmitted) {
					consumeEnd(this[kConsume])
				} else {
					consume.stream.on('end', function () {
						consumeEnd(this[kConsume])
					})
				}

				consume.stream.resume()

				while (consume.stream.read() != null) {
					// Loop
				}
			}

			function consumeEnd(consume) {
				const { type, body, resolve, stream, length } = consume

				try {
					if (type === 'text') {
						resolve(toUSVString(Buffer.concat(body)))
					} else if (type === 'json') {
						resolve(JSON.parse(Buffer.concat(body)))
					} else if (type === 'arrayBuffer') {
						const dst = new Uint8Array(length)

						let pos = 0
						for (const buf of body) {
							dst.set(buf, pos)
							pos += buf.byteLength
						}

						resolve(dst.buffer)
					} else if (type === 'blob') {
						if (!Blob) {
							Blob = __nccwpck_require__(20181).Blob
						}
						resolve(new Blob(body, { type: stream[kContentType] }))
					}

					consumeFinish(consume)
				} catch (err) {
					stream.destroy(err)
				}
			}

			function consumePush(consume, chunk) {
				consume.length += chunk.length
				consume.body.push(chunk)
			}

			function consumeFinish(consume, err) {
				if (consume.body === null) {
					return
				}

				if (err) {
					consume.reject(err)
				} else {
					consume.resolve()
				}

				consume.type = null
				consume.stream = null
				consume.resolve = null
				consume.reject = null
				consume.length = 0
				consume.body = null
			}

			/***/
		},

		/***/ 87655: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			const assert = __nccwpck_require__(42613)
			const { ResponseStatusCodeError } = __nccwpck_require__(68707)
			const { toUSVString } = __nccwpck_require__(3440)

			async function getResolveErrorBodyCallback({
				callback,
				body,
				contentType,
				statusCode,
				statusMessage,
				headers,
			}) {
				assert(body)

				let chunks = []
				let limit = 0

				for await (const chunk of body) {
					chunks.push(chunk)
					limit += chunk.length
					if (limit > 128 * 1024) {
						chunks = null
						break
					}
				}

				if (statusCode === 204 || !contentType || !chunks) {
					process.nextTick(
						callback,
						new ResponseStatusCodeError(
							`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`,
							statusCode,
							headers,
						),
					)
					return
				}

				try {
					if (contentType.startsWith('application/json')) {
						const payload = JSON.parse(toUSVString(Buffer.concat(chunks)))
						process.nextTick(
							callback,
							new ResponseStatusCodeError(
								`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`,
								statusCode,
								headers,
								payload,
							),
						)
						return
					}

					if (contentType.startsWith('text/')) {
						const payload = toUSVString(Buffer.concat(chunks))
						process.nextTick(
							callback,
							new ResponseStatusCodeError(
								`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`,
								statusCode,
								headers,
								payload,
							),
						)
						return
					}
				} catch (err) {
					// Process in a fallback if error
				}

				process.nextTick(
					callback,
					new ResponseStatusCodeError(
						`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`,
						statusCode,
						headers,
					),
				)
			}

			module.exports = { getResolveErrorBodyCallback }

			/***/
		},

		/***/ 81093: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { BalancedPoolMissingUpstreamError, InvalidArgumentError } =
				__nccwpck_require__(68707)
			const {
				PoolBase,
				kClients,
				kNeedDrain,
				kAddClient,
				kRemoveClient,
				kGetDispatcher,
			} = __nccwpck_require__(58640)
			const Pool = __nccwpck_require__(35076)
			const { kUrl, kInterceptors } = __nccwpck_require__(36443)
			const { parseOrigin } = __nccwpck_require__(3440)
			const kFactory = Symbol('factory')

			const kOptions = Symbol('options')
			const kGreatestCommonDivisor = Symbol('kGreatestCommonDivisor')
			const kCurrentWeight = Symbol('kCurrentWeight')
			const kIndex = Symbol('kIndex')
			const kWeight = Symbol('kWeight')
			const kMaxWeightPerServer = Symbol('kMaxWeightPerServer')
			const kErrorPenalty = Symbol('kErrorPenalty')

			function getGreatestCommonDivisor(a, b) {
				if (b === 0) return a
				return getGreatestCommonDivisor(b, a % b)
			}

			function defaultFactory(origin, opts) {
				return new Pool(origin, opts)
			}

			class BalancedPool extends PoolBase {
				constructor(
					upstreams = [],
					{ factory = defaultFactory, ...opts } = {},
				) {
					super()

					this[kOptions] = opts
					this[kIndex] = -1
					this[kCurrentWeight] = 0

					this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100
					this[kErrorPenalty] = this[kOptions].errorPenalty || 15

					if (!Array.isArray(upstreams)) {
						upstreams = [upstreams]
					}

					if (typeof factory !== 'function') {
						throw new InvalidArgumentError('factory must be a function.')
					}

					this[kInterceptors] =
						opts.interceptors &&
						opts.interceptors.BalancedPool &&
						Array.isArray(opts.interceptors.BalancedPool)
							? opts.interceptors.BalancedPool
							: []
					this[kFactory] = factory

					for (const upstream of upstreams) {
						this.addUpstream(upstream)
					}
					this._updateBalancedPoolStats()
				}

				addUpstream(upstream) {
					const upstreamOrigin = parseOrigin(upstream).origin

					if (
						this[kClients].find(
							(pool) =>
								pool[kUrl].origin === upstreamOrigin &&
								pool.closed !== true &&
								pool.destroyed !== true,
						)
					) {
						return this
					}
					const pool = this[kFactory](
						upstreamOrigin,
						Object.assign({}, this[kOptions]),
					)

					this[kAddClient](pool)
					pool.on('connect', () => {
						pool[kWeight] = Math.min(
							this[kMaxWeightPerServer],
							pool[kWeight] + this[kErrorPenalty],
						)
					})

					pool.on('connectionError', () => {
						pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty])
						this._updateBalancedPoolStats()
					})

					pool.on('disconnect', (...args) => {
						const err = args[2]
						if (err && err.code === 'UND_ERR_SOCKET') {
							// decrease the weight of the pool.
							pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty])
							this._updateBalancedPoolStats()
						}
					})

					for (const client of this[kClients]) {
						client[kWeight] = this[kMaxWeightPerServer]
					}

					this._updateBalancedPoolStats()

					return this
				}

				_updateBalancedPoolStats() {
					this[kGreatestCommonDivisor] = this[kClients]
						.map((p) => p[kWeight])
						.reduce(getGreatestCommonDivisor, 0)
				}

				removeUpstream(upstream) {
					const upstreamOrigin = parseOrigin(upstream).origin

					const pool = this[kClients].find(
						(pool) =>
							pool[kUrl].origin === upstreamOrigin &&
							pool.closed !== true &&
							pool.destroyed !== true,
					)

					if (pool) {
						this[kRemoveClient](pool)
					}

					return this
				}

				get upstreams() {
					return this[kClients]
						.filter(
							(dispatcher) =>
								dispatcher.closed !== true && dispatcher.destroyed !== true,
						)
						.map((p) => p[kUrl].origin)
				}

				[kGetDispatcher]() {
					// We validate that pools is greater than 0,
					// otherwise we would have to wait until an upstream
					// is added, which might never happen.
					if (this[kClients].length === 0) {
						throw new BalancedPoolMissingUpstreamError()
					}

					const dispatcher = this[kClients].find(
						(dispatcher) =>
							!dispatcher[kNeedDrain] &&
							dispatcher.closed !== true &&
							dispatcher.destroyed !== true,
					)

					if (!dispatcher) {
						return
					}

					const allClientsBusy = this[kClients]
						.map((pool) => pool[kNeedDrain])
						.reduce((a, b) => a && b, true)

					if (allClientsBusy) {
						return
					}

					let counter = 0

					let maxWeightIndex = this[kClients].findIndex(
						(pool) => !pool[kNeedDrain],
					)

					while (counter++ < this[kClients].length) {
						this[kIndex] = (this[kIndex] + 1) % this[kClients].length
						const pool = this[kClients][this[kIndex]]

						// find pool index with the largest weight
						if (
							pool[kWeight] > this[kClients][maxWeightIndex][kWeight] &&
							!pool[kNeedDrain]
						) {
							maxWeightIndex = this[kIndex]
						}

						// decrease the current weight every `this[kClients].length`.
						if (this[kIndex] === 0) {
							// Set the current weight to the next lower weight.
							this[kCurrentWeight] =
								this[kCurrentWeight] - this[kGreatestCommonDivisor]

							if (this[kCurrentWeight] <= 0) {
								this[kCurrentWeight] = this[kMaxWeightPerServer]
							}
						}
						if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {
							return pool
						}
					}

					this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight]
					this[kIndex] = maxWeightIndex
					return this[kClients][maxWeightIndex]
				}
			}

			module.exports = BalancedPool

			/***/
		},

		/***/ 50479: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { kConstruct } = __nccwpck_require__(80296)
			const { urlEquals, fieldValues: getFieldValues } =
				__nccwpck_require__(23993)
			const { kEnumerableProperty, isDisturbed } = __nccwpck_require__(3440)
			const { kHeadersList } = __nccwpck_require__(36443)
			const { webidl } = __nccwpck_require__(74222)
			const { Response, cloneResponse } = __nccwpck_require__(48676)
			const { Request } = __nccwpck_require__(25194)
			const { kState, kHeaders, kGuard, kRealm } = __nccwpck_require__(89710)
			const { fetching } = __nccwpck_require__(12315)
			const { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } =
				__nccwpck_require__(15523)
			const assert = __nccwpck_require__(42613)
			const { getGlobalDispatcher } = __nccwpck_require__(32581)

			/**
			 * @see https://w3c.github.io/ServiceWorker/#dfn-cache-batch-operation
			 * @typedef {Object} CacheBatchOperation
			 * @property {'delete' | 'put'} type
			 * @property {any} request
			 * @property {any} response
			 * @property {import('../../types/cache').CacheQueryOptions} options
			 */

			/**
			 * @see https://w3c.github.io/ServiceWorker/#dfn-request-response-list
			 * @typedef {[any, any][]} requestResponseList
			 */

			class Cache {
				/**
				 * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
				 * @type {requestResponseList}
				 */
				#relevantRequestResponseList

				constructor() {
					if (arguments[0] !== kConstruct) {
						webidl.illegalConstructor()
					}

					this.#relevantRequestResponseList = arguments[1]
				}

				async match(request, options = {}) {
					webidl.brandCheck(this, Cache)
					webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.match' })

					request = webidl.converters.RequestInfo(request)
					options = webidl.converters.CacheQueryOptions(options)

					const p = await this.matchAll(request, options)

					if (p.length === 0) {
						return
					}

					return p[0]
				}

				async matchAll(request = undefined, options = {}) {
					webidl.brandCheck(this, Cache)

					if (request !== undefined)
						request = webidl.converters.RequestInfo(request)
					options = webidl.converters.CacheQueryOptions(options)

					// 1.
					let r = null

					// 2.
					if (request !== undefined) {
						if (request instanceof Request) {
							// 2.1.1
							r = request[kState]

							// 2.1.2
							if (r.method !== 'GET' && !options.ignoreMethod) {
								return []
							}
						} else if (typeof request === 'string') {
							// 2.2.1
							r = new Request(request)[kState]
						}
					}

					// 5.
					// 5.1
					const responses = []

					// 5.2
					if (request === undefined) {
						// 5.2.1
						for (const requestResponse of this.#relevantRequestResponseList) {
							responses.push(requestResponse[1])
						}
					} else {
						// 5.3
						// 5.3.1
						const requestResponses = this.#queryCache(r, options)

						// 5.3.2
						for (const requestResponse of requestResponses) {
							responses.push(requestResponse[1])
						}
					}

					// 5.4
					// We don't implement CORs so we don't need to loop over the responses, yay!

					// 5.5.1
					const responseList = []

					// 5.5.2
					for (const response of responses) {
						// 5.5.2.1
						const responseObject = new Response(response.body?.source ?? null)
						const body = responseObject[kState].body
						responseObject[kState] = response
						responseObject[kState].body = body
						responseObject[kHeaders][kHeadersList] = response.headersList
						responseObject[kHeaders][kGuard] = 'immutable'

						responseList.push(responseObject)
					}

					// 6.
					return Object.freeze(responseList)
				}

				async add(request) {
					webidl.brandCheck(this, Cache)
					webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.add' })

					request = webidl.converters.RequestInfo(request)

					// 1.
					const requests = [request]

					// 2.
					const responseArrayPromise = this.addAll(requests)

					// 3.
					return await responseArrayPromise
				}

				async addAll(requests) {
					webidl.brandCheck(this, Cache)
					webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.addAll' })

					requests = webidl.converters['sequence<RequestInfo>'](requests)

					// 1.
					const responsePromises = []

					// 2.
					const requestList = []

					// 3.
					for (const request of requests) {
						if (typeof request === 'string') {
							continue
						}

						// 3.1
						const r = request[kState]

						// 3.2
						if (!urlIsHttpHttpsScheme(r.url) || r.method !== 'GET') {
							throw webidl.errors.exception({
								header: 'Cache.addAll',
								message: 'Expected http/s scheme when method is not GET.',
							})
						}
					}

					// 4.
					/** @type {ReturnType<typeof fetching>[]} */
					const fetchControllers = []

					// 5.
					for (const request of requests) {
						// 5.1
						const r = new Request(request)[kState]

						// 5.2
						if (!urlIsHttpHttpsScheme(r.url)) {
							throw webidl.errors.exception({
								header: 'Cache.addAll',
								message: 'Expected http/s scheme.',
							})
						}

						// 5.4
						r.initiator = 'fetch'
						r.destination = 'subresource'

						// 5.5
						requestList.push(r)

						// 5.6
						const responsePromise = createDeferredPromise()

						// 5.7
						fetchControllers.push(
							fetching({
								request: r,
								dispatcher: getGlobalDispatcher(),
								processResponse(response) {
									// 1.
									if (
										response.type === 'error' ||
										response.status === 206 ||
										response.status < 200 ||
										response.status > 299
									) {
										responsePromise.reject(
											webidl.errors.exception({
												header: 'Cache.addAll',
												message:
													'Received an invalid status code or the request failed.',
											}),
										)
									} else if (response.headersList.contains('vary')) {
										// 2.
										// 2.1
										const fieldValues = getFieldValues(
											response.headersList.get('vary'),
										)

										// 2.2
										for (const fieldValue of fieldValues) {
											// 2.2.1
											if (fieldValue === '*') {
												responsePromise.reject(
													webidl.errors.exception({
														header: 'Cache.addAll',
														message: 'invalid vary field value',
													}),
												)

												for (const controller of fetchControllers) {
													controller.abort()
												}

												return
											}
										}
									}
								},
								processResponseEndOfBody(response) {
									// 1.
									if (response.aborted) {
										responsePromise.reject(
											new DOMException('aborted', 'AbortError'),
										)
										return
									}

									// 2.
									responsePromise.resolve(response)
								},
							}),
						)

						// 5.8
						responsePromises.push(responsePromise.promise)
					}

					// 6.
					const p = Promise.all(responsePromises)

					// 7.
					const responses = await p

					// 7.1
					const operations = []

					// 7.2
					let index = 0

					// 7.3
					for (const response of responses) {
						// 7.3.1
						/** @type {CacheBatchOperation} */
						const operation = {
							type: 'put', // 7.3.2
							request: requestList[index], // 7.3.3
							response, // 7.3.4
						}

						operations.push(operation) // 7.3.5

						index++ // 7.3.6
					}

					// 7.5
					const cacheJobPromise = createDeferredPromise()

					// 7.6.1
					let errorData = null

					// 7.6.2
					try {
						this.#batchCacheOperations(operations)
					} catch (e) {
						errorData = e
					}

					// 7.6.3
					queueMicrotask(() => {
						// 7.6.3.1
						if (errorData === null) {
							cacheJobPromise.resolve(undefined)
						} else {
							// 7.6.3.2
							cacheJobPromise.reject(errorData)
						}
					})

					// 7.7
					return cacheJobPromise.promise
				}

				async put(request, response) {
					webidl.brandCheck(this, Cache)
					webidl.argumentLengthCheck(arguments, 2, { header: 'Cache.put' })

					request = webidl.converters.RequestInfo(request)
					response = webidl.converters.Response(response)

					// 1.
					let innerRequest = null

					// 2.
					if (request instanceof Request) {
						innerRequest = request[kState]
					} else {
						// 3.
						innerRequest = new Request(request)[kState]
					}

					// 4.
					if (
						!urlIsHttpHttpsScheme(innerRequest.url) ||
						innerRequest.method !== 'GET'
					) {
						throw webidl.errors.exception({
							header: 'Cache.put',
							message: 'Expected an http/s scheme when method is not GET',
						})
					}

					// 5.
					const innerResponse = response[kState]

					// 6.
					if (innerResponse.status === 206) {
						throw webidl.errors.exception({
							header: 'Cache.put',
							message: 'Got 206 status',
						})
					}

					// 7.
					if (innerResponse.headersList.contains('vary')) {
						// 7.1.
						const fieldValues = getFieldValues(
							innerResponse.headersList.get('vary'),
						)

						// 7.2.
						for (const fieldValue of fieldValues) {
							// 7.2.1
							if (fieldValue === '*') {
								throw webidl.errors.exception({
									header: 'Cache.put',
									message: 'Got * vary field value',
								})
							}
						}
					}

					// 8.
					if (
						innerResponse.body &&
						(isDisturbed(innerResponse.body.stream) ||
							innerResponse.body.stream.locked)
					) {
						throw webidl.errors.exception({
							header: 'Cache.put',
							message: 'Response body is locked or disturbed',
						})
					}

					// 9.
					const clonedResponse = cloneResponse(innerResponse)

					// 10.
					const bodyReadPromise = createDeferredPromise()

					// 11.
					if (innerResponse.body != null) {
						// 11.1
						const stream = innerResponse.body.stream

						// 11.2
						const reader = stream.getReader()

						// 11.3
						readAllBytes(reader).then(
							bodyReadPromise.resolve,
							bodyReadPromise.reject,
						)
					} else {
						bodyReadPromise.resolve(undefined)
					}

					// 12.
					/** @type {CacheBatchOperation[]} */
					const operations = []

					// 13.
					/** @type {CacheBatchOperation} */
					const operation = {
						type: 'put', // 14.
						request: innerRequest, // 15.
						response: clonedResponse, // 16.
					}

					// 17.
					operations.push(operation)

					// 19.
					const bytes = await bodyReadPromise.promise

					if (clonedResponse.body != null) {
						clonedResponse.body.source = bytes
					}

					// 19.1
					const cacheJobPromise = createDeferredPromise()

					// 19.2.1
					let errorData = null

					// 19.2.2
					try {
						this.#batchCacheOperations(operations)
					} catch (e) {
						errorData = e
					}

					// 19.2.3
					queueMicrotask(() => {
						// 19.2.3.1
						if (errorData === null) {
							cacheJobPromise.resolve()
						} else {
							// 19.2.3.2
							cacheJobPromise.reject(errorData)
						}
					})

					return cacheJobPromise.promise
				}

				async delete(request, options = {}) {
					webidl.brandCheck(this, Cache)
					webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.delete' })

					request = webidl.converters.RequestInfo(request)
					options = webidl.converters.CacheQueryOptions(options)

					/**
					 * @type {Request}
					 */
					let r = null

					if (request instanceof Request) {
						r = request[kState]

						if (r.method !== 'GET' && !options.ignoreMethod) {
							return false
						}
					} else {
						assert(typeof request === 'string')

						r = new Request(request)[kState]
					}

					/** @type {CacheBatchOperation[]} */
					const operations = []

					/** @type {CacheBatchOperation} */
					const operation = {
						type: 'delete',
						request: r,
						options,
					}

					operations.push(operation)

					const cacheJobPromise = createDeferredPromise()

					let errorData = null
					let requestResponses

					try {
						requestResponses = this.#batchCacheOperations(operations)
					} catch (e) {
						errorData = e
					}

					queueMicrotask(() => {
						if (errorData === null) {
							cacheJobPromise.resolve(!!requestResponses?.length)
						} else {
							cacheJobPromise.reject(errorData)
						}
					})

					return cacheJobPromise.promise
				}

				/**
				 * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
				 * @param {any} request
				 * @param {import('../../types/cache').CacheQueryOptions} options
				 * @returns {readonly Request[]}
				 */
				async keys(request = undefined, options = {}) {
					webidl.brandCheck(this, Cache)

					if (request !== undefined)
						request = webidl.converters.RequestInfo(request)
					options = webidl.converters.CacheQueryOptions(options)

					// 1.
					let r = null

					// 2.
					if (request !== undefined) {
						// 2.1
						if (request instanceof Request) {
							// 2.1.1
							r = request[kState]

							// 2.1.2
							if (r.method !== 'GET' && !options.ignoreMethod) {
								return []
							}
						} else if (typeof request === 'string') {
							// 2.2
							r = new Request(request)[kState]
						}
					}

					// 4.
					const promise = createDeferredPromise()

					// 5.
					// 5.1
					const requests = []

					// 5.2
					if (request === undefined) {
						// 5.2.1
						for (const requestResponse of this.#relevantRequestResponseList) {
							// 5.2.1.1
							requests.push(requestResponse[0])
						}
					} else {
						// 5.3
						// 5.3.1
						const requestResponses = this.#queryCache(r, options)

						// 5.3.2
						for (const requestResponse of requestResponses) {
							// 5.3.2.1
							requests.push(requestResponse[0])
						}
					}

					// 5.4
					queueMicrotask(() => {
						// 5.4.1
						const requestList = []

						// 5.4.2
						for (const request of requests) {
							const requestObject = new Request('https://a')
							requestObject[kState] = request
							requestObject[kHeaders][kHeadersList] = request.headersList
							requestObject[kHeaders][kGuard] = 'immutable'
							requestObject[kRealm] = request.client

							// 5.4.2.1
							requestList.push(requestObject)
						}

						// 5.4.3
						promise.resolve(Object.freeze(requestList))
					})

					return promise.promise
				}

				/**
				 * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
				 * @param {CacheBatchOperation[]} operations
				 * @returns {requestResponseList}
				 */
				#batchCacheOperations(operations) {
					// 1.
					const cache = this.#relevantRequestResponseList

					// 2.
					const backupCache = [...cache]

					// 3.
					const addedItems = []

					// 4.1
					const resultList = []

					try {
						// 4.2
						for (const operation of operations) {
							// 4.2.1
							if (operation.type !== 'delete' && operation.type !== 'put') {
								throw webidl.errors.exception({
									header: 'Cache.#batchCacheOperations',
									message: 'operation type does not match "delete" or "put"',
								})
							}

							// 4.2.2
							if (operation.type === 'delete' && operation.response != null) {
								throw webidl.errors.exception({
									header: 'Cache.#batchCacheOperations',
									message:
										'delete operation should not have an associated response',
								})
							}

							// 4.2.3
							if (
								this.#queryCache(
									operation.request,
									operation.options,
									addedItems,
								).length
							) {
								throw new DOMException('???', 'InvalidStateError')
							}

							// 4.2.4
							let requestResponses

							// 4.2.5
							if (operation.type === 'delete') {
								// 4.2.5.1
								requestResponses = this.#queryCache(
									operation.request,
									operation.options,
								)

								// TODO: the spec is wrong, this is needed to pass WPTs
								if (requestResponses.length === 0) {
									return []
								}

								// 4.2.5.2
								for (const requestResponse of requestResponses) {
									const idx = cache.indexOf(requestResponse)
									assert(idx !== -1)

									// 4.2.5.2.1
									cache.splice(idx, 1)
								}
							} else if (operation.type === 'put') {
								// 4.2.6
								// 4.2.6.1
								if (operation.response == null) {
									throw webidl.errors.exception({
										header: 'Cache.#batchCacheOperations',
										message: 'put operation should have an associated response',
									})
								}

								// 4.2.6.2
								const r = operation.request

								// 4.2.6.3
								if (!urlIsHttpHttpsScheme(r.url)) {
									throw webidl.errors.exception({
										header: 'Cache.#batchCacheOperations',
										message: 'expected http or https scheme',
									})
								}

								// 4.2.6.4
								if (r.method !== 'GET') {
									throw webidl.errors.exception({
										header: 'Cache.#batchCacheOperations',
										message: 'not get method',
									})
								}

								// 4.2.6.5
								if (operation.options != null) {
									throw webidl.errors.exception({
										header: 'Cache.#batchCacheOperations',
										message: 'options must not be defined',
									})
								}

								// 4.2.6.6
								requestResponses = this.#queryCache(operation.request)

								// 4.2.6.7
								for (const requestResponse of requestResponses) {
									const idx = cache.indexOf(requestResponse)
									assert(idx !== -1)

									// 4.2.6.7.1
									cache.splice(idx, 1)
								}

								// 4.2.6.8
								cache.push([operation.request, operation.response])

								// 4.2.6.10
								addedItems.push([operation.request, operation.response])
							}

							// 4.2.7
							resultList.push([operation.request, operation.response])
						}

						// 4.3
						return resultList
					} catch (e) {
						// 5.
						// 5.1
						this.#relevantRequestResponseList.length = 0

						// 5.2
						this.#relevantRequestResponseList = backupCache

						// 5.3
						throw e
					}
				}

				/**
				 * @see https://w3c.github.io/ServiceWorker/#query-cache
				 * @param {any} requestQuery
				 * @param {import('../../types/cache').CacheQueryOptions} options
				 * @param {requestResponseList} targetStorage
				 * @returns {requestResponseList}
				 */
				#queryCache(requestQuery, options, targetStorage) {
					/** @type {requestResponseList} */
					const resultList = []

					const storage = targetStorage ?? this.#relevantRequestResponseList

					for (const requestResponse of storage) {
						const [cachedRequest, cachedResponse] = requestResponse
						if (
							this.#requestMatchesCachedItem(
								requestQuery,
								cachedRequest,
								cachedResponse,
								options,
							)
						) {
							resultList.push(requestResponse)
						}
					}

					return resultList
				}

				/**
				 * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
				 * @param {any} requestQuery
				 * @param {any} request
				 * @param {any | null} response
				 * @param {import('../../types/cache').CacheQueryOptions | undefined} options
				 * @returns {boolean}
				 */
				#requestMatchesCachedItem(
					requestQuery,
					request,
					response = null,
					options,
				) {
					// if (options?.ignoreMethod === false && request.method === 'GET') {
					//   return false
					// }

					const queryURL = new URL(requestQuery.url)

					const cachedURL = new URL(request.url)

					if (options?.ignoreSearch) {
						cachedURL.search = ''

						queryURL.search = ''
					}

					if (!urlEquals(queryURL, cachedURL, true)) {
						return false
					}

					if (
						response == null ||
						options?.ignoreVary ||
						!response.headersList.contains('vary')
					) {
						return true
					}

					const fieldValues = getFieldValues(response.headersList.get('vary'))

					for (const fieldValue of fieldValues) {
						if (fieldValue === '*') {
							return false
						}

						const requestValue = request.headersList.get(fieldValue)
						const queryValue = requestQuery.headersList.get(fieldValue)

						// If one has the header and the other doesn't, or one has
						// a different value than the other, return false
						if (requestValue !== queryValue) {
							return false
						}
					}

					return true
				}
			}

			Object.defineProperties(Cache.prototype, {
				[Symbol.toStringTag]: {
					value: 'Cache',
					configurable: true,
				},
				match: kEnumerableProperty,
				matchAll: kEnumerableProperty,
				add: kEnumerableProperty,
				addAll: kEnumerableProperty,
				put: kEnumerableProperty,
				delete: kEnumerableProperty,
				keys: kEnumerableProperty,
			})

			const cacheQueryOptionConverters = [
				{
					key: 'ignoreSearch',
					converter: webidl.converters.boolean,
					defaultValue: false,
				},
				{
					key: 'ignoreMethod',
					converter: webidl.converters.boolean,
					defaultValue: false,
				},
				{
					key: 'ignoreVary',
					converter: webidl.converters.boolean,
					defaultValue: false,
				},
			]

			webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(
				cacheQueryOptionConverters,
			)

			webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
				...cacheQueryOptionConverters,
				{
					key: 'cacheName',
					converter: webidl.converters.DOMString,
				},
			])

			webidl.converters.Response = webidl.interfaceConverter(Response)

			webidl.converters['sequence<RequestInfo>'] = webidl.sequenceConverter(
				webidl.converters.RequestInfo,
			)

			module.exports = {
				Cache,
			}

			/***/
		},

		/***/ 44738: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { kConstruct } = __nccwpck_require__(80296)
			const { Cache } = __nccwpck_require__(50479)
			const { webidl } = __nccwpck_require__(74222)
			const { kEnumerableProperty } = __nccwpck_require__(3440)

			class CacheStorage {
				/**
				 * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
				 * @type {Map<string, import('./cache').requestResponseList}
				 */
				#caches = new Map()

				constructor() {
					if (arguments[0] !== kConstruct) {
						webidl.illegalConstructor()
					}
				}

				async match(request, options = {}) {
					webidl.brandCheck(this, CacheStorage)
					webidl.argumentLengthCheck(arguments, 1, {
						header: 'CacheStorage.match',
					})

					request = webidl.converters.RequestInfo(request)
					options = webidl.converters.MultiCacheQueryOptions(options)

					// 1.
					if (options.cacheName != null) {
						// 1.1.1.1
						if (this.#caches.has(options.cacheName)) {
							// 1.1.1.1.1
							const cacheList = this.#caches.get(options.cacheName)
							const cache = new Cache(kConstruct, cacheList)

							return await cache.match(request, options)
						}
					} else {
						// 2.
						// 2.2
						for (const cacheList of this.#caches.values()) {
							const cache = new Cache(kConstruct, cacheList)

							// 2.2.1.2
							const response = await cache.match(request, options)

							if (response !== undefined) {
								return response
							}
						}
					}
				}

				/**
				 * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
				 * @param {string} cacheName
				 * @returns {Promise<boolean>}
				 */
				async has(cacheName) {
					webidl.brandCheck(this, CacheStorage)
					webidl.argumentLengthCheck(arguments, 1, {
						header: 'CacheStorage.has',
					})

					cacheName = webidl.converters.DOMString(cacheName)

					// 2.1.1
					// 2.2
					return this.#caches.has(cacheName)
				}

				/**
				 * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
				 * @param {string} cacheName
				 * @returns {Promise<Cache>}
				 */
				async open(cacheName) {
					webidl.brandCheck(this, CacheStorage)
					webidl.argumentLengthCheck(arguments, 1, {
						header: 'CacheStorage.open',
					})

					cacheName = webidl.converters.DOMString(cacheName)

					// 2.1
					if (this.#caches.has(cacheName)) {
						// await caches.open('v1') !== await caches.open('v1')

						// 2.1.1
						const cache = this.#caches.get(cacheName)

						// 2.1.1.1
						return new Cache(kConstruct, cache)
					}

					// 2.2
					const cache = []

					// 2.3
					this.#caches.set(cacheName, cache)

					// 2.4
					return new Cache(kConstruct, cache)
				}

				/**
				 * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
				 * @param {string} cacheName
				 * @returns {Promise<boolean>}
				 */
				async delete(cacheName) {
					webidl.brandCheck(this, CacheStorage)
					webidl.argumentLengthCheck(arguments, 1, {
						header: 'CacheStorage.delete',
					})

					cacheName = webidl.converters.DOMString(cacheName)

					return this.#caches.delete(cacheName)
				}

				/**
				 * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
				 * @returns {string[]}
				 */
				async keys() {
					webidl.brandCheck(this, CacheStorage)

					// 2.1
					const keys = this.#caches.keys()

					// 2.2
					return [...keys]
				}
			}

			Object.defineProperties(CacheStorage.prototype, {
				[Symbol.toStringTag]: {
					value: 'CacheStorage',
					configurable: true,
				},
				match: kEnumerableProperty,
				has: kEnumerableProperty,
				open: kEnumerableProperty,
				delete: kEnumerableProperty,
				keys: kEnumerableProperty,
			})

			module.exports = {
				CacheStorage,
			}

			/***/
		},

		/***/ 80296: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			module.exports = {
				kConstruct: __nccwpck_require__(36443).kConstruct,
			}

			/***/
		},

		/***/ 23993: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const assert = __nccwpck_require__(42613)
			const { URLSerializer } = __nccwpck_require__(94322)
			const { isValidHeaderName } = __nccwpck_require__(15523)

			/**
			 * @see https://url.spec.whatwg.org/#concept-url-equals
			 * @param {URL} A
			 * @param {URL} B
			 * @param {boolean | undefined} excludeFragment
			 * @returns {boolean}
			 */
			function urlEquals(A, B, excludeFragment = false) {
				const serializedA = URLSerializer(A, excludeFragment)

				const serializedB = URLSerializer(B, excludeFragment)

				return serializedA === serializedB
			}

			/**
			 * @see https://github.com/chromium/chromium/blob/694d20d134cb553d8d89e5500b9148012b1ba299/content/browser/cache_storage/cache_storage_cache.cc#L260-L262
			 * @param {string} header
			 */
			function fieldValues(header) {
				assert(header !== null)

				const values = []

				for (let value of header.split(',')) {
					value = value.trim()

					if (!value.length) {
						continue
					} else if (!isValidHeaderName(value)) {
						continue
					}

					values.push(value)
				}

				return values
			}

			module.exports = {
				urlEquals,
				fieldValues,
			}

			/***/
		},

		/***/ 86197: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'
			// @ts-check

			/* global WebAssembly */

			const assert = __nccwpck_require__(42613)
			const net = __nccwpck_require__(69278)
			const http = __nccwpck_require__(58611)
			const { pipeline } = __nccwpck_require__(2203)
			const util = __nccwpck_require__(3440)
			const timers = __nccwpck_require__(28804)
			const Request = __nccwpck_require__(44655)
			const DispatcherBase = __nccwpck_require__(50001)
			const {
				RequestContentLengthMismatchError,
				ResponseContentLengthMismatchError,
				InvalidArgumentError,
				RequestAbortedError,
				HeadersTimeoutError,
				HeadersOverflowError,
				SocketError,
				InformationalError,
				BodyTimeoutError,
				HTTPParserError,
				ResponseExceededMaxSizeError,
				ClientDestroyedError,
			} = __nccwpck_require__(68707)
			const buildConnector = __nccwpck_require__(59136)
			const {
				kUrl,
				kReset,
				kServerName,
				kClient,
				kBusy,
				kParser,
				kConnect,
				kBlocking,
				kResuming,
				kRunning,
				kPending,
				kSize,
				kWriting,
				kQueue,
				kConnected,
				kConnecting,
				kNeedDrain,
				kNoRef,
				kKeepAliveDefaultTimeout,
				kHostHeader,
				kPendingIdx,
				kRunningIdx,
				kError,
				kPipelining,
				kSocket,
				kKeepAliveTimeoutValue,
				kMaxHeadersSize,
				kKeepAliveMaxTimeout,
				kKeepAliveTimeoutThreshold,
				kHeadersTimeout,
				kBodyTimeout,
				kStrictContentLength,
				kConnector,
				kMaxRedirections,
				kMaxRequests,
				kCounter,
				kClose,
				kDestroy,
				kDispatch,
				kInterceptors,
				kLocalAddress,
				kMaxResponseSize,
				kHTTPConnVersion,
				// HTTP2
				kHost,
				kHTTP2Session,
				kHTTP2SessionState,
				kHTTP2BuildRequest,
				kHTTP2CopyHeaders,
				kHTTP1BuildRequest,
			} = __nccwpck_require__(36443)

			/** @type {import('http2')} */
			let http2
			try {
				http2 = __nccwpck_require__(85675)
			} catch {
				// @ts-ignore
				http2 = { constants: {} }
			}

			const {
				constants: {
					HTTP2_HEADER_AUTHORITY,
					HTTP2_HEADER_METHOD,
					HTTP2_HEADER_PATH,
					HTTP2_HEADER_SCHEME,
					HTTP2_HEADER_CONTENT_LENGTH,
					HTTP2_HEADER_EXPECT,
					HTTP2_HEADER_STATUS,
				},
			} = http2

			// Experimental
			let h2ExperimentalWarned = false

			const FastBuffer = Buffer[Symbol.species]

			const kClosedResolve = Symbol('kClosedResolve')

			const channels = {}

			try {
				const diagnosticsChannel = __nccwpck_require__(31637)
				channels.sendHeaders = diagnosticsChannel.channel(
					'undici:client:sendHeaders',
				)
				channels.beforeConnect = diagnosticsChannel.channel(
					'undici:client:beforeConnect',
				)
				channels.connectError = diagnosticsChannel.channel(
					'undici:client:connectError',
				)
				channels.connected = diagnosticsChannel.channel(
					'undici:client:connected',
				)
			} catch {
				channels.sendHeaders = { hasSubscribers: false }
				channels.beforeConnect = { hasSubscribers: false }
				channels.connectError = { hasSubscribers: false }
				channels.connected = { hasSubscribers: false }
			}

			/**
			 * @type {import('../types/client').default}
			 */
			class Client extends DispatcherBase {
				/**
				 *
				 * @param {string|URL} url
				 * @param {import('../types/client').Client.Options} options
				 */
				constructor(
					url,
					{
						interceptors,
						maxHeaderSize,
						headersTimeout,
						socketTimeout,
						requestTimeout,
						connectTimeout,
						bodyTimeout,
						idleTimeout,
						keepAlive,
						keepAliveTimeout,
						maxKeepAliveTimeout,
						keepAliveMaxTimeout,
						keepAliveTimeoutThreshold,
						socketPath,
						pipelining,
						tls,
						strictContentLength,
						maxCachedSessions,
						maxRedirections,
						connect,
						maxRequestsPerClient,
						localAddress,
						maxResponseSize,
						autoSelectFamily,
						autoSelectFamilyAttemptTimeout,
						// h2
						allowH2,
						maxConcurrentStreams,
					} = {},
				) {
					super()

					if (keepAlive !== undefined) {
						throw new InvalidArgumentError(
							'unsupported keepAlive, use pipelining=0 instead',
						)
					}

					if (socketTimeout !== undefined) {
						throw new InvalidArgumentError(
							'unsupported socketTimeout, use headersTimeout & bodyTimeout instead',
						)
					}

					if (requestTimeout !== undefined) {
						throw new InvalidArgumentError(
							'unsupported requestTimeout, use headersTimeout & bodyTimeout instead',
						)
					}

					if (idleTimeout !== undefined) {
						throw new InvalidArgumentError(
							'unsupported idleTimeout, use keepAliveTimeout instead',
						)
					}

					if (maxKeepAliveTimeout !== undefined) {
						throw new InvalidArgumentError(
							'unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead',
						)
					}

					if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
						throw new InvalidArgumentError('invalid maxHeaderSize')
					}

					if (socketPath != null && typeof socketPath !== 'string') {
						throw new InvalidArgumentError('invalid socketPath')
					}

					if (
						connectTimeout != null &&
						(!Number.isFinite(connectTimeout) || connectTimeout < 0)
					) {
						throw new InvalidArgumentError('invalid connectTimeout')
					}

					if (
						keepAliveTimeout != null &&
						(!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)
					) {
						throw new InvalidArgumentError('invalid keepAliveTimeout')
					}

					if (
						keepAliveMaxTimeout != null &&
						(!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)
					) {
						throw new InvalidArgumentError('invalid keepAliveMaxTimeout')
					}

					if (
						keepAliveTimeoutThreshold != null &&
						!Number.isFinite(keepAliveTimeoutThreshold)
					) {
						throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold')
					}

					if (
						headersTimeout != null &&
						(!Number.isInteger(headersTimeout) || headersTimeout < 0)
					) {
						throw new InvalidArgumentError(
							'headersTimeout must be a positive integer or zero',
						)
					}

					if (
						bodyTimeout != null &&
						(!Number.isInteger(bodyTimeout) || bodyTimeout < 0)
					) {
						throw new InvalidArgumentError(
							'bodyTimeout must be a positive integer or zero',
						)
					}

					if (
						connect != null &&
						typeof connect !== 'function' &&
						typeof connect !== 'object'
					) {
						throw new InvalidArgumentError(
							'connect must be a function or an object',
						)
					}

					if (
						maxRedirections != null &&
						(!Number.isInteger(maxRedirections) || maxRedirections < 0)
					) {
						throw new InvalidArgumentError(
							'maxRedirections must be a positive number',
						)
					}

					if (
						maxRequestsPerClient != null &&
						(!Number.isInteger(maxRequestsPerClient) ||
							maxRequestsPerClient < 0)
					) {
						throw new InvalidArgumentError(
							'maxRequestsPerClient must be a positive number',
						)
					}

					if (
						localAddress != null &&
						(typeof localAddress !== 'string' || net.isIP(localAddress) === 0)
					) {
						throw new InvalidArgumentError(
							'localAddress must be valid string IP address',
						)
					}

					if (
						maxResponseSize != null &&
						(!Number.isInteger(maxResponseSize) || maxResponseSize < -1)
					) {
						throw new InvalidArgumentError(
							'maxResponseSize must be a positive number',
						)
					}

					if (
						autoSelectFamilyAttemptTimeout != null &&
						(!Number.isInteger(autoSelectFamilyAttemptTimeout) ||
							autoSelectFamilyAttemptTimeout < -1)
					) {
						throw new InvalidArgumentError(
							'autoSelectFamilyAttemptTimeout must be a positive number',
						)
					}

					// h2
					if (allowH2 != null && typeof allowH2 !== 'boolean') {
						throw new InvalidArgumentError(
							'allowH2 must be a valid boolean value',
						)
					}

					if (
						maxConcurrentStreams != null &&
						(typeof maxConcurrentStreams !== 'number' ||
							maxConcurrentStreams < 1)
					) {
						throw new InvalidArgumentError(
							'maxConcurrentStreams must be a possitive integer, greater than 0',
						)
					}

					if (typeof connect !== 'function') {
						connect = buildConnector({
							...tls,
							maxCachedSessions,
							allowH2,
							socketPath,
							timeout: connectTimeout,
							...(util.nodeHasAutoSelectFamily && autoSelectFamily
								? { autoSelectFamily, autoSelectFamilyAttemptTimeout }
								: undefined),
							...connect,
						})
					}

					this[kInterceptors] =
						interceptors &&
						interceptors.Client &&
						Array.isArray(interceptors.Client)
							? interceptors.Client
							: [createRedirectInterceptor({ maxRedirections })]
					this[kUrl] = util.parseOrigin(url)
					this[kConnector] = connect
					this[kSocket] = null
					this[kPipelining] = pipelining != null ? pipelining : 1
					this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize
					this[kKeepAliveDefaultTimeout] =
						keepAliveTimeout == null ? 4e3 : keepAliveTimeout
					this[kKeepAliveMaxTimeout] =
						keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout
					this[kKeepAliveTimeoutThreshold] =
						keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold
					this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout]
					this[kServerName] = null
					this[kLocalAddress] = localAddress != null ? localAddress : null
					this[kResuming] = 0 // 0, idle, 1, scheduled, 2 resuming
					this[kNeedDrain] = 0 // 0, idle, 1, scheduled, 2 resuming
					this[kHostHeader] =
						`host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\r\n`
					this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300e3
					this[kHeadersTimeout] =
						headersTimeout != null ? headersTimeout : 300e3
					this[kStrictContentLength] =
						strictContentLength == null ? true : strictContentLength
					this[kMaxRedirections] = maxRedirections
					this[kMaxRequests] = maxRequestsPerClient
					this[kClosedResolve] = null
					this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1
					this[kHTTPConnVersion] = 'h1'

					// HTTP/2
					this[kHTTP2Session] = null
					this[kHTTP2SessionState] = !allowH2
						? null
						: {
								// streams: null, // Fixed queue of streams - For future support of `push`
								openStreams: 0, // Keep track of them to decide wether or not unref the session
								maxConcurrentStreams:
									maxConcurrentStreams != null ? maxConcurrentStreams : 100, // Max peerConcurrentStreams for a Node h2 server
							}
					this[kHost] =
						`${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}`

					// kQueue is built up of 3 sections separated by
					// the kRunningIdx and kPendingIdx indices.
					// |   complete   |   running   |   pending   |
					//                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length
					// kRunningIdx points to the first running element.
					// kPendingIdx points to the first pending element.
					// This implements a fast queue with an amortized
					// time of O(1).

					this[kQueue] = []
					this[kRunningIdx] = 0
					this[kPendingIdx] = 0
				}

				get pipelining() {
					return this[kPipelining]
				}

				set pipelining(value) {
					this[kPipelining] = value
					resume(this, true)
				}

				get [kPending]() {
					return this[kQueue].length - this[kPendingIdx]
				}

				get [kRunning]() {
					return this[kPendingIdx] - this[kRunningIdx]
				}

				get [kSize]() {
					return this[kQueue].length - this[kRunningIdx]
				}

				get [kConnected]() {
					return (
						!!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed
					)
				}

				get [kBusy]() {
					const socket = this[kSocket]
					return (
						(socket &&
							(socket[kReset] || socket[kWriting] || socket[kBlocking])) ||
						this[kSize] >= (this[kPipelining] || 1) ||
						this[kPending] > 0
					)
				}

				/* istanbul ignore: only used for test */
				[kConnect](cb) {
					connect(this)
					this.once('connect', cb)
				}

				[kDispatch](opts, handler) {
					const origin = opts.origin || this[kUrl].origin

					const request =
						this[kHTTPConnVersion] === 'h2'
							? Request[kHTTP2BuildRequest](origin, opts, handler)
							: Request[kHTTP1BuildRequest](origin, opts, handler)

					this[kQueue].push(request)
					if (this[kResuming]) {
						// Do nothing.
					} else if (
						util.bodyLength(request.body) == null &&
						util.isIterable(request.body)
					) {
						// Wait a tick in case stream/iterator is ended in the same tick.
						this[kResuming] = 1
						process.nextTick(resume, this)
					} else {
						resume(this, true)
					}

					if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
						this[kNeedDrain] = 2
					}

					return this[kNeedDrain] < 2
				}

				async [kClose]() {
					// TODO: for H2 we need to gracefully flush the remaining enqueued
					// request and close each stream.
					return new Promise((resolve) => {
						if (!this[kSize]) {
							resolve(null)
						} else {
							this[kClosedResolve] = resolve
						}
					})
				}

				async [kDestroy](err) {
					return new Promise((resolve) => {
						const requests = this[kQueue].splice(this[kPendingIdx])
						for (let i = 0; i < requests.length; i++) {
							const request = requests[i]
							errorRequest(this, request, err)
						}

						const callback = () => {
							if (this[kClosedResolve]) {
								// TODO (fix): Should we error here with ClientDestroyedError?
								this[kClosedResolve]()
								this[kClosedResolve] = null
							}
							resolve()
						}

						if (this[kHTTP2Session] != null) {
							util.destroy(this[kHTTP2Session], err)
							this[kHTTP2Session] = null
							this[kHTTP2SessionState] = null
						}

						if (!this[kSocket]) {
							queueMicrotask(callback)
						} else {
							util.destroy(this[kSocket].on('close', callback), err)
						}

						resume(this)
					})
				}
			}

			function onHttp2SessionError(err) {
				assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')

				this[kSocket][kError] = err

				onError(this[kClient], err)
			}

			function onHttp2FrameError(type, code, id) {
				const err = new InformationalError(
					`HTTP/2: "frameError" received - type ${type}, code ${code}`,
				)

				if (id === 0) {
					this[kSocket][kError] = err
					onError(this[kClient], err)
				}
			}

			function onHttp2SessionEnd() {
				util.destroy(this, new SocketError('other side closed'))
				util.destroy(this[kSocket], new SocketError('other side closed'))
			}

			function onHTTP2GoAway(code) {
				const client = this[kClient]
				const err = new InformationalError(
					`HTTP/2: "GOAWAY" frame received with code ${code}`,
				)
				client[kSocket] = null
				client[kHTTP2Session] = null

				if (client.destroyed) {
					assert(this[kPending] === 0)

					// Fail entire queue.
					const requests = client[kQueue].splice(client[kRunningIdx])
					for (let i = 0; i < requests.length; i++) {
						const request = requests[i]
						errorRequest(this, request, err)
					}
				} else if (client[kRunning] > 0) {
					// Fail head of pipeline.
					const request = client[kQueue][client[kRunningIdx]]
					client[kQueue][client[kRunningIdx]++] = null

					errorRequest(client, request, err)
				}

				client[kPendingIdx] = client[kRunningIdx]

				assert(client[kRunning] === 0)

				client.emit('disconnect', client[kUrl], [client], err)

				resume(client)
			}

			const constants = __nccwpck_require__(52824)
			const createRedirectInterceptor = __nccwpck_require__(64415)
			const EMPTY_BUF = Buffer.alloc(0)

			async function lazyllhttp() {
				const llhttpWasmData = process.env.JEST_WORKER_ID
					? __nccwpck_require__(63870)
					: undefined

				let mod
				try {
					mod = await WebAssembly.compile(
						Buffer.from(__nccwpck_require__(53434), 'base64'),
					)
				} catch (e) {
					/* istanbul ignore next */

					// We could check if the error was caused by the simd option not
					// being enabled, but the occurring of this other error
					// * https://github.com/emscripten-core/emscripten/issues/11495
					// got me to remove that check to avoid breaking Node 12.
					mod = await WebAssembly.compile(
						Buffer.from(llhttpWasmData || __nccwpck_require__(63870), 'base64'),
					)
				}

				return await WebAssembly.instantiate(mod, {
					env: {
						/* eslint-disable camelcase */

						wasm_on_url: (p, at, len) => {
							/* istanbul ignore next */
							return 0
						},
						wasm_on_status: (p, at, len) => {
							assert.strictEqual(currentParser.ptr, p)
							const start = at - currentBufferPtr + currentBufferRef.byteOffset
							return (
								currentParser.onStatus(
									new FastBuffer(currentBufferRef.buffer, start, len),
								) || 0
							)
						},
						wasm_on_message_begin: (p) => {
							assert.strictEqual(currentParser.ptr, p)
							return currentParser.onMessageBegin() || 0
						},
						wasm_on_header_field: (p, at, len) => {
							assert.strictEqual(currentParser.ptr, p)
							const start = at - currentBufferPtr + currentBufferRef.byteOffset
							return (
								currentParser.onHeaderField(
									new FastBuffer(currentBufferRef.buffer, start, len),
								) || 0
							)
						},
						wasm_on_header_value: (p, at, len) => {
							assert.strictEqual(currentParser.ptr, p)
							const start = at - currentBufferPtr + currentBufferRef.byteOffset
							return (
								currentParser.onHeaderValue(
									new FastBuffer(currentBufferRef.buffer, start, len),
								) || 0
							)
						},
						wasm_on_headers_complete: (
							p,
							statusCode,
							upgrade,
							shouldKeepAlive,
						) => {
							assert.strictEqual(currentParser.ptr, p)
							return (
								currentParser.onHeadersComplete(
									statusCode,
									Boolean(upgrade),
									Boolean(shouldKeepAlive),
								) || 0
							)
						},
						wasm_on_body: (p, at, len) => {
							assert.strictEqual(currentParser.ptr, p)
							const start = at - currentBufferPtr + currentBufferRef.byteOffset
							return (
								currentParser.onBody(
									new FastBuffer(currentBufferRef.buffer, start, len),
								) || 0
							)
						},
						wasm_on_message_complete: (p) => {
							assert.strictEqual(currentParser.ptr, p)
							return currentParser.onMessageComplete() || 0
						},

						/* eslint-enable camelcase */
					},
				})
			}

			let llhttpInstance = null
			let llhttpPromise = lazyllhttp()
			llhttpPromise.catch()

			let currentParser = null
			let currentBufferRef = null
			let currentBufferSize = 0
			let currentBufferPtr = null

			const TIMEOUT_HEADERS = 1
			const TIMEOUT_BODY = 2
			const TIMEOUT_IDLE = 3

			class Parser {
				constructor(client, socket, { exports }) {
					assert(
						Number.isFinite(client[kMaxHeadersSize]) &&
							client[kMaxHeadersSize] > 0,
					)

					this.llhttp = exports
					this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE)
					this.client = client
					this.socket = socket
					this.timeout = null
					this.timeoutValue = null
					this.timeoutType = null
					this.statusCode = null
					this.statusText = ''
					this.upgrade = false
					this.headers = []
					this.headersSize = 0
					this.headersMaxSize = client[kMaxHeadersSize]
					this.shouldKeepAlive = false
					this.paused = false
					this.resume = this.resume.bind(this)

					this.bytesRead = 0

					this.keepAlive = ''
					this.contentLength = ''
					this.connection = ''
					this.maxResponseSize = client[kMaxResponseSize]
				}

				setTimeout(value, type) {
					this.timeoutType = type
					if (value !== this.timeoutValue) {
						timers.clearTimeout(this.timeout)
						if (value) {
							this.timeout = timers.setTimeout(onParserTimeout, value, this)
							// istanbul ignore else: only for jest
							if (this.timeout.unref) {
								this.timeout.unref()
							}
						} else {
							this.timeout = null
						}
						this.timeoutValue = value
					} else if (this.timeout) {
						// istanbul ignore else: only for jest
						if (this.timeout.refresh) {
							this.timeout.refresh()
						}
					}
				}

				resume() {
					if (this.socket.destroyed || !this.paused) {
						return
					}

					assert(this.ptr != null)
					assert(currentParser == null)

					this.llhttp.llhttp_resume(this.ptr)

					assert(this.timeoutType === TIMEOUT_BODY)
					if (this.timeout) {
						// istanbul ignore else: only for jest
						if (this.timeout.refresh) {
							this.timeout.refresh()
						}
					}

					this.paused = false
					this.execute(this.socket.read() || EMPTY_BUF) // Flush parser.
					this.readMore()
				}

				readMore() {
					while (!this.paused && this.ptr) {
						const chunk = this.socket.read()
						if (chunk === null) {
							break
						}
						this.execute(chunk)
					}
				}

				execute(data) {
					assert(this.ptr != null)
					assert(currentParser == null)
					assert(!this.paused)

					const { socket, llhttp } = this

					if (data.length > currentBufferSize) {
						if (currentBufferPtr) {
							llhttp.free(currentBufferPtr)
						}
						currentBufferSize = Math.ceil(data.length / 4096) * 4096
						currentBufferPtr = llhttp.malloc(currentBufferSize)
					}

					new Uint8Array(
						llhttp.memory.buffer,
						currentBufferPtr,
						currentBufferSize,
					).set(data)

					// Call `execute` on the wasm parser.
					// We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,
					// and finally the length of bytes to parse.
					// The return value is an error code or `constants.ERROR.OK`.
					try {
						let ret

						try {
							currentBufferRef = data
							currentParser = this
							ret = llhttp.llhttp_execute(
								this.ptr,
								currentBufferPtr,
								data.length,
							)
							/* eslint-disable-next-line no-useless-catch */
						} catch (err) {
							/* istanbul ignore next: difficult to make a test case for */
							throw err
						} finally {
							currentParser = null
							currentBufferRef = null
						}

						const offset =
							llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr

						if (ret === constants.ERROR.PAUSED_UPGRADE) {
							this.onUpgrade(data.slice(offset))
						} else if (ret === constants.ERROR.PAUSED) {
							this.paused = true
							socket.unshift(data.slice(offset))
						} else if (ret !== constants.ERROR.OK) {
							const ptr = llhttp.llhttp_get_error_reason(this.ptr)
							let message = ''
							/* istanbul ignore else: difficult to make a test case for */
							if (ptr) {
								const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0)
								message =
									'Response does not match the HTTP/1.1 protocol (' +
									Buffer.from(llhttp.memory.buffer, ptr, len).toString() +
									')'
							}
							throw new HTTPParserError(
								message,
								constants.ERROR[ret],
								data.slice(offset),
							)
						}
					} catch (err) {
						util.destroy(socket, err)
					}
				}

				destroy() {
					assert(this.ptr != null)
					assert(currentParser == null)

					this.llhttp.llhttp_free(this.ptr)
					this.ptr = null

					timers.clearTimeout(this.timeout)
					this.timeout = null
					this.timeoutValue = null
					this.timeoutType = null

					this.paused = false
				}

				onStatus(buf) {
					this.statusText = buf.toString()
				}

				onMessageBegin() {
					const { socket, client } = this

					/* istanbul ignore next: difficult to make a test case for */
					if (socket.destroyed) {
						return -1
					}

					const request = client[kQueue][client[kRunningIdx]]
					if (!request) {
						return -1
					}
				}

				onHeaderField(buf) {
					const len = this.headers.length

					if ((len & 1) === 0) {
						this.headers.push(buf)
					} else {
						this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])
					}

					this.trackHeader(buf.length)
				}

				onHeaderValue(buf) {
					let len = this.headers.length

					if ((len & 1) === 1) {
						this.headers.push(buf)
						len += 1
					} else {
						this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])
					}

					const key = this.headers[len - 2]
					if (
						key.length === 10 &&
						key.toString().toLowerCase() === 'keep-alive'
					) {
						this.keepAlive += buf.toString()
					} else if (
						key.length === 10 &&
						key.toString().toLowerCase() === 'connection'
					) {
						this.connection += buf.toString()
					} else if (
						key.length === 14 &&
						key.toString().toLowerCase() === 'content-length'
					) {
						this.contentLength += buf.toString()
					}

					this.trackHeader(buf.length)
				}

				trackHeader(len) {
					this.headersSize += len
					if (this.headersSize >= this.headersMaxSize) {
						util.destroy(this.socket, new HeadersOverflowError())
					}
				}

				onUpgrade(head) {
					const { upgrade, client, socket, headers, statusCode } = this

					assert(upgrade)

					const request = client[kQueue][client[kRunningIdx]]
					assert(request)

					assert(!socket.destroyed)
					assert(socket === client[kSocket])
					assert(!this.paused)
					assert(request.upgrade || request.method === 'CONNECT')

					this.statusCode = null
					this.statusText = ''
					this.shouldKeepAlive = null

					assert(this.headers.length % 2 === 0)
					this.headers = []
					this.headersSize = 0

					socket.unshift(head)

					socket[kParser].destroy()
					socket[kParser] = null

					socket[kClient] = null
					socket[kError] = null
					socket
						.removeListener('error', onSocketError)
						.removeListener('readable', onSocketReadable)
						.removeListener('end', onSocketEnd)
						.removeListener('close', onSocketClose)

					client[kSocket] = null
					client[kQueue][client[kRunningIdx]++] = null
					client.emit(
						'disconnect',
						client[kUrl],
						[client],
						new InformationalError('upgrade'),
					)

					try {
						request.onUpgrade(statusCode, headers, socket)
					} catch (err) {
						util.destroy(socket, err)
					}

					resume(client)
				}

				onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
					const { client, socket, headers, statusText } = this

					/* istanbul ignore next: difficult to make a test case for */
					if (socket.destroyed) {
						return -1
					}

					const request = client[kQueue][client[kRunningIdx]]

					/* istanbul ignore next: difficult to make a test case for */
					if (!request) {
						return -1
					}

					assert(!this.upgrade)
					assert(this.statusCode < 200)

					if (statusCode === 100) {
						util.destroy(
							socket,
							new SocketError('bad response', util.getSocketInfo(socket)),
						)
						return -1
					}

					/* this can only happen if server is misbehaving */
					if (upgrade && !request.upgrade) {
						util.destroy(
							socket,
							new SocketError('bad upgrade', util.getSocketInfo(socket)),
						)
						return -1
					}

					assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS)

					this.statusCode = statusCode
					this.shouldKeepAlive =
						shouldKeepAlive ||
						// Override llhttp value which does not allow keepAlive for HEAD.
						(request.method === 'HEAD' &&
							!socket[kReset] &&
							this.connection.toLowerCase() === 'keep-alive')

					if (this.statusCode >= 200) {
						const bodyTimeout =
							request.bodyTimeout != null
								? request.bodyTimeout
								: client[kBodyTimeout]
						this.setTimeout(bodyTimeout, TIMEOUT_BODY)
					} else if (this.timeout) {
						// istanbul ignore else: only for jest
						if (this.timeout.refresh) {
							this.timeout.refresh()
						}
					}

					if (request.method === 'CONNECT') {
						assert(client[kRunning] === 1)
						this.upgrade = true
						return 2
					}

					if (upgrade) {
						assert(client[kRunning] === 1)
						this.upgrade = true
						return 2
					}

					assert(this.headers.length % 2 === 0)
					this.headers = []
					this.headersSize = 0

					if (this.shouldKeepAlive && client[kPipelining]) {
						const keepAliveTimeout = this.keepAlive
							? util.parseKeepAliveTimeout(this.keepAlive)
							: null

						if (keepAliveTimeout != null) {
							const timeout = Math.min(
								keepAliveTimeout - client[kKeepAliveTimeoutThreshold],
								client[kKeepAliveMaxTimeout],
							)
							if (timeout <= 0) {
								socket[kReset] = true
							} else {
								client[kKeepAliveTimeoutValue] = timeout
							}
						} else {
							client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout]
						}
					} else {
						// Stop more requests from being dispatched.
						socket[kReset] = true
					}

					const pause =
						request.onHeaders(statusCode, headers, this.resume, statusText) ===
						false

					if (request.aborted) {
						return -1
					}

					if (request.method === 'HEAD') {
						return 1
					}

					if (statusCode < 200) {
						return 1
					}

					if (socket[kBlocking]) {
						socket[kBlocking] = false
						resume(client)
					}

					return pause ? constants.ERROR.PAUSED : 0
				}

				onBody(buf) {
					const { client, socket, statusCode, maxResponseSize } = this

					if (socket.destroyed) {
						return -1
					}

					const request = client[kQueue][client[kRunningIdx]]
					assert(request)

					assert.strictEqual(this.timeoutType, TIMEOUT_BODY)
					if (this.timeout) {
						// istanbul ignore else: only for jest
						if (this.timeout.refresh) {
							this.timeout.refresh()
						}
					}

					assert(statusCode >= 200)

					if (
						maxResponseSize > -1 &&
						this.bytesRead + buf.length > maxResponseSize
					) {
						util.destroy(socket, new ResponseExceededMaxSizeError())
						return -1
					}

					this.bytesRead += buf.length

					if (request.onData(buf) === false) {
						return constants.ERROR.PAUSED
					}
				}

				onMessageComplete() {
					const {
						client,
						socket,
						statusCode,
						upgrade,
						headers,
						contentLength,
						bytesRead,
						shouldKeepAlive,
					} = this

					if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
						return -1
					}

					if (upgrade) {
						return
					}

					const request = client[kQueue][client[kRunningIdx]]
					assert(request)

					assert(statusCode >= 100)

					this.statusCode = null
					this.statusText = ''
					this.bytesRead = 0
					this.contentLength = ''
					this.keepAlive = ''
					this.connection = ''

					assert(this.headers.length % 2 === 0)
					this.headers = []
					this.headersSize = 0

					if (statusCode < 200) {
						return
					}

					/* istanbul ignore next: should be handled by llhttp? */
					if (
						request.method !== 'HEAD' &&
						contentLength &&
						bytesRead !== parseInt(contentLength, 10)
					) {
						util.destroy(socket, new ResponseContentLengthMismatchError())
						return -1
					}

					request.onComplete(headers)

					client[kQueue][client[kRunningIdx]++] = null

					if (socket[kWriting]) {
						assert.strictEqual(client[kRunning], 0)
						// Response completed before request.
						util.destroy(socket, new InformationalError('reset'))
						return constants.ERROR.PAUSED
					} else if (!shouldKeepAlive) {
						util.destroy(socket, new InformationalError('reset'))
						return constants.ERROR.PAUSED
					} else if (socket[kReset] && client[kRunning] === 0) {
						// Destroy socket once all requests have completed.
						// The request at the tail of the pipeline is the one
						// that requested reset and no further requests should
						// have been queued since then.
						util.destroy(socket, new InformationalError('reset'))
						return constants.ERROR.PAUSED
					} else if (client[kPipelining] === 1) {
						// We must wait a full event loop cycle to reuse this socket to make sure
						// that non-spec compliant servers are not closing the connection even if they
						// said they won't.
						setImmediate(resume, client)
					} else {
						resume(client)
					}
				}
			}

			function onParserTimeout(parser) {
				const { socket, timeoutType, client } = parser

				/* istanbul ignore else */
				if (timeoutType === TIMEOUT_HEADERS) {
					if (
						!socket[kWriting] ||
						socket.writableNeedDrain ||
						client[kRunning] > 1
					) {
						assert(!parser.paused, 'cannot be paused while waiting for headers')
						util.destroy(socket, new HeadersTimeoutError())
					}
				} else if (timeoutType === TIMEOUT_BODY) {
					if (!parser.paused) {
						util.destroy(socket, new BodyTimeoutError())
					}
				} else if (timeoutType === TIMEOUT_IDLE) {
					assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue])
					util.destroy(socket, new InformationalError('socket idle timeout'))
				}
			}

			function onSocketReadable() {
				const { [kParser]: parser } = this
				if (parser) {
					parser.readMore()
				}
			}

			function onSocketError(err) {
				const { [kClient]: client, [kParser]: parser } = this

				assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')

				if (client[kHTTPConnVersion] !== 'h2') {
					// On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded
					// to the user.
					if (
						err.code === 'ECONNRESET' &&
						parser.statusCode &&
						!parser.shouldKeepAlive
					) {
						// We treat all incoming data so for as a valid response.
						parser.onMessageComplete()
						return
					}
				}

				this[kError] = err

				onError(this[kClient], err)
			}

			function onError(client, err) {
				if (
					client[kRunning] === 0 &&
					err.code !== 'UND_ERR_INFO' &&
					err.code !== 'UND_ERR_SOCKET'
				) {
					// Error is not caused by running request and not a recoverable
					// socket error.

					assert(client[kPendingIdx] === client[kRunningIdx])

					const requests = client[kQueue].splice(client[kRunningIdx])
					for (let i = 0; i < requests.length; i++) {
						const request = requests[i]
						errorRequest(client, request, err)
					}
					assert(client[kSize] === 0)
				}
			}

			function onSocketEnd() {
				const { [kParser]: parser, [kClient]: client } = this

				if (client[kHTTPConnVersion] !== 'h2') {
					if (parser.statusCode && !parser.shouldKeepAlive) {
						// We treat all incoming data so far as a valid response.
						parser.onMessageComplete()
						return
					}
				}

				util.destroy(
					this,
					new SocketError('other side closed', util.getSocketInfo(this)),
				)
			}

			function onSocketClose() {
				const { [kClient]: client, [kParser]: parser } = this

				if (client[kHTTPConnVersion] === 'h1' && parser) {
					if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {
						// We treat all incoming data so far as a valid response.
						parser.onMessageComplete()
					}

					this[kParser].destroy()
					this[kParser] = null
				}

				const err =
					this[kError] || new SocketError('closed', util.getSocketInfo(this))

				client[kSocket] = null

				if (client.destroyed) {
					assert(client[kPending] === 0)

					// Fail entire queue.
					const requests = client[kQueue].splice(client[kRunningIdx])
					for (let i = 0; i < requests.length; i++) {
						const request = requests[i]
						errorRequest(client, request, err)
					}
				} else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {
					// Fail head of pipeline.
					const request = client[kQueue][client[kRunningIdx]]
					client[kQueue][client[kRunningIdx]++] = null

					errorRequest(client, request, err)
				}

				client[kPendingIdx] = client[kRunningIdx]

				assert(client[kRunning] === 0)

				client.emit('disconnect', client[kUrl], [client], err)

				resume(client)
			}

			async function connect(client) {
				assert(!client[kConnecting])
				assert(!client[kSocket])

				let { host, hostname, protocol, port } = client[kUrl]

				// Resolve ipv6
				if (hostname[0] === '[') {
					const idx = hostname.indexOf(']')

					assert(idx !== -1)
					const ip = hostname.substring(1, idx)

					assert(net.isIP(ip))
					hostname = ip
				}

				client[kConnecting] = true

				if (channels.beforeConnect.hasSubscribers) {
					channels.beforeConnect.publish({
						connectParams: {
							host,
							hostname,
							protocol,
							port,
							servername: client[kServerName],
							localAddress: client[kLocalAddress],
						},
						connector: client[kConnector],
					})
				}

				try {
					const socket = await new Promise((resolve, reject) => {
						client[kConnector](
							{
								host,
								hostname,
								protocol,
								port,
								servername: client[kServerName],
								localAddress: client[kLocalAddress],
							},
							(err, socket) => {
								if (err) {
									reject(err)
								} else {
									resolve(socket)
								}
							},
						)
					})

					if (client.destroyed) {
						util.destroy(
							socket.on('error', () => {}),
							new ClientDestroyedError(),
						)
						return
					}

					client[kConnecting] = false

					assert(socket)

					const isH2 = socket.alpnProtocol === 'h2'
					if (isH2) {
						if (!h2ExperimentalWarned) {
							h2ExperimentalWarned = true
							process.emitWarning(
								'H2 support is experimental, expect them to change at any time.',
								{
									code: 'UNDICI-H2',
								},
							)
						}

						const session = http2.connect(client[kUrl], {
							createConnection: () => socket,
							peerMaxConcurrentStreams:
								client[kHTTP2SessionState].maxConcurrentStreams,
						})

						client[kHTTPConnVersion] = 'h2'
						session[kClient] = client
						session[kSocket] = socket
						session.on('error', onHttp2SessionError)
						session.on('frameError', onHttp2FrameError)
						session.on('end', onHttp2SessionEnd)
						session.on('goaway', onHTTP2GoAway)
						session.on('close', onSocketClose)
						session.unref()

						client[kHTTP2Session] = session
						socket[kHTTP2Session] = session
					} else {
						if (!llhttpInstance) {
							llhttpInstance = await llhttpPromise
							llhttpPromise = null
						}

						socket[kNoRef] = false
						socket[kWriting] = false
						socket[kReset] = false
						socket[kBlocking] = false
						socket[kParser] = new Parser(client, socket, llhttpInstance)
					}

					socket[kCounter] = 0
					socket[kMaxRequests] = client[kMaxRequests]
					socket[kClient] = client
					socket[kError] = null

					socket
						.on('error', onSocketError)
						.on('readable', onSocketReadable)
						.on('end', onSocketEnd)
						.on('close', onSocketClose)

					client[kSocket] = socket

					if (channels.connected.hasSubscribers) {
						channels.connected.publish({
							connectParams: {
								host,
								hostname,
								protocol,
								port,
								servername: client[kServerName],
								localAddress: client[kLocalAddress],
							},
							connector: client[kConnector],
							socket,
						})
					}
					client.emit('connect', client[kUrl], [client])
				} catch (err) {
					if (client.destroyed) {
						return
					}

					client[kConnecting] = false

					if (channels.connectError.hasSubscribers) {
						channels.connectError.publish({
							connectParams: {
								host,
								hostname,
								protocol,
								port,
								servername: client[kServerName],
								localAddress: client[kLocalAddress],
							},
							connector: client[kConnector],
							error: err,
						})
					}

					if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {
						assert(client[kRunning] === 0)
						while (
							client[kPending] > 0 &&
							client[kQueue][client[kPendingIdx]].servername ===
								client[kServerName]
						) {
							const request = client[kQueue][client[kPendingIdx]++]
							errorRequest(client, request, err)
						}
					} else {
						onError(client, err)
					}

					client.emit('connectionError', client[kUrl], [client], err)
				}

				resume(client)
			}

			function emitDrain(client) {
				client[kNeedDrain] = 0
				client.emit('drain', client[kUrl], [client])
			}

			function resume(client, sync) {
				if (client[kResuming] === 2) {
					return
				}

				client[kResuming] = 2

				_resume(client, sync)
				client[kResuming] = 0

				if (client[kRunningIdx] > 256) {
					client[kQueue].splice(0, client[kRunningIdx])
					client[kPendingIdx] -= client[kRunningIdx]
					client[kRunningIdx] = 0
				}
			}

			function _resume(client, sync) {
				while (true) {
					if (client.destroyed) {
						assert(client[kPending] === 0)
						return
					}

					if (client[kClosedResolve] && !client[kSize]) {
						client[kClosedResolve]()
						client[kClosedResolve] = null
						return
					}

					const socket = client[kSocket]

					if (socket && !socket.destroyed && socket.alpnProtocol !== 'h2') {
						if (client[kSize] === 0) {
							if (!socket[kNoRef] && socket.unref) {
								socket.unref()
								socket[kNoRef] = true
							}
						} else if (socket[kNoRef] && socket.ref) {
							socket.ref()
							socket[kNoRef] = false
						}

						if (client[kSize] === 0) {
							if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
								socket[kParser].setTimeout(
									client[kKeepAliveTimeoutValue],
									TIMEOUT_IDLE,
								)
							}
						} else if (
							client[kRunning] > 0 &&
							socket[kParser].statusCode < 200
						) {
							if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
								const request = client[kQueue][client[kRunningIdx]]
								const headersTimeout =
									request.headersTimeout != null
										? request.headersTimeout
										: client[kHeadersTimeout]
								socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS)
							}
						}
					}

					if (client[kBusy]) {
						client[kNeedDrain] = 2
					} else if (client[kNeedDrain] === 2) {
						if (sync) {
							client[kNeedDrain] = 1
							process.nextTick(emitDrain, client)
						} else {
							emitDrain(client)
						}
						continue
					}

					if (client[kPending] === 0) {
						return
					}

					if (client[kRunning] >= (client[kPipelining] || 1)) {
						return
					}

					const request = client[kQueue][client[kPendingIdx]]

					if (
						client[kUrl].protocol === 'https:' &&
						client[kServerName] !== request.servername
					) {
						if (client[kRunning] > 0) {
							return
						}

						client[kServerName] = request.servername

						if (socket && socket.servername !== request.servername) {
							util.destroy(socket, new InformationalError('servername changed'))
							return
						}
					}

					if (client[kConnecting]) {
						return
					}

					if (!socket && !client[kHTTP2Session]) {
						connect(client)
						return
					}

					if (
						socket.destroyed ||
						socket[kWriting] ||
						socket[kReset] ||
						socket[kBlocking]
					) {
						return
					}

					if (client[kRunning] > 0 && !request.idempotent) {
						// Non-idempotent request cannot be retried.
						// Ensure that no other requests are inflight and
						// could cause failure.
						return
					}

					if (
						client[kRunning] > 0 &&
						(request.upgrade || request.method === 'CONNECT')
					) {
						// Don't dispatch an upgrade until all preceding requests have completed.
						// A misbehaving server might upgrade the connection before all pipelined
						// request has completed.
						return
					}

					if (
						client[kRunning] > 0 &&
						util.bodyLength(request.body) !== 0 &&
						(util.isStream(request.body) || util.isAsyncIterable(request.body))
					) {
						// Request with stream or iterator body can error while other requests
						// are inflight and indirectly error those as well.
						// Ensure this doesn't happen by waiting for inflight
						// to complete before dispatching.

						// Request with stream or iterator body cannot be retried.
						// Ensure that no other requests are inflight and
						// could cause failure.
						return
					}

					if (!request.aborted && write(client, request)) {
						client[kPendingIdx]++
					} else {
						client[kQueue].splice(client[kPendingIdx], 1)
					}
				}
			}

			// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2
			function shouldSendContentLength(method) {
				return (
					method !== 'GET' &&
					method !== 'HEAD' &&
					method !== 'OPTIONS' &&
					method !== 'TRACE' &&
					method !== 'CONNECT'
				)
			}

			function write(client, request) {
				if (client[kHTTPConnVersion] === 'h2') {
					writeH2(client, client[kHTTP2Session], request)
					return
				}

				const { body, method, path, host, upgrade, headers, blocking, reset } =
					request

				// https://tools.ietf.org/html/rfc7231#section-4.3.1
				// https://tools.ietf.org/html/rfc7231#section-4.3.2
				// https://tools.ietf.org/html/rfc7231#section-4.3.5

				// Sending a payload body on a request that does not
				// expect it can cause undefined behavior on some
				// servers and corrupt connection state. Do not
				// re-use the connection for further requests.

				const expectsPayload =
					method === 'PUT' || method === 'POST' || method === 'PATCH'

				if (body && typeof body.read === 'function') {
					// Try to read EOF in order to get length.
					body.read(0)
				}

				const bodyLength = util.bodyLength(body)

				let contentLength = bodyLength

				if (contentLength === null) {
					contentLength = request.contentLength
				}

				if (contentLength === 0 && !expectsPayload) {
					// https://tools.ietf.org/html/rfc7230#section-3.3.2
					// A user agent SHOULD NOT send a Content-Length header field when
					// the request message does not contain a payload body and the method
					// semantics do not anticipate such a body.

					contentLength = null
				}

				// https://github.com/nodejs/undici/issues/2046
				// A user agent may send a Content-Length header with 0 value, this should be allowed.
				if (
					shouldSendContentLength(method) &&
					contentLength > 0 &&
					request.contentLength !== null &&
					request.contentLength !== contentLength
				) {
					if (client[kStrictContentLength]) {
						errorRequest(
							client,
							request,
							new RequestContentLengthMismatchError(),
						)
						return false
					}

					process.emitWarning(new RequestContentLengthMismatchError())
				}

				const socket = client[kSocket]

				try {
					request.onConnect((err) => {
						if (request.aborted || request.completed) {
							return
						}

						errorRequest(client, request, err || new RequestAbortedError())

						util.destroy(socket, new InformationalError('aborted'))
					})
				} catch (err) {
					errorRequest(client, request, err)
				}

				if (request.aborted) {
					return false
				}

				if (method === 'HEAD') {
					// https://github.com/mcollina/undici/issues/258
					// Close after a HEAD request to interop with misbehaving servers
					// that may send a body in the response.

					socket[kReset] = true
				}

				if (upgrade || method === 'CONNECT') {
					// On CONNECT or upgrade, block pipeline from dispatching further
					// requests on this connection.

					socket[kReset] = true
				}

				if (reset != null) {
					socket[kReset] = reset
				}

				if (
					client[kMaxRequests] &&
					socket[kCounter]++ >= client[kMaxRequests]
				) {
					socket[kReset] = true
				}

				if (blocking) {
					socket[kBlocking] = true
				}

				let header = `${method} ${path} HTTP/1.1\r\n`

				if (typeof host === 'string') {
					header += `host: ${host}\r\n`
				} else {
					header += client[kHostHeader]
				}

				if (upgrade) {
					header += `connection: upgrade\r\nupgrade: ${upgrade}\r\n`
				} else if (client[kPipelining] && !socket[kReset]) {
					header += 'connection: keep-alive\r\n'
				} else {
					header += 'connection: close\r\n'
				}

				if (headers) {
					header += headers
				}

				if (channels.sendHeaders.hasSubscribers) {
					channels.sendHeaders.publish({ request, headers: header, socket })
				}

				/* istanbul ignore else: assertion */
				if (!body || bodyLength === 0) {
					if (contentLength === 0) {
						socket.write(`${header}content-length: 0\r\n\r\n`, 'latin1')
					} else {
						assert(
							contentLength === null,
							'no body must not have content length',
						)
						socket.write(`${header}\r\n`, 'latin1')
					}
					request.onRequestSent()
				} else if (util.isBuffer(body)) {
					assert(
						contentLength === body.byteLength,
						'buffer body must have content length',
					)

					socket.cork()
					socket.write(
						`${header}content-length: ${contentLength}\r\n\r\n`,
						'latin1',
					)
					socket.write(body)
					socket.uncork()
					request.onBodySent(body)
					request.onRequestSent()
					if (!expectsPayload) {
						socket[kReset] = true
					}
				} else if (util.isBlobLike(body)) {
					if (typeof body.stream === 'function') {
						writeIterable({
							body: body.stream(),
							client,
							request,
							socket,
							contentLength,
							header,
							expectsPayload,
						})
					} else {
						writeBlob({
							body,
							client,
							request,
							socket,
							contentLength,
							header,
							expectsPayload,
						})
					}
				} else if (util.isStream(body)) {
					writeStream({
						body,
						client,
						request,
						socket,
						contentLength,
						header,
						expectsPayload,
					})
				} else if (util.isIterable(body)) {
					writeIterable({
						body,
						client,
						request,
						socket,
						contentLength,
						header,
						expectsPayload,
					})
				} else {
					assert(false)
				}

				return true
			}

			function writeH2(client, session, request) {
				const {
					body,
					method,
					path,
					host,
					upgrade,
					expectContinue,
					signal,
					headers: reqHeaders,
				} = request

				let headers
				if (typeof reqHeaders === 'string')
					headers = Request[kHTTP2CopyHeaders](reqHeaders.trim())
				else headers = reqHeaders

				if (upgrade) {
					errorRequest(
						client,
						request,
						new Error('Upgrade not supported for H2'),
					)
					return false
				}

				try {
					// TODO(HTTP/2): Should we call onConnect immediately or on stream ready event?
					request.onConnect((err) => {
						if (request.aborted || request.completed) {
							return
						}

						errorRequest(client, request, err || new RequestAbortedError())
					})
				} catch (err) {
					errorRequest(client, request, err)
				}

				if (request.aborted) {
					return false
				}

				/** @type {import('node:http2').ClientHttp2Stream} */
				let stream
				const h2State = client[kHTTP2SessionState]

				headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost]
				headers[HTTP2_HEADER_METHOD] = method

				if (method === 'CONNECT') {
					session.ref()
					// we are already connected, streams are pending, first request
					// will create a new stream. We trigger a request to create the stream and wait until
					// `ready` event is triggered
					// We disabled endStream to allow the user to write to the stream
					stream = session.request(headers, { endStream: false, signal })

					if (stream.id && !stream.pending) {
						request.onUpgrade(null, null, stream)
						++h2State.openStreams
					} else {
						stream.once('ready', () => {
							request.onUpgrade(null, null, stream)
							++h2State.openStreams
						})
					}

					stream.once('close', () => {
						h2State.openStreams -= 1
						// TODO(HTTP/2): unref only if current streams count is 0
						if (h2State.openStreams === 0) session.unref()
					})

					return true
				}

				// https://tools.ietf.org/html/rfc7540#section-8.3
				// :path and :scheme headers must be omited when sending CONNECT

				headers[HTTP2_HEADER_PATH] = path
				headers[HTTP2_HEADER_SCHEME] = 'https'

				// https://tools.ietf.org/html/rfc7231#section-4.3.1
				// https://tools.ietf.org/html/rfc7231#section-4.3.2
				// https://tools.ietf.org/html/rfc7231#section-4.3.5

				// Sending a payload body on a request that does not
				// expect it can cause undefined behavior on some
				// servers and corrupt connection state. Do not
				// re-use the connection for further requests.

				const expectsPayload =
					method === 'PUT' || method === 'POST' || method === 'PATCH'

				if (body && typeof body.read === 'function') {
					// Try to read EOF in order to get length.
					body.read(0)
				}

				let contentLength = util.bodyLength(body)

				if (contentLength == null) {
					contentLength = request.contentLength
				}

				if (contentLength === 0 || !expectsPayload) {
					// https://tools.ietf.org/html/rfc7230#section-3.3.2
					// A user agent SHOULD NOT send a Content-Length header field when
					// the request message does not contain a payload body and the method
					// semantics do not anticipate such a body.

					contentLength = null
				}

				// https://github.com/nodejs/undici/issues/2046
				// A user agent may send a Content-Length header with 0 value, this should be allowed.
				if (
					shouldSendContentLength(method) &&
					contentLength > 0 &&
					request.contentLength != null &&
					request.contentLength !== contentLength
				) {
					if (client[kStrictContentLength]) {
						errorRequest(
							client,
							request,
							new RequestContentLengthMismatchError(),
						)
						return false
					}

					process.emitWarning(new RequestContentLengthMismatchError())
				}

				if (contentLength != null) {
					assert(body, 'no body must not have content length')
					headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`
				}

				session.ref()

				const shouldEndStream = method === 'GET' || method === 'HEAD'
				if (expectContinue) {
					headers[HTTP2_HEADER_EXPECT] = '100-continue'
					stream = session.request(headers, {
						endStream: shouldEndStream,
						signal,
					})

					stream.once('continue', writeBodyH2)
				} else {
					stream = session.request(headers, {
						endStream: shouldEndStream,
						signal,
					})
					writeBodyH2()
				}

				// Increment counter as we have new several streams open
				++h2State.openStreams

				stream.once('response', (headers) => {
					const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers

					if (
						request.onHeaders(
							Number(statusCode),
							realHeaders,
							stream.resume.bind(stream),
							'',
						) === false
					) {
						stream.pause()
					}
				})

				stream.once('end', () => {
					request.onComplete([])
				})

				stream.on('data', (chunk) => {
					if (request.onData(chunk) === false) {
						stream.pause()
					}
				})

				stream.once('close', () => {
					h2State.openStreams -= 1
					// TODO(HTTP/2): unref only if current streams count is 0
					if (h2State.openStreams === 0) {
						session.unref()
					}
				})

				stream.once('error', function (err) {
					if (
						client[kHTTP2Session] &&
						!client[kHTTP2Session].destroyed &&
						!this.closed &&
						!this.destroyed
					) {
						h2State.streams -= 1
						util.destroy(stream, err)
					}
				})

				stream.once('frameError', (type, code) => {
					const err = new InformationalError(
						`HTTP/2: "frameError" received - type ${type}, code ${code}`,
					)
					errorRequest(client, request, err)

					if (
						client[kHTTP2Session] &&
						!client[kHTTP2Session].destroyed &&
						!this.closed &&
						!this.destroyed
					) {
						h2State.streams -= 1
						util.destroy(stream, err)
					}
				})

				// stream.on('aborted', () => {
				//   // TODO(HTTP/2): Support aborted
				// })

				// stream.on('timeout', () => {
				//   // TODO(HTTP/2): Support timeout
				// })

				// stream.on('push', headers => {
				//   // TODO(HTTP/2): Suppor push
				// })

				// stream.on('trailers', headers => {
				//   // TODO(HTTP/2): Support trailers
				// })

				return true

				function writeBodyH2() {
					/* istanbul ignore else: assertion */
					if (!body) {
						request.onRequestSent()
					} else if (util.isBuffer(body)) {
						assert(
							contentLength === body.byteLength,
							'buffer body must have content length',
						)
						stream.cork()
						stream.write(body)
						stream.uncork()
						stream.end()
						request.onBodySent(body)
						request.onRequestSent()
					} else if (util.isBlobLike(body)) {
						if (typeof body.stream === 'function') {
							writeIterable({
								client,
								request,
								contentLength,
								h2stream: stream,
								expectsPayload,
								body: body.stream(),
								socket: client[kSocket],
								header: '',
							})
						} else {
							writeBlob({
								body,
								client,
								request,
								contentLength,
								expectsPayload,
								h2stream: stream,
								header: '',
								socket: client[kSocket],
							})
						}
					} else if (util.isStream(body)) {
						writeStream({
							body,
							client,
							request,
							contentLength,
							expectsPayload,
							socket: client[kSocket],
							h2stream: stream,
							header: '',
						})
					} else if (util.isIterable(body)) {
						writeIterable({
							body,
							client,
							request,
							contentLength,
							expectsPayload,
							header: '',
							h2stream: stream,
							socket: client[kSocket],
						})
					} else {
						assert(false)
					}
				}
			}

			function writeStream({
				h2stream,
				body,
				client,
				request,
				socket,
				contentLength,
				header,
				expectsPayload,
			}) {
				assert(
					contentLength !== 0 || client[kRunning] === 0,
					'stream body cannot be pipelined',
				)

				if (client[kHTTPConnVersion] === 'h2') {
					// For HTTP/2, is enough to pipe the stream
					const pipe = pipeline(body, h2stream, (err) => {
						if (err) {
							util.destroy(body, err)
							util.destroy(h2stream, err)
						} else {
							request.onRequestSent()
						}
					})

					pipe.on('data', onPipeData)
					pipe.once('end', () => {
						pipe.removeListener('data', onPipeData)
						util.destroy(pipe)
					})

					function onPipeData(chunk) {
						request.onBodySent(chunk)
					}

					return
				}

				let finished = false

				const writer = new AsyncWriter({
					socket,
					request,
					contentLength,
					client,
					expectsPayload,
					header,
				})

				const onData = function (chunk) {
					if (finished) {
						return
					}

					try {
						if (!writer.write(chunk) && this.pause) {
							this.pause()
						}
					} catch (err) {
						util.destroy(this, err)
					}
				}
				const onDrain = function () {
					if (finished) {
						return
					}

					if (body.resume) {
						body.resume()
					}
				}
				const onAbort = function () {
					if (finished) {
						return
					}
					const err = new RequestAbortedError()
					queueMicrotask(() => onFinished(err))
				}
				const onFinished = function (err) {
					if (finished) {
						return
					}

					finished = true

					assert(
						socket.destroyed || (socket[kWriting] && client[kRunning] <= 1),
					)

					socket.off('drain', onDrain).off('error', onFinished)

					body
						.removeListener('data', onData)
						.removeListener('end', onFinished)
						.removeListener('error', onFinished)
						.removeListener('close', onAbort)

					if (!err) {
						try {
							writer.end()
						} catch (er) {
							err = er
						}
					}

					writer.destroy(err)

					if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {
						util.destroy(body, err)
					} else {
						util.destroy(body)
					}
				}

				body
					.on('data', onData)
					.on('end', onFinished)
					.on('error', onFinished)
					.on('close', onAbort)

				if (body.resume) {
					body.resume()
				}

				socket.on('drain', onDrain).on('error', onFinished)
			}

			async function writeBlob({
				h2stream,
				body,
				client,
				request,
				socket,
				contentLength,
				header,
				expectsPayload,
			}) {
				assert(
					contentLength === body.size,
					'blob body must have content length',
				)

				const isH2 = client[kHTTPConnVersion] === 'h2'
				try {
					if (contentLength != null && contentLength !== body.size) {
						throw new RequestContentLengthMismatchError()
					}

					const buffer = Buffer.from(await body.arrayBuffer())

					if (isH2) {
						h2stream.cork()
						h2stream.write(buffer)
						h2stream.uncork()
					} else {
						socket.cork()
						socket.write(
							`${header}content-length: ${contentLength}\r\n\r\n`,
							'latin1',
						)
						socket.write(buffer)
						socket.uncork()
					}

					request.onBodySent(buffer)
					request.onRequestSent()

					if (!expectsPayload) {
						socket[kReset] = true
					}

					resume(client)
				} catch (err) {
					util.destroy(isH2 ? h2stream : socket, err)
				}
			}

			async function writeIterable({
				h2stream,
				body,
				client,
				request,
				socket,
				contentLength,
				header,
				expectsPayload,
			}) {
				assert(
					contentLength !== 0 || client[kRunning] === 0,
					'iterator body cannot be pipelined',
				)

				let callback = null
				function onDrain() {
					if (callback) {
						const cb = callback
						callback = null
						cb()
					}
				}

				const waitForDrain = () =>
					new Promise((resolve, reject) => {
						assert(callback === null)

						if (socket[kError]) {
							reject(socket[kError])
						} else {
							callback = resolve
						}
					})

				if (client[kHTTPConnVersion] === 'h2') {
					h2stream.on('close', onDrain).on('drain', onDrain)

					try {
						// It's up to the user to somehow abort the async iterable.
						for await (const chunk of body) {
							if (socket[kError]) {
								throw socket[kError]
							}

							const res = h2stream.write(chunk)
							request.onBodySent(chunk)
							if (!res) {
								await waitForDrain()
							}
						}
					} catch (err) {
						h2stream.destroy(err)
					} finally {
						request.onRequestSent()
						h2stream.end()
						h2stream.off('close', onDrain).off('drain', onDrain)
					}

					return
				}

				socket.on('close', onDrain).on('drain', onDrain)

				const writer = new AsyncWriter({
					socket,
					request,
					contentLength,
					client,
					expectsPayload,
					header,
				})
				try {
					// It's up to the user to somehow abort the async iterable.
					for await (const chunk of body) {
						if (socket[kError]) {
							throw socket[kError]
						}

						if (!writer.write(chunk)) {
							await waitForDrain()
						}
					}

					writer.end()
				} catch (err) {
					writer.destroy(err)
				} finally {
					socket.off('close', onDrain).off('drain', onDrain)
				}
			}

			class AsyncWriter {
				constructor({
					socket,
					request,
					contentLength,
					client,
					expectsPayload,
					header,
				}) {
					this.socket = socket
					this.request = request
					this.contentLength = contentLength
					this.client = client
					this.bytesWritten = 0
					this.expectsPayload = expectsPayload
					this.header = header

					socket[kWriting] = true
				}

				write(chunk) {
					const {
						socket,
						request,
						contentLength,
						client,
						bytesWritten,
						expectsPayload,
						header,
					} = this

					if (socket[kError]) {
						throw socket[kError]
					}

					if (socket.destroyed) {
						return false
					}

					const len = Buffer.byteLength(chunk)
					if (!len) {
						return true
					}

					// We should defer writing chunks.
					if (contentLength !== null && bytesWritten + len > contentLength) {
						if (client[kStrictContentLength]) {
							throw new RequestContentLengthMismatchError()
						}

						process.emitWarning(new RequestContentLengthMismatchError())
					}

					socket.cork()

					if (bytesWritten === 0) {
						if (!expectsPayload) {
							socket[kReset] = true
						}

						if (contentLength === null) {
							socket.write(`${header}transfer-encoding: chunked\r\n`, 'latin1')
						} else {
							socket.write(
								`${header}content-length: ${contentLength}\r\n\r\n`,
								'latin1',
							)
						}
					}

					if (contentLength === null) {
						socket.write(`\r\n${len.toString(16)}\r\n`, 'latin1')
					}

					this.bytesWritten += len

					const ret = socket.write(chunk)

					socket.uncork()

					request.onBodySent(chunk)

					if (!ret) {
						if (
							socket[kParser].timeout &&
							socket[kParser].timeoutType === TIMEOUT_HEADERS
						) {
							// istanbul ignore else: only for jest
							if (socket[kParser].timeout.refresh) {
								socket[kParser].timeout.refresh()
							}
						}
					}

					return ret
				}

				end() {
					const {
						socket,
						contentLength,
						client,
						bytesWritten,
						expectsPayload,
						header,
						request,
					} = this
					request.onRequestSent()

					socket[kWriting] = false

					if (socket[kError]) {
						throw socket[kError]
					}

					if (socket.destroyed) {
						return
					}

					if (bytesWritten === 0) {
						if (expectsPayload) {
							// https://tools.ietf.org/html/rfc7230#section-3.3.2
							// A user agent SHOULD send a Content-Length in a request message when
							// no Transfer-Encoding is sent and the request method defines a meaning
							// for an enclosed payload body.

							socket.write(`${header}content-length: 0\r\n\r\n`, 'latin1')
						} else {
							socket.write(`${header}\r\n`, 'latin1')
						}
					} else if (contentLength === null) {
						socket.write('\r\n0\r\n\r\n', 'latin1')
					}

					if (contentLength !== null && bytesWritten !== contentLength) {
						if (client[kStrictContentLength]) {
							throw new RequestContentLengthMismatchError()
						} else {
							process.emitWarning(new RequestContentLengthMismatchError())
						}
					}

					if (
						socket[kParser].timeout &&
						socket[kParser].timeoutType === TIMEOUT_HEADERS
					) {
						// istanbul ignore else: only for jest
						if (socket[kParser].timeout.refresh) {
							socket[kParser].timeout.refresh()
						}
					}

					resume(client)
				}

				destroy(err) {
					const { socket, client } = this

					socket[kWriting] = false

					if (err) {
						assert(
							client[kRunning] <= 1,
							'pipeline should only contain this request',
						)
						util.destroy(socket, err)
					}
				}
			}

			function errorRequest(client, request, err) {
				try {
					request.onError(err)
					assert(request.aborted)
				} catch (err) {
					client.emit('error', err)
				}
			}

			module.exports = Client

			/***/
		},

		/***/ 13194: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			/* istanbul ignore file: only for Node 12 */

			const { kConnected, kSize } = __nccwpck_require__(36443)

			class CompatWeakRef {
				constructor(value) {
					this.value = value
				}

				deref() {
					return this.value[kConnected] === 0 && this.value[kSize] === 0
						? undefined
						: this.value
				}
			}

			class CompatFinalizer {
				constructor(finalizer) {
					this.finalizer = finalizer
				}

				register(dispatcher, key) {
					if (dispatcher.on) {
						dispatcher.on('disconnect', () => {
							if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
								this.finalizer(key)
							}
						})
					}
				}
			}

			module.exports = function () {
				// FIXME: remove workaround when the Node bug is fixed
				// https://github.com/nodejs/node/issues/49344#issuecomment-1741776308
				if (process.env.NODE_V8_COVERAGE) {
					return {
						WeakRef: CompatWeakRef,
						FinalizationRegistry: CompatFinalizer,
					}
				}
				return {
					WeakRef: global.WeakRef || CompatWeakRef,
					FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer,
				}
			}

			/***/
		},

		/***/ 19237: /***/ (module) => {
			'use strict'

			// https://wicg.github.io/cookie-store/#cookie-maximum-attribute-value-size
			const maxAttributeValueSize = 1024

			// https://wicg.github.io/cookie-store/#cookie-maximum-name-value-pair-size
			const maxNameValuePairSize = 4096

			module.exports = {
				maxAttributeValueSize,
				maxNameValuePairSize,
			}

			/***/
		},

		/***/ 53168: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { parseSetCookie } = __nccwpck_require__(8915)
			const { stringify } = __nccwpck_require__(3834)
			const { webidl } = __nccwpck_require__(74222)
			const { Headers } = __nccwpck_require__(26349)

			/**
			 * @typedef {Object} Cookie
			 * @property {string} name
			 * @property {string} value
			 * @property {Date|number|undefined} expires
			 * @property {number|undefined} maxAge
			 * @property {string|undefined} domain
			 * @property {string|undefined} path
			 * @property {boolean|undefined} secure
			 * @property {boolean|undefined} httpOnly
			 * @property {'Strict'|'Lax'|'None'} sameSite
			 * @property {string[]} unparsed
			 */

			/**
			 * @param {Headers} headers
			 * @returns {Record<string, string>}
			 */
			function getCookies(headers) {
				webidl.argumentLengthCheck(arguments, 1, { header: 'getCookies' })

				webidl.brandCheck(headers, Headers, { strict: false })

				const cookie = headers.get('cookie')
				const out = {}

				if (!cookie) {
					return out
				}

				for (const piece of cookie.split(';')) {
					const [name, ...value] = piece.split('=')

					out[name.trim()] = value.join('=')
				}

				return out
			}

			/**
			 * @param {Headers} headers
			 * @param {string} name
			 * @param {{ path?: string, domain?: string }|undefined} attributes
			 * @returns {void}
			 */
			function deleteCookie(headers, name, attributes) {
				webidl.argumentLengthCheck(arguments, 2, { header: 'deleteCookie' })

				webidl.brandCheck(headers, Headers, { strict: false })

				name = webidl.converters.DOMString(name)
				attributes = webidl.converters.DeleteCookieAttributes(attributes)

				// Matches behavior of
				// https://github.com/denoland/deno_std/blob/63827b16330b82489a04614027c33b7904e08be5/http/cookie.ts#L278
				setCookie(headers, {
					name,
					value: '',
					expires: new Date(0),
					...attributes,
				})
			}

			/**
			 * @param {Headers} headers
			 * @returns {Cookie[]}
			 */
			function getSetCookies(headers) {
				webidl.argumentLengthCheck(arguments, 1, { header: 'getSetCookies' })

				webidl.brandCheck(headers, Headers, { strict: false })

				const cookies = headers.getSetCookie()

				if (!cookies) {
					return []
				}

				return cookies.map((pair) => parseSetCookie(pair))
			}

			/**
			 * @param {Headers} headers
			 * @param {Cookie} cookie
			 * @returns {void}
			 */
			function setCookie(headers, cookie) {
				webidl.argumentLengthCheck(arguments, 2, { header: 'setCookie' })

				webidl.brandCheck(headers, Headers, { strict: false })

				cookie = webidl.converters.Cookie(cookie)

				const str = stringify(cookie)

				if (str) {
					headers.append('Set-Cookie', stringify(cookie))
				}
			}

			webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
				{
					converter: webidl.nullableConverter(webidl.converters.DOMString),
					key: 'path',
					defaultValue: null,
				},
				{
					converter: webidl.nullableConverter(webidl.converters.DOMString),
					key: 'domain',
					defaultValue: null,
				},
			])

			webidl.converters.Cookie = webidl.dictionaryConverter([
				{
					converter: webidl.converters.DOMString,
					key: 'name',
				},
				{
					converter: webidl.converters.DOMString,
					key: 'value',
				},
				{
					converter: webidl.nullableConverter((value) => {
						if (typeof value === 'number') {
							return webidl.converters['unsigned long long'](value)
						}

						return new Date(value)
					}),
					key: 'expires',
					defaultValue: null,
				},
				{
					converter: webidl.nullableConverter(webidl.converters['long long']),
					key: 'maxAge',
					defaultValue: null,
				},
				{
					converter: webidl.nullableConverter(webidl.converters.DOMString),
					key: 'domain',
					defaultValue: null,
				},
				{
					converter: webidl.nullableConverter(webidl.converters.DOMString),
					key: 'path',
					defaultValue: null,
				},
				{
					converter: webidl.nullableConverter(webidl.converters.boolean),
					key: 'secure',
					defaultValue: null,
				},
				{
					converter: webidl.nullableConverter(webidl.converters.boolean),
					key: 'httpOnly',
					defaultValue: null,
				},
				{
					converter: webidl.converters.USVString,
					key: 'sameSite',
					allowedValues: ['Strict', 'Lax', 'None'],
				},
				{
					converter: webidl.sequenceConverter(webidl.converters.DOMString),
					key: 'unparsed',
					defaultValue: [],
				},
			])

			module.exports = {
				getCookies,
				deleteCookie,
				getSetCookies,
				setCookie,
			}

			/***/
		},

		/***/ 8915: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { maxNameValuePairSize, maxAttributeValueSize } =
				__nccwpck_require__(19237)
			const { isCTLExcludingHtab } = __nccwpck_require__(3834)
			const { collectASequenceOfCodePointsFast } = __nccwpck_require__(94322)
			const assert = __nccwpck_require__(42613)

			/**
			 * @description Parses the field-value attributes of a set-cookie header string.
			 * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4
			 * @param {string} header
			 * @returns if the header is invalid, null will be returned
			 */
			function parseSetCookie(header) {
				// 1. If the set-cookie-string contains a %x00-08 / %x0A-1F / %x7F
				//    character (CTL characters excluding HTAB): Abort these steps and
				//    ignore the set-cookie-string entirely.
				if (isCTLExcludingHtab(header)) {
					return null
				}

				let nameValuePair = ''
				let unparsedAttributes = ''
				let name = ''
				let value = ''

				// 2. If the set-cookie-string contains a %x3B (";") character:
				if (header.includes(';')) {
					// 1. The name-value-pair string consists of the characters up to,
					//    but not including, the first %x3B (";"), and the unparsed-
					//    attributes consist of the remainder of the set-cookie-string
					//    (including the %x3B (";") in question).
					const position = { position: 0 }

					nameValuePair = collectASequenceOfCodePointsFast(
						';',
						header,
						position,
					)
					unparsedAttributes = header.slice(position.position)
				} else {
					// Otherwise:

					// 1. The name-value-pair string consists of all the characters
					//    contained in the set-cookie-string, and the unparsed-
					//    attributes is the empty string.
					nameValuePair = header
				}

				// 3. If the name-value-pair string lacks a %x3D ("=") character, then
				//    the name string is empty, and the value string is the value of
				//    name-value-pair.
				if (!nameValuePair.includes('=')) {
					value = nameValuePair
				} else {
					//    Otherwise, the name string consists of the characters up to, but
					//    not including, the first %x3D ("=") character, and the (possibly
					//    empty) value string consists of the characters after the first
					//    %x3D ("=") character.
					const position = { position: 0 }
					name = collectASequenceOfCodePointsFast('=', nameValuePair, position)
					value = nameValuePair.slice(position.position + 1)
				}

				// 4. Remove any leading or trailing WSP characters from the name
				//    string and the value string.
				name = name.trim()
				value = value.trim()

				// 5. If the sum of the lengths of the name string and the value string
				//    is more than 4096 octets, abort these steps and ignore the set-
				//    cookie-string entirely.
				if (name.length + value.length > maxNameValuePairSize) {
					return null
				}

				// 6. The cookie-name is the name string, and the cookie-value is the
				//    value string.
				return {
					name,
					value,
					...parseUnparsedAttributes(unparsedAttributes),
				}
			}

			/**
			 * Parses the remaining attributes of a set-cookie header
			 * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4
			 * @param {string} unparsedAttributes
			 * @param {[Object.<string, unknown>]={}} cookieAttributeList
			 */
			function parseUnparsedAttributes(
				unparsedAttributes,
				cookieAttributeList = {},
			) {
				// 1. If the unparsed-attributes string is empty, skip the rest of
				//    these steps.
				if (unparsedAttributes.length === 0) {
					return cookieAttributeList
				}

				// 2. Discard the first character of the unparsed-attributes (which
				//    will be a %x3B (";") character).
				assert(unparsedAttributes[0] === ';')
				unparsedAttributes = unparsedAttributes.slice(1)

				let cookieAv = ''

				// 3. If the remaining unparsed-attributes contains a %x3B (";")
				//    character:
				if (unparsedAttributes.includes(';')) {
					// 1. Consume the characters of the unparsed-attributes up to, but
					//    not including, the first %x3B (";") character.
					cookieAv = collectASequenceOfCodePointsFast(';', unparsedAttributes, {
						position: 0,
					})
					unparsedAttributes = unparsedAttributes.slice(cookieAv.length)
				} else {
					// Otherwise:

					// 1. Consume the remainder of the unparsed-attributes.
					cookieAv = unparsedAttributes
					unparsedAttributes = ''
				}

				// Let the cookie-av string be the characters consumed in this step.

				let attributeName = ''
				let attributeValue = ''

				// 4. If the cookie-av string contains a %x3D ("=") character:
				if (cookieAv.includes('=')) {
					// 1. The (possibly empty) attribute-name string consists of the
					//    characters up to, but not including, the first %x3D ("=")
					//    character, and the (possibly empty) attribute-value string
					//    consists of the characters after the first %x3D ("=")
					//    character.
					const position = { position: 0 }

					attributeName = collectASequenceOfCodePointsFast(
						'=',
						cookieAv,
						position,
					)
					attributeValue = cookieAv.slice(position.position + 1)
				} else {
					// Otherwise:

					// 1. The attribute-name string consists of the entire cookie-av
					//    string, and the attribute-value string is empty.
					attributeName = cookieAv
				}

				// 5. Remove any leading or trailing WSP characters from the attribute-
				//    name string and the attribute-value string.
				attributeName = attributeName.trim()
				attributeValue = attributeValue.trim()

				// 6. If the attribute-value is longer than 1024 octets, ignore the
				//    cookie-av string and return to Step 1 of this algorithm.
				if (attributeValue.length > maxAttributeValueSize) {
					return parseUnparsedAttributes(
						unparsedAttributes,
						cookieAttributeList,
					)
				}

				// 7. Process the attribute-name and attribute-value according to the
				//    requirements in the following subsections.  (Notice that
				//    attributes with unrecognized attribute-names are ignored.)
				const attributeNameLowercase = attributeName.toLowerCase()

				// https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.1
				// If the attribute-name case-insensitively matches the string
				// "Expires", the user agent MUST process the cookie-av as follows.
				if (attributeNameLowercase === 'expires') {
					// 1. Let the expiry-time be the result of parsing the attribute-value
					//    as cookie-date (see Section 5.1.1).
					const expiryTime = new Date(attributeValue)

					// 2. If the attribute-value failed to parse as a cookie date, ignore
					//    the cookie-av.

					cookieAttributeList.expires = expiryTime
				} else if (attributeNameLowercase === 'max-age') {
					// https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.2
					// If the attribute-name case-insensitively matches the string "Max-
					// Age", the user agent MUST process the cookie-av as follows.

					// 1. If the first character of the attribute-value is not a DIGIT or a
					//    "-" character, ignore the cookie-av.
					const charCode = attributeValue.charCodeAt(0)

					if ((charCode < 48 || charCode > 57) && attributeValue[0] !== '-') {
						return parseUnparsedAttributes(
							unparsedAttributes,
							cookieAttributeList,
						)
					}

					// 2. If the remainder of attribute-value contains a non-DIGIT
					//    character, ignore the cookie-av.
					if (!/^\d+$/.test(attributeValue)) {
						return parseUnparsedAttributes(
							unparsedAttributes,
							cookieAttributeList,
						)
					}

					// 3. Let delta-seconds be the attribute-value converted to an integer.
					const deltaSeconds = Number(attributeValue)

					// 4. Let cookie-age-limit be the maximum age of the cookie (which
					//    SHOULD be 400 days or less, see Section 4.1.2.2).

					// 5. Set delta-seconds to the smaller of its present value and cookie-
					//    age-limit.
					// deltaSeconds = Math.min(deltaSeconds * 1000, maxExpiresMs)

					// 6. If delta-seconds is less than or equal to zero (0), let expiry-
					//    time be the earliest representable date and time.  Otherwise, let
					//    the expiry-time be the current date and time plus delta-seconds
					//    seconds.
					// const expiryTime = deltaSeconds <= 0 ? Date.now() : Date.now() + deltaSeconds

					// 7. Append an attribute to the cookie-attribute-list with an
					//    attribute-name of Max-Age and an attribute-value of expiry-time.
					cookieAttributeList.maxAge = deltaSeconds
				} else if (attributeNameLowercase === 'domain') {
					// https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.3
					// If the attribute-name case-insensitively matches the string "Domain",
					// the user agent MUST process the cookie-av as follows.

					// 1. Let cookie-domain be the attribute-value.
					let cookieDomain = attributeValue

					// 2. If cookie-domain starts with %x2E ("."), let cookie-domain be
					//    cookie-domain without its leading %x2E (".").
					if (cookieDomain[0] === '.') {
						cookieDomain = cookieDomain.slice(1)
					}

					// 3. Convert the cookie-domain to lower case.
					cookieDomain = cookieDomain.toLowerCase()

					// 4. Append an attribute to the cookie-attribute-list with an
					//    attribute-name of Domain and an attribute-value of cookie-domain.
					cookieAttributeList.domain = cookieDomain
				} else if (attributeNameLowercase === 'path') {
					// https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.4
					// If the attribute-name case-insensitively matches the string "Path",
					// the user agent MUST process the cookie-av as follows.

					// 1. If the attribute-value is empty or if the first character of the
					//    attribute-value is not %x2F ("/"):
					let cookiePath = ''
					if (attributeValue.length === 0 || attributeValue[0] !== '/') {
						// 1. Let cookie-path be the default-path.
						cookiePath = '/'
					} else {
						// Otherwise:

						// 1. Let cookie-path be the attribute-value.
						cookiePath = attributeValue
					}

					// 2. Append an attribute to the cookie-attribute-list with an
					//    attribute-name of Path and an attribute-value of cookie-path.
					cookieAttributeList.path = cookiePath
				} else if (attributeNameLowercase === 'secure') {
					// https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.5
					// If the attribute-name case-insensitively matches the string "Secure",
					// the user agent MUST append an attribute to the cookie-attribute-list
					// with an attribute-name of Secure and an empty attribute-value.

					cookieAttributeList.secure = true
				} else if (attributeNameLowercase === 'httponly') {
					// https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.6
					// If the attribute-name case-insensitively matches the string
					// "HttpOnly", the user agent MUST append an attribute to the cookie-
					// attribute-list with an attribute-name of HttpOnly and an empty
					// attribute-value.

					cookieAttributeList.httpOnly = true
				} else if (attributeNameLowercase === 'samesite') {
					// https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.7
					// If the attribute-name case-insensitively matches the string
					// "SameSite", the user agent MUST process the cookie-av as follows:

					// 1. Let enforcement be "Default".
					let enforcement = 'Default'

					const attributeValueLowercase = attributeValue.toLowerCase()
					// 2. If cookie-av's attribute-value is a case-insensitive match for
					//    "None", set enforcement to "None".
					if (attributeValueLowercase.includes('none')) {
						enforcement = 'None'
					}

					// 3. If cookie-av's attribute-value is a case-insensitive match for
					//    "Strict", set enforcement to "Strict".
					if (attributeValueLowercase.includes('strict')) {
						enforcement = 'Strict'
					}

					// 4. If cookie-av's attribute-value is a case-insensitive match for
					//    "Lax", set enforcement to "Lax".
					if (attributeValueLowercase.includes('lax')) {
						enforcement = 'Lax'
					}

					// 5. Append an attribute to the cookie-attribute-list with an
					//    attribute-name of "SameSite" and an attribute-value of
					//    enforcement.
					cookieAttributeList.sameSite = enforcement
				} else {
					cookieAttributeList.unparsed ??= []

					cookieAttributeList.unparsed.push(
						`${attributeName}=${attributeValue}`,
					)
				}

				// 8. Return to Step 1 of this algorithm.
				return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)
			}

			module.exports = {
				parseSetCookie,
				parseUnparsedAttributes,
			}

			/***/
		},

		/***/ 3834: /***/ (module) => {
			'use strict'

			/**
			 * @param {string} value
			 * @returns {boolean}
			 */
			function isCTLExcludingHtab(value) {
				if (value.length === 0) {
					return false
				}

				for (const char of value) {
					const code = char.charCodeAt(0)

					if (
						code >= 0x00 ||
						code <= 0x08 ||
						code >= 0x0a ||
						code <= 0x1f ||
						code === 0x7f
					) {
						return false
					}
				}
			}

			/**
 CHAR           = <any US-ASCII character (octets 0 - 127)>
 token          = 1*<any CHAR except CTLs or separators>
 separators     = "(" | ")" | "<" | ">" | "@"
                | "," | ";" | ":" | "\" | <">
                | "/" | "[" | "]" | "?" | "="
                | "{" | "}" | SP | HT
 * @param {string} name
 */
			function validateCookieName(name) {
				for (const char of name) {
					const code = char.charCodeAt(0)

					if (
						code <= 0x20 ||
						code > 0x7f ||
						char === '(' ||
						char === ')' ||
						char === '>' ||
						char === '<' ||
						char === '@' ||
						char === ',' ||
						char === ';' ||
						char === ':' ||
						char === '\\' ||
						char === '"' ||
						char === '/' ||
						char === '[' ||
						char === ']' ||
						char === '?' ||
						char === '=' ||
						char === '{' ||
						char === '}'
					) {
						throw new Error('Invalid cookie name')
					}
				}
			}

			/**
 cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
 cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
                       ; US-ASCII characters excluding CTLs,
                       ; whitespace DQUOTE, comma, semicolon,
                       ; and backslash
 * @param {string} value
 */
			function validateCookieValue(value) {
				for (const char of value) {
					const code = char.charCodeAt(0)

					if (
						code < 0x21 || // exclude CTLs (0-31)
						code === 0x22 ||
						code === 0x2c ||
						code === 0x3b ||
						code === 0x5c ||
						code > 0x7e // non-ascii
					) {
						throw new Error('Invalid header value')
					}
				}
			}

			/**
			 * path-value        = <any CHAR except CTLs or ";">
			 * @param {string} path
			 */
			function validateCookiePath(path) {
				for (const char of path) {
					const code = char.charCodeAt(0)

					if (code < 0x21 || char === ';') {
						throw new Error('Invalid cookie path')
					}
				}
			}

			/**
			 * I have no idea why these values aren't allowed to be honest,
			 * but Deno tests these. - Khafra
			 * @param {string} domain
			 */
			function validateCookieDomain(domain) {
				if (
					domain.startsWith('-') ||
					domain.endsWith('.') ||
					domain.endsWith('-')
				) {
					throw new Error('Invalid cookie domain')
				}
			}

			/**
 * @see https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1
 * @param {number|Date} date
  IMF-fixdate  = day-name "," SP date1 SP time-of-day SP GMT
  ; fixed length/zone/capitalization subset of the format
  ; see Section 3.3 of [RFC5322]

  day-name     = %x4D.6F.6E ; "Mon", case-sensitive
              / %x54.75.65 ; "Tue", case-sensitive
              / %x57.65.64 ; "Wed", case-sensitive
              / %x54.68.75 ; "Thu", case-sensitive
              / %x46.72.69 ; "Fri", case-sensitive
              / %x53.61.74 ; "Sat", case-sensitive
              / %x53.75.6E ; "Sun", case-sensitive
  date1        = day SP month SP year
                  ; e.g., 02 Jun 1982

  day          = 2DIGIT
  month        = %x4A.61.6E ; "Jan", case-sensitive
              / %x46.65.62 ; "Feb", case-sensitive
              / %x4D.61.72 ; "Mar", case-sensitive
              / %x41.70.72 ; "Apr", case-sensitive
              / %x4D.61.79 ; "May", case-sensitive
              / %x4A.75.6E ; "Jun", case-sensitive
              / %x4A.75.6C ; "Jul", case-sensitive
              / %x41.75.67 ; "Aug", case-sensitive
              / %x53.65.70 ; "Sep", case-sensitive
              / %x4F.63.74 ; "Oct", case-sensitive
              / %x4E.6F.76 ; "Nov", case-sensitive
              / %x44.65.63 ; "Dec", case-sensitive
  year         = 4DIGIT

  GMT          = %x47.4D.54 ; "GMT", case-sensitive

  time-of-day  = hour ":" minute ":" second
              ; 00:00:00 - 23:59:60 (leap second)

  hour         = 2DIGIT
  minute       = 2DIGIT
  second       = 2DIGIT
 */
			function toIMFDate(date) {
				if (typeof date === 'number') {
					date = new Date(date)
				}

				const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']

				const months = [
					'Jan',
					'Feb',
					'Mar',
					'Apr',
					'May',
					'Jun',
					'Jul',
					'Aug',
					'Sep',
					'Oct',
					'Nov',
					'Dec',
				]

				const dayName = days[date.getUTCDay()]
				const day = date.getUTCDate().toString().padStart(2, '0')
				const month = months[date.getUTCMonth()]
				const year = date.getUTCFullYear()
				const hour = date.getUTCHours().toString().padStart(2, '0')
				const minute = date.getUTCMinutes().toString().padStart(2, '0')
				const second = date.getUTCSeconds().toString().padStart(2, '0')

				return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`
			}

			/**
 max-age-av        = "Max-Age=" non-zero-digit *DIGIT
                       ; In practice, both expires-av and max-age-av
                       ; are limited to dates representable by the
                       ; user agent.
 * @param {number} maxAge
 */
			function validateCookieMaxAge(maxAge) {
				if (maxAge < 0) {
					throw new Error('Invalid cookie max-age')
				}
			}

			/**
			 * @see https://www.rfc-editor.org/rfc/rfc6265#section-4.1.1
			 * @param {import('./index').Cookie} cookie
			 */
			function stringify(cookie) {
				if (cookie.name.length === 0) {
					return null
				}

				validateCookieName(cookie.name)
				validateCookieValue(cookie.value)

				const out = [`${cookie.name}=${cookie.value}`]

				// https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.1
				// https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.2
				if (cookie.name.startsWith('__Secure-')) {
					cookie.secure = true
				}

				if (cookie.name.startsWith('__Host-')) {
					cookie.secure = true
					cookie.domain = null
					cookie.path = '/'
				}

				if (cookie.secure) {
					out.push('Secure')
				}

				if (cookie.httpOnly) {
					out.push('HttpOnly')
				}

				if (typeof cookie.maxAge === 'number') {
					validateCookieMaxAge(cookie.maxAge)
					out.push(`Max-Age=${cookie.maxAge}`)
				}

				if (cookie.domain) {
					validateCookieDomain(cookie.domain)
					out.push(`Domain=${cookie.domain}`)
				}

				if (cookie.path) {
					validateCookiePath(cookie.path)
					out.push(`Path=${cookie.path}`)
				}

				if (cookie.expires && cookie.expires.toString() !== 'Invalid Date') {
					out.push(`Expires=${toIMFDate(cookie.expires)}`)
				}

				if (cookie.sameSite) {
					out.push(`SameSite=${cookie.sameSite}`)
				}

				for (const part of cookie.unparsed) {
					if (!part.includes('=')) {
						throw new Error('Invalid unparsed')
					}

					const [key, ...value] = part.split('=')

					out.push(`${key.trim()}=${value.join('=')}`)
				}

				return out.join('; ')
			}

			module.exports = {
				isCTLExcludingHtab,
				validateCookieName,
				validateCookiePath,
				validateCookieValue,
				toIMFDate,
				stringify,
			}

			/***/
		},

		/***/ 59136: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const net = __nccwpck_require__(69278)
			const assert = __nccwpck_require__(42613)
			const util = __nccwpck_require__(3440)
			const { InvalidArgumentError, ConnectTimeoutError } =
				__nccwpck_require__(68707)

			let tls // include tls conditionally since it is not always available

			// TODO: session re-use does not wait for the first
			// connection to resolve the session and might therefore
			// resolve the same servername multiple times even when
			// re-use is enabled.

			let SessionCache
			// FIXME: remove workaround when the Node bug is fixed
			// https://github.com/nodejs/node/issues/49344#issuecomment-1741776308
			if (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) {
				SessionCache = class WeakSessionCache {
					constructor(maxCachedSessions) {
						this._maxCachedSessions = maxCachedSessions
						this._sessionCache = new Map()
						this._sessionRegistry = new global.FinalizationRegistry((key) => {
							if (this._sessionCache.size < this._maxCachedSessions) {
								return
							}

							const ref = this._sessionCache.get(key)
							if (ref !== undefined && ref.deref() === undefined) {
								this._sessionCache.delete(key)
							}
						})
					}

					get(sessionKey) {
						const ref = this._sessionCache.get(sessionKey)
						return ref ? ref.deref() : null
					}

					set(sessionKey, session) {
						if (this._maxCachedSessions === 0) {
							return
						}

						this._sessionCache.set(sessionKey, new WeakRef(session))
						this._sessionRegistry.register(session, sessionKey)
					}
				}
			} else {
				SessionCache = class SimpleSessionCache {
					constructor(maxCachedSessions) {
						this._maxCachedSessions = maxCachedSessions
						this._sessionCache = new Map()
					}

					get(sessionKey) {
						return this._sessionCache.get(sessionKey)
					}

					set(sessionKey, session) {
						if (this._maxCachedSessions === 0) {
							return
						}

						if (this._sessionCache.size >= this._maxCachedSessions) {
							// remove the oldest session
							const { value: oldestKey } = this._sessionCache.keys().next()
							this._sessionCache.delete(oldestKey)
						}

						this._sessionCache.set(sessionKey, session)
					}
				}
			}

			function buildConnector({
				allowH2,
				maxCachedSessions,
				socketPath,
				timeout,
				...opts
			}) {
				if (
					maxCachedSessions != null &&
					(!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)
				) {
					throw new InvalidArgumentError(
						'maxCachedSessions must be a positive integer or zero',
					)
				}

				const options = { path: socketPath, ...opts }
				const sessionCache = new SessionCache(
					maxCachedSessions == null ? 100 : maxCachedSessions,
				)
				timeout = timeout == null ? 10e3 : timeout
				allowH2 = allowH2 != null ? allowH2 : false
				return function connect(
					{
						hostname,
						host,
						protocol,
						port,
						servername,
						localAddress,
						httpSocket,
					},
					callback,
				) {
					let socket
					if (protocol === 'https:') {
						if (!tls) {
							tls = __nccwpck_require__(64756)
						}
						servername =
							servername ||
							options.servername ||
							util.getServerName(host) ||
							null

						const sessionKey = servername || hostname
						const session = sessionCache.get(sessionKey) || null

						assert(sessionKey)

						socket = tls.connect({
							highWaterMark: 16384, // TLS in node can't have bigger HWM anyway...
							...options,
							servername,
							session,
							localAddress,
							// TODO(HTTP/2): Add support for h2c
							ALPNProtocols: allowH2 ? ['http/1.1', 'h2'] : ['http/1.1'],
							socket: httpSocket, // upgrade socket connection
							port: port || 443,
							host: hostname,
						})

						socket.on('session', function (session) {
							// TODO (fix): Can a session become invalid once established? Don't think so?
							sessionCache.set(sessionKey, session)
						})
					} else {
						assert(!httpSocket, 'httpSocket can only be sent on TLS update')
						socket = net.connect({
							highWaterMark: 64 * 1024, // Same as nodejs fs streams.
							...options,
							localAddress,
							port: port || 80,
							host: hostname,
						})
					}

					// Set TCP keep alive options on the socket here instead of in connect() for the case of assigning the socket
					if (options.keepAlive == null || options.keepAlive) {
						const keepAliveInitialDelay =
							options.keepAliveInitialDelay === undefined
								? 60e3
								: options.keepAliveInitialDelay
						socket.setKeepAlive(true, keepAliveInitialDelay)
					}

					const cancelTimeout = setupTimeout(
						() => onConnectTimeout(socket),
						timeout,
					)

					socket
						.setNoDelay(true)
						.once(
							protocol === 'https:' ? 'secureConnect' : 'connect',
							function () {
								cancelTimeout()

								if (callback) {
									const cb = callback
									callback = null
									cb(null, this)
								}
							},
						)
						.on('error', function (err) {
							cancelTimeout()

							if (callback) {
								const cb = callback
								callback = null
								cb(err)
							}
						})

					return socket
				}
			}

			function setupTimeout(onConnectTimeout, timeout) {
				if (!timeout) {
					return () => {}
				}

				let s1 = null
				let s2 = null
				const timeoutId = setTimeout(() => {
					// setImmediate is added to make sure that we priotorise socket error events over timeouts
					s1 = setImmediate(() => {
						if (process.platform === 'win32') {
							// Windows needs an extra setImmediate probably due to implementation differences in the socket logic
							s2 = setImmediate(() => onConnectTimeout())
						} else {
							onConnectTimeout()
						}
					})
				}, timeout)
				return () => {
					clearTimeout(timeoutId)
					clearImmediate(s1)
					clearImmediate(s2)
				}
			}

			function onConnectTimeout(socket) {
				util.destroy(socket, new ConnectTimeoutError())
			}

			module.exports = buildConnector

			/***/
		},

		/***/ 10735: /***/ (module) => {
			'use strict'

			/** @type {Record<string, string | undefined>} */
			const headerNameLowerCasedRecord = {}

			// https://developer.mozilla.org/docs/Web/HTTP/Headers
			const wellknownHeaderNames = [
				'Accept',
				'Accept-Encoding',
				'Accept-Language',
				'Accept-Ranges',
				'Access-Control-Allow-Credentials',
				'Access-Control-Allow-Headers',
				'Access-Control-Allow-Methods',
				'Access-Control-Allow-Origin',
				'Access-Control-Expose-Headers',
				'Access-Control-Max-Age',
				'Access-Control-Request-Headers',
				'Access-Control-Request-Method',
				'Age',
				'Allow',
				'Alt-Svc',
				'Alt-Used',
				'Authorization',
				'Cache-Control',
				'Clear-Site-Data',
				'Connection',
				'Content-Disposition',
				'Content-Encoding',
				'Content-Language',
				'Content-Length',
				'Content-Location',
				'Content-Range',
				'Content-Security-Policy',
				'Content-Security-Policy-Report-Only',
				'Content-Type',
				'Cookie',
				'Cross-Origin-Embedder-Policy',
				'Cross-Origin-Opener-Policy',
				'Cross-Origin-Resource-Policy',
				'Date',
				'Device-Memory',
				'Downlink',
				'ECT',
				'ETag',
				'Expect',
				'Expect-CT',
				'Expires',
				'Forwarded',
				'From',
				'Host',
				'If-Match',
				'If-Modified-Since',
				'If-None-Match',
				'If-Range',
				'If-Unmodified-Since',
				'Keep-Alive',
				'Last-Modified',
				'Link',
				'Location',
				'Max-Forwards',
				'Origin',
				'Permissions-Policy',
				'Pragma',
				'Proxy-Authenticate',
				'Proxy-Authorization',
				'RTT',
				'Range',
				'Referer',
				'Referrer-Policy',
				'Refresh',
				'Retry-After',
				'Sec-WebSocket-Accept',
				'Sec-WebSocket-Extensions',
				'Sec-WebSocket-Key',
				'Sec-WebSocket-Protocol',
				'Sec-WebSocket-Version',
				'Server',
				'Server-Timing',
				'Service-Worker-Allowed',
				'Service-Worker-Navigation-Preload',
				'Set-Cookie',
				'SourceMap',
				'Strict-Transport-Security',
				'Supports-Loading-Mode',
				'TE',
				'Timing-Allow-Origin',
				'Trailer',
				'Transfer-Encoding',
				'Upgrade',
				'Upgrade-Insecure-Requests',
				'User-Agent',
				'Vary',
				'Via',
				'WWW-Authenticate',
				'X-Content-Type-Options',
				'X-DNS-Prefetch-Control',
				'X-Frame-Options',
				'X-Permitted-Cross-Domain-Policies',
				'X-Powered-By',
				'X-Requested-With',
				'X-XSS-Protection',
			]

			for (let i = 0; i < wellknownHeaderNames.length; ++i) {
				const key = wellknownHeaderNames[i]
				const lowerCasedKey = key.toLowerCase()
				headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[
					lowerCasedKey
				] = lowerCasedKey
			}

			// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.
			Object.setPrototypeOf(headerNameLowerCasedRecord, null)

			module.exports = {
				wellknownHeaderNames,
				headerNameLowerCasedRecord,
			}

			/***/
		},

		/***/ 68707: /***/ (module) => {
			'use strict'

			class UndiciError extends Error {
				constructor(message) {
					super(message)
					this.name = 'UndiciError'
					this.code = 'UND_ERR'
				}
			}

			class ConnectTimeoutError extends UndiciError {
				constructor(message) {
					super(message)
					Error.captureStackTrace(this, ConnectTimeoutError)
					this.name = 'ConnectTimeoutError'
					this.message = message || 'Connect Timeout Error'
					this.code = 'UND_ERR_CONNECT_TIMEOUT'
				}
			}

			class HeadersTimeoutError extends UndiciError {
				constructor(message) {
					super(message)
					Error.captureStackTrace(this, HeadersTimeoutError)
					this.name = 'HeadersTimeoutError'
					this.message = message || 'Headers Timeout Error'
					this.code = 'UND_ERR_HEADERS_TIMEOUT'
				}
			}

			class HeadersOverflowError extends UndiciError {
				constructor(message) {
					super(message)
					Error.captureStackTrace(this, HeadersOverflowError)
					this.name = 'HeadersOverflowError'
					this.message = message || 'Headers Overflow Error'
					this.code = 'UND_ERR_HEADERS_OVERFLOW'
				}
			}

			class BodyTimeoutError extends UndiciError {
				constructor(message) {
					super(message)
					Error.captureStackTrace(this, BodyTimeoutError)
					this.name = 'BodyTimeoutError'
					this.message = message || 'Body Timeout Error'
					this.code = 'UND_ERR_BODY_TIMEOUT'
				}
			}

			class ResponseStatusCodeError extends UndiciError {
				constructor(message, statusCode, headers, body) {
					super(message)
					Error.captureStackTrace(this, ResponseStatusCodeError)
					this.name = 'ResponseStatusCodeError'
					this.message = message || 'Response Status Code Error'
					this.code = 'UND_ERR_RESPONSE_STATUS_CODE'
					this.body = body
					this.status = statusCode
					this.statusCode = statusCode
					this.headers = headers
				}
			}

			class InvalidArgumentError extends UndiciError {
				constructor(message) {
					super(message)
					Error.captureStackTrace(this, InvalidArgumentError)
					this.name = 'InvalidArgumentError'
					this.message = message || 'Invalid Argument Error'
					this.code = 'UND_ERR_INVALID_ARG'
				}
			}

			class InvalidReturnValueError extends UndiciError {
				constructor(message) {
					super(message)
					Error.captureStackTrace(this, InvalidReturnValueError)
					this.name = 'InvalidReturnValueError'
					this.message = message || 'Invalid Return Value Error'
					this.code = 'UND_ERR_INVALID_RETURN_VALUE'
				}
			}

			class RequestAbortedError extends UndiciError {
				constructor(message) {
					super(message)
					Error.captureStackTrace(this, RequestAbortedError)
					this.name = 'AbortError'
					this.message = message || 'Request aborted'
					this.code = 'UND_ERR_ABORTED'
				}
			}

			class InformationalError extends UndiciError {
				constructor(message) {
					super(message)
					Error.captureStackTrace(this, InformationalError)
					this.name = 'InformationalError'
					this.message = message || 'Request information'
					this.code = 'UND_ERR_INFO'
				}
			}

			class RequestContentLengthMismatchError extends UndiciError {
				constructor(message) {
					super(message)
					Error.captureStackTrace(this, RequestContentLengthMismatchError)
					this.name = 'RequestContentLengthMismatchError'
					this.message =
						message ||
						'Request body length does not match content-length header'
					this.code = 'UND_ERR_REQ_CONTENT_LENGTH_MISMATCH'
				}
			}

			class ResponseContentLengthMismatchError extends UndiciError {
				constructor(message) {
					super(message)
					Error.captureStackTrace(this, ResponseContentLengthMismatchError)
					this.name = 'ResponseContentLengthMismatchError'
					this.message =
						message ||
						'Response body length does not match content-length header'
					this.code = 'UND_ERR_RES_CONTENT_LENGTH_MISMATCH'
				}
			}

			class ClientDestroyedError extends UndiciError {
				constructor(message) {
					super(message)
					Error.captureStackTrace(this, ClientDestroyedError)
					this.name = 'ClientDestroyedError'
					this.message = message || 'The client is destroyed'
					this.code = 'UND_ERR_DESTROYED'
				}
			}

			class ClientClosedError extends UndiciError {
				constructor(message) {
					super(message)
					Error.captureStackTrace(this, ClientClosedError)
					this.name = 'ClientClosedError'
					this.message = message || 'The client is closed'
					this.code = 'UND_ERR_CLOSED'
				}
			}

			class SocketError extends UndiciError {
				constructor(message, socket) {
					super(message)
					Error.captureStackTrace(this, SocketError)
					this.name = 'SocketError'
					this.message = message || 'Socket error'
					this.code = 'UND_ERR_SOCKET'
					this.socket = socket
				}
			}

			class NotSupportedError extends UndiciError {
				constructor(message) {
					super(message)
					Error.captureStackTrace(this, NotSupportedError)
					this.name = 'NotSupportedError'
					this.message = message || 'Not supported error'
					this.code = 'UND_ERR_NOT_SUPPORTED'
				}
			}

			class BalancedPoolMissingUpstreamError extends UndiciError {
				constructor(message) {
					super(message)
					Error.captureStackTrace(this, NotSupportedError)
					this.name = 'MissingUpstreamError'
					this.message =
						message || 'No upstream has been added to the BalancedPool'
					this.code = 'UND_ERR_BPL_MISSING_UPSTREAM'
				}
			}

			class HTTPParserError extends Error {
				constructor(message, code, data) {
					super(message)
					Error.captureStackTrace(this, HTTPParserError)
					this.name = 'HTTPParserError'
					this.code = code ? `HPE_${code}` : undefined
					this.data = data ? data.toString() : undefined
				}
			}

			class ResponseExceededMaxSizeError extends UndiciError {
				constructor(message) {
					super(message)
					Error.captureStackTrace(this, ResponseExceededMaxSizeError)
					this.name = 'ResponseExceededMaxSizeError'
					this.message = message || 'Response content exceeded max size'
					this.code = 'UND_ERR_RES_EXCEEDED_MAX_SIZE'
				}
			}

			class RequestRetryError extends UndiciError {
				constructor(message, code, { headers, data }) {
					super(message)
					Error.captureStackTrace(this, RequestRetryError)
					this.name = 'RequestRetryError'
					this.message = message || 'Request retry error'
					this.code = 'UND_ERR_REQ_RETRY'
					this.statusCode = code
					this.data = data
					this.headers = headers
				}
			}

			module.exports = {
				HTTPParserError,
				UndiciError,
				HeadersTimeoutError,
				HeadersOverflowError,
				BodyTimeoutError,
				RequestContentLengthMismatchError,
				ConnectTimeoutError,
				ResponseStatusCodeError,
				InvalidArgumentError,
				InvalidReturnValueError,
				RequestAbortedError,
				ClientDestroyedError,
				ClientClosedError,
				InformationalError,
				SocketError,
				NotSupportedError,
				ResponseContentLengthMismatchError,
				BalancedPoolMissingUpstreamError,
				ResponseExceededMaxSizeError,
				RequestRetryError,
			}

			/***/
		},

		/***/ 44655: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { InvalidArgumentError, NotSupportedError } =
				__nccwpck_require__(68707)
			const assert = __nccwpck_require__(42613)
			const { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } =
				__nccwpck_require__(36443)
			const util = __nccwpck_require__(3440)

			// tokenRegExp and headerCharRegex have been lifted from
			// https://github.com/nodejs/node/blob/main/lib/_http_common.js

			/**
			 * Verifies that the given val is a valid HTTP token
			 * per the rules defined in RFC 7230
			 * See https://tools.ietf.org/html/rfc7230#section-3.2.6
			 */
			const tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/

			/**
			 * Matches if val contains an invalid field-vchar
			 *  field-value    = *( field-content / obs-fold )
			 *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
			 *  field-vchar    = VCHAR / obs-text
			 */
			const headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/

			// Verifies that a given path is valid does not contain control chars \x00 to \x20
			const invalidPathRegex = /[^\u0021-\u00ff]/

			const kHandler = Symbol('handler')

			const channels = {}

			let extractBody

			try {
				const diagnosticsChannel = __nccwpck_require__(31637)
				channels.create = diagnosticsChannel.channel('undici:request:create')
				channels.bodySent = diagnosticsChannel.channel(
					'undici:request:bodySent',
				)
				channels.headers = diagnosticsChannel.channel('undici:request:headers')
				channels.trailers = diagnosticsChannel.channel(
					'undici:request:trailers',
				)
				channels.error = diagnosticsChannel.channel('undici:request:error')
			} catch {
				channels.create = { hasSubscribers: false }
				channels.bodySent = { hasSubscribers: false }
				channels.headers = { hasSubscribers: false }
				channels.trailers = { hasSubscribers: false }
				channels.error = { hasSubscribers: false }
			}

			class Request {
				constructor(
					origin,
					{
						path,
						method,
						body,
						headers,
						query,
						idempotent,
						blocking,
						upgrade,
						headersTimeout,
						bodyTimeout,
						reset,
						throwOnError,
						expectContinue,
					},
					handler,
				) {
					if (typeof path !== 'string') {
						throw new InvalidArgumentError('path must be a string')
					} else if (
						path[0] !== '/' &&
						!(path.startsWith('http://') || path.startsWith('https://')) &&
						method !== 'CONNECT'
					) {
						throw new InvalidArgumentError(
							'path must be an absolute URL or start with a slash',
						)
					} else if (invalidPathRegex.exec(path) !== null) {
						throw new InvalidArgumentError('invalid request path')
					}

					if (typeof method !== 'string') {
						throw new InvalidArgumentError('method must be a string')
					} else if (tokenRegExp.exec(method) === null) {
						throw new InvalidArgumentError('invalid request method')
					}

					if (upgrade && typeof upgrade !== 'string') {
						throw new InvalidArgumentError('upgrade must be a string')
					}

					if (
						headersTimeout != null &&
						(!Number.isFinite(headersTimeout) || headersTimeout < 0)
					) {
						throw new InvalidArgumentError('invalid headersTimeout')
					}

					if (
						bodyTimeout != null &&
						(!Number.isFinite(bodyTimeout) || bodyTimeout < 0)
					) {
						throw new InvalidArgumentError('invalid bodyTimeout')
					}

					if (reset != null && typeof reset !== 'boolean') {
						throw new InvalidArgumentError('invalid reset')
					}

					if (expectContinue != null && typeof expectContinue !== 'boolean') {
						throw new InvalidArgumentError('invalid expectContinue')
					}

					this.headersTimeout = headersTimeout

					this.bodyTimeout = bodyTimeout

					this.throwOnError = throwOnError === true

					this.method = method

					this.abort = null

					if (body == null) {
						this.body = null
					} else if (util.isStream(body)) {
						this.body = body

						const rState = this.body._readableState
						if (!rState || !rState.autoDestroy) {
							this.endHandler = function autoDestroy() {
								util.destroy(this)
							}
							this.body.on('end', this.endHandler)
						}

						this.errorHandler = (err) => {
							if (this.abort) {
								this.abort(err)
							} else {
								this.error = err
							}
						}
						this.body.on('error', this.errorHandler)
					} else if (util.isBuffer(body)) {
						this.body = body.byteLength ? body : null
					} else if (ArrayBuffer.isView(body)) {
						this.body = body.buffer.byteLength
							? Buffer.from(body.buffer, body.byteOffset, body.byteLength)
							: null
					} else if (body instanceof ArrayBuffer) {
						this.body = body.byteLength ? Buffer.from(body) : null
					} else if (typeof body === 'string') {
						this.body = body.length ? Buffer.from(body) : null
					} else if (
						util.isFormDataLike(body) ||
						util.isIterable(body) ||
						util.isBlobLike(body)
					) {
						this.body = body
					} else {
						throw new InvalidArgumentError(
							'body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable',
						)
					}

					this.completed = false

					this.aborted = false

					this.upgrade = upgrade || null

					this.path = query ? util.buildURL(path, query) : path

					this.origin = origin

					this.idempotent =
						idempotent == null
							? method === 'HEAD' || method === 'GET'
							: idempotent

					this.blocking = blocking == null ? false : blocking

					this.reset = reset == null ? null : reset

					this.host = null

					this.contentLength = null

					this.contentType = null

					this.headers = ''

					// Only for H2
					this.expectContinue = expectContinue != null ? expectContinue : false

					if (Array.isArray(headers)) {
						if (headers.length % 2 !== 0) {
							throw new InvalidArgumentError('headers array must be even')
						}
						for (let i = 0; i < headers.length; i += 2) {
							processHeader(this, headers[i], headers[i + 1])
						}
					} else if (headers && typeof headers === 'object') {
						const keys = Object.keys(headers)
						for (let i = 0; i < keys.length; i++) {
							const key = keys[i]
							processHeader(this, key, headers[key])
						}
					} else if (headers != null) {
						throw new InvalidArgumentError(
							'headers must be an object or an array',
						)
					}

					if (util.isFormDataLike(this.body)) {
						if (
							util.nodeMajor < 16 ||
							(util.nodeMajor === 16 && util.nodeMinor < 8)
						) {
							throw new InvalidArgumentError(
								'Form-Data bodies are only supported in node v16.8 and newer.',
							)
						}

						if (!extractBody) {
							extractBody = __nccwpck_require__(8923).extractBody
						}

						const [bodyStream, contentType] = extractBody(body)
						if (this.contentType == null) {
							this.contentType = contentType
							this.headers += `content-type: ${contentType}\r\n`
						}
						this.body = bodyStream.stream
						this.contentLength = bodyStream.length
					} else if (
						util.isBlobLike(body) &&
						this.contentType == null &&
						body.type
					) {
						this.contentType = body.type
						this.headers += `content-type: ${body.type}\r\n`
					}

					util.validateHandler(handler, method, upgrade)

					this.servername = util.getServerName(this.host)

					this[kHandler] = handler

					if (channels.create.hasSubscribers) {
						channels.create.publish({ request: this })
					}
				}

				onBodySent(chunk) {
					if (this[kHandler].onBodySent) {
						try {
							return this[kHandler].onBodySent(chunk)
						} catch (err) {
							this.abort(err)
						}
					}
				}

				onRequestSent() {
					if (channels.bodySent.hasSubscribers) {
						channels.bodySent.publish({ request: this })
					}

					if (this[kHandler].onRequestSent) {
						try {
							return this[kHandler].onRequestSent()
						} catch (err) {
							this.abort(err)
						}
					}
				}

				onConnect(abort) {
					assert(!this.aborted)
					assert(!this.completed)

					if (this.error) {
						abort(this.error)
					} else {
						this.abort = abort
						return this[kHandler].onConnect(abort)
					}
				}

				onHeaders(statusCode, headers, resume, statusText) {
					assert(!this.aborted)
					assert(!this.completed)

					if (channels.headers.hasSubscribers) {
						channels.headers.publish({
							request: this,
							response: { statusCode, headers, statusText },
						})
					}

					try {
						return this[kHandler].onHeaders(
							statusCode,
							headers,
							resume,
							statusText,
						)
					} catch (err) {
						this.abort(err)
					}
				}

				onData(chunk) {
					assert(!this.aborted)
					assert(!this.completed)

					try {
						return this[kHandler].onData(chunk)
					} catch (err) {
						this.abort(err)
						return false
					}
				}

				onUpgrade(statusCode, headers, socket) {
					assert(!this.aborted)
					assert(!this.completed)

					return this[kHandler].onUpgrade(statusCode, headers, socket)
				}

				onComplete(trailers) {
					this.onFinally()

					assert(!this.aborted)

					this.completed = true
					if (channels.trailers.hasSubscribers) {
						channels.trailers.publish({ request: this, trailers })
					}

					try {
						return this[kHandler].onComplete(trailers)
					} catch (err) {
						// TODO (fix): This might be a bad idea?
						this.onError(err)
					}
				}

				onError(error) {
					this.onFinally()

					if (channels.error.hasSubscribers) {
						channels.error.publish({ request: this, error })
					}

					if (this.aborted) {
						return
					}
					this.aborted = true

					return this[kHandler].onError(error)
				}

				onFinally() {
					if (this.errorHandler) {
						this.body.off('error', this.errorHandler)
						this.errorHandler = null
					}

					if (this.endHandler) {
						this.body.off('end', this.endHandler)
						this.endHandler = null
					}
				}

				// TODO: adjust to support H2
				addHeader(key, value) {
					processHeader(this, key, value)
					return this
				}

				static [kHTTP1BuildRequest](origin, opts, handler) {
					// TODO: Migrate header parsing here, to make Requests
					// HTTP agnostic
					return new Request(origin, opts, handler)
				}

				static [kHTTP2BuildRequest](origin, opts, handler) {
					const headers = opts.headers
					opts = { ...opts, headers: null }

					const request = new Request(origin, opts, handler)

					request.headers = {}

					if (Array.isArray(headers)) {
						if (headers.length % 2 !== 0) {
							throw new InvalidArgumentError('headers array must be even')
						}
						for (let i = 0; i < headers.length; i += 2) {
							processHeader(request, headers[i], headers[i + 1], true)
						}
					} else if (headers && typeof headers === 'object') {
						const keys = Object.keys(headers)
						for (let i = 0; i < keys.length; i++) {
							const key = keys[i]
							processHeader(request, key, headers[key], true)
						}
					} else if (headers != null) {
						throw new InvalidArgumentError(
							'headers must be an object or an array',
						)
					}

					return request
				}

				static [kHTTP2CopyHeaders](raw) {
					const rawHeaders = raw.split('\r\n')
					const headers = {}

					for (const header of rawHeaders) {
						const [key, value] = header.split(': ')

						if (value == null || value.length === 0) continue

						if (headers[key]) headers[key] += `,${value}`
						else headers[key] = value
					}

					return headers
				}
			}

			function processHeaderValue(key, val, skipAppend) {
				if (val && typeof val === 'object') {
					throw new InvalidArgumentError(`invalid ${key} header`)
				}

				val = val != null ? `${val}` : ''

				if (headerCharRegex.exec(val) !== null) {
					throw new InvalidArgumentError(`invalid ${key} header`)
				}

				return skipAppend ? val : `${key}: ${val}\r\n`
			}

			function processHeader(request, key, val, skipAppend = false) {
				if (val && typeof val === 'object' && !Array.isArray(val)) {
					throw new InvalidArgumentError(`invalid ${key} header`)
				} else if (val === undefined) {
					return
				}

				if (
					request.host === null &&
					key.length === 4 &&
					key.toLowerCase() === 'host'
				) {
					if (headerCharRegex.exec(val) !== null) {
						throw new InvalidArgumentError(`invalid ${key} header`)
					}
					// Consumed by Client
					request.host = val
				} else if (
					request.contentLength === null &&
					key.length === 14 &&
					key.toLowerCase() === 'content-length'
				) {
					request.contentLength = parseInt(val, 10)
					if (!Number.isFinite(request.contentLength)) {
						throw new InvalidArgumentError('invalid content-length header')
					}
				} else if (
					request.contentType === null &&
					key.length === 12 &&
					key.toLowerCase() === 'content-type'
				) {
					request.contentType = val
					if (skipAppend)
						request.headers[key] = processHeaderValue(key, val, skipAppend)
					else request.headers += processHeaderValue(key, val)
				} else if (
					key.length === 17 &&
					key.toLowerCase() === 'transfer-encoding'
				) {
					throw new InvalidArgumentError('invalid transfer-encoding header')
				} else if (key.length === 10 && key.toLowerCase() === 'connection') {
					const value = typeof val === 'string' ? val.toLowerCase() : null
					if (value !== 'close' && value !== 'keep-alive') {
						throw new InvalidArgumentError('invalid connection header')
					} else if (value === 'close') {
						request.reset = true
					}
				} else if (key.length === 10 && key.toLowerCase() === 'keep-alive') {
					throw new InvalidArgumentError('invalid keep-alive header')
				} else if (key.length === 7 && key.toLowerCase() === 'upgrade') {
					throw new InvalidArgumentError('invalid upgrade header')
				} else if (key.length === 6 && key.toLowerCase() === 'expect') {
					throw new NotSupportedError('expect header not supported')
				} else if (tokenRegExp.exec(key) === null) {
					throw new InvalidArgumentError('invalid header key')
				} else {
					if (Array.isArray(val)) {
						for (let i = 0; i < val.length; i++) {
							if (skipAppend) {
								if (request.headers[key])
									request.headers[key] +=
										`,${processHeaderValue(key, val[i], skipAppend)}`
								else
									request.headers[key] = processHeaderValue(
										key,
										val[i],
										skipAppend,
									)
							} else {
								request.headers += processHeaderValue(key, val[i])
							}
						}
					} else {
						if (skipAppend)
							request.headers[key] = processHeaderValue(key, val, skipAppend)
						else request.headers += processHeaderValue(key, val)
					}
				}
			}

			module.exports = Request

			/***/
		},

		/***/ 36443: /***/ (module) => {
			module.exports = {
				kClose: Symbol('close'),
				kDestroy: Symbol('destroy'),
				kDispatch: Symbol('dispatch'),
				kUrl: Symbol('url'),
				kWriting: Symbol('writing'),
				kResuming: Symbol('resuming'),
				kQueue: Symbol('queue'),
				kConnect: Symbol('connect'),
				kConnecting: Symbol('connecting'),
				kHeadersList: Symbol('headers list'),
				kKeepAliveDefaultTimeout: Symbol('default keep alive timeout'),
				kKeepAliveMaxTimeout: Symbol('max keep alive timeout'),
				kKeepAliveTimeoutThreshold: Symbol('keep alive timeout threshold'),
				kKeepAliveTimeoutValue: Symbol('keep alive timeout'),
				kKeepAlive: Symbol('keep alive'),
				kHeadersTimeout: Symbol('headers timeout'),
				kBodyTimeout: Symbol('body timeout'),
				kServerName: Symbol('server name'),
				kLocalAddress: Symbol('local address'),
				kHost: Symbol('host'),
				kNoRef: Symbol('no ref'),
				kBodyUsed: Symbol('used'),
				kRunning: Symbol('running'),
				kBlocking: Symbol('blocking'),
				kPending: Symbol('pending'),
				kSize: Symbol('size'),
				kBusy: Symbol('busy'),
				kQueued: Symbol('queued'),
				kFree: Symbol('free'),
				kConnected: Symbol('connected'),
				kClosed: Symbol('closed'),
				kNeedDrain: Symbol('need drain'),
				kReset: Symbol('reset'),
				kDestroyed: Symbol.for('nodejs.stream.destroyed'),
				kMaxHeadersSize: Symbol('max headers size'),
				kRunningIdx: Symbol('running index'),
				kPendingIdx: Symbol('pending index'),
				kError: Symbol('error'),
				kClients: Symbol('clients'),
				kClient: Symbol('client'),
				kParser: Symbol('parser'),
				kOnDestroyed: Symbol('destroy callbacks'),
				kPipelining: Symbol('pipelining'),
				kSocket: Symbol('socket'),
				kHostHeader: Symbol('host header'),
				kConnector: Symbol('connector'),
				kStrictContentLength: Symbol('strict content length'),
				kMaxRedirections: Symbol('maxRedirections'),
				kMaxRequests: Symbol('maxRequestsPerClient'),
				kProxy: Symbol('proxy agent options'),
				kCounter: Symbol('socket request counter'),
				kInterceptors: Symbol('dispatch interceptors'),
				kMaxResponseSize: Symbol('max response size'),
				kHTTP2Session: Symbol('http2Session'),
				kHTTP2SessionState: Symbol('http2Session state'),
				kHTTP2BuildRequest: Symbol('http2 build request'),
				kHTTP1BuildRequest: Symbol('http1 build request'),
				kHTTP2CopyHeaders: Symbol('http2 copy headers'),
				kHTTPConnVersion: Symbol('http connection version'),
				kRetryHandlerDefaultRetry: Symbol('retry agent default retry'),
				kConstruct: Symbol('constructable'),
			}

			/***/
		},

		/***/ 3440: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const assert = __nccwpck_require__(42613)
			const { kDestroyed, kBodyUsed } = __nccwpck_require__(36443)
			const { IncomingMessage } = __nccwpck_require__(58611)
			const stream = __nccwpck_require__(2203)
			const net = __nccwpck_require__(69278)
			const { InvalidArgumentError } = __nccwpck_require__(68707)
			const { Blob } = __nccwpck_require__(20181)
			const nodeUtil = __nccwpck_require__(39023)
			const { stringify } = __nccwpck_require__(83480)
			const { headerNameLowerCasedRecord } = __nccwpck_require__(10735)

			const [nodeMajor, nodeMinor] = process.versions.node
				.split('.')
				.map((v) => Number(v))

			function nop() {}

			function isStream(obj) {
				return (
					obj &&
					typeof obj === 'object' &&
					typeof obj.pipe === 'function' &&
					typeof obj.on === 'function'
				)
			}

			// based on https://github.com/node-fetch/fetch-blob/blob/8ab587d34080de94140b54f07168451e7d0b655e/index.js#L229-L241 (MIT License)
			function isBlobLike(object) {
				return (
					(Blob && object instanceof Blob) ||
					(object &&
						typeof object === 'object' &&
						(typeof object.stream === 'function' ||
							typeof object.arrayBuffer === 'function') &&
						/^(Blob|File)$/.test(object[Symbol.toStringTag]))
				)
			}

			function buildURL(url, queryParams) {
				if (url.includes('?') || url.includes('#')) {
					throw new Error(
						'Query params cannot be passed when url already contains "?" or "#".',
					)
				}

				const stringified = stringify(queryParams)

				if (stringified) {
					url += '?' + stringified
				}

				return url
			}

			function parseURL(url) {
				if (typeof url === 'string') {
					url = new URL(url)

					if (!/^https?:/.test(url.origin || url.protocol)) {
						throw new InvalidArgumentError(
							'Invalid URL protocol: the URL must start with `http:` or `https:`.',
						)
					}

					return url
				}

				if (!url || typeof url !== 'object') {
					throw new InvalidArgumentError(
						'Invalid URL: The URL argument must be a non-null object.',
					)
				}

				if (!/^https?:/.test(url.origin || url.protocol)) {
					throw new InvalidArgumentError(
						'Invalid URL protocol: the URL must start with `http:` or `https:`.',
					)
				}

				if (!(url instanceof URL)) {
					if (
						url.port != null &&
						url.port !== '' &&
						!Number.isFinite(parseInt(url.port))
					) {
						throw new InvalidArgumentError(
							'Invalid URL: port must be a valid integer or a string representation of an integer.',
						)
					}

					if (url.path != null && typeof url.path !== 'string') {
						throw new InvalidArgumentError(
							'Invalid URL path: the path must be a string or null/undefined.',
						)
					}

					if (url.pathname != null && typeof url.pathname !== 'string') {
						throw new InvalidArgumentError(
							'Invalid URL pathname: the pathname must be a string or null/undefined.',
						)
					}

					if (url.hostname != null && typeof url.hostname !== 'string') {
						throw new InvalidArgumentError(
							'Invalid URL hostname: the hostname must be a string or null/undefined.',
						)
					}

					if (url.origin != null && typeof url.origin !== 'string') {
						throw new InvalidArgumentError(
							'Invalid URL origin: the origin must be a string or null/undefined.',
						)
					}

					const port =
						url.port != null ? url.port : url.protocol === 'https:' ? 443 : 80
					let origin =
						url.origin != null
							? url.origin
							: `${url.protocol}//${url.hostname}:${port}`
					let path =
						url.path != null
							? url.path
							: `${url.pathname || ''}${url.search || ''}`

					if (origin.endsWith('/')) {
						origin = origin.substring(0, origin.length - 1)
					}

					if (path && !path.startsWith('/')) {
						path = `/${path}`
					}
					// new URL(path, origin) is unsafe when `path` contains an absolute URL
					// From https://developer.mozilla.org/en-US/docs/Web/API/URL/URL:
					// If first parameter is a relative URL, second param is required, and will be used as the base URL.
					// If first parameter is an absolute URL, a given second param will be ignored.
					url = new URL(origin + path)
				}

				return url
			}

			function parseOrigin(url) {
				url = parseURL(url)

				if (url.pathname !== '/' || url.search || url.hash) {
					throw new InvalidArgumentError('invalid url')
				}

				return url
			}

			function getHostname(host) {
				if (host[0] === '[') {
					const idx = host.indexOf(']')

					assert(idx !== -1)
					return host.substring(1, idx)
				}

				const idx = host.indexOf(':')
				if (idx === -1) return host

				return host.substring(0, idx)
			}

			// IP addresses are not valid server names per RFC6066
			// > Currently, the only server names supported are DNS hostnames
			function getServerName(host) {
				if (!host) {
					return null
				}

				assert.strictEqual(typeof host, 'string')

				const servername = getHostname(host)
				if (net.isIP(servername)) {
					return ''
				}

				return servername
			}

			function deepClone(obj) {
				return JSON.parse(JSON.stringify(obj))
			}

			function isAsyncIterable(obj) {
				return !!(
					obj != null && typeof obj[Symbol.asyncIterator] === 'function'
				)
			}

			function isIterable(obj) {
				return !!(
					obj != null &&
					(typeof obj[Symbol.iterator] === 'function' ||
						typeof obj[Symbol.asyncIterator] === 'function')
				)
			}

			function bodyLength(body) {
				if (body == null) {
					return 0
				} else if (isStream(body)) {
					const state = body._readableState
					return state &&
						state.objectMode === false &&
						state.ended === true &&
						Number.isFinite(state.length)
						? state.length
						: null
				} else if (isBlobLike(body)) {
					return body.size != null ? body.size : null
				} else if (isBuffer(body)) {
					return body.byteLength
				}

				return null
			}

			function isDestroyed(stream) {
				return !stream || !!(stream.destroyed || stream[kDestroyed])
			}

			function isReadableAborted(stream) {
				const state = stream && stream._readableState
				return isDestroyed(stream) && state && !state.endEmitted
			}

			function destroy(stream, err) {
				if (stream == null || !isStream(stream) || isDestroyed(stream)) {
					return
				}

				if (typeof stream.destroy === 'function') {
					if (Object.getPrototypeOf(stream).constructor === IncomingMessage) {
						// See: https://github.com/nodejs/node/pull/38505/files
						stream.socket = null
					}

					stream.destroy(err)
				} else if (err) {
					process.nextTick(
						(stream, err) => {
							stream.emit('error', err)
						},
						stream,
						err,
					)
				}

				if (stream.destroyed !== true) {
					stream[kDestroyed] = true
				}
			}

			const KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/
			function parseKeepAliveTimeout(val) {
				const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR)
				return m ? parseInt(m[1], 10) * 1000 : null
			}

			/**
			 * Retrieves a header name and returns its lowercase value.
			 * @param {string | Buffer} value Header name
			 * @returns {string}
			 */
			function headerNameToString(value) {
				return headerNameLowerCasedRecord[value] || value.toLowerCase()
			}

			function parseHeaders(headers, obj = {}) {
				// For H2 support
				if (!Array.isArray(headers)) return headers

				for (let i = 0; i < headers.length; i += 2) {
					const key = headers[i].toString().toLowerCase()
					let val = obj[key]

					if (!val) {
						if (Array.isArray(headers[i + 1])) {
							obj[key] = headers[i + 1].map((x) => x.toString('utf8'))
						} else {
							obj[key] = headers[i + 1].toString('utf8')
						}
					} else {
						if (!Array.isArray(val)) {
							val = [val]
							obj[key] = val
						}
						val.push(headers[i + 1].toString('utf8'))
					}
				}

				// See https://github.com/nodejs/node/pull/46528
				if ('content-length' in obj && 'content-disposition' in obj) {
					obj['content-disposition'] = Buffer.from(
						obj['content-disposition'],
					).toString('latin1')
				}

				return obj
			}

			function parseRawHeaders(headers) {
				const ret = []
				let hasContentLength = false
				let contentDispositionIdx = -1

				for (let n = 0; n < headers.length; n += 2) {
					const key = headers[n + 0].toString()
					const val = headers[n + 1].toString('utf8')

					if (
						key.length === 14 &&
						(key === 'content-length' || key.toLowerCase() === 'content-length')
					) {
						ret.push(key, val)
						hasContentLength = true
					} else if (
						key.length === 19 &&
						(key === 'content-disposition' ||
							key.toLowerCase() === 'content-disposition')
					) {
						contentDispositionIdx = ret.push(key, val) - 1
					} else {
						ret.push(key, val)
					}
				}

				// See https://github.com/nodejs/node/pull/46528
				if (hasContentLength && contentDispositionIdx !== -1) {
					ret[contentDispositionIdx] = Buffer.from(
						ret[contentDispositionIdx],
					).toString('latin1')
				}

				return ret
			}

			function isBuffer(buffer) {
				// See, https://github.com/mcollina/undici/pull/319
				return buffer instanceof Uint8Array || Buffer.isBuffer(buffer)
			}

			function validateHandler(handler, method, upgrade) {
				if (!handler || typeof handler !== 'object') {
					throw new InvalidArgumentError('handler must be an object')
				}

				if (typeof handler.onConnect !== 'function') {
					throw new InvalidArgumentError('invalid onConnect method')
				}

				if (typeof handler.onError !== 'function') {
					throw new InvalidArgumentError('invalid onError method')
				}

				if (
					typeof handler.onBodySent !== 'function' &&
					handler.onBodySent !== undefined
				) {
					throw new InvalidArgumentError('invalid onBodySent method')
				}

				if (upgrade || method === 'CONNECT') {
					if (typeof handler.onUpgrade !== 'function') {
						throw new InvalidArgumentError('invalid onUpgrade method')
					}
				} else {
					if (typeof handler.onHeaders !== 'function') {
						throw new InvalidArgumentError('invalid onHeaders method')
					}

					if (typeof handler.onData !== 'function') {
						throw new InvalidArgumentError('invalid onData method')
					}

					if (typeof handler.onComplete !== 'function') {
						throw new InvalidArgumentError('invalid onComplete method')
					}
				}
			}

			// A body is disturbed if it has been read from and it cannot
			// be re-used without losing state or data.
			function isDisturbed(body) {
				return !!(
					body &&
					(stream.isDisturbed
						? stream.isDisturbed(body) || body[kBodyUsed] // TODO (fix): Why is body[kBodyUsed] needed?
						: body[kBodyUsed] ||
							body.readableDidRead ||
							(body._readableState && body._readableState.dataEmitted) ||
							isReadableAborted(body))
				)
			}

			function isErrored(body) {
				return !!(
					body &&
					(stream.isErrored
						? stream.isErrored(body)
						: /state: 'errored'/.test(nodeUtil.inspect(body)))
				)
			}

			function isReadable(body) {
				return !!(
					body &&
					(stream.isReadable
						? stream.isReadable(body)
						: /state: 'readable'/.test(nodeUtil.inspect(body)))
				)
			}

			function getSocketInfo(socket) {
				return {
					localAddress: socket.localAddress,
					localPort: socket.localPort,
					remoteAddress: socket.remoteAddress,
					remotePort: socket.remotePort,
					remoteFamily: socket.remoteFamily,
					timeout: socket.timeout,
					bytesWritten: socket.bytesWritten,
					bytesRead: socket.bytesRead,
				}
			}

			async function* convertIterableToBuffer(iterable) {
				for await (const chunk of iterable) {
					yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk)
				}
			}

			let ReadableStream
			function ReadableStreamFrom(iterable) {
				if (!ReadableStream) {
					ReadableStream = __nccwpck_require__(63774).ReadableStream
				}

				if (ReadableStream.from) {
					return ReadableStream.from(convertIterableToBuffer(iterable))
				}

				let iterator
				return new ReadableStream(
					{
						async start() {
							iterator = iterable[Symbol.asyncIterator]()
						},
						async pull(controller) {
							const { done, value } = await iterator.next()
							if (done) {
								queueMicrotask(() => {
									controller.close()
								})
							} else {
								const buf = Buffer.isBuffer(value) ? value : Buffer.from(value)
								controller.enqueue(new Uint8Array(buf))
							}
							return controller.desiredSize > 0
						},
						async cancel(reason) {
							await iterator.return()
						},
					},
					0,
				)
			}

			// The chunk should be a FormData instance and contains
			// all the required methods.
			function isFormDataLike(object) {
				return (
					object &&
					typeof object === 'object' &&
					typeof object.append === 'function' &&
					typeof object.delete === 'function' &&
					typeof object.get === 'function' &&
					typeof object.getAll === 'function' &&
					typeof object.has === 'function' &&
					typeof object.set === 'function' &&
					object[Symbol.toStringTag] === 'FormData'
				)
			}

			function throwIfAborted(signal) {
				if (!signal) {
					return
				}
				if (typeof signal.throwIfAborted === 'function') {
					signal.throwIfAborted()
				} else {
					if (signal.aborted) {
						// DOMException not available < v17.0.0
						const err = new Error('The operation was aborted')
						err.name = 'AbortError'
						throw err
					}
				}
			}

			function addAbortListener(signal, listener) {
				if ('addEventListener' in signal) {
					signal.addEventListener('abort', listener, { once: true })
					return () => signal.removeEventListener('abort', listener)
				}
				signal.addListener('abort', listener)
				return () => signal.removeListener('abort', listener)
			}

			const hasToWellFormed = !!String.prototype.toWellFormed

			/**
			 * @param {string} val
			 */
			function toUSVString(val) {
				if (hasToWellFormed) {
					return `${val}`.toWellFormed()
				} else if (nodeUtil.toUSVString) {
					return nodeUtil.toUSVString(val)
				}

				return `${val}`
			}

			// Parsed accordingly to RFC 9110
			// https://www.rfc-editor.org/rfc/rfc9110#field.content-range
			function parseRangeHeader(range) {
				if (range == null || range === '')
					return { start: 0, end: null, size: null }

				const m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null
				return m
					? {
							start: parseInt(m[1]),
							end: m[2] ? parseInt(m[2]) : null,
							size: m[3] ? parseInt(m[3]) : null,
						}
					: null
			}

			const kEnumerableProperty = Object.create(null)
			kEnumerableProperty.enumerable = true

			module.exports = {
				kEnumerableProperty,
				nop,
				isDisturbed,
				isErrored,
				isReadable,
				toUSVString,
				isReadableAborted,
				isBlobLike,
				parseOrigin,
				parseURL,
				getServerName,
				isStream,
				isIterable,
				isAsyncIterable,
				isDestroyed,
				headerNameToString,
				parseRawHeaders,
				parseHeaders,
				parseKeepAliveTimeout,
				destroy,
				bodyLength,
				deepClone,
				ReadableStreamFrom,
				isBuffer,
				validateHandler,
				getSocketInfo,
				isFormDataLike,
				buildURL,
				throwIfAborted,
				addAbortListener,
				parseRangeHeader,
				nodeMajor,
				nodeMinor,
				nodeHasAutoSelectFamily:
					nodeMajor > 18 || (nodeMajor === 18 && nodeMinor >= 13),
				safeHTTPMethods: ['GET', 'HEAD', 'OPTIONS', 'TRACE'],
			}

			/***/
		},

		/***/ 50001: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const Dispatcher = __nccwpck_require__(28611)
			const { ClientDestroyedError, ClientClosedError, InvalidArgumentError } =
				__nccwpck_require__(68707)
			const { kDestroy, kClose, kDispatch, kInterceptors } =
				__nccwpck_require__(36443)

			const kDestroyed = Symbol('destroyed')
			const kClosed = Symbol('closed')
			const kOnDestroyed = Symbol('onDestroyed')
			const kOnClosed = Symbol('onClosed')
			const kInterceptedDispatch = Symbol('Intercepted Dispatch')

			class DispatcherBase extends Dispatcher {
				constructor() {
					super()

					this[kDestroyed] = false
					this[kOnDestroyed] = null
					this[kClosed] = false
					this[kOnClosed] = []
				}

				get destroyed() {
					return this[kDestroyed]
				}

				get closed() {
					return this[kClosed]
				}

				get interceptors() {
					return this[kInterceptors]
				}

				set interceptors(newInterceptors) {
					if (newInterceptors) {
						for (let i = newInterceptors.length - 1; i >= 0; i--) {
							const interceptor = this[kInterceptors][i]
							if (typeof interceptor !== 'function') {
								throw new InvalidArgumentError(
									'interceptor must be an function',
								)
							}
						}
					}

					this[kInterceptors] = newInterceptors
				}

				close(callback) {
					if (callback === undefined) {
						return new Promise((resolve, reject) => {
							this.close((err, data) => {
								return err ? reject(err) : resolve(data)
							})
						})
					}

					if (typeof callback !== 'function') {
						throw new InvalidArgumentError('invalid callback')
					}

					if (this[kDestroyed]) {
						queueMicrotask(() => callback(new ClientDestroyedError(), null))
						return
					}

					if (this[kClosed]) {
						if (this[kOnClosed]) {
							this[kOnClosed].push(callback)
						} else {
							queueMicrotask(() => callback(null, null))
						}
						return
					}

					this[kClosed] = true
					this[kOnClosed].push(callback)

					const onClosed = () => {
						const callbacks = this[kOnClosed]
						this[kOnClosed] = null
						for (let i = 0; i < callbacks.length; i++) {
							callbacks[i](null, null)
						}
					}

					// Should not error.
					this[kClose]()
						.then(() => this.destroy())
						.then(() => {
							queueMicrotask(onClosed)
						})
				}

				destroy(err, callback) {
					if (typeof err === 'function') {
						callback = err
						err = null
					}

					if (callback === undefined) {
						return new Promise((resolve, reject) => {
							this.destroy(err, (err, data) => {
								return err
									? /* istanbul ignore next: should never error */ reject(err)
									: resolve(data)
							})
						})
					}

					if (typeof callback !== 'function') {
						throw new InvalidArgumentError('invalid callback')
					}

					if (this[kDestroyed]) {
						if (this[kOnDestroyed]) {
							this[kOnDestroyed].push(callback)
						} else {
							queueMicrotask(() => callback(null, null))
						}
						return
					}

					if (!err) {
						err = new ClientDestroyedError()
					}

					this[kDestroyed] = true
					this[kOnDestroyed] = this[kOnDestroyed] || []
					this[kOnDestroyed].push(callback)

					const onDestroyed = () => {
						const callbacks = this[kOnDestroyed]
						this[kOnDestroyed] = null
						for (let i = 0; i < callbacks.length; i++) {
							callbacks[i](null, null)
						}
					}

					// Should not error.
					this[kDestroy](err).then(() => {
						queueMicrotask(onDestroyed)
					})
				}

				[kInterceptedDispatch](opts, handler) {
					if (!this[kInterceptors] || this[kInterceptors].length === 0) {
						this[kInterceptedDispatch] = this[kDispatch]
						return this[kDispatch](opts, handler)
					}

					let dispatch = this[kDispatch].bind(this)
					for (let i = this[kInterceptors].length - 1; i >= 0; i--) {
						dispatch = this[kInterceptors][i](dispatch)
					}
					this[kInterceptedDispatch] = dispatch
					return dispatch(opts, handler)
				}

				dispatch(opts, handler) {
					if (!handler || typeof handler !== 'object') {
						throw new InvalidArgumentError('handler must be an object')
					}

					try {
						if (!opts || typeof opts !== 'object') {
							throw new InvalidArgumentError('opts must be an object.')
						}

						if (this[kDestroyed] || this[kOnDestroyed]) {
							throw new ClientDestroyedError()
						}

						if (this[kClosed]) {
							throw new ClientClosedError()
						}

						return this[kInterceptedDispatch](opts, handler)
					} catch (err) {
						if (typeof handler.onError !== 'function') {
							throw new InvalidArgumentError('invalid onError method')
						}

						handler.onError(err)

						return false
					}
				}
			}

			module.exports = DispatcherBase

			/***/
		},

		/***/ 28611: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const EventEmitter = __nccwpck_require__(24434)

			class Dispatcher extends EventEmitter {
				dispatch() {
					throw new Error('not implemented')
				}

				close() {
					throw new Error('not implemented')
				}

				destroy() {
					throw new Error('not implemented')
				}
			}

			module.exports = Dispatcher

			/***/
		},

		/***/ 8923: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const Busboy = __nccwpck_require__(89581)
			const util = __nccwpck_require__(3440)
			const {
				ReadableStreamFrom,
				isBlobLike,
				isReadableStreamLike,
				readableStreamClose,
				createDeferredPromise,
				fullyReadBody,
			} = __nccwpck_require__(15523)
			const { FormData } = __nccwpck_require__(43073)
			const { kState } = __nccwpck_require__(89710)
			const { webidl } = __nccwpck_require__(74222)
			const { DOMException, structuredClone } = __nccwpck_require__(87326)
			const { Blob, File: NativeFile } = __nccwpck_require__(20181)
			const { kBodyUsed } = __nccwpck_require__(36443)
			const assert = __nccwpck_require__(42613)
			const { isErrored } = __nccwpck_require__(3440)
			const { isUint8Array, isArrayBuffer } = __nccwpck_require__(98253)
			const { File: UndiciFile } = __nccwpck_require__(63041)
			const { parseMIMEType, serializeAMimeType } = __nccwpck_require__(94322)

			let random
			try {
				const crypto = __nccwpck_require__(77598)
				random = (max) => crypto.randomInt(0, max)
			} catch {
				random = (max) => Math.floor(Math.random(max))
			}

			let ReadableStream = globalThis.ReadableStream

			/** @type {globalThis['File']} */
			const File = NativeFile ?? UndiciFile
			const textEncoder = new TextEncoder()
			const textDecoder = new TextDecoder()

			// https://fetch.spec.whatwg.org/#concept-bodyinit-extract
			function extractBody(object, keepalive = false) {
				if (!ReadableStream) {
					ReadableStream = __nccwpck_require__(63774).ReadableStream
				}

				// 1. Let stream be null.
				let stream = null

				// 2. If object is a ReadableStream object, then set stream to object.
				if (object instanceof ReadableStream) {
					stream = object
				} else if (isBlobLike(object)) {
					// 3. Otherwise, if object is a Blob object, set stream to the
					//    result of running objects get stream.
					stream = object.stream()
				} else {
					// 4. Otherwise, set stream to a new ReadableStream object, and set
					//    up stream.
					stream = new ReadableStream({
						async pull(controller) {
							controller.enqueue(
								typeof source === 'string'
									? textEncoder.encode(source)
									: source,
							)
							queueMicrotask(() => readableStreamClose(controller))
						},
						start() {},
						type: undefined,
					})
				}

				// 5. Assert: stream is a ReadableStream object.
				assert(isReadableStreamLike(stream))

				// 6. Let action be null.
				let action = null

				// 7. Let source be null.
				let source = null

				// 8. Let length be null.
				let length = null

				// 9. Let type be null.
				let type = null

				// 10. Switch on object:
				if (typeof object === 'string') {
					// Set source to the UTF-8 encoding of object.
					// Note: setting source to a Uint8Array here breaks some mocking assumptions.
					source = object

					// Set type to `text/plain;charset=UTF-8`.
					type = 'text/plain;charset=UTF-8'
				} else if (object instanceof URLSearchParams) {
					// URLSearchParams

					// spec says to run application/x-www-form-urlencoded on body.list
					// this is implemented in Node.js as apart of an URLSearchParams instance toString method
					// See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490
					// and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100

					// Set source to the result of running the application/x-www-form-urlencoded serializer with objects list.
					source = object.toString()

					// Set type to `application/x-www-form-urlencoded;charset=UTF-8`.
					type = 'application/x-www-form-urlencoded;charset=UTF-8'
				} else if (isArrayBuffer(object)) {
					// BufferSource/ArrayBuffer

					// Set source to a copy of the bytes held by object.
					source = new Uint8Array(object.slice())
				} else if (ArrayBuffer.isView(object)) {
					// BufferSource/ArrayBufferView

					// Set source to a copy of the bytes held by object.
					source = new Uint8Array(
						object.buffer.slice(
							object.byteOffset,
							object.byteOffset + object.byteLength,
						),
					)
				} else if (util.isFormDataLike(object)) {
					const boundary = `----formdata-undici-0${`${random(1e11)}`.padStart(11, '0')}`
					const prefix = `--${boundary}\r\nContent-Disposition: form-data`

					/*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
					const escape = (str) =>
						str.replace(/\n/g, '%0A').replace(/\r/g, '%0D').replace(/"/g, '%22')
					const normalizeLinefeeds = (value) =>
						value.replace(/\r?\n|\r/g, '\r\n')

					// Set action to this step: run the multipart/form-data
					// encoding algorithm, with objects entry list and UTF-8.
					// - This ensures that the body is immutable and can't be changed afterwords
					// - That the content-length is calculated in advance.
					// - And that all parts are pre-encoded and ready to be sent.

					const blobParts = []
					const rn = new Uint8Array([13, 10]) // '\r\n'
					length = 0
					let hasUnknownSizeValue = false

					for (const [name, value] of object) {
						if (typeof value === 'string') {
							const chunk = textEncoder.encode(
								prefix +
									`; name="${escape(normalizeLinefeeds(name))}"` +
									`\r\n\r\n${normalizeLinefeeds(value)}\r\n`,
							)
							blobParts.push(chunk)
							length += chunk.byteLength
						} else {
							const chunk = textEncoder.encode(
								`${prefix}; name="${escape(normalizeLinefeeds(name))}"` +
									(value.name ? `; filename="${escape(value.name)}"` : '') +
									'\r\n' +
									`Content-Type: ${
										value.type || 'application/octet-stream'
									}\r\n\r\n`,
							)
							blobParts.push(chunk, value, rn)
							if (typeof value.size === 'number') {
								length += chunk.byteLength + value.size + rn.byteLength
							} else {
								hasUnknownSizeValue = true
							}
						}
					}

					const chunk = textEncoder.encode(`--${boundary}--`)
					blobParts.push(chunk)
					length += chunk.byteLength
					if (hasUnknownSizeValue) {
						length = null
					}

					// Set source to object.
					source = object

					action = async function* () {
						for (const part of blobParts) {
							if (part.stream) {
								yield* part.stream()
							} else {
								yield part
							}
						}
					}

					// Set type to `multipart/form-data; boundary=`,
					// followed by the multipart/form-data boundary string generated
					// by the multipart/form-data encoding algorithm.
					type = 'multipart/form-data; boundary=' + boundary
				} else if (isBlobLike(object)) {
					// Blob

					// Set source to object.
					source = object

					// Set length to objects size.
					length = object.size

					// If objects type attribute is not the empty byte sequence, set
					// type to its value.
					if (object.type) {
						type = object.type
					}
				} else if (typeof object[Symbol.asyncIterator] === 'function') {
					// If keepalive is true, then throw a TypeError.
					if (keepalive) {
						throw new TypeError('keepalive')
					}

					// If object is disturbed or locked, then throw a TypeError.
					if (util.isDisturbed(object) || object.locked) {
						throw new TypeError(
							'Response body object should not be disturbed or locked',
						)
					}

					stream =
						object instanceof ReadableStream
							? object
							: ReadableStreamFrom(object)
				}

				// 11. If source is a byte sequence, then set action to a
				// step that returns source and length to sources length.
				if (typeof source === 'string' || util.isBuffer(source)) {
					length = Buffer.byteLength(source)
				}

				// 12. If action is non-null, then run these steps in in parallel:
				if (action != null) {
					// Run action.
					let iterator
					stream = new ReadableStream({
						async start() {
							iterator = action(object)[Symbol.asyncIterator]()
						},
						async pull(controller) {
							const { value, done } = await iterator.next()
							if (done) {
								// When running action is done, close stream.
								queueMicrotask(() => {
									controller.close()
								})
							} else {
								// Whenever one or more bytes are available and stream is not errored,
								// enqueue a Uint8Array wrapping an ArrayBuffer containing the available
								// bytes into stream.
								if (!isErrored(stream)) {
									controller.enqueue(new Uint8Array(value))
								}
							}
							return controller.desiredSize > 0
						},
						async cancel(reason) {
							await iterator.return()
						},
						type: undefined,
					})
				}

				// 13. Let body be a body whose stream is stream, source is source,
				// and length is length.
				const body = { stream, source, length }

				// 14. Return (body, type).
				return [body, type]
			}

			// https://fetch.spec.whatwg.org/#bodyinit-safely-extract
			function safelyExtractBody(object, keepalive = false) {
				if (!ReadableStream) {
					// istanbul ignore next
					ReadableStream = __nccwpck_require__(63774).ReadableStream
				}

				// To safely extract a body and a `Content-Type` value from
				// a byte sequence or BodyInit object object, run these steps:

				// 1. If object is a ReadableStream object, then:
				if (object instanceof ReadableStream) {
					// Assert: object is neither disturbed nor locked.
					// istanbul ignore next
					assert(
						!util.isDisturbed(object),
						'The body has already been consumed.',
					)
					// istanbul ignore next
					assert(!object.locked, 'The stream is locked.')
				}

				// 2. Return the results of extracting object.
				return extractBody(object, keepalive)
			}

			function cloneBody(body) {
				// To clone a body body, run these steps:

				// https://fetch.spec.whatwg.org/#concept-body-clone

				// 1. Let  out1, out2  be the result of teeing bodys stream.
				const [out1, out2] = body.stream.tee()
				const out2Clone = structuredClone(out2, { transfer: [out2] })
				// This, for whatever reasons, unrefs out2Clone which allows
				// the process to exit by itself.
				const [, finalClone] = out2Clone.tee()

				// 2. Set bodys stream to out1.
				body.stream = out1

				// 3. Return a body whose stream is out2 and other members are copied from body.
				return {
					stream: finalClone,
					length: body.length,
					source: body.source,
				}
			}

			async function* consumeBody(body) {
				if (body) {
					if (isUint8Array(body)) {
						yield body
					} else {
						const stream = body.stream

						if (util.isDisturbed(stream)) {
							throw new TypeError('The body has already been consumed.')
						}

						if (stream.locked) {
							throw new TypeError('The stream is locked.')
						}

						// Compat.
						stream[kBodyUsed] = true

						yield* stream
					}
				}
			}

			function throwIfAborted(state) {
				if (state.aborted) {
					throw new DOMException('The operation was aborted.', 'AbortError')
				}
			}

			function bodyMixinMethods(instance) {
				const methods = {
					blob() {
						// The blob() method steps are to return the result of
						// running consume body with this and the following step
						// given a byte sequence bytes: return a Blob whose
						// contents are bytes and whose type attribute is thiss
						// MIME type.
						return specConsumeBody(
							this,
							(bytes) => {
								let mimeType = bodyMimeType(this)

								if (mimeType === 'failure') {
									mimeType = ''
								} else if (mimeType) {
									mimeType = serializeAMimeType(mimeType)
								}

								// Return a Blob whose contents are bytes and type attribute
								// is mimeType.
								return new Blob([bytes], { type: mimeType })
							},
							instance,
						)
					},

					arrayBuffer() {
						// The arrayBuffer() method steps are to return the result
						// of running consume body with this and the following step
						// given a byte sequence bytes: return a new ArrayBuffer
						// whose contents are bytes.
						return specConsumeBody(
							this,
							(bytes) => {
								return new Uint8Array(bytes).buffer
							},
							instance,
						)
					},

					text() {
						// The text() method steps are to return the result of running
						// consume body with this and UTF-8 decode.
						return specConsumeBody(this, utf8DecodeBytes, instance)
					},

					json() {
						// The json() method steps are to return the result of running
						// consume body with this and parse JSON from bytes.
						return specConsumeBody(this, parseJSONFromBytes, instance)
					},

					async formData() {
						webidl.brandCheck(this, instance)

						throwIfAborted(this[kState])

						const contentType = this.headers.get('Content-Type')

						// If mimeTypes essence is "multipart/form-data", then:
						if (/multipart\/form-data/.test(contentType)) {
							const headers = {}
							for (const [key, value] of this.headers)
								headers[key.toLowerCase()] = value

							const responseFormData = new FormData()

							let busboy

							try {
								busboy = new Busboy({
									headers,
									preservePath: true,
								})
							} catch (err) {
								throw new DOMException(`${err}`, 'AbortError')
							}

							busboy.on('field', (name, value) => {
								responseFormData.append(name, value)
							})
							busboy.on('file', (name, value, filename, encoding, mimeType) => {
								const chunks = []

								if (
									encoding === 'base64' ||
									encoding.toLowerCase() === 'base64'
								) {
									let base64chunk = ''

									value.on('data', (chunk) => {
										base64chunk += chunk.toString().replace(/[\r\n]/gm, '')

										const end = base64chunk.length - (base64chunk.length % 4)
										chunks.push(
											Buffer.from(base64chunk.slice(0, end), 'base64'),
										)

										base64chunk = base64chunk.slice(end)
									})
									value.on('end', () => {
										chunks.push(Buffer.from(base64chunk, 'base64'))
										responseFormData.append(
											name,
											new File(chunks, filename, { type: mimeType }),
										)
									})
								} else {
									value.on('data', (chunk) => {
										chunks.push(chunk)
									})
									value.on('end', () => {
										responseFormData.append(
											name,
											new File(chunks, filename, { type: mimeType }),
										)
									})
								}
							})

							const busboyResolve = new Promise((resolve, reject) => {
								busboy.on('finish', resolve)
								busboy.on('error', (err) => reject(new TypeError(err)))
							})

							if (this.body !== null)
								for await (const chunk of consumeBody(this[kState].body))
									busboy.write(chunk)
							busboy.end()
							await busboyResolve

							return responseFormData
						} else if (/application\/x-www-form-urlencoded/.test(contentType)) {
							// Otherwise, if mimeTypes essence is "application/x-www-form-urlencoded", then:

							// 1. Let entries be the result of parsing bytes.
							let entries
							try {
								let text = ''
								// application/x-www-form-urlencoded parser will keep the BOM.
								// https://url.spec.whatwg.org/#concept-urlencoded-parser
								// Note that streaming decoder is stateful and cannot be reused
								const streamingDecoder = new TextDecoder('utf-8', {
									ignoreBOM: true,
								})

								for await (const chunk of consumeBody(this[kState].body)) {
									if (!isUint8Array(chunk)) {
										throw new TypeError('Expected Uint8Array chunk')
									}
									text += streamingDecoder.decode(chunk, { stream: true })
								}
								text += streamingDecoder.decode()
								entries = new URLSearchParams(text)
							} catch (err) {
								// istanbul ignore next: Unclear when new URLSearchParams can fail on a string.
								// 2. If entries is failure, then throw a TypeError.
								throw Object.assign(new TypeError(), { cause: err })
							}

							// 3. Return a new FormData object whose entries are entries.
							const formData = new FormData()
							for (const [name, value] of entries) {
								formData.append(name, value)
							}
							return formData
						} else {
							// Wait a tick before checking if the request has been aborted.
							// Otherwise, a TypeError can be thrown when an AbortError should.
							await Promise.resolve()

							throwIfAborted(this[kState])

							// Otherwise, throw a TypeError.
							throw webidl.errors.exception({
								header: `${instance.name}.formData`,
								message: 'Could not parse content as FormData.',
							})
						}
					},
				}

				return methods
			}

			function mixinBody(prototype) {
				Object.assign(prototype.prototype, bodyMixinMethods(prototype))
			}

			/**
			 * @see https://fetch.spec.whatwg.org/#concept-body-consume-body
			 * @param {Response|Request} object
			 * @param {(value: unknown) => unknown} convertBytesToJSValue
			 * @param {Response|Request} instance
			 */
			async function specConsumeBody(object, convertBytesToJSValue, instance) {
				webidl.brandCheck(object, instance)

				throwIfAborted(object[kState])

				// 1. If object is unusable, then return a promise rejected
				//    with a TypeError.
				if (bodyUnusable(object[kState].body)) {
					throw new TypeError('Body is unusable')
				}

				// 2. Let promise be a new promise.
				const promise = createDeferredPromise()

				// 3. Let errorSteps given error be to reject promise with error.
				const errorSteps = (error) => promise.reject(error)

				// 4. Let successSteps given a byte sequence data be to resolve
				//    promise with the result of running convertBytesToJSValue
				//    with data. If that threw an exception, then run errorSteps
				//    with that exception.
				const successSteps = (data) => {
					try {
						promise.resolve(convertBytesToJSValue(data))
					} catch (e) {
						errorSteps(e)
					}
				}

				// 5. If objects body is null, then run successSteps with an
				//    empty byte sequence.
				if (object[kState].body == null) {
					successSteps(new Uint8Array())
					return promise.promise
				}

				// 6. Otherwise, fully read objects body given successSteps,
				//    errorSteps, and objects relevant global object.
				await fullyReadBody(object[kState].body, successSteps, errorSteps)

				// 7. Return promise.
				return promise.promise
			}

			// https://fetch.spec.whatwg.org/#body-unusable
			function bodyUnusable(body) {
				// An object including the Body interface mixin is
				// said to be unusable if its body is non-null and
				// its bodys stream is disturbed or locked.
				return (
					body != null && (body.stream.locked || util.isDisturbed(body.stream))
				)
			}

			/**
			 * @see https://encoding.spec.whatwg.org/#utf-8-decode
			 * @param {Buffer} buffer
			 */
			function utf8DecodeBytes(buffer) {
				if (buffer.length === 0) {
					return ''
				}

				// 1. Let buffer be the result of peeking three bytes from
				//    ioQueue, converted to a byte sequence.

				// 2. If buffer is 0xEF 0xBB 0xBF, then read three
				//    bytes from ioQueue. (Do nothing with those bytes.)
				if (buffer[0] === 0xef && buffer[1] === 0xbb && buffer[2] === 0xbf) {
					buffer = buffer.subarray(3)
				}

				// 3. Process a queue with an instance of UTF-8s
				//    decoder, ioQueue, output, and "replacement".
				const output = textDecoder.decode(buffer)

				// 4. Return output.
				return output
			}

			/**
			 * @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value
			 * @param {Uint8Array} bytes
			 */
			function parseJSONFromBytes(bytes) {
				return JSON.parse(utf8DecodeBytes(bytes))
			}

			/**
			 * @see https://fetch.spec.whatwg.org/#concept-body-mime-type
			 * @param {import('./response').Response|import('./request').Request} object
			 */
			function bodyMimeType(object) {
				const { headersList } = object[kState]
				const contentType = headersList.get('content-type')

				if (contentType === null) {
					return 'failure'
				}

				return parseMIMEType(contentType)
			}

			module.exports = {
				extractBody,
				safelyExtractBody,
				cloneBody,
				mixinBody,
			}

			/***/
		},

		/***/ 87326: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { MessageChannel, receiveMessageOnPort } =
				__nccwpck_require__(28167)

			const corsSafeListedMethods = ['GET', 'HEAD', 'POST']
			const corsSafeListedMethodsSet = new Set(corsSafeListedMethods)

			const nullBodyStatus = [101, 204, 205, 304]

			const redirectStatus = [301, 302, 303, 307, 308]
			const redirectStatusSet = new Set(redirectStatus)

			// https://fetch.spec.whatwg.org/#block-bad-port
			const badPorts = [
				'1',
				'7',
				'9',
				'11',
				'13',
				'15',
				'17',
				'19',
				'20',
				'21',
				'22',
				'23',
				'25',
				'37',
				'42',
				'43',
				'53',
				'69',
				'77',
				'79',
				'87',
				'95',
				'101',
				'102',
				'103',
				'104',
				'109',
				'110',
				'111',
				'113',
				'115',
				'117',
				'119',
				'123',
				'135',
				'137',
				'139',
				'143',
				'161',
				'179',
				'389',
				'427',
				'465',
				'512',
				'513',
				'514',
				'515',
				'526',
				'530',
				'531',
				'532',
				'540',
				'548',
				'554',
				'556',
				'563',
				'587',
				'601',
				'636',
				'989',
				'990',
				'993',
				'995',
				'1719',
				'1720',
				'1723',
				'2049',
				'3659',
				'4045',
				'5060',
				'5061',
				'6000',
				'6566',
				'6665',
				'6666',
				'6667',
				'6668',
				'6669',
				'6697',
				'10080',
			]

			const badPortsSet = new Set(badPorts)

			// https://w3c.github.io/webappsec-referrer-policy/#referrer-policies
			const referrerPolicy = [
				'',
				'no-referrer',
				'no-referrer-when-downgrade',
				'same-origin',
				'origin',
				'strict-origin',
				'origin-when-cross-origin',
				'strict-origin-when-cross-origin',
				'unsafe-url',
			]
			const referrerPolicySet = new Set(referrerPolicy)

			const requestRedirect = ['follow', 'manual', 'error']

			const safeMethods = ['GET', 'HEAD', 'OPTIONS', 'TRACE']
			const safeMethodsSet = new Set(safeMethods)

			const requestMode = ['navigate', 'same-origin', 'no-cors', 'cors']

			const requestCredentials = ['omit', 'same-origin', 'include']

			const requestCache = [
				'default',
				'no-store',
				'reload',
				'no-cache',
				'force-cache',
				'only-if-cached',
			]

			// https://fetch.spec.whatwg.org/#request-body-header-name
			const requestBodyHeader = [
				'content-encoding',
				'content-language',
				'content-location',
				'content-type',
				// See https://github.com/nodejs/undici/issues/2021
				// 'Content-Length' is a forbidden header name, which is typically
				// removed in the Headers implementation. However, undici doesn't
				// filter out headers, so we add it here.
				'content-length',
			]

			// https://fetch.spec.whatwg.org/#enumdef-requestduplex
			const requestDuplex = ['half']

			// http://fetch.spec.whatwg.org/#forbidden-method
			const forbiddenMethods = ['CONNECT', 'TRACE', 'TRACK']
			const forbiddenMethodsSet = new Set(forbiddenMethods)

			const subresource = [
				'audio',
				'audioworklet',
				'font',
				'image',
				'manifest',
				'paintworklet',
				'script',
				'style',
				'track',
				'video',
				'xslt',
				'',
			]
			const subresourceSet = new Set(subresource)

			/** @type {globalThis['DOMException']} */
			const DOMException =
				globalThis.DOMException ??
				(() => {
					// DOMException was only made a global in Node v17.0.0,
					// but fetch supports >= v16.8.
					try {
						atob('~')
					} catch (err) {
						return Object.getPrototypeOf(err).constructor
					}
				})()

			let channel

			/** @type {globalThis['structuredClone']} */
			const structuredClone =
				globalThis.structuredClone ??
				// https://github.com/nodejs/node/blob/b27ae24dcc4251bad726d9d84baf678d1f707fed/lib/internal/structured_clone.js
				// structuredClone was added in v17.0.0, but fetch supports v16.8
				function structuredClone(value, options = undefined) {
					if (arguments.length === 0) {
						throw new TypeError('missing argument')
					}

					if (!channel) {
						channel = new MessageChannel()
					}
					channel.port1.unref()
					channel.port2.unref()
					channel.port1.postMessage(value, options?.transfer)
					return receiveMessageOnPort(channel.port2).message
				}

			module.exports = {
				DOMException,
				structuredClone,
				subresource,
				forbiddenMethods,
				requestBodyHeader,
				referrerPolicy,
				requestRedirect,
				requestMode,
				requestCredentials,
				requestCache,
				redirectStatus,
				corsSafeListedMethods,
				nullBodyStatus,
				safeMethods,
				badPorts,
				requestDuplex,
				subresourceSet,
				badPortsSet,
				redirectStatusSet,
				corsSafeListedMethodsSet,
				safeMethodsSet,
				forbiddenMethodsSet,
				referrerPolicySet,
			}

			/***/
		},

		/***/ 94322: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			const assert = __nccwpck_require__(42613)
			const { atob } = __nccwpck_require__(20181)
			const { isomorphicDecode } = __nccwpck_require__(15523)

			const encoder = new TextEncoder()

			/**
			 * @see https://mimesniff.spec.whatwg.org/#http-token-code-point
			 */
			const HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/
			const HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/ // eslint-disable-line
			/**
			 * @see https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point
			 */
			const HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/ // eslint-disable-line

			// https://fetch.spec.whatwg.org/#data-url-processor
			/** @param {URL} dataURL */
			function dataURLProcessor(dataURL) {
				// 1. Assert: dataURLs scheme is "data".
				assert(dataURL.protocol === 'data:')

				// 2. Let input be the result of running the URL
				// serializer on dataURL with exclude fragment
				// set to true.
				let input = URLSerializer(dataURL, true)

				// 3. Remove the leading "data:" string from input.
				input = input.slice(5)

				// 4. Let position point at the start of input.
				const position = { position: 0 }

				// 5. Let mimeType be the result of collecting a
				// sequence of code points that are not equal
				// to U+002C (,), given position.
				let mimeType = collectASequenceOfCodePointsFast(',', input, position)

				// 6. Strip leading and trailing ASCII whitespace
				// from mimeType.
				// Undici implementation note: we need to store the
				// length because if the mimetype has spaces removed,
				// the wrong amount will be sliced from the input in
				// step #9
				const mimeTypeLength = mimeType.length
				mimeType = removeASCIIWhitespace(mimeType, true, true)

				// 7. If position is past the end of input, then
				// return failure
				if (position.position >= input.length) {
					return 'failure'
				}

				// 8. Advance position by 1.
				position.position++

				// 9. Let encodedBody be the remainder of input.
				const encodedBody = input.slice(mimeTypeLength + 1)

				// 10. Let body be the percent-decoding of encodedBody.
				let body = stringPercentDecode(encodedBody)

				// 11. If mimeType ends with U+003B (;), followed by
				// zero or more U+0020 SPACE, followed by an ASCII
				// case-insensitive match for "base64", then:
				if (/;(\u0020){0,}base64$/i.test(mimeType)) {
					// 1. Let stringBody be the isomorphic decode of body.
					const stringBody = isomorphicDecode(body)

					// 2. Set body to the forgiving-base64 decode of
					// stringBody.
					body = forgivingBase64(stringBody)

					// 3. If body is failure, then return failure.
					if (body === 'failure') {
						return 'failure'
					}

					// 4. Remove the last 6 code points from mimeType.
					mimeType = mimeType.slice(0, -6)

					// 5. Remove trailing U+0020 SPACE code points from mimeType,
					// if any.
					mimeType = mimeType.replace(/(\u0020)+$/, '')

					// 6. Remove the last U+003B (;) code point from mimeType.
					mimeType = mimeType.slice(0, -1)
				}

				// 12. If mimeType starts with U+003B (;), then prepend
				// "text/plain" to mimeType.
				if (mimeType.startsWith(';')) {
					mimeType = 'text/plain' + mimeType
				}

				// 13. Let mimeTypeRecord be the result of parsing
				// mimeType.
				let mimeTypeRecord = parseMIMEType(mimeType)

				// 14. If mimeTypeRecord is failure, then set
				// mimeTypeRecord to text/plain;charset=US-ASCII.
				if (mimeTypeRecord === 'failure') {
					mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII')
				}

				// 15. Return a new data: URL struct whose MIME
				// type is mimeTypeRecord and body is body.
				// https://fetch.spec.whatwg.org/#data-url-struct
				return { mimeType: mimeTypeRecord, body }
			}

			// https://url.spec.whatwg.org/#concept-url-serializer
			/**
			 * @param {URL} url
			 * @param {boolean} excludeFragment
			 */
			function URLSerializer(url, excludeFragment = false) {
				if (!excludeFragment) {
					return url.href
				}

				const href = url.href
				const hashLength = url.hash.length

				return hashLength === 0
					? href
					: href.substring(0, href.length - hashLength)
			}

			// https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points
			/**
			 * @param {(char: string) => boolean} condition
			 * @param {string} input
			 * @param {{ position: number }} position
			 */
			function collectASequenceOfCodePoints(condition, input, position) {
				// 1. Let result be the empty string.
				let result = ''

				// 2. While position doesnt point past the end of input and the
				// code point at position within input meets the condition condition:
				while (
					position.position < input.length &&
					condition(input[position.position])
				) {
					// 1. Append that code point to the end of result.
					result += input[position.position]

					// 2. Advance position by 1.
					position.position++
				}

				// 3. Return result.
				return result
			}

			/**
			 * A faster collectASequenceOfCodePoints that only works when comparing a single character.
			 * @param {string} char
			 * @param {string} input
			 * @param {{ position: number }} position
			 */
			function collectASequenceOfCodePointsFast(char, input, position) {
				const idx = input.indexOf(char, position.position)
				const start = position.position

				if (idx === -1) {
					position.position = input.length
					return input.slice(start)
				}

				position.position = idx
				return input.slice(start, position.position)
			}

			// https://url.spec.whatwg.org/#string-percent-decode
			/** @param {string} input */
			function stringPercentDecode(input) {
				// 1. Let bytes be the UTF-8 encoding of input.
				const bytes = encoder.encode(input)

				// 2. Return the percent-decoding of bytes.
				return percentDecode(bytes)
			}

			// https://url.spec.whatwg.org/#percent-decode
			/** @param {Uint8Array} input */
			function percentDecode(input) {
				// 1. Let output be an empty byte sequence.
				/** @type {number[]} */
				const output = []

				// 2. For each byte byte in input:
				for (let i = 0; i < input.length; i++) {
					const byte = input[i]

					// 1. If byte is not 0x25 (%), then append byte to output.
					if (byte !== 0x25) {
						output.push(byte)

						// 2. Otherwise, if byte is 0x25 (%) and the next two bytes
						// after byte in input are not in the ranges
						// 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),
						// and 0x61 (a) to 0x66 (f), all inclusive, append byte
						// to output.
					} else if (
						byte === 0x25 &&
						!/^[0-9A-Fa-f]{2}$/i.test(
							String.fromCharCode(input[i + 1], input[i + 2]),
						)
					) {
						output.push(0x25)

						// 3. Otherwise:
					} else {
						// 1. Let bytePoint be the two bytes after byte in input,
						// decoded, and then interpreted as hexadecimal number.
						const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2])
						const bytePoint = Number.parseInt(nextTwoBytes, 16)

						// 2. Append a byte whose value is bytePoint to output.
						output.push(bytePoint)

						// 3. Skip the next two bytes in input.
						i += 2
					}
				}

				// 3. Return output.
				return Uint8Array.from(output)
			}

			// https://mimesniff.spec.whatwg.org/#parse-a-mime-type
			/** @param {string} input */
			function parseMIMEType(input) {
				// 1. Remove any leading and trailing HTTP whitespace
				// from input.
				input = removeHTTPWhitespace(input, true, true)

				// 2. Let position be a position variable for input,
				// initially pointing at the start of input.
				const position = { position: 0 }

				// 3. Let type be the result of collecting a sequence
				// of code points that are not U+002F (/) from
				// input, given position.
				const type = collectASequenceOfCodePointsFast('/', input, position)

				// 4. If type is the empty string or does not solely
				// contain HTTP token code points, then return failure.
				// https://mimesniff.spec.whatwg.org/#http-token-code-point
				if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
					return 'failure'
				}

				// 5. If position is past the end of input, then return
				// failure
				if (position.position > input.length) {
					return 'failure'
				}

				// 6. Advance position by 1. (This skips past U+002F (/).)
				position.position++

				// 7. Let subtype be the result of collecting a sequence of
				// code points that are not U+003B (;) from input, given
				// position.
				let subtype = collectASequenceOfCodePointsFast(';', input, position)

				// 8. Remove any trailing HTTP whitespace from subtype.
				subtype = removeHTTPWhitespace(subtype, false, true)

				// 9. If subtype is the empty string or does not solely
				// contain HTTP token code points, then return failure.
				if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
					return 'failure'
				}

				const typeLowercase = type.toLowerCase()
				const subtypeLowercase = subtype.toLowerCase()

				// 10. Let mimeType be a new MIME type record whose type
				// is type, in ASCII lowercase, and subtype is subtype,
				// in ASCII lowercase.
				// https://mimesniff.spec.whatwg.org/#mime-type
				const mimeType = {
					type: typeLowercase,
					subtype: subtypeLowercase,
					/** @type {Map<string, string>} */
					parameters: new Map(),
					// https://mimesniff.spec.whatwg.org/#mime-type-essence
					essence: `${typeLowercase}/${subtypeLowercase}`,
				}

				// 11. While position is not past the end of input:
				while (position.position < input.length) {
					// 1. Advance position by 1. (This skips past U+003B (;).)
					position.position++

					// 2. Collect a sequence of code points that are HTTP
					// whitespace from input given position.
					collectASequenceOfCodePoints(
						// https://fetch.spec.whatwg.org/#http-whitespace
						(char) => HTTP_WHITESPACE_REGEX.test(char),
						input,
						position,
					)

					// 3. Let parameterName be the result of collecting a
					// sequence of code points that are not U+003B (;)
					// or U+003D (=) from input, given position.
					let parameterName = collectASequenceOfCodePoints(
						(char) => char !== ';' && char !== '=',
						input,
						position,
					)

					// 4. Set parameterName to parameterName, in ASCII
					// lowercase.
					parameterName = parameterName.toLowerCase()

					// 5. If position is not past the end of input, then:
					if (position.position < input.length) {
						// 1. If the code point at position within input is
						// U+003B (;), then continue.
						if (input[position.position] === ';') {
							continue
						}

						// 2. Advance position by 1. (This skips past U+003D (=).)
						position.position++
					}

					// 6. If position is past the end of input, then break.
					if (position.position > input.length) {
						break
					}

					// 7. Let parameterValue be null.
					let parameterValue = null

					// 8. If the code point at position within input is
					// U+0022 ("), then:
					if (input[position.position] === '"') {
						// 1. Set parameterValue to the result of collecting
						// an HTTP quoted string from input, given position
						// and the extract-value flag.
						parameterValue = collectAnHTTPQuotedString(input, position, true)

						// 2. Collect a sequence of code points that are not
						// U+003B (;) from input, given position.
						collectASequenceOfCodePointsFast(';', input, position)

						// 9. Otherwise:
					} else {
						// 1. Set parameterValue to the result of collecting
						// a sequence of code points that are not U+003B (;)
						// from input, given position.
						parameterValue = collectASequenceOfCodePointsFast(
							';',
							input,
							position,
						)

						// 2. Remove any trailing HTTP whitespace from parameterValue.
						parameterValue = removeHTTPWhitespace(parameterValue, false, true)

						// 3. If parameterValue is the empty string, then continue.
						if (parameterValue.length === 0) {
							continue
						}
					}

					// 10. If all of the following are true
					// - parameterName is not the empty string
					// - parameterName solely contains HTTP token code points
					// - parameterValue solely contains HTTP quoted-string token code points
					// - mimeTypes parameters[parameterName] does not exist
					// then set mimeTypes parameters[parameterName] to parameterValue.
					if (
						parameterName.length !== 0 &&
						HTTP_TOKEN_CODEPOINTS.test(parameterName) &&
						(parameterValue.length === 0 ||
							HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) &&
						!mimeType.parameters.has(parameterName)
					) {
						mimeType.parameters.set(parameterName, parameterValue)
					}
				}

				// 12. Return mimeType.
				return mimeType
			}

			// https://infra.spec.whatwg.org/#forgiving-base64-decode
			/** @param {string} data */
			function forgivingBase64(data) {
				// 1. Remove all ASCII whitespace from data.
				data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, '') // eslint-disable-line

				// 2. If datas code point length divides by 4 leaving
				// no remainder, then:
				if (data.length % 4 === 0) {
					// 1. If data ends with one or two U+003D (=) code points,
					// then remove them from data.
					data = data.replace(/=?=$/, '')
				}

				// 3. If datas code point length divides by 4 leaving
				// a remainder of 1, then return failure.
				if (data.length % 4 === 1) {
					return 'failure'
				}

				// 4. If data contains a code point that is not one of
				//  U+002B (+)
				//  U+002F (/)
				//  ASCII alphanumeric
				// then return failure.
				if (/[^+/0-9A-Za-z]/.test(data)) {
					return 'failure'
				}

				const binary = atob(data)
				const bytes = new Uint8Array(binary.length)

				for (let byte = 0; byte < binary.length; byte++) {
					bytes[byte] = binary.charCodeAt(byte)
				}

				return bytes
			}

			// https://fetch.spec.whatwg.org/#collect-an-http-quoted-string
			// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string
			/**
			 * @param {string} input
			 * @param {{ position: number }} position
			 * @param {boolean?} extractValue
			 */
			function collectAnHTTPQuotedString(input, position, extractValue) {
				// 1. Let positionStart be position.
				const positionStart = position.position

				// 2. Let value be the empty string.
				let value = ''

				// 3. Assert: the code point at position within input
				// is U+0022 (").
				assert(input[position.position] === '"')

				// 4. Advance position by 1.
				position.position++

				// 5. While true:
				while (true) {
					// 1. Append the result of collecting a sequence of code points
					// that are not U+0022 (") or U+005C (\) from input, given
					// position, to value.
					value += collectASequenceOfCodePoints(
						(char) => char !== '"' && char !== '\\',
						input,
						position,
					)

					// 2. If position is past the end of input, then break.
					if (position.position >= input.length) {
						break
					}

					// 3. Let quoteOrBackslash be the code point at position within
					// input.
					const quoteOrBackslash = input[position.position]

					// 4. Advance position by 1.
					position.position++

					// 5. If quoteOrBackslash is U+005C (\), then:
					if (quoteOrBackslash === '\\') {
						// 1. If position is past the end of input, then append
						// U+005C (\) to value and break.
						if (position.position >= input.length) {
							value += '\\'
							break
						}

						// 2. Append the code point at position within input to value.
						value += input[position.position]

						// 3. Advance position by 1.
						position.position++

						// 6. Otherwise:
					} else {
						// 1. Assert: quoteOrBackslash is U+0022 (").
						assert(quoteOrBackslash === '"')

						// 2. Break.
						break
					}
				}

				// 6. If the extract-value flag is set, then return value.
				if (extractValue) {
					return value
				}

				// 7. Return the code points from positionStart to position,
				// inclusive, within input.
				return input.slice(positionStart, position.position)
			}

			/**
			 * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type
			 */
			function serializeAMimeType(mimeType) {
				assert(mimeType !== 'failure')
				const { parameters, essence } = mimeType

				// 1. Let serialization be the concatenation of mimeTypes
				//    type, U+002F (/), and mimeTypes subtype.
				let serialization = essence

				// 2. For each name  value of mimeTypes parameters:
				for (let [name, value] of parameters.entries()) {
					// 1. Append U+003B (;) to serialization.
					serialization += ';'

					// 2. Append name to serialization.
					serialization += name

					// 3. Append U+003D (=) to serialization.
					serialization += '='

					// 4. If value does not solely contain HTTP token code
					//    points or value is the empty string, then:
					if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
						// 1. Precede each occurence of U+0022 (") or
						//    U+005C (\) in value with U+005C (\).
						value = value.replace(/(\\|")/g, '\\$1')

						// 2. Prepend U+0022 (") to value.
						value = '"' + value

						// 3. Append U+0022 (") to value.
						value += '"'
					}

					// 5. Append value to serialization.
					serialization += value
				}

				// 3. Return serialization.
				return serialization
			}

			/**
			 * @see https://fetch.spec.whatwg.org/#http-whitespace
			 * @param {string} char
			 */
			function isHTTPWhiteSpace(char) {
				return char === '\r' || char === '\n' || char === '\t' || char === ' '
			}

			/**
			 * @see https://fetch.spec.whatwg.org/#http-whitespace
			 * @param {string} str
			 */
			function removeHTTPWhitespace(str, leading = true, trailing = true) {
				let lead = 0
				let trail = str.length - 1

				if (leading) {
					for (; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++);
				}

				if (trailing) {
					for (; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--);
				}

				return str.slice(lead, trail + 1)
			}

			/**
			 * @see https://infra.spec.whatwg.org/#ascii-whitespace
			 * @param {string} char
			 */
			function isASCIIWhitespace(char) {
				return (
					char === '\r' ||
					char === '\n' ||
					char === '\t' ||
					char === '\f' ||
					char === ' '
				)
			}

			/**
			 * @see https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace
			 */
			function removeASCIIWhitespace(str, leading = true, trailing = true) {
				let lead = 0
				let trail = str.length - 1

				if (leading) {
					for (; lead < str.length && isASCIIWhitespace(str[lead]); lead++);
				}

				if (trailing) {
					for (; trail > 0 && isASCIIWhitespace(str[trail]); trail--);
				}

				return str.slice(lead, trail + 1)
			}

			module.exports = {
				dataURLProcessor,
				URLSerializer,
				collectASequenceOfCodePoints,
				collectASequenceOfCodePointsFast,
				stringPercentDecode,
				parseMIMEType,
				collectAnHTTPQuotedString,
				serializeAMimeType,
			}

			/***/
		},

		/***/ 63041: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { Blob, File: NativeFile } = __nccwpck_require__(20181)
			const { types } = __nccwpck_require__(39023)
			const { kState } = __nccwpck_require__(89710)
			const { isBlobLike } = __nccwpck_require__(15523)
			const { webidl } = __nccwpck_require__(74222)
			const { parseMIMEType, serializeAMimeType } = __nccwpck_require__(94322)
			const { kEnumerableProperty } = __nccwpck_require__(3440)
			const encoder = new TextEncoder()

			class File extends Blob {
				constructor(fileBits, fileName, options = {}) {
					// The File constructor is invoked with two or three parameters, depending
					// on whether the optional dictionary parameter is used. When the File()
					// constructor is invoked, user agents must run the following steps:
					webidl.argumentLengthCheck(arguments, 2, {
						header: 'File constructor',
					})

					fileBits = webidl.converters['sequence<BlobPart>'](fileBits)
					fileName = webidl.converters.USVString(fileName)
					options = webidl.converters.FilePropertyBag(options)

					// 1. Let bytes be the result of processing blob parts given fileBits and
					// options.
					// Note: Blob handles this for us

					// 2. Let n be the fileName argument to the constructor.
					const n = fileName

					// 3. Process FilePropertyBag dictionary argument by running the following
					// substeps:

					//    1. If the type member is provided and is not the empty string, let t
					//    be set to the type dictionary member. If t contains any characters
					//    outside the range U+0020 to U+007E, then set t to the empty string
					//    and return from these substeps.
					//    2. Convert every character in t to ASCII lowercase.
					let t = options.type
					let d

					// eslint-disable-next-line no-labels
					substep: {
						if (t) {
							t = parseMIMEType(t)

							if (t === 'failure') {
								t = ''
								// eslint-disable-next-line no-labels
								break substep
							}

							t = serializeAMimeType(t).toLowerCase()
						}

						//    3. If the lastModified member is provided, let d be set to the
						//    lastModified dictionary member. If it is not provided, set d to the
						//    current date and time represented as the number of milliseconds since
						//    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).
						d = options.lastModified
					}

					// 4. Return a new File object F such that:
					// F refers to the bytes byte sequence.
					// F.size is set to the number of total bytes in bytes.
					// F.name is set to n.
					// F.type is set to t.
					// F.lastModified is set to d.

					super(processBlobParts(fileBits, options), { type: t })
					this[kState] = {
						name: n,
						lastModified: d,
						type: t,
					}
				}

				get name() {
					webidl.brandCheck(this, File)

					return this[kState].name
				}

				get lastModified() {
					webidl.brandCheck(this, File)

					return this[kState].lastModified
				}

				get type() {
					webidl.brandCheck(this, File)

					return this[kState].type
				}
			}

			class FileLike {
				constructor(blobLike, fileName, options = {}) {
					// TODO: argument idl type check

					// The File constructor is invoked with two or three parameters, depending
					// on whether the optional dictionary parameter is used. When the File()
					// constructor is invoked, user agents must run the following steps:

					// 1. Let bytes be the result of processing blob parts given fileBits and
					// options.

					// 2. Let n be the fileName argument to the constructor.
					const n = fileName

					// 3. Process FilePropertyBag dictionary argument by running the following
					// substeps:

					//    1. If the type member is provided and is not the empty string, let t
					//    be set to the type dictionary member. If t contains any characters
					//    outside the range U+0020 to U+007E, then set t to the empty string
					//    and return from these substeps.
					//    TODO
					const t = options.type

					//    2. Convert every character in t to ASCII lowercase.
					//    TODO

					//    3. If the lastModified member is provided, let d be set to the
					//    lastModified dictionary member. If it is not provided, set d to the
					//    current date and time represented as the number of milliseconds since
					//    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).
					const d = options.lastModified ?? Date.now()

					// 4. Return a new File object F such that:
					// F refers to the bytes byte sequence.
					// F.size is set to the number of total bytes in bytes.
					// F.name is set to n.
					// F.type is set to t.
					// F.lastModified is set to d.

					this[kState] = {
						blobLike,
						name: n,
						type: t,
						lastModified: d,
					}
				}

				stream(...args) {
					webidl.brandCheck(this, FileLike)

					return this[kState].blobLike.stream(...args)
				}

				arrayBuffer(...args) {
					webidl.brandCheck(this, FileLike)

					return this[kState].blobLike.arrayBuffer(...args)
				}

				slice(...args) {
					webidl.brandCheck(this, FileLike)

					return this[kState].blobLike.slice(...args)
				}

				text(...args) {
					webidl.brandCheck(this, FileLike)

					return this[kState].blobLike.text(...args)
				}

				get size() {
					webidl.brandCheck(this, FileLike)

					return this[kState].blobLike.size
				}

				get type() {
					webidl.brandCheck(this, FileLike)

					return this[kState].blobLike.type
				}

				get name() {
					webidl.brandCheck(this, FileLike)

					return this[kState].name
				}

				get lastModified() {
					webidl.brandCheck(this, FileLike)

					return this[kState].lastModified
				}

				get [Symbol.toStringTag]() {
					return 'File'
				}
			}

			Object.defineProperties(File.prototype, {
				[Symbol.toStringTag]: {
					value: 'File',
					configurable: true,
				},
				name: kEnumerableProperty,
				lastModified: kEnumerableProperty,
			})

			webidl.converters.Blob = webidl.interfaceConverter(Blob)

			webidl.converters.BlobPart = function (V, opts) {
				if (webidl.util.Type(V) === 'Object') {
					if (isBlobLike(V)) {
						return webidl.converters.Blob(V, { strict: false })
					}

					if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
						return webidl.converters.BufferSource(V, opts)
					}
				}

				return webidl.converters.USVString(V, opts)
			}

			webidl.converters['sequence<BlobPart>'] = webidl.sequenceConverter(
				webidl.converters.BlobPart,
			)

			// https://www.w3.org/TR/FileAPI/#dfn-FilePropertyBag
			webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
				{
					key: 'lastModified',
					converter: webidl.converters['long long'],
					get defaultValue() {
						return Date.now()
					},
				},
				{
					key: 'type',
					converter: webidl.converters.DOMString,
					defaultValue: '',
				},
				{
					key: 'endings',
					converter: (value) => {
						value = webidl.converters.DOMString(value)
						value = value.toLowerCase()

						if (value !== 'native') {
							value = 'transparent'
						}

						return value
					},
					defaultValue: 'transparent',
				},
			])

			/**
			 * @see https://www.w3.org/TR/FileAPI/#process-blob-parts
			 * @param {(NodeJS.TypedArray|Blob|string)[]} parts
			 * @param {{ type: string, endings: string }} options
			 */
			function processBlobParts(parts, options) {
				// 1. Let bytes be an empty sequence of bytes.
				/** @type {NodeJS.TypedArray[]} */
				const bytes = []

				// 2. For each element in parts:
				for (const element of parts) {
					// 1. If element is a USVString, run the following substeps:
					if (typeof element === 'string') {
						// 1. Let s be element.
						let s = element

						// 2. If the endings member of options is "native", set s
						//    to the result of converting line endings to native
						//    of element.
						if (options.endings === 'native') {
							s = convertLineEndingsNative(s)
						}

						// 3. Append the result of UTF-8 encoding s to bytes.
						bytes.push(encoder.encode(s))
					} else if (
						types.isAnyArrayBuffer(element) ||
						types.isTypedArray(element)
					) {
						// 2. If element is a BufferSource, get a copy of the
						//    bytes held by the buffer source, and append those
						//    bytes to bytes.
						if (!element.buffer) {
							// ArrayBuffer
							bytes.push(new Uint8Array(element))
						} else {
							bytes.push(
								new Uint8Array(
									element.buffer,
									element.byteOffset,
									element.byteLength,
								),
							)
						}
					} else if (isBlobLike(element)) {
						// 3. If element is a Blob, append the bytes it represents
						//    to bytes.
						bytes.push(element)
					}
				}

				// 3. Return bytes.
				return bytes
			}

			/**
			 * @see https://www.w3.org/TR/FileAPI/#convert-line-endings-to-native
			 * @param {string} s
			 */
			function convertLineEndingsNative(s) {
				// 1. Let native line ending be be the code point U+000A LF.
				let nativeLineEnding = '\n'

				// 2. If the underlying platforms conventions are to
				//    represent newlines as a carriage return and line feed
				//    sequence, set native line ending to the code point
				//    U+000D CR followed by the code point U+000A LF.
				if (process.platform === 'win32') {
					nativeLineEnding = '\r\n'
				}

				return s.replace(/\r?\n/g, nativeLineEnding)
			}

			// If this function is moved to ./util.js, some tools (such as
			// rollup) will warn about circular dependencies. See:
			// https://github.com/nodejs/undici/issues/1629
			function isFileLike(object) {
				return (
					(NativeFile && object instanceof NativeFile) ||
					object instanceof File ||
					(object &&
						(typeof object.stream === 'function' ||
							typeof object.arrayBuffer === 'function') &&
						object[Symbol.toStringTag] === 'File')
				)
			}

			module.exports = { File, FileLike, isFileLike }

			/***/
		},

		/***/ 43073: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { isBlobLike, toUSVString, makeIterator } =
				__nccwpck_require__(15523)
			const { kState } = __nccwpck_require__(89710)
			const {
				File: UndiciFile,
				FileLike,
				isFileLike,
			} = __nccwpck_require__(63041)
			const { webidl } = __nccwpck_require__(74222)
			const { Blob, File: NativeFile } = __nccwpck_require__(20181)

			/** @type {globalThis['File']} */
			const File = NativeFile ?? UndiciFile

			// https://xhr.spec.whatwg.org/#formdata
			class FormData {
				constructor(form) {
					if (form !== undefined) {
						throw webidl.errors.conversionFailed({
							prefix: 'FormData constructor',
							argument: 'Argument 1',
							types: ['undefined'],
						})
					}

					this[kState] = []
				}

				append(name, value, filename = undefined) {
					webidl.brandCheck(this, FormData)

					webidl.argumentLengthCheck(arguments, 2, {
						header: 'FormData.append',
					})

					if (arguments.length === 3 && !isBlobLike(value)) {
						throw new TypeError(
							"Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'",
						)
					}

					// 1. Let value be value if given; otherwise blobValue.

					name = webidl.converters.USVString(name)
					value = isBlobLike(value)
						? webidl.converters.Blob(value, { strict: false })
						: webidl.converters.USVString(value)
					filename =
						arguments.length === 3
							? webidl.converters.USVString(filename)
							: undefined

					// 2. Let entry be the result of creating an entry with
					// name, value, and filename if given.
					const entry = makeEntry(name, value, filename)

					// 3. Append entry to thiss entry list.
					this[kState].push(entry)
				}

				delete(name) {
					webidl.brandCheck(this, FormData)

					webidl.argumentLengthCheck(arguments, 1, {
						header: 'FormData.delete',
					})

					name = webidl.converters.USVString(name)

					// The delete(name) method steps are to remove all entries whose name
					// is name from thiss entry list.
					this[kState] = this[kState].filter((entry) => entry.name !== name)
				}

				get(name) {
					webidl.brandCheck(this, FormData)

					webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.get' })

					name = webidl.converters.USVString(name)

					// 1. If there is no entry whose name is name in thiss entry list,
					// then return null.
					const idx = this[kState].findIndex((entry) => entry.name === name)
					if (idx === -1) {
						return null
					}

					// 2. Return the value of the first entry whose name is name from
					// thiss entry list.
					return this[kState][idx].value
				}

				getAll(name) {
					webidl.brandCheck(this, FormData)

					webidl.argumentLengthCheck(arguments, 1, {
						header: 'FormData.getAll',
					})

					name = webidl.converters.USVString(name)

					// 1. If there is no entry whose name is name in thiss entry list,
					// then return the empty list.
					// 2. Return the values of all entries whose name is name, in order,
					// from thiss entry list.
					return this[kState]
						.filter((entry) => entry.name === name)
						.map((entry) => entry.value)
				}

				has(name) {
					webidl.brandCheck(this, FormData)

					webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.has' })

					name = webidl.converters.USVString(name)

					// The has(name) method steps are to return true if there is an entry
					// whose name is name in thiss entry list; otherwise false.
					return this[kState].findIndex((entry) => entry.name === name) !== -1
				}

				set(name, value, filename = undefined) {
					webidl.brandCheck(this, FormData)

					webidl.argumentLengthCheck(arguments, 2, { header: 'FormData.set' })

					if (arguments.length === 3 && !isBlobLike(value)) {
						throw new TypeError(
							"Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'",
						)
					}

					// The set(name, value) and set(name, blobValue, filename) method steps
					// are:

					// 1. Let value be value if given; otherwise blobValue.

					name = webidl.converters.USVString(name)
					value = isBlobLike(value)
						? webidl.converters.Blob(value, { strict: false })
						: webidl.converters.USVString(value)
					filename = arguments.length === 3 ? toUSVString(filename) : undefined

					// 2. Let entry be the result of creating an entry with name, value, and
					// filename if given.
					const entry = makeEntry(name, value, filename)

					// 3. If there are entries in thiss entry list whose name is name, then
					// replace the first such entry with entry and remove the others.
					const idx = this[kState].findIndex((entry) => entry.name === name)
					if (idx !== -1) {
						this[kState] = [
							...this[kState].slice(0, idx),
							entry,
							...this[kState]
								.slice(idx + 1)
								.filter((entry) => entry.name !== name),
						]
					} else {
						// 4. Otherwise, append entry to thiss entry list.
						this[kState].push(entry)
					}
				}

				entries() {
					webidl.brandCheck(this, FormData)

					return makeIterator(
						() => this[kState].map((pair) => [pair.name, pair.value]),
						'FormData',
						'key+value',
					)
				}

				keys() {
					webidl.brandCheck(this, FormData)

					return makeIterator(
						() => this[kState].map((pair) => [pair.name, pair.value]),
						'FormData',
						'key',
					)
				}

				values() {
					webidl.brandCheck(this, FormData)

					return makeIterator(
						() => this[kState].map((pair) => [pair.name, pair.value]),
						'FormData',
						'value',
					)
				}

				/**
				 * @param {(value: string, key: string, self: FormData) => void} callbackFn
				 * @param {unknown} thisArg
				 */
				forEach(callbackFn, thisArg = globalThis) {
					webidl.brandCheck(this, FormData)

					webidl.argumentLengthCheck(arguments, 1, {
						header: 'FormData.forEach',
					})

					if (typeof callbackFn !== 'function') {
						throw new TypeError(
							"Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'.",
						)
					}

					for (const [key, value] of this) {
						callbackFn.apply(thisArg, [value, key, this])
					}
				}
			}

			FormData.prototype[Symbol.iterator] = FormData.prototype.entries

			Object.defineProperties(FormData.prototype, {
				[Symbol.toStringTag]: {
					value: 'FormData',
					configurable: true,
				},
			})

			/**
			 * @see https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#create-an-entry
			 * @param {string} name
			 * @param {string|Blob} value
			 * @param {?string} filename
			 * @returns
			 */
			function makeEntry(name, value, filename) {
				// 1. Set name to the result of converting name into a scalar value string.
				// "To convert a string into a scalar value string, replace any surrogates
				//  with U+FFFD."
				// see: https://nodejs.org/dist/latest-v18.x/docs/api/buffer.html#buftostringencoding-start-end
				name = Buffer.from(name).toString('utf8')

				// 2. If value is a string, then set value to the result of converting
				//    value into a scalar value string.
				if (typeof value === 'string') {
					value = Buffer.from(value).toString('utf8')
				} else {
					// 3. Otherwise:

					// 1. If value is not a File object, then set value to a new File object,
					//    representing the same bytes, whose name attribute value is "blob"
					if (!isFileLike(value)) {
						value =
							value instanceof Blob
								? new File([value], 'blob', { type: value.type })
								: new FileLike(value, 'blob', { type: value.type })
					}

					// 2. If filename is given, then set value to a new File object,
					//    representing the same bytes, whose name attribute is filename.
					if (filename !== undefined) {
						/** @type {FilePropertyBag} */
						const options = {
							type: value.type,
							lastModified: value.lastModified,
						}

						value =
							(NativeFile && value instanceof NativeFile) ||
							value instanceof UndiciFile
								? new File([value], filename, options)
								: new FileLike(value, filename, options)
					}
				}

				// 4. Return an entry whose name is name and whose value is value.
				return { name, value }
			}

			module.exports = { FormData }

			/***/
		},

		/***/ 75628: /***/ (module) => {
			'use strict'

			// In case of breaking changes, increase the version
			// number to avoid conflicts.
			const globalOrigin = Symbol.for('undici.globalOrigin.1')

			function getGlobalOrigin() {
				return globalThis[globalOrigin]
			}

			function setGlobalOrigin(newOrigin) {
				if (newOrigin === undefined) {
					Object.defineProperty(globalThis, globalOrigin, {
						value: undefined,
						writable: true,
						enumerable: false,
						configurable: false,
					})

					return
				}

				const parsedURL = new URL(newOrigin)

				if (parsedURL.protocol !== 'http:' && parsedURL.protocol !== 'https:') {
					throw new TypeError(
						`Only http & https urls are allowed, received ${parsedURL.protocol}`,
					)
				}

				Object.defineProperty(globalThis, globalOrigin, {
					value: parsedURL,
					writable: true,
					enumerable: false,
					configurable: false,
				})
			}

			module.exports = {
				getGlobalOrigin,
				setGlobalOrigin,
			}

			/***/
		},

		/***/ 26349: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'
			// https://github.com/Ethan-Arrowood/undici-fetch

			const { kHeadersList, kConstruct } = __nccwpck_require__(36443)
			const { kGuard } = __nccwpck_require__(89710)
			const { kEnumerableProperty } = __nccwpck_require__(3440)
			const { makeIterator, isValidHeaderName, isValidHeaderValue } =
				__nccwpck_require__(15523)
			const util = __nccwpck_require__(39023)
			const { webidl } = __nccwpck_require__(74222)
			const assert = __nccwpck_require__(42613)

			const kHeadersMap = Symbol('headers map')
			const kHeadersSortedMap = Symbol('headers map sorted')

			/**
			 * @param {number} code
			 */
			function isHTTPWhiteSpaceCharCode(code) {
				return (
					code === 0x00a || code === 0x00d || code === 0x009 || code === 0x020
				)
			}

			/**
			 * @see https://fetch.spec.whatwg.org/#concept-header-value-normalize
			 * @param {string} potentialValue
			 */
			function headerValueNormalize(potentialValue) {
				//  To normalize a byte sequence potentialValue, remove
				//  any leading and trailing HTTP whitespace bytes from
				//  potentialValue.
				let i = 0
				let j = potentialValue.length

				while (
					j > i &&
					isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))
				)
					--j
				while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i)))
					++i

				return i === 0 && j === potentialValue.length
					? potentialValue
					: potentialValue.substring(i, j)
			}

			function fill(headers, object) {
				// To fill a Headers object headers with a given object object, run these steps:

				// 1. If object is a sequence, then for each header in object:
				// Note: webidl conversion to array has already been done.
				if (Array.isArray(object)) {
					for (let i = 0; i < object.length; ++i) {
						const header = object[i]
						// 1. If header does not contain exactly two items, then throw a TypeError.
						if (header.length !== 2) {
							throw webidl.errors.exception({
								header: 'Headers constructor',
								message: `expected name/value pair to be length 2, found ${header.length}.`,
							})
						}

						// 2. Append (headers first item, headers second item) to headers.
						appendHeader(headers, header[0], header[1])
					}
				} else if (typeof object === 'object' && object !== null) {
					// Note: null should throw

					// 2. Otherwise, object is a record, then for each key  value in object,
					//    append (key, value) to headers
					const keys = Object.keys(object)
					for (let i = 0; i < keys.length; ++i) {
						appendHeader(headers, keys[i], object[keys[i]])
					}
				} else {
					throw webidl.errors.conversionFailed({
						prefix: 'Headers constructor',
						argument: 'Argument 1',
						types: [
							'sequence<sequence<ByteString>>',
							'record<ByteString, ByteString>',
						],
					})
				}
			}

			/**
			 * @see https://fetch.spec.whatwg.org/#concept-headers-append
			 */
			function appendHeader(headers, name, value) {
				// 1. Normalize value.
				value = headerValueNormalize(value)

				// 2. If name is not a header name or value is not a
				//    header value, then throw a TypeError.
				if (!isValidHeaderName(name)) {
					throw webidl.errors.invalidArgument({
						prefix: 'Headers.append',
						value: name,
						type: 'header name',
					})
				} else if (!isValidHeaderValue(value)) {
					throw webidl.errors.invalidArgument({
						prefix: 'Headers.append',
						value,
						type: 'header value',
					})
				}

				// 3. If headerss guard is "immutable", then throw a TypeError.
				// 4. Otherwise, if headerss guard is "request" and name is a
				//    forbidden header name, return.
				// Note: undici does not implement forbidden header names
				if (headers[kGuard] === 'immutable') {
					throw new TypeError('immutable')
				} else if (headers[kGuard] === 'request-no-cors') {
					// 5. Otherwise, if headerss guard is "request-no-cors":
					// TODO
				}

				// 6. Otherwise, if headerss guard is "response" and name is a
				//    forbidden response-header name, return.

				// 7. Append (name, value) to headerss header list.
				return headers[kHeadersList].append(name, value)

				// 8. If headerss guard is "request-no-cors", then remove
				//    privileged no-CORS request headers from headers
			}

			class HeadersList {
				/** @type {[string, string][]|null} */
				cookies = null

				constructor(init) {
					if (init instanceof HeadersList) {
						this[kHeadersMap] = new Map(init[kHeadersMap])
						this[kHeadersSortedMap] = init[kHeadersSortedMap]
						this.cookies = init.cookies === null ? null : [...init.cookies]
					} else {
						this[kHeadersMap] = new Map(init)
						this[kHeadersSortedMap] = null
					}
				}

				// https://fetch.spec.whatwg.org/#header-list-contains
				contains(name) {
					// A header list list contains a header name name if list
					// contains a header whose name is a byte-case-insensitive
					// match for name.
					name = name.toLowerCase()

					return this[kHeadersMap].has(name)
				}

				clear() {
					this[kHeadersMap].clear()
					this[kHeadersSortedMap] = null
					this.cookies = null
				}

				// https://fetch.spec.whatwg.org/#concept-header-list-append
				append(name, value) {
					this[kHeadersSortedMap] = null

					// 1. If list contains name, then set name to the first such
					//    headers name.
					const lowercaseName = name.toLowerCase()
					const exists = this[kHeadersMap].get(lowercaseName)

					// 2. Append (name, value) to list.
					if (exists) {
						const delimiter = lowercaseName === 'cookie' ? '; ' : ', '
						this[kHeadersMap].set(lowercaseName, {
							name: exists.name,
							value: `${exists.value}${delimiter}${value}`,
						})
					} else {
						this[kHeadersMap].set(lowercaseName, { name, value })
					}

					if (lowercaseName === 'set-cookie') {
						this.cookies ??= []
						this.cookies.push(value)
					}
				}

				// https://fetch.spec.whatwg.org/#concept-header-list-set
				set(name, value) {
					this[kHeadersSortedMap] = null
					const lowercaseName = name.toLowerCase()

					if (lowercaseName === 'set-cookie') {
						this.cookies = [value]
					}

					// 1. If list contains name, then set the value of
					//    the first such header to value and remove the
					//    others.
					// 2. Otherwise, append header (name, value) to list.
					this[kHeadersMap].set(lowercaseName, { name, value })
				}

				// https://fetch.spec.whatwg.org/#concept-header-list-delete
				delete(name) {
					this[kHeadersSortedMap] = null

					name = name.toLowerCase()

					if (name === 'set-cookie') {
						this.cookies = null
					}

					this[kHeadersMap].delete(name)
				}

				// https://fetch.spec.whatwg.org/#concept-header-list-get
				get(name) {
					const value = this[kHeadersMap].get(name.toLowerCase())

					// 1. If list does not contain name, then return null.
					// 2. Return the values of all headers in list whose name
					//    is a byte-case-insensitive match for name,
					//    separated from each other by 0x2C 0x20, in order.
					return value === undefined ? null : value.value
				}

				*[Symbol.iterator]() {
					// use the lowercased name
					for (const [name, { value }] of this[kHeadersMap]) {
						yield [name, value]
					}
				}

				get entries() {
					const headers = {}

					if (this[kHeadersMap].size) {
						for (const { name, value } of this[kHeadersMap].values()) {
							headers[name] = value
						}
					}

					return headers
				}
			}

			// https://fetch.spec.whatwg.org/#headers-class
			class Headers {
				constructor(init = undefined) {
					if (init === kConstruct) {
						return
					}
					this[kHeadersList] = new HeadersList()

					// The new Headers(init) constructor steps are:

					// 1. Set thiss guard to "none".
					this[kGuard] = 'none'

					// 2. If init is given, then fill this with init.
					if (init !== undefined) {
						init = webidl.converters.HeadersInit(init)
						fill(this, init)
					}
				}

				// https://fetch.spec.whatwg.org/#dom-headers-append
				append(name, value) {
					webidl.brandCheck(this, Headers)

					webidl.argumentLengthCheck(arguments, 2, { header: 'Headers.append' })

					name = webidl.converters.ByteString(name)
					value = webidl.converters.ByteString(value)

					return appendHeader(this, name, value)
				}

				// https://fetch.spec.whatwg.org/#dom-headers-delete
				delete(name) {
					webidl.brandCheck(this, Headers)

					webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.delete' })

					name = webidl.converters.ByteString(name)

					// 1. If name is not a header name, then throw a TypeError.
					if (!isValidHeaderName(name)) {
						throw webidl.errors.invalidArgument({
							prefix: 'Headers.delete',
							value: name,
							type: 'header name',
						})
					}

					// 2. If thiss guard is "immutable", then throw a TypeError.
					// 3. Otherwise, if thiss guard is "request" and name is a
					//    forbidden header name, return.
					// 4. Otherwise, if thiss guard is "request-no-cors", name
					//    is not a no-CORS-safelisted request-header name, and
					//    name is not a privileged no-CORS request-header name,
					//    return.
					// 5. Otherwise, if thiss guard is "response" and name is
					//    a forbidden response-header name, return.
					// Note: undici does not implement forbidden header names
					if (this[kGuard] === 'immutable') {
						throw new TypeError('immutable')
					} else if (this[kGuard] === 'request-no-cors') {
						// TODO
					}

					// 6. If thiss header list does not contain name, then
					//    return.
					if (!this[kHeadersList].contains(name)) {
						return
					}

					// 7. Delete name from thiss header list.
					// 8. If thiss guard is "request-no-cors", then remove
					//    privileged no-CORS request headers from this.
					this[kHeadersList].delete(name)
				}

				// https://fetch.spec.whatwg.org/#dom-headers-get
				get(name) {
					webidl.brandCheck(this, Headers)

					webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.get' })

					name = webidl.converters.ByteString(name)

					// 1. If name is not a header name, then throw a TypeError.
					if (!isValidHeaderName(name)) {
						throw webidl.errors.invalidArgument({
							prefix: 'Headers.get',
							value: name,
							type: 'header name',
						})
					}

					// 2. Return the result of getting name from thiss header
					//    list.
					return this[kHeadersList].get(name)
				}

				// https://fetch.spec.whatwg.org/#dom-headers-has
				has(name) {
					webidl.brandCheck(this, Headers)

					webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.has' })

					name = webidl.converters.ByteString(name)

					// 1. If name is not a header name, then throw a TypeError.
					if (!isValidHeaderName(name)) {
						throw webidl.errors.invalidArgument({
							prefix: 'Headers.has',
							value: name,
							type: 'header name',
						})
					}

					// 2. Return true if thiss header list contains name;
					//    otherwise false.
					return this[kHeadersList].contains(name)
				}

				// https://fetch.spec.whatwg.org/#dom-headers-set
				set(name, value) {
					webidl.brandCheck(this, Headers)

					webidl.argumentLengthCheck(arguments, 2, { header: 'Headers.set' })

					name = webidl.converters.ByteString(name)
					value = webidl.converters.ByteString(value)

					// 1. Normalize value.
					value = headerValueNormalize(value)

					// 2. If name is not a header name or value is not a
					//    header value, then throw a TypeError.
					if (!isValidHeaderName(name)) {
						throw webidl.errors.invalidArgument({
							prefix: 'Headers.set',
							value: name,
							type: 'header name',
						})
					} else if (!isValidHeaderValue(value)) {
						throw webidl.errors.invalidArgument({
							prefix: 'Headers.set',
							value,
							type: 'header value',
						})
					}

					// 3. If thiss guard is "immutable", then throw a TypeError.
					// 4. Otherwise, if thiss guard is "request" and name is a
					//    forbidden header name, return.
					// 5. Otherwise, if thiss guard is "request-no-cors" and
					//    name/value is not a no-CORS-safelisted request-header,
					//    return.
					// 6. Otherwise, if thiss guard is "response" and name is a
					//    forbidden response-header name, return.
					// Note: undici does not implement forbidden header names
					if (this[kGuard] === 'immutable') {
						throw new TypeError('immutable')
					} else if (this[kGuard] === 'request-no-cors') {
						// TODO
					}

					// 7. Set (name, value) in thiss header list.
					// 8. If thiss guard is "request-no-cors", then remove
					//    privileged no-CORS request headers from this
					this[kHeadersList].set(name, value)
				}

				// https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
				getSetCookie() {
					webidl.brandCheck(this, Headers)

					// 1. If thiss header list does not contain `Set-Cookie`, then return  .
					// 2. Return the values of all headers in thiss header list whose name is
					//    a byte-case-insensitive match for `Set-Cookie`, in order.

					const list = this[kHeadersList].cookies

					if (list) {
						return [...list]
					}

					return []
				}

				// https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine
				get [kHeadersSortedMap]() {
					if (this[kHeadersList][kHeadersSortedMap]) {
						return this[kHeadersList][kHeadersSortedMap]
					}

					// 1. Let headers be an empty list of headers with the key being the name
					//    and value the value.
					const headers = []

					// 2. Let names be the result of convert header names to a sorted-lowercase
					//    set with all the names of the headers in list.
					const names = [...this[kHeadersList]].sort((a, b) =>
						a[0] < b[0] ? -1 : 1,
					)
					const cookies = this[kHeadersList].cookies

					// 3. For each name of names:
					for (let i = 0; i < names.length; ++i) {
						const [name, value] = names[i]
						// 1. If name is `set-cookie`, then:
						if (name === 'set-cookie') {
							// 1. Let values be a list of all values of headers in list whose name
							//    is a byte-case-insensitive match for name, in order.

							// 2. For each value of values:
							// 1. Append (name, value) to headers.
							for (let j = 0; j < cookies.length; ++j) {
								headers.push([name, cookies[j]])
							}
						} else {
							// 2. Otherwise:

							// 1. Let value be the result of getting name from list.

							// 2. Assert: value is non-null.
							assert(value !== null)

							// 3. Append (name, value) to headers.
							headers.push([name, value])
						}
					}

					this[kHeadersList][kHeadersSortedMap] = headers

					// 4. Return headers.
					return headers
				}

				keys() {
					webidl.brandCheck(this, Headers)

					if (this[kGuard] === 'immutable') {
						const value = this[kHeadersSortedMap]
						return makeIterator(() => value, 'Headers', 'key')
					}

					return makeIterator(
						() => [...this[kHeadersSortedMap].values()],
						'Headers',
						'key',
					)
				}

				values() {
					webidl.brandCheck(this, Headers)

					if (this[kGuard] === 'immutable') {
						const value = this[kHeadersSortedMap]
						return makeIterator(() => value, 'Headers', 'value')
					}

					return makeIterator(
						() => [...this[kHeadersSortedMap].values()],
						'Headers',
						'value',
					)
				}

				entries() {
					webidl.brandCheck(this, Headers)

					if (this[kGuard] === 'immutable') {
						const value = this[kHeadersSortedMap]
						return makeIterator(() => value, 'Headers', 'key+value')
					}

					return makeIterator(
						() => [...this[kHeadersSortedMap].values()],
						'Headers',
						'key+value',
					)
				}

				/**
				 * @param {(value: string, key: string, self: Headers) => void} callbackFn
				 * @param {unknown} thisArg
				 */
				forEach(callbackFn, thisArg = globalThis) {
					webidl.brandCheck(this, Headers)

					webidl.argumentLengthCheck(arguments, 1, {
						header: 'Headers.forEach',
					})

					if (typeof callbackFn !== 'function') {
						throw new TypeError(
							"Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.",
						)
					}

					for (const [key, value] of this) {
						callbackFn.apply(thisArg, [value, key, this])
					}
				}

				[Symbol.for('nodejs.util.inspect.custom')]() {
					webidl.brandCheck(this, Headers)

					return this[kHeadersList]
				}
			}

			Headers.prototype[Symbol.iterator] = Headers.prototype.entries

			Object.defineProperties(Headers.prototype, {
				append: kEnumerableProperty,
				delete: kEnumerableProperty,
				get: kEnumerableProperty,
				has: kEnumerableProperty,
				set: kEnumerableProperty,
				getSetCookie: kEnumerableProperty,
				keys: kEnumerableProperty,
				values: kEnumerableProperty,
				entries: kEnumerableProperty,
				forEach: kEnumerableProperty,
				[Symbol.iterator]: { enumerable: false },
				[Symbol.toStringTag]: {
					value: 'Headers',
					configurable: true,
				},
				[util.inspect.custom]: {
					enumerable: false,
				},
			})

			webidl.converters.HeadersInit = function (V) {
				if (webidl.util.Type(V) === 'Object') {
					if (V[Symbol.iterator]) {
						return webidl.converters['sequence<sequence<ByteString>>'](V)
					}

					return webidl.converters['record<ByteString, ByteString>'](V)
				}

				throw webidl.errors.conversionFailed({
					prefix: 'Headers constructor',
					argument: 'Argument 1',
					types: [
						'sequence<sequence<ByteString>>',
						'record<ByteString, ByteString>',
					],
				})
			}

			module.exports = {
				fill,
				Headers,
				HeadersList,
			}

			/***/
		},

		/***/ 12315: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'
			// https://github.com/Ethan-Arrowood/undici-fetch

			const {
				Response,
				makeNetworkError,
				makeAppropriateNetworkError,
				filterResponse,
				makeResponse,
			} = __nccwpck_require__(48676)
			const { Headers } = __nccwpck_require__(26349)
			const { Request, makeRequest } = __nccwpck_require__(25194)
			const zlib = __nccwpck_require__(43106)
			const {
				bytesMatch,
				makePolicyContainer,
				clonePolicyContainer,
				requestBadPort,
				TAOCheck,
				appendRequestOriginHeader,
				responseLocationURL,
				requestCurrentURL,
				setRequestReferrerPolicyOnRedirect,
				tryUpgradeRequestToAPotentiallyTrustworthyURL,
				createOpaqueTimingInfo,
				appendFetchMetadata,
				corsCheck,
				crossOriginResourcePolicyCheck,
				determineRequestsReferrer,
				coarsenedSharedCurrentTime,
				createDeferredPromise,
				isBlobLike,
				sameOrigin,
				isCancelled,
				isAborted,
				isErrorLike,
				fullyReadBody,
				readableStreamClose,
				isomorphicEncode,
				urlIsLocal,
				urlIsHttpHttpsScheme,
				urlHasHttpsScheme,
			} = __nccwpck_require__(15523)
			const { kState, kHeaders, kGuard, kRealm } = __nccwpck_require__(89710)
			const assert = __nccwpck_require__(42613)
			const { safelyExtractBody } = __nccwpck_require__(8923)
			const {
				redirectStatusSet,
				nullBodyStatus,
				safeMethodsSet,
				requestBodyHeader,
				subresourceSet,
				DOMException,
			} = __nccwpck_require__(87326)
			const { kHeadersList } = __nccwpck_require__(36443)
			const EE = __nccwpck_require__(24434)
			const { Readable, pipeline } = __nccwpck_require__(2203)
			const { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } =
				__nccwpck_require__(3440)
			const { dataURLProcessor, serializeAMimeType } =
				__nccwpck_require__(94322)
			const { TransformStream } = __nccwpck_require__(63774)
			const { getGlobalDispatcher } = __nccwpck_require__(32581)
			const { webidl } = __nccwpck_require__(74222)
			const { STATUS_CODES } = __nccwpck_require__(58611)
			const GET_OR_HEAD = ['GET', 'HEAD']

			/** @type {import('buffer').resolveObjectURL} */
			let resolveObjectURL
			let ReadableStream = globalThis.ReadableStream

			class Fetch extends EE {
				constructor(dispatcher) {
					super()

					this.dispatcher = dispatcher
					this.connection = null
					this.dump = false
					this.state = 'ongoing'
					// 2 terminated listeners get added per request,
					// but only 1 gets removed. If there are 20 redirects,
					// 21 listeners will be added.
					// See https://github.com/nodejs/undici/issues/1711
					// TODO (fix): Find and fix root cause for leaked listener.
					this.setMaxListeners(21)
				}

				terminate(reason) {
					if (this.state !== 'ongoing') {
						return
					}

					this.state = 'terminated'
					this.connection?.destroy(reason)
					this.emit('terminated', reason)
				}

				// https://fetch.spec.whatwg.org/#fetch-controller-abort
				abort(error) {
					if (this.state !== 'ongoing') {
						return
					}

					// 1. Set controllers state to "aborted".
					this.state = 'aborted'

					// 2. Let fallbackError be an "AbortError" DOMException.
					// 3. Set error to fallbackError if it is not given.
					if (!error) {
						error = new DOMException('The operation was aborted.', 'AbortError')
					}

					// 4. Let serializedError be StructuredSerialize(error).
					//    If that threw an exception, catch it, and let
					//    serializedError be StructuredSerialize(fallbackError).

					// 5. Set controllers serialized abort reason to serializedError.
					this.serializedAbortReason = error

					this.connection?.destroy(error)
					this.emit('terminated', error)
				}
			}

			// https://fetch.spec.whatwg.org/#fetch-method
			function fetch(input, init = {}) {
				webidl.argumentLengthCheck(arguments, 1, { header: 'globalThis.fetch' })

				// 1. Let p be a new promise.
				const p = createDeferredPromise()

				// 2. Let requestObject be the result of invoking the initial value of
				// Request as constructor with input and init as arguments. If this throws
				// an exception, reject p with it and return p.
				let requestObject

				try {
					requestObject = new Request(input, init)
				} catch (e) {
					p.reject(e)
					return p.promise
				}

				// 3. Let request be requestObjects request.
				const request = requestObject[kState]

				// 4. If requestObjects signals aborted flag is set, then:
				if (requestObject.signal.aborted) {
					// 1. Abort the fetch() call with p, request, null, and
					//    requestObjects signals abort reason.
					abortFetch(p, request, null, requestObject.signal.reason)

					// 2. Return p.
					return p.promise
				}

				// 5. Let globalObject be requests clients global object.
				const globalObject = request.client.globalObject

				// 6. If globalObject is a ServiceWorkerGlobalScope object, then set
				// requests service-workers mode to "none".
				if (globalObject?.constructor?.name === 'ServiceWorkerGlobalScope') {
					request.serviceWorkers = 'none'
				}

				// 7. Let responseObject be null.
				let responseObject = null

				// 8. Let relevantRealm be thiss relevant Realm.
				const relevantRealm = null

				// 9. Let locallyAborted be false.
				let locallyAborted = false

				// 10. Let controller be null.
				let controller = null

				// 11. Add the following abort steps to requestObjects signal:
				addAbortListener(requestObject.signal, () => {
					// 1. Set locallyAborted to true.
					locallyAborted = true

					// 2. Assert: controller is non-null.
					assert(controller != null)

					// 3. Abort controller with requestObjects signals abort reason.
					controller.abort(requestObject.signal.reason)

					// 4. Abort the fetch() call with p, request, responseObject,
					//    and requestObjects signals abort reason.
					abortFetch(p, request, responseObject, requestObject.signal.reason)
				})

				// 12. Let handleFetchDone given response response be to finalize and
				// report timing with response, globalObject, and "fetch".
				const handleFetchDone = (response) =>
					finalizeAndReportTiming(response, 'fetch')

				// 13. Set controller to the result of calling fetch given request,
				// with processResponseEndOfBody set to handleFetchDone, and processResponse
				// given response being these substeps:

				const processResponse = (response) => {
					// 1. If locallyAborted is true, terminate these substeps.
					if (locallyAborted) {
						return Promise.resolve()
					}

					// 2. If responses aborted flag is set, then:
					if (response.aborted) {
						// 1. Let deserializedError be the result of deserialize a serialized
						//    abort reason given controllers serialized abort reason and
						//    relevantRealm.

						// 2. Abort the fetch() call with p, request, responseObject, and
						//    deserializedError.

						abortFetch(
							p,
							request,
							responseObject,
							controller.serializedAbortReason,
						)
						return Promise.resolve()
					}

					// 3. If response is a network error, then reject p with a TypeError
					// and terminate these substeps.
					if (response.type === 'error') {
						p.reject(
							Object.assign(new TypeError('fetch failed'), {
								cause: response.error,
							}),
						)
						return Promise.resolve()
					}

					// 4. Set responseObject to the result of creating a Response object,
					// given response, "immutable", and relevantRealm.
					responseObject = new Response()
					responseObject[kState] = response
					responseObject[kRealm] = relevantRealm
					responseObject[kHeaders][kHeadersList] = response.headersList
					responseObject[kHeaders][kGuard] = 'immutable'
					responseObject[kHeaders][kRealm] = relevantRealm

					// 5. Resolve p with responseObject.
					p.resolve(responseObject)
				}

				controller = fetching({
					request,
					processResponseEndOfBody: handleFetchDone,
					processResponse,
					dispatcher: init.dispatcher ?? getGlobalDispatcher(), // undici
				})

				// 14. Return p.
				return p.promise
			}

			// https://fetch.spec.whatwg.org/#finalize-and-report-timing
			function finalizeAndReportTiming(response, initiatorType = 'other') {
				// 1. If response is an aborted network error, then return.
				if (response.type === 'error' && response.aborted) {
					return
				}

				// 2. If responses URL list is null or empty, then return.
				if (!response.urlList?.length) {
					return
				}

				// 3. Let originalURL be responses URL list[0].
				const originalURL = response.urlList[0]

				// 4. Let timingInfo be responses timing info.
				let timingInfo = response.timingInfo

				// 5. Let cacheState be responses cache state.
				let cacheState = response.cacheState

				// 6. If originalURLs scheme is not an HTTP(S) scheme, then return.
				if (!urlIsHttpHttpsScheme(originalURL)) {
					return
				}

				// 7. If timingInfo is null, then return.
				if (timingInfo === null) {
					return
				}

				// 8. If responses timing allow passed flag is not set, then:
				if (!response.timingAllowPassed) {
					//  1. Set timingInfo to a the result of creating an opaque timing info for timingInfo.
					timingInfo = createOpaqueTimingInfo({
						startTime: timingInfo.startTime,
					})

					//  2. Set cacheState to the empty string.
					cacheState = ''
				}

				// 9. Set timingInfos end time to the coarsened shared current time
				// given globals relevant settings objects cross-origin isolated
				// capability.
				// TODO: given globals relevant settings objects cross-origin isolated
				// capability?
				timingInfo.endTime = coarsenedSharedCurrentTime()

				// 10. Set responses timing info to timingInfo.
				response.timingInfo = timingInfo

				// 11. Mark resource timing for timingInfo, originalURL, initiatorType,
				// global, and cacheState.
				markResourceTiming(
					timingInfo,
					originalURL,
					initiatorType,
					globalThis,
					cacheState,
				)
			}

			// https://w3c.github.io/resource-timing/#dfn-mark-resource-timing
			function markResourceTiming(
				timingInfo,
				originalURL,
				initiatorType,
				globalThis,
				cacheState,
			) {
				if (nodeMajor > 18 || (nodeMajor === 18 && nodeMinor >= 2)) {
					performance.markResourceTiming(
						timingInfo,
						originalURL.href,
						initiatorType,
						globalThis,
						cacheState,
					)
				}
			}

			// https://fetch.spec.whatwg.org/#abort-fetch
			function abortFetch(p, request, responseObject, error) {
				// Note: AbortSignal.reason was added in node v17.2.0
				// which would give us an undefined error to reject with.
				// Remove this once node v16 is no longer supported.
				if (!error) {
					error = new DOMException('The operation was aborted.', 'AbortError')
				}

				// 1. Reject promise with error.
				p.reject(error)

				// 2. If requests body is not null and is readable, then cancel requests
				// body with error.
				if (request.body != null && isReadable(request.body?.stream)) {
					request.body.stream.cancel(error).catch((err) => {
						if (err.code === 'ERR_INVALID_STATE') {
							// Node bug?
							return
						}
						throw err
					})
				}

				// 3. If responseObject is null, then return.
				if (responseObject == null) {
					return
				}

				// 4. Let response be responseObjects response.
				const response = responseObject[kState]

				// 5. If responses body is not null and is readable, then error responses
				// body with error.
				if (response.body != null && isReadable(response.body?.stream)) {
					response.body.stream.cancel(error).catch((err) => {
						if (err.code === 'ERR_INVALID_STATE') {
							// Node bug?
							return
						}
						throw err
					})
				}
			}

			// https://fetch.spec.whatwg.org/#fetching
			function fetching({
				request,
				processRequestBodyChunkLength,
				processRequestEndOfBody,
				processResponse,
				processResponseEndOfBody,
				processResponseConsumeBody,
				useParallelQueue = false,
				dispatcher, // undici
			}) {
				// 1. Let taskDestination be null.
				let taskDestination = null

				// 2. Let crossOriginIsolatedCapability be false.
				let crossOriginIsolatedCapability = false

				// 3. If requests client is non-null, then:
				if (request.client != null) {
					// 1. Set taskDestination to requests clients global object.
					taskDestination = request.client.globalObject

					// 2. Set crossOriginIsolatedCapability to requests clients cross-origin
					// isolated capability.
					crossOriginIsolatedCapability =
						request.client.crossOriginIsolatedCapability
				}

				// 4. If useParallelQueue is true, then set taskDestination to the result of
				// starting a new parallel queue.
				// TODO

				// 5. Let timingInfo be a new fetch timing info whose start time and
				// post-redirect start time are the coarsened shared current time given
				// crossOriginIsolatedCapability.
				const currenTime = coarsenedSharedCurrentTime(
					crossOriginIsolatedCapability,
				)
				const timingInfo = createOpaqueTimingInfo({
					startTime: currenTime,
				})

				// 6. Let fetchParams be a new fetch params whose
				// request is request,
				// timing info is timingInfo,
				// process request body chunk length is processRequestBodyChunkLength,
				// process request end-of-body is processRequestEndOfBody,
				// process response is processResponse,
				// process response consume body is processResponseConsumeBody,
				// process response end-of-body is processResponseEndOfBody,
				// task destination is taskDestination,
				// and cross-origin isolated capability is crossOriginIsolatedCapability.
				const fetchParams = {
					controller: new Fetch(dispatcher),
					request,
					timingInfo,
					processRequestBodyChunkLength,
					processRequestEndOfBody,
					processResponse,
					processResponseConsumeBody,
					processResponseEndOfBody,
					taskDestination,
					crossOriginIsolatedCapability,
				}

				// 7. If requests body is a byte sequence, then set requests body to
				//    requests body as a body.
				// NOTE: Since fetching is only called from fetch, body should already be
				// extracted.
				assert(!request.body || request.body.stream)

				// 8. If requests window is "client", then set requests window to requests
				// client, if requests clients global object is a Window object; otherwise
				// "no-window".
				if (request.window === 'client') {
					// TODO: What if request.client is null?
					request.window =
						request.client?.globalObject?.constructor?.name === 'Window'
							? request.client
							: 'no-window'
				}

				// 9. If requests origin is "client", then set requests origin to requests
				// clients origin.
				if (request.origin === 'client') {
					// TODO: What if request.client is null?
					request.origin = request.client?.origin
				}

				// 10. If all of the following conditions are true:
				// TODO

				// 11. If requests policy container is "client", then:
				if (request.policyContainer === 'client') {
					// 1. If requests client is non-null, then set requests policy
					// container to a clone of requests clients policy container. [HTML]
					if (request.client != null) {
						request.policyContainer = clonePolicyContainer(
							request.client.policyContainer,
						)
					} else {
						// 2. Otherwise, set requests policy container to a new policy
						// container.
						request.policyContainer = makePolicyContainer()
					}
				}

				// 12. If requests header list does not contain `Accept`, then:
				if (!request.headersList.contains('accept')) {
					// 1. Let value be `*/*`.
					const value = '*/*'

					// 2. A user agent should set value to the first matching statement, if
					// any, switching on requests destination:
					// "document"
					// "frame"
					// "iframe"
					// `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`
					// "image"
					// `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`
					// "style"
					// `text/css,*/*;q=0.1`
					// TODO

					// 3. Append `Accept`/value to requests header list.
					request.headersList.append('accept', value)
				}

				// 13. If requests header list does not contain `Accept-Language`, then
				// user agents should append `Accept-Language`/an appropriate value to
				// requests header list.
				if (!request.headersList.contains('accept-language')) {
					request.headersList.append('accept-language', '*')
				}

				// 14. If requests priority is null, then use requests initiator and
				// destination appropriately in setting requests priority to a
				// user-agent-defined object.
				if (request.priority === null) {
					// TODO
				}

				// 15. If request is a subresource request, then:
				if (subresourceSet.has(request.destination)) {
					// TODO
				}

				// 16. Run main fetch given fetchParams.
				mainFetch(fetchParams).catch((err) => {
					fetchParams.controller.terminate(err)
				})

				// 17. Return fetchParam's controller
				return fetchParams.controller
			}

			// https://fetch.spec.whatwg.org/#concept-main-fetch
			async function mainFetch(fetchParams, recursive = false) {
				// 1. Let request be fetchParamss request.
				const request = fetchParams.request

				// 2. Let response be null.
				let response = null

				// 3. If requests local-URLs-only flag is set and requests current URL is
				// not local, then set response to a network error.
				if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {
					response = makeNetworkError('local URLs only')
				}

				// 4. Run report Content Security Policy violations for request.
				// TODO

				// 5. Upgrade request to a potentially trustworthy URL, if appropriate.
				tryUpgradeRequestToAPotentiallyTrustworthyURL(request)

				// 6. If should request be blocked due to a bad port, should fetching request
				// be blocked as mixed content, or should request be blocked by Content
				// Security Policy returns blocked, then set response to a network error.
				if (requestBadPort(request) === 'blocked') {
					response = makeNetworkError('bad port')
				}
				// TODO: should fetching request be blocked as mixed content?
				// TODO: should request be blocked by Content Security Policy?

				// 7. If requests referrer policy is the empty string, then set requests
				// referrer policy to requests policy containers referrer policy.
				if (request.referrerPolicy === '') {
					request.referrerPolicy = request.policyContainer.referrerPolicy
				}

				// 8. If requests referrer is not "no-referrer", then set requests
				// referrer to the result of invoking determine requests referrer.
				if (request.referrer !== 'no-referrer') {
					request.referrer = determineRequestsReferrer(request)
				}

				// 9. Set requests current URLs scheme to "https" if all of the following
				// conditions are true:
				// - requests current URLs scheme is "http"
				// - requests current URLs host is a domain
				// - Matching requests current URLs host per Known HSTS Host Domain Name
				//   Matching results in either a superdomain match with an asserted
				//   includeSubDomains directive or a congruent match (with or without an
				//   asserted includeSubDomains directive). [HSTS]
				// TODO

				// 10. If recursive is false, then run the remaining steps in parallel.
				// TODO

				// 11. If response is null, then set response to the result of running
				// the steps corresponding to the first matching statement:
				if (response === null) {
					response = await (async () => {
						const currentURL = requestCurrentURL(request)

						if (
							// - requests current URLs origin is same origin with requests origin,
							//   and requests response tainting is "basic"
							(sameOrigin(currentURL, request.url) &&
								request.responseTainting === 'basic') ||
							// requests current URLs scheme is "data"
							currentURL.protocol === 'data:' ||
							// - requests mode is "navigate" or "websocket"
							request.mode === 'navigate' ||
							request.mode === 'websocket'
						) {
							// 1. Set requests response tainting to "basic".
							request.responseTainting = 'basic'

							// 2. Return the result of running scheme fetch given fetchParams.
							return await schemeFetch(fetchParams)
						}

						// requests mode is "same-origin"
						if (request.mode === 'same-origin') {
							// 1. Return a network error.
							return makeNetworkError('request mode cannot be "same-origin"')
						}

						// requests mode is "no-cors"
						if (request.mode === 'no-cors') {
							// 1. If requests redirect mode is not "follow", then return a network
							// error.
							if (request.redirect !== 'follow') {
								return makeNetworkError(
									'redirect mode cannot be "follow" for "no-cors" request',
								)
							}

							// 2. Set requests response tainting to "opaque".
							request.responseTainting = 'opaque'

							// 3. Return the result of running scheme fetch given fetchParams.
							return await schemeFetch(fetchParams)
						}

						// requests current URLs scheme is not an HTTP(S) scheme
						if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {
							// Return a network error.
							return makeNetworkError('URL scheme must be a HTTP(S) scheme')
						}

						// - requests use-CORS-preflight flag is set
						// - requests unsafe-request flag is set and either requests method is
						//   not a CORS-safelisted method or CORS-unsafe request-header names with
						//   requests header list is not empty
						//    1. Set requests response tainting to "cors".
						//    2. Let corsWithPreflightResponse be the result of running HTTP fetch
						//    given fetchParams and true.
						//    3. If corsWithPreflightResponse is a network error, then clear cache
						//    entries using request.
						//    4. Return corsWithPreflightResponse.
						// TODO

						// Otherwise
						//    1. Set requests response tainting to "cors".
						request.responseTainting = 'cors'

						//    2. Return the result of running HTTP fetch given fetchParams.
						return await httpFetch(fetchParams)
					})()
				}

				// 12. If recursive is true, then return response.
				if (recursive) {
					return response
				}

				// 13. If response is not a network error and response is not a filtered
				// response, then:
				if (response.status !== 0 && !response.internalResponse) {
					// If requests response tainting is "cors", then:
					if (request.responseTainting === 'cors') {
						// 1. Let headerNames be the result of extracting header list values
						// given `Access-Control-Expose-Headers` and responses header list.
						// TODO
						// 2. If requests credentials mode is not "include" and headerNames
						// contains `*`, then set responses CORS-exposed header-name list to
						// all unique header names in responses header list.
						// TODO
						// 3. Otherwise, if headerNames is not null or failure, then set
						// responses CORS-exposed header-name list to headerNames.
						// TODO
					}

					// Set response to the following filtered response with response as its
					// internal response, depending on requests response tainting:
					if (request.responseTainting === 'basic') {
						response = filterResponse(response, 'basic')
					} else if (request.responseTainting === 'cors') {
						response = filterResponse(response, 'cors')
					} else if (request.responseTainting === 'opaque') {
						response = filterResponse(response, 'opaque')
					} else {
						assert(false)
					}
				}

				// 14. Let internalResponse be response, if response is a network error,
				// and responses internal response otherwise.
				let internalResponse =
					response.status === 0 ? response : response.internalResponse

				// 15. If internalResponses URL list is empty, then set it to a clone of
				// requests URL list.
				if (internalResponse.urlList.length === 0) {
					internalResponse.urlList.push(...request.urlList)
				}

				// 16. If requests timing allow failed flag is unset, then set
				// internalResponses timing allow passed flag.
				if (!request.timingAllowFailed) {
					response.timingAllowPassed = true
				}

				// 17. If response is not a network error and any of the following returns
				// blocked
				// - should internalResponse to request be blocked as mixed content
				// - should internalResponse to request be blocked by Content Security Policy
				// - should internalResponse to request be blocked due to its MIME type
				// - should internalResponse to request be blocked due to nosniff
				// TODO

				// 18. If responses type is "opaque", internalResponses status is 206,
				// internalResponses range-requested flag is set, and requests header
				// list does not contain `Range`, then set response and internalResponse
				// to a network error.
				if (
					response.type === 'opaque' &&
					internalResponse.status === 206 &&
					internalResponse.rangeRequested &&
					!request.headers.contains('range')
				) {
					response = internalResponse = makeNetworkError()
				}

				// 19. If response is not a network error and either requests method is
				// `HEAD` or `CONNECT`, or internalResponses status is a null body status,
				// set internalResponses body to null and disregard any enqueuing toward
				// it (if any).
				if (
					response.status !== 0 &&
					(request.method === 'HEAD' ||
						request.method === 'CONNECT' ||
						nullBodyStatus.includes(internalResponse.status))
				) {
					internalResponse.body = null
					fetchParams.controller.dump = true
				}

				// 20. If requests integrity metadata is not the empty string, then:
				if (request.integrity) {
					// 1. Let processBodyError be this step: run fetch finale given fetchParams
					// and a network error.
					const processBodyError = (reason) =>
						fetchFinale(fetchParams, makeNetworkError(reason))

					// 2. If requests response tainting is "opaque", or responses body is null,
					// then run processBodyError and abort these steps.
					if (request.responseTainting === 'opaque' || response.body == null) {
						processBodyError(response.error)
						return
					}

					// 3. Let processBody given bytes be these steps:
					const processBody = (bytes) => {
						// 1. If bytes do not match requests integrity metadata,
						// then run processBodyError and abort these steps. [SRI]
						if (!bytesMatch(bytes, request.integrity)) {
							processBodyError('integrity mismatch')
							return
						}

						// 2. Set responses body to bytes as a body.
						response.body = safelyExtractBody(bytes)[0]

						// 3. Run fetch finale given fetchParams and response.
						fetchFinale(fetchParams, response)
					}

					// 4. Fully read responses body given processBody and processBodyError.
					await fullyReadBody(response.body, processBody, processBodyError)
				} else {
					// 21. Otherwise, run fetch finale given fetchParams and response.
					fetchFinale(fetchParams, response)
				}
			}

			// https://fetch.spec.whatwg.org/#concept-scheme-fetch
			// given a fetch params fetchParams
			function schemeFetch(fetchParams) {
				// Note: since the connection is destroyed on redirect, which sets fetchParams to a
				// cancelled state, we do not want this condition to trigger *unless* there have been
				// no redirects. See https://github.com/nodejs/undici/issues/1776
				// 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.
				if (
					isCancelled(fetchParams) &&
					fetchParams.request.redirectCount === 0
				) {
					return Promise.resolve(makeAppropriateNetworkError(fetchParams))
				}

				// 2. Let request be fetchParamss request.
				const { request } = fetchParams

				const { protocol: scheme } = requestCurrentURL(request)

				// 3. Switch on requests current URLs scheme and run the associated steps:
				switch (scheme) {
					case 'about:': {
						// If requests current URLs path is the string "blank", then return a new response
						// whose status message is `OK`, header list is  (`Content-Type`, `text/html;charset=utf-8`) ,
						// and body is the empty byte sequence as a body.

						// Otherwise, return a network error.
						return Promise.resolve(
							makeNetworkError('about scheme is not supported'),
						)
					}
					case 'blob:': {
						if (!resolveObjectURL) {
							resolveObjectURL = __nccwpck_require__(20181).resolveObjectURL
						}

						// 1. Let blobURLEntry be requests current URLs blob URL entry.
						const blobURLEntry = requestCurrentURL(request)

						// https://github.com/web-platform-tests/wpt/blob/7b0ebaccc62b566a1965396e5be7bb2bc06f841f/FileAPI/url/resources/fetch-tests.js#L52-L56
						// Buffer.resolveObjectURL does not ignore URL queries.
						if (blobURLEntry.search.length !== 0) {
							return Promise.resolve(
								makeNetworkError(
									'NetworkError when attempting to fetch resource.',
								),
							)
						}

						const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString())

						// 2. If requests method is not `GET`, blobURLEntry is null, or blobURLEntrys
						//    object is not a Blob object, then return a network error.
						if (request.method !== 'GET' || !isBlobLike(blobURLEntryObject)) {
							return Promise.resolve(makeNetworkError('invalid method'))
						}

						// 3. Let bodyWithType be the result of safely extracting blobURLEntrys object.
						const bodyWithType = safelyExtractBody(blobURLEntryObject)

						// 4. Let body be bodyWithTypes body.
						const body = bodyWithType[0]

						// 5. Let length be bodys length, serialized and isomorphic encoded.
						const length = isomorphicEncode(`${body.length}`)

						// 6. Let type be bodyWithTypes type if it is non-null; otherwise the empty byte sequence.
						const type = bodyWithType[1] ?? ''

						// 7. Return a new response whose status message is `OK`, header list is
						//     (`Content-Length`, length), (`Content-Type`, type) , and body is body.
						const response = makeResponse({
							statusText: 'OK',
							headersList: [
								['content-length', { name: 'Content-Length', value: length }],
								['content-type', { name: 'Content-Type', value: type }],
							],
						})

						response.body = body

						return Promise.resolve(response)
					}
					case 'data:': {
						// 1. Let dataURLStruct be the result of running the
						//    data: URL processor on requests current URL.
						const currentURL = requestCurrentURL(request)
						const dataURLStruct = dataURLProcessor(currentURL)

						// 2. If dataURLStruct is failure, then return a
						//    network error.
						if (dataURLStruct === 'failure') {
							return Promise.resolve(
								makeNetworkError('failed to fetch the data URL'),
							)
						}

						// 3. Let mimeType be dataURLStructs MIME type, serialized.
						const mimeType = serializeAMimeType(dataURLStruct.mimeType)

						// 4. Return a response whose status message is `OK`,
						//    header list is  (`Content-Type`, mimeType) ,
						//    and body is dataURLStructs body as a body.
						return Promise.resolve(
							makeResponse({
								statusText: 'OK',
								headersList: [
									['content-type', { name: 'Content-Type', value: mimeType }],
								],
								body: safelyExtractBody(dataURLStruct.body)[0],
							}),
						)
					}
					case 'file:': {
						// For now, unfortunate as it is, file URLs are left as an exercise for the reader.
						// When in doubt, return a network error.
						return Promise.resolve(
							makeNetworkError('not implemented... yet...'),
						)
					}
					case 'http:':
					case 'https:': {
						// Return the result of running HTTP fetch given fetchParams.

						return httpFetch(fetchParams).catch((err) => makeNetworkError(err))
					}
					default: {
						return Promise.resolve(makeNetworkError('unknown scheme'))
					}
				}
			}

			// https://fetch.spec.whatwg.org/#finalize-response
			function finalizeResponse(fetchParams, response) {
				// 1. Set fetchParamss requests done flag.
				fetchParams.request.done = true

				// 2, If fetchParamss process response done is not null, then queue a fetch
				// task to run fetchParamss process response done given response, with
				// fetchParamss task destination.
				if (fetchParams.processResponseDone != null) {
					queueMicrotask(() => fetchParams.processResponseDone(response))
				}
			}

			// https://fetch.spec.whatwg.org/#fetch-finale
			function fetchFinale(fetchParams, response) {
				// 1. If response is a network error, then:
				if (response.type === 'error') {
					// 1. Set responses URL list to  fetchParamss requests URL list[0] .
					response.urlList = [fetchParams.request.urlList[0]]

					// 2. Set responses timing info to the result of creating an opaque timing
					// info for fetchParamss timing info.
					response.timingInfo = createOpaqueTimingInfo({
						startTime: fetchParams.timingInfo.startTime,
					})
				}

				// 2. Let processResponseEndOfBody be the following steps:
				const processResponseEndOfBody = () => {
					// 1. Set fetchParamss requests done flag.
					fetchParams.request.done = true

					// If fetchParamss process response end-of-body is not null,
					// then queue a fetch task to run fetchParamss process response
					// end-of-body given response with fetchParamss task destination.
					if (fetchParams.processResponseEndOfBody != null) {
						queueMicrotask(() => fetchParams.processResponseEndOfBody(response))
					}
				}

				// 3. If fetchParamss process response is non-null, then queue a fetch task
				// to run fetchParamss process response given response, with fetchParamss
				// task destination.
				if (fetchParams.processResponse != null) {
					queueMicrotask(() => fetchParams.processResponse(response))
				}

				// 4. If responses body is null, then run processResponseEndOfBody.
				if (response.body == null) {
					processResponseEndOfBody()
				} else {
					// 5. Otherwise:

					// 1. Let transformStream be a new a TransformStream.

					// 2. Let identityTransformAlgorithm be an algorithm which, given chunk,
					// enqueues chunk in transformStream.
					const identityTransformAlgorithm = (chunk, controller) => {
						controller.enqueue(chunk)
					}

					// 3. Set up transformStream with transformAlgorithm set to identityTransformAlgorithm
					// and flushAlgorithm set to processResponseEndOfBody.
					const transformStream = new TransformStream(
						{
							start() {},
							transform: identityTransformAlgorithm,
							flush: processResponseEndOfBody,
						},
						{
							size() {
								return 1
							},
						},
						{
							size() {
								return 1
							},
						},
					)

					// 4. Set responses body to the result of piping responses body through transformStream.
					response.body = {
						stream: response.body.stream.pipeThrough(transformStream),
					}
				}

				// 6. If fetchParamss process response consume body is non-null, then:
				if (fetchParams.processResponseConsumeBody != null) {
					// 1. Let processBody given nullOrBytes be this step: run fetchParamss
					// process response consume body given response and nullOrBytes.
					const processBody = (nullOrBytes) =>
						fetchParams.processResponseConsumeBody(response, nullOrBytes)

					// 2. Let processBodyError be this step: run fetchParamss process
					// response consume body given response and failure.
					const processBodyError = (failure) =>
						fetchParams.processResponseConsumeBody(response, failure)

					// 3. If responses body is null, then queue a fetch task to run processBody
					// given null, with fetchParamss task destination.
					if (response.body == null) {
						queueMicrotask(() => processBody(null))
					} else {
						// 4. Otherwise, fully read responses body given processBody, processBodyError,
						// and fetchParamss task destination.
						return fullyReadBody(response.body, processBody, processBodyError)
					}
					return Promise.resolve()
				}
			}

			// https://fetch.spec.whatwg.org/#http-fetch
			async function httpFetch(fetchParams) {
				// 1. Let request be fetchParamss request.
				const request = fetchParams.request

				// 2. Let response be null.
				let response = null

				// 3. Let actualResponse be null.
				let actualResponse = null

				// 4. Let timingInfo be fetchParamss timing info.
				const timingInfo = fetchParams.timingInfo

				// 5. If requests service-workers mode is "all", then:
				if (request.serviceWorkers === 'all') {
					// TODO
				}

				// 6. If response is null, then:
				if (response === null) {
					// 1. If makeCORSPreflight is true and one of these conditions is true:
					// TODO

					// 2. If requests redirect mode is "follow", then set requests
					// service-workers mode to "none".
					if (request.redirect === 'follow') {
						request.serviceWorkers = 'none'
					}

					// 3. Set response and actualResponse to the result of running
					// HTTP-network-or-cache fetch given fetchParams.
					actualResponse = response = await httpNetworkOrCacheFetch(fetchParams)

					// 4. If requests response tainting is "cors" and a CORS check
					// for request and response returns failure, then return a network error.
					if (
						request.responseTainting === 'cors' &&
						corsCheck(request, response) === 'failure'
					) {
						return makeNetworkError('cors failure')
					}

					// 5. If the TAO check for request and response returns failure, then set
					// requests timing allow failed flag.
					if (TAOCheck(request, response) === 'failure') {
						request.timingAllowFailed = true
					}
				}

				// 7. If either requests response tainting or responses type
				// is "opaque", and the cross-origin resource policy check with
				// requests origin, requests client, requests destination,
				// and actualResponse returns blocked, then return a network error.
				if (
					(request.responseTainting === 'opaque' ||
						response.type === 'opaque') &&
					crossOriginResourcePolicyCheck(
						request.origin,
						request.client,
						request.destination,
						actualResponse,
					) === 'blocked'
				) {
					return makeNetworkError('blocked')
				}

				// 8. If actualResponses status is a redirect status, then:
				if (redirectStatusSet.has(actualResponse.status)) {
					// 1. If actualResponses status is not 303, requests body is not null,
					// and the connection uses HTTP/2, then user agents may, and are even
					// encouraged to, transmit an RST_STREAM frame.
					// See, https://github.com/whatwg/fetch/issues/1288
					if (request.redirect !== 'manual') {
						fetchParams.controller.connection.destroy()
					}

					// 2. Switch on requests redirect mode:
					if (request.redirect === 'error') {
						// Set response to a network error.
						response = makeNetworkError('unexpected redirect')
					} else if (request.redirect === 'manual') {
						// Set response to an opaque-redirect filtered response whose internal
						// response is actualResponse.
						// NOTE(spec): On the web this would return an `opaqueredirect` response,
						// but that doesn't make sense server side.
						// See https://github.com/nodejs/undici/issues/1193.
						response = actualResponse
					} else if (request.redirect === 'follow') {
						// Set response to the result of running HTTP-redirect fetch given
						// fetchParams and response.
						response = await httpRedirectFetch(fetchParams, response)
					} else {
						assert(false)
					}
				}

				// 9. Set responses timing info to timingInfo.
				response.timingInfo = timingInfo

				// 10. Return response.
				return response
			}

			// https://fetch.spec.whatwg.org/#http-redirect-fetch
			function httpRedirectFetch(fetchParams, response) {
				// 1. Let request be fetchParamss request.
				const request = fetchParams.request

				// 2. Let actualResponse be response, if response is not a filtered response,
				// and responses internal response otherwise.
				const actualResponse = response.internalResponse
					? response.internalResponse
					: response

				// 3. Let locationURL be actualResponses location URL given requests current
				// URLs fragment.
				let locationURL

				try {
					locationURL = responseLocationURL(
						actualResponse,
						requestCurrentURL(request).hash,
					)

					// 4. If locationURL is null, then return response.
					if (locationURL == null) {
						return response
					}
				} catch (err) {
					// 5. If locationURL is failure, then return a network error.
					return Promise.resolve(makeNetworkError(err))
				}

				// 6. If locationURLs scheme is not an HTTP(S) scheme, then return a network
				// error.
				if (!urlIsHttpHttpsScheme(locationURL)) {
					return Promise.resolve(
						makeNetworkError('URL scheme must be a HTTP(S) scheme'),
					)
				}

				// 7. If requests redirect count is 20, then return a network error.
				if (request.redirectCount === 20) {
					return Promise.resolve(makeNetworkError('redirect count exceeded'))
				}

				// 8. Increase requests redirect count by 1.
				request.redirectCount += 1

				// 9. If requests mode is "cors", locationURL includes credentials, and
				// requests origin is not same origin with locationURLs origin, then return
				//  a network error.
				if (
					request.mode === 'cors' &&
					(locationURL.username || locationURL.password) &&
					!sameOrigin(request, locationURL)
				) {
					return Promise.resolve(
						makeNetworkError(
							'cross origin not allowed for request mode "cors"',
						),
					)
				}

				// 10. If requests response tainting is "cors" and locationURL includes
				// credentials, then return a network error.
				if (
					request.responseTainting === 'cors' &&
					(locationURL.username || locationURL.password)
				) {
					return Promise.resolve(
						makeNetworkError(
							'URL cannot contain credentials for request mode "cors"',
						),
					)
				}

				// 11. If actualResponses status is not 303, requests body is non-null,
				// and requests bodys source is null, then return a network error.
				if (
					actualResponse.status !== 303 &&
					request.body != null &&
					request.body.source == null
				) {
					return Promise.resolve(makeNetworkError())
				}

				// 12. If one of the following is true
				// - actualResponses status is 301 or 302 and requests method is `POST`
				// - actualResponses status is 303 and requests method is not `GET` or `HEAD`
				if (
					([301, 302].includes(actualResponse.status) &&
						request.method === 'POST') ||
					(actualResponse.status === 303 &&
						!GET_OR_HEAD.includes(request.method))
				) {
					// then:
					// 1. Set requests method to `GET` and requests body to null.
					request.method = 'GET'
					request.body = null

					// 2. For each headerName of request-body-header name, delete headerName from
					// requests header list.
					for (const headerName of requestBodyHeader) {
						request.headersList.delete(headerName)
					}
				}

				// 13. If requests current URLs origin is not same origin with locationURLs
				//     origin, then for each headerName of CORS non-wildcard request-header name,
				//     delete headerName from requests header list.
				if (!sameOrigin(requestCurrentURL(request), locationURL)) {
					// https://fetch.spec.whatwg.org/#cors-non-wildcard-request-header-name
					request.headersList.delete('authorization')

					// https://fetch.spec.whatwg.org/#authentication-entries
					request.headersList.delete('proxy-authorization', true)

					// "Cookie" and "Host" are forbidden request-headers, which undici doesn't implement.
					request.headersList.delete('cookie')
					request.headersList.delete('host')
				}

				// 14. If requests body is non-null, then set requests body to the first return
				// value of safely extracting requests bodys source.
				if (request.body != null) {
					assert(request.body.source != null)
					request.body = safelyExtractBody(request.body.source)[0]
				}

				// 15. Let timingInfo be fetchParamss timing info.
				const timingInfo = fetchParams.timingInfo

				// 16. Set timingInfos redirect end time and post-redirect start time to the
				// coarsened shared current time given fetchParamss cross-origin isolated
				// capability.
				timingInfo.redirectEndTime = timingInfo.postRedirectStartTime =
					coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)

				// 17. If timingInfos redirect start time is 0, then set timingInfos
				//  redirect start time to timingInfos start time.
				if (timingInfo.redirectStartTime === 0) {
					timingInfo.redirectStartTime = timingInfo.startTime
				}

				// 18. Append locationURL to requests URL list.
				request.urlList.push(locationURL)

				// 19. Invoke set requests referrer policy on redirect on request and
				// actualResponse.
				setRequestReferrerPolicyOnRedirect(request, actualResponse)

				// 20. Return the result of running main fetch given fetchParams and true.
				return mainFetch(fetchParams, true)
			}

			// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch
			async function httpNetworkOrCacheFetch(
				fetchParams,
				isAuthenticationFetch = false,
				isNewConnectionFetch = false,
			) {
				// 1. Let request be fetchParamss request.
				const request = fetchParams.request

				// 2. Let httpFetchParams be null.
				let httpFetchParams = null

				// 3. Let httpRequest be null.
				let httpRequest = null

				// 4. Let response be null.
				let response = null

				// 5. Let storedResponse be null.
				// TODO: cache

				// 6. Let httpCache be null.
				const httpCache = null

				// 7. Let the revalidatingFlag be unset.
				const revalidatingFlag = false

				// 8. Run these steps, but abort when the ongoing fetch is terminated:

				//    1. If requests window is "no-window" and requests redirect mode is
				//    "error", then set httpFetchParams to fetchParams and httpRequest to
				//    request.
				if (request.window === 'no-window' && request.redirect === 'error') {
					httpFetchParams = fetchParams
					httpRequest = request
				} else {
					// Otherwise:

					// 1. Set httpRequest to a clone of request.
					httpRequest = makeRequest(request)

					// 2. Set httpFetchParams to a copy of fetchParams.
					httpFetchParams = { ...fetchParams }

					// 3. Set httpFetchParamss request to httpRequest.
					httpFetchParams.request = httpRequest
				}

				//    3. Let includeCredentials be true if one of
				const includeCredentials =
					request.credentials === 'include' ||
					(request.credentials === 'same-origin' &&
						request.responseTainting === 'basic')

				//    4. Let contentLength be httpRequests bodys length, if httpRequests
				//    body is non-null; otherwise null.
				const contentLength = httpRequest.body ? httpRequest.body.length : null

				//    5. Let contentLengthHeaderValue be null.
				let contentLengthHeaderValue = null

				//    6. If httpRequests body is null and httpRequests method is `POST` or
				//    `PUT`, then set contentLengthHeaderValue to `0`.
				if (
					httpRequest.body == null &&
					['POST', 'PUT'].includes(httpRequest.method)
				) {
					contentLengthHeaderValue = '0'
				}

				//    7. If contentLength is non-null, then set contentLengthHeaderValue to
				//    contentLength, serialized and isomorphic encoded.
				if (contentLength != null) {
					contentLengthHeaderValue = isomorphicEncode(`${contentLength}`)
				}

				//    8. If contentLengthHeaderValue is non-null, then append
				//    `Content-Length`/contentLengthHeaderValue to httpRequests header
				//    list.
				if (contentLengthHeaderValue != null) {
					httpRequest.headersList.append(
						'content-length',
						contentLengthHeaderValue,
					)
				}

				//    9. If contentLengthHeaderValue is non-null, then append (`Content-Length`,
				//    contentLengthHeaderValue) to httpRequests header list.

				//    10. If contentLength is non-null and httpRequests keepalive is true,
				//    then:
				if (contentLength != null && httpRequest.keepalive) {
					// NOTE: keepalive is a noop outside of browser context.
				}

				//    11. If httpRequests referrer is a URL, then append
				//    `Referer`/httpRequests referrer, serialized and isomorphic encoded,
				//     to httpRequests header list.
				if (httpRequest.referrer instanceof URL) {
					httpRequest.headersList.append(
						'referer',
						isomorphicEncode(httpRequest.referrer.href),
					)
				}

				//    12. Append a request `Origin` header for httpRequest.
				appendRequestOriginHeader(httpRequest)

				//    13. Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]
				appendFetchMetadata(httpRequest)

				//    14. If httpRequests header list does not contain `User-Agent`, then
				//    user agents should append `User-Agent`/default `User-Agent` value to
				//    httpRequests header list.
				if (!httpRequest.headersList.contains('user-agent')) {
					httpRequest.headersList.append(
						'user-agent',
						typeof esbuildDetection === 'undefined' ? 'undici' : 'node',
					)
				}

				//    15. If httpRequests cache mode is "default" and httpRequests header
				//    list contains `If-Modified-Since`, `If-None-Match`,
				//    `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set
				//    httpRequests cache mode to "no-store".
				if (
					httpRequest.cache === 'default' &&
					(httpRequest.headersList.contains('if-modified-since') ||
						httpRequest.headersList.contains('if-none-match') ||
						httpRequest.headersList.contains('if-unmodified-since') ||
						httpRequest.headersList.contains('if-match') ||
						httpRequest.headersList.contains('if-range'))
				) {
					httpRequest.cache = 'no-store'
				}

				//    16. If httpRequests cache mode is "no-cache", httpRequests prevent
				//    no-cache cache-control header modification flag is unset, and
				//    httpRequests header list does not contain `Cache-Control`, then append
				//    `Cache-Control`/`max-age=0` to httpRequests header list.
				if (
					httpRequest.cache === 'no-cache' &&
					!httpRequest.preventNoCacheCacheControlHeaderModification &&
					!httpRequest.headersList.contains('cache-control')
				) {
					httpRequest.headersList.append('cache-control', 'max-age=0')
				}

				//    17. If httpRequests cache mode is "no-store" or "reload", then:
				if (
					httpRequest.cache === 'no-store' ||
					httpRequest.cache === 'reload'
				) {
					// 1. If httpRequests header list does not contain `Pragma`, then append
					// `Pragma`/`no-cache` to httpRequests header list.
					if (!httpRequest.headersList.contains('pragma')) {
						httpRequest.headersList.append('pragma', 'no-cache')
					}

					// 2. If httpRequests header list does not contain `Cache-Control`,
					// then append `Cache-Control`/`no-cache` to httpRequests header list.
					if (!httpRequest.headersList.contains('cache-control')) {
						httpRequest.headersList.append('cache-control', 'no-cache')
					}
				}

				//    18. If httpRequests header list contains `Range`, then append
				//    `Accept-Encoding`/`identity` to httpRequests header list.
				if (httpRequest.headersList.contains('range')) {
					httpRequest.headersList.append('accept-encoding', 'identity')
				}

				//    19. Modify httpRequests header list per HTTP. Do not append a given
				//    header if httpRequests header list contains that headers name.
				//    TODO: https://github.com/whatwg/fetch/issues/1285#issuecomment-896560129
				if (!httpRequest.headersList.contains('accept-encoding')) {
					if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
						httpRequest.headersList.append(
							'accept-encoding',
							'br, gzip, deflate',
						)
					} else {
						httpRequest.headersList.append('accept-encoding', 'gzip, deflate')
					}
				}

				httpRequest.headersList.delete('host')

				//    20. If includeCredentials is true, then:
				if (includeCredentials) {
					// 1. If the user agent is not configured to block cookies for httpRequest
					// (see section 7 of [COOKIES]), then:
					// TODO: credentials
					// 2. If httpRequests header list does not contain `Authorization`, then:
					// TODO: credentials
				}

				//    21. If theres a proxy-authentication entry, use it as appropriate.
				//    TODO: proxy-authentication

				//    22. Set httpCache to the result of determining the HTTP cache
				//    partition, given httpRequest.
				//    TODO: cache

				//    23. If httpCache is null, then set httpRequests cache mode to
				//    "no-store".
				if (httpCache == null) {
					httpRequest.cache = 'no-store'
				}

				//    24. If httpRequests cache mode is neither "no-store" nor "reload",
				//    then:
				if (httpRequest.mode !== 'no-store' && httpRequest.mode !== 'reload') {
					// TODO: cache
				}

				// 9. If aborted, then return the appropriate network error for fetchParams.
				// TODO

				// 10. If response is null, then:
				if (response == null) {
					// 1. If httpRequests cache mode is "only-if-cached", then return a
					// network error.
					if (httpRequest.mode === 'only-if-cached') {
						return makeNetworkError('only if cached')
					}

					// 2. Let forwardResponse be the result of running HTTP-network fetch
					// given httpFetchParams, includeCredentials, and isNewConnectionFetch.
					const forwardResponse = await httpNetworkFetch(
						httpFetchParams,
						includeCredentials,
						isNewConnectionFetch,
					)

					// 3. If httpRequests method is unsafe and forwardResponses status is
					// in the range 200 to 399, inclusive, invalidate appropriate stored
					// responses in httpCache, as per the "Invalidation" chapter of HTTP
					// Caching, and set storedResponse to null. [HTTP-CACHING]
					if (
						!safeMethodsSet.has(httpRequest.method) &&
						forwardResponse.status >= 200 &&
						forwardResponse.status <= 399
					) {
						// TODO: cache
					}

					// 4. If the revalidatingFlag is set and forwardResponses status is 304,
					// then:
					if (revalidatingFlag && forwardResponse.status === 304) {
						// TODO: cache
					}

					// 5. If response is null, then:
					if (response == null) {
						// 1. Set response to forwardResponse.
						response = forwardResponse

						// 2. Store httpRequest and forwardResponse in httpCache, as per the
						// "Storing Responses in Caches" chapter of HTTP Caching. [HTTP-CACHING]
						// TODO: cache
					}
				}

				// 11. Set responses URL list to a clone of httpRequests URL list.
				response.urlList = [...httpRequest.urlList]

				// 12. If httpRequests header list contains `Range`, then set responses
				// range-requested flag.
				if (httpRequest.headersList.contains('range')) {
					response.rangeRequested = true
				}

				// 13. Set responses request-includes-credentials to includeCredentials.
				response.requestIncludesCredentials = includeCredentials

				// 14. If responses status is 401, httpRequests response tainting is not
				// "cors", includeCredentials is true, and requests window is an environment
				// settings object, then:
				// TODO

				// 15. If responses status is 407, then:
				if (response.status === 407) {
					// 1. If requests window is "no-window", then return a network error.
					if (request.window === 'no-window') {
						return makeNetworkError()
					}

					// 2. ???

					// 3. If fetchParams is canceled, then return the appropriate network error for fetchParams.
					if (isCancelled(fetchParams)) {
						return makeAppropriateNetworkError(fetchParams)
					}

					// 4. Prompt the end user as appropriate in requests window and store
					// the result as a proxy-authentication entry. [HTTP-AUTH]
					// TODO: Invoke some kind of callback?

					// 5. Set response to the result of running HTTP-network-or-cache fetch given
					// fetchParams.
					// TODO
					return makeNetworkError('proxy authentication required')
				}

				// 16. If all of the following are true
				if (
					// responses status is 421
					response.status === 421 &&
					// isNewConnectionFetch is false
					!isNewConnectionFetch &&
					// requests body is null, or requests body is non-null and requests bodys source is non-null
					(request.body == null || request.body.source != null)
				) {
					// then:

					// 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.
					if (isCancelled(fetchParams)) {
						return makeAppropriateNetworkError(fetchParams)
					}

					// 2. Set response to the result of running HTTP-network-or-cache
					// fetch given fetchParams, isAuthenticationFetch, and true.

					// TODO (spec): The spec doesn't specify this but we need to cancel
					// the active response before we can start a new one.
					// https://github.com/whatwg/fetch/issues/1293
					fetchParams.controller.connection.destroy()

					response = await httpNetworkOrCacheFetch(
						fetchParams,
						isAuthenticationFetch,
						true,
					)
				}

				// 17. If isAuthenticationFetch is true, then create an authentication entry
				if (isAuthenticationFetch) {
					// TODO
				}

				// 18. Return response.
				return response
			}

			// https://fetch.spec.whatwg.org/#http-network-fetch
			async function httpNetworkFetch(
				fetchParams,
				includeCredentials = false,
				forceNewConnection = false,
			) {
				assert(
					!fetchParams.controller.connection ||
						fetchParams.controller.connection.destroyed,
				)

				fetchParams.controller.connection = {
					abort: null,
					destroyed: false,
					destroy(err) {
						if (!this.destroyed) {
							this.destroyed = true
							this.abort?.(
								err ??
									new DOMException('The operation was aborted.', 'AbortError'),
							)
						}
					},
				}

				// 1. Let request be fetchParamss request.
				const request = fetchParams.request

				// 2. Let response be null.
				let response = null

				// 3. Let timingInfo be fetchParamss timing info.
				const timingInfo = fetchParams.timingInfo

				// 4. Let httpCache be the result of determining the HTTP cache partition,
				// given request.
				// TODO: cache
				const httpCache = null

				// 5. If httpCache is null, then set requests cache mode to "no-store".
				if (httpCache == null) {
					request.cache = 'no-store'
				}

				// 6. Let networkPartitionKey be the result of determining the network
				// partition key given request.
				// TODO

				// 7. Let newConnection be "yes" if forceNewConnection is true; otherwise
				// "no".
				const newConnection = forceNewConnection ? 'yes' : 'no' // eslint-disable-line no-unused-vars

				// 8. Switch on requests mode:
				if (request.mode === 'websocket') {
					// Let connection be the result of obtaining a WebSocket connection,
					// given requests current URL.
					// TODO
				} else {
					// Let connection be the result of obtaining a connection, given
					// networkPartitionKey, requests current URLs origin,
					// includeCredentials, and forceNewConnection.
					// TODO
				}

				// 9. Run these steps, but abort when the ongoing fetch is terminated:

				//    1. If connection is failure, then return a network error.

				//    2. Set timingInfos final connection timing info to the result of
				//    calling clamp and coarsen connection timing info with connections
				//    timing info, timingInfos post-redirect start time, and fetchParamss
				//    cross-origin isolated capability.

				//    3. If connection is not an HTTP/2 connection, requests body is non-null,
				//    and requests bodys source is null, then append (`Transfer-Encoding`,
				//    `chunked`) to requests header list.

				//    4. Set timingInfos final network-request start time to the coarsened
				//    shared current time given fetchParamss cross-origin isolated
				//    capability.

				//    5. Set response to the result of making an HTTP request over connection
				//    using request with the following caveats:

				//        - Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS]
				//        [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]

				//        - If requests body is non-null, and requests bodys source is null,
				//        then the user agent may have a buffer of up to 64 kibibytes and store
				//        a part of requests body in that buffer. If the user agent reads from
				//        requests body beyond that buffers size and the user agent needs to
				//        resend request, then instead return a network error.

				//        - Set timingInfos final network-response start time to the coarsened
				//        shared current time given fetchParamss cross-origin isolated capability,
				//        immediately after the user agents HTTP parser receives the first byte
				//        of the response (e.g., frame header bytes for HTTP/2 or response status
				//        line for HTTP/1.x).

				//        - Wait until all the headers are transmitted.

				//        - Any responses whose status is in the range 100 to 199, inclusive,
				//        and is not 101, are to be ignored, except for the purposes of setting
				//        timingInfos final network-response start time above.

				//    - If requests header list contains `Transfer-Encoding`/`chunked` and
				//    response is transferred via HTTP/1.0 or older, then return a network
				//    error.

				//    - If the HTTP request results in a TLS client certificate dialog, then:

				//        1. If requests window is an environment settings object, make the
				//        dialog available in requests window.

				//        2. Otherwise, return a network error.

				// To transmit requests body body, run these steps:
				let requestBody = null
				// 1. If body is null and fetchParamss process request end-of-body is
				// non-null, then queue a fetch task given fetchParamss process request
				// end-of-body and fetchParamss task destination.
				if (request.body == null && fetchParams.processRequestEndOfBody) {
					queueMicrotask(() => fetchParams.processRequestEndOfBody())
				} else if (request.body != null) {
					// 2. Otherwise, if body is non-null:

					//    1. Let processBodyChunk given bytes be these steps:
					const processBodyChunk = async function* (bytes) {
						// 1. If the ongoing fetch is terminated, then abort these steps.
						if (isCancelled(fetchParams)) {
							return
						}

						// 2. Run this step in parallel: transmit bytes.
						yield bytes

						// 3. If fetchParamss process request body is non-null, then run
						// fetchParamss process request body given bytess length.
						fetchParams.processRequestBodyChunkLength?.(bytes.byteLength)
					}

					// 2. Let processEndOfBody be these steps:
					const processEndOfBody = () => {
						// 1. If fetchParams is canceled, then abort these steps.
						if (isCancelled(fetchParams)) {
							return
						}

						// 2. If fetchParamss process request end-of-body is non-null,
						// then run fetchParamss process request end-of-body.
						if (fetchParams.processRequestEndOfBody) {
							fetchParams.processRequestEndOfBody()
						}
					}

					// 3. Let processBodyError given e be these steps:
					const processBodyError = (e) => {
						// 1. If fetchParams is canceled, then abort these steps.
						if (isCancelled(fetchParams)) {
							return
						}

						// 2. If e is an "AbortError" DOMException, then abort fetchParamss controller.
						if (e.name === 'AbortError') {
							fetchParams.controller.abort()
						} else {
							fetchParams.controller.terminate(e)
						}
					}

					// 4. Incrementally read requests body given processBodyChunk, processEndOfBody,
					// processBodyError, and fetchParamss task destination.
					requestBody = (async function* () {
						try {
							for await (const bytes of request.body.stream) {
								yield* processBodyChunk(bytes)
							}
							processEndOfBody()
						} catch (err) {
							processBodyError(err)
						}
					})()
				}

				try {
					// socket is only provided for websockets
					const { body, status, statusText, headersList, socket } =
						await dispatch({ body: requestBody })

					if (socket) {
						response = makeResponse({ status, statusText, headersList, socket })
					} else {
						const iterator = body[Symbol.asyncIterator]()
						fetchParams.controller.next = () => iterator.next()

						response = makeResponse({ status, statusText, headersList })
					}
				} catch (err) {
					// 10. If aborted, then:
					if (err.name === 'AbortError') {
						// 1. If connection uses HTTP/2, then transmit an RST_STREAM frame.
						fetchParams.controller.connection.destroy()

						// 2. Return the appropriate network error for fetchParams.
						return makeAppropriateNetworkError(fetchParams, err)
					}

					return makeNetworkError(err)
				}

				// 11. Let pullAlgorithm be an action that resumes the ongoing fetch
				// if it is suspended.
				const pullAlgorithm = () => {
					fetchParams.controller.resume()
				}

				// 12. Let cancelAlgorithm be an algorithm that aborts fetchParamss
				// controller with reason, given reason.
				const cancelAlgorithm = (reason) => {
					fetchParams.controller.abort(reason)
				}

				// 13. Let highWaterMark be a non-negative, non-NaN number, chosen by
				// the user agent.
				// TODO

				// 14. Let sizeAlgorithm be an algorithm that accepts a chunk object
				// and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.
				// TODO

				// 15. Let stream be a new ReadableStream.
				// 16. Set up stream with pullAlgorithm set to pullAlgorithm,
				// cancelAlgorithm set to cancelAlgorithm, highWaterMark set to
				// highWaterMark, and sizeAlgorithm set to sizeAlgorithm.
				if (!ReadableStream) {
					ReadableStream = __nccwpck_require__(63774).ReadableStream
				}

				const stream = new ReadableStream(
					{
						async start(controller) {
							fetchParams.controller.controller = controller
						},
						async pull(controller) {
							await pullAlgorithm(controller)
						},
						async cancel(reason) {
							await cancelAlgorithm(reason)
						},
					},
					{
						highWaterMark: 0,
						size() {
							return 1
						},
					},
				)

				// 17. Run these steps, but abort when the ongoing fetch is terminated:

				//    1. Set responses body to a new body whose stream is stream.
				response.body = { stream }

				//    2. If response is not a network error and requests cache mode is
				//    not "no-store", then update response in httpCache for request.
				//    TODO

				//    3. If includeCredentials is true and the user agent is not configured
				//    to block cookies for request (see section 7 of [COOKIES]), then run the
				//    "set-cookie-string" parsing algorithm (see section 5.2 of [COOKIES]) on
				//    the value of each header whose name is a byte-case-insensitive match for
				//    `Set-Cookie` in responses header list, if any, and requests current URL.
				//    TODO

				// 18. If aborted, then:
				// TODO

				// 19. Run these steps in parallel:

				//    1. Run these steps, but abort when fetchParams is canceled:
				fetchParams.controller.on('terminated', onAborted)
				fetchParams.controller.resume = async () => {
					// 1. While true
					while (true) {
						// 1-3. See onData...

						// 4. Set bytes to the result of handling content codings given
						// codings and bytes.
						let bytes
						let isFailure
						try {
							const { done, value } = await fetchParams.controller.next()

							if (isAborted(fetchParams)) {
								break
							}

							bytes = done ? undefined : value
						} catch (err) {
							if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
								// zlib doesn't like empty streams.
								bytes = undefined
							} else {
								bytes = err

								// err may be propagated from the result of calling readablestream.cancel,
								// which might not be an error. https://github.com/nodejs/undici/issues/2009
								isFailure = true
							}
						}

						if (bytes === undefined) {
							// 2. Otherwise, if the bytes transmission for responses message
							// body is done normally and stream is readable, then close
							// stream, finalize response for fetchParams and response, and
							// abort these in-parallel steps.
							readableStreamClose(fetchParams.controller.controller)

							finalizeResponse(fetchParams, response)

							return
						}

						// 5. Increase timingInfos decoded body size by bytess length.
						timingInfo.decodedBodySize += bytes?.byteLength ?? 0

						// 6. If bytes is failure, then terminate fetchParamss controller.
						if (isFailure) {
							fetchParams.controller.terminate(bytes)
							return
						}

						// 7. Enqueue a Uint8Array wrapping an ArrayBuffer containing bytes
						// into stream.
						fetchParams.controller.controller.enqueue(new Uint8Array(bytes))

						// 8. If stream is errored, then terminate the ongoing fetch.
						if (isErrored(stream)) {
							fetchParams.controller.terminate()
							return
						}

						// 9. If stream doesnt need more data ask the user agent to suspend
						// the ongoing fetch.
						if (!fetchParams.controller.controller.desiredSize) {
							return
						}
					}
				}

				//    2. If aborted, then:
				function onAborted(reason) {
					// 2. If fetchParams is aborted, then:
					if (isAborted(fetchParams)) {
						// 1. Set responses aborted flag.
						response.aborted = true

						// 2. If stream is readable, then error stream with the result of
						//    deserialize a serialized abort reason given fetchParamss
						//    controllers serialized abort reason and an
						//    implementation-defined realm.
						if (isReadable(stream)) {
							fetchParams.controller.controller.error(
								fetchParams.controller.serializedAbortReason,
							)
						}
					} else {
						// 3. Otherwise, if stream is readable, error stream with a TypeError.
						if (isReadable(stream)) {
							fetchParams.controller.controller.error(
								new TypeError('terminated', {
									cause: isErrorLike(reason) ? reason : undefined,
								}),
							)
						}
					}

					// 4. If connection uses HTTP/2, then transmit an RST_STREAM frame.
					// 5. Otherwise, the user agent should close connection unless it would be bad for performance to do so.
					fetchParams.controller.connection.destroy()
				}

				// 20. Return response.
				return response

				async function dispatch({ body }) {
					const url = requestCurrentURL(request)
					/** @type {import('../..').Agent} */
					const agent = fetchParams.controller.dispatcher

					return new Promise((resolve, reject) =>
						agent.dispatch(
							{
								path: url.pathname + url.search,
								origin: url.origin,
								method: request.method,
								body: fetchParams.controller.dispatcher.isMockActive
									? request.body && (request.body.source || request.body.stream)
									: body,
								headers: request.headersList.entries,
								maxRedirections: 0,
								upgrade: request.mode === 'websocket' ? 'websocket' : undefined,
							},
							{
								body: null,
								abort: null,

								onConnect(abort) {
									// TODO (fix): Do we need connection here?
									const { connection } = fetchParams.controller

									if (connection.destroyed) {
										abort(
											new DOMException(
												'The operation was aborted.',
												'AbortError',
											),
										)
									} else {
										fetchParams.controller.on('terminated', abort)
										this.abort = connection.abort = abort
									}
								},

								onHeaders(status, headersList, resume, statusText) {
									if (status < 200) {
										return
									}

									let codings = []
									let location = ''

									const headers = new Headers()

									// For H2, the headers are a plain JS object
									// We distinguish between them and iterate accordingly
									if (Array.isArray(headersList)) {
										for (let n = 0; n < headersList.length; n += 2) {
											const key = headersList[n + 0].toString('latin1')
											const val = headersList[n + 1].toString('latin1')
											if (key.toLowerCase() === 'content-encoding') {
												// https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1
												// "All content-coding values are case-insensitive..."
												codings = val
													.toLowerCase()
													.split(',')
													.map((x) => x.trim())
											} else if (key.toLowerCase() === 'location') {
												location = val
											}

											headers[kHeadersList].append(key, val)
										}
									} else {
										const keys = Object.keys(headersList)
										for (const key of keys) {
											const val = headersList[key]
											if (key.toLowerCase() === 'content-encoding') {
												// https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1
												// "All content-coding values are case-insensitive..."
												codings = val
													.toLowerCase()
													.split(',')
													.map((x) => x.trim())
													.reverse()
											} else if (key.toLowerCase() === 'location') {
												location = val
											}

											headers[kHeadersList].append(key, val)
										}
									}

									this.body = new Readable({ read: resume })

									const decoders = []

									const willFollow =
										request.redirect === 'follow' &&
										location &&
										redirectStatusSet.has(status)

									// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding
									if (
										request.method !== 'HEAD' &&
										request.method !== 'CONNECT' &&
										!nullBodyStatus.includes(status) &&
										!willFollow
									) {
										for (const coding of codings) {
											// https://www.rfc-editor.org/rfc/rfc9112.html#section-7.2
											if (coding === 'x-gzip' || coding === 'gzip') {
												decoders.push(
													zlib.createGunzip({
														// Be less strict when decoding compressed responses, since sometimes
														// servers send slightly invalid responses that are still accepted
														// by common browsers.
														// Always using Z_SYNC_FLUSH is what cURL does.
														flush: zlib.constants.Z_SYNC_FLUSH,
														finishFlush: zlib.constants.Z_SYNC_FLUSH,
													}),
												)
											} else if (coding === 'deflate') {
												decoders.push(zlib.createInflate())
											} else if (coding === 'br') {
												decoders.push(zlib.createBrotliDecompress())
											} else {
												decoders.length = 0
												break
											}
										}
									}

									resolve({
										status,
										statusText,
										headersList: headers[kHeadersList],
										body: decoders.length
											? pipeline(this.body, ...decoders, () => {})
											: this.body.on('error', () => {}),
									})

									return true
								},

								onData(chunk) {
									if (fetchParams.controller.dump) {
										return
									}

									// 1. If one or more bytes have been transmitted from responses
									// message body, then:

									//  1. Let bytes be the transmitted bytes.
									const bytes = chunk

									//  2. Let codings be the result of extracting header list values
									//  given `Content-Encoding` and responses header list.
									//  See pullAlgorithm.

									//  3. Increase timingInfos encoded body size by bytess length.
									timingInfo.encodedBodySize += bytes.byteLength

									//  4. See pullAlgorithm...

									return this.body.push(bytes)
								},

								onComplete() {
									if (this.abort) {
										fetchParams.controller.off('terminated', this.abort)
									}

									fetchParams.controller.ended = true

									this.body.push(null)
								},

								onError(error) {
									if (this.abort) {
										fetchParams.controller.off('terminated', this.abort)
									}

									this.body?.destroy(error)

									fetchParams.controller.terminate(error)

									reject(error)
								},

								onUpgrade(status, headersList, socket) {
									if (status !== 101) {
										return
									}

									const headers = new Headers()

									for (let n = 0; n < headersList.length; n += 2) {
										const key = headersList[n + 0].toString('latin1')
										const val = headersList[n + 1].toString('latin1')

										headers[kHeadersList].append(key, val)
									}

									resolve({
										status,
										statusText: STATUS_CODES[status],
										headersList: headers[kHeadersList],
										socket,
									})

									return true
								},
							},
						),
					)
				}
			}

			module.exports = {
				fetch,
				Fetch,
				fetching,
				finalizeAndReportTiming,
			}

			/***/
		},

		/***/ 25194: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'
			/* globals AbortController */

			const { extractBody, mixinBody, cloneBody } = __nccwpck_require__(8923)
			const {
				Headers,
				fill: fillHeaders,
				HeadersList,
			} = __nccwpck_require__(26349)
			const { FinalizationRegistry } = __nccwpck_require__(13194)()
			const util = __nccwpck_require__(3440)
			const {
				isValidHTTPToken,
				sameOrigin,
				normalizeMethod,
				makePolicyContainer,
				normalizeMethodRecord,
			} = __nccwpck_require__(15523)
			const {
				forbiddenMethodsSet,
				corsSafeListedMethodsSet,
				referrerPolicy,
				requestRedirect,
				requestMode,
				requestCredentials,
				requestCache,
				requestDuplex,
			} = __nccwpck_require__(87326)
			const { kEnumerableProperty } = util
			const { kHeaders, kSignal, kState, kGuard, kRealm } =
				__nccwpck_require__(89710)
			const { webidl } = __nccwpck_require__(74222)
			const { getGlobalOrigin } = __nccwpck_require__(75628)
			const { URLSerializer } = __nccwpck_require__(94322)
			const { kHeadersList, kConstruct } = __nccwpck_require__(36443)
			const assert = __nccwpck_require__(42613)
			const {
				getMaxListeners,
				setMaxListeners,
				getEventListeners,
				defaultMaxListeners,
			} = __nccwpck_require__(24434)

			let TransformStream = globalThis.TransformStream

			const kAbortController = Symbol('abortController')

			const requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
				signal.removeEventListener('abort', abort)
			})

			// https://fetch.spec.whatwg.org/#request-class
			class Request {
				// https://fetch.spec.whatwg.org/#dom-request
				constructor(input, init = {}) {
					if (input === kConstruct) {
						return
					}

					webidl.argumentLengthCheck(arguments, 1, {
						header: 'Request constructor',
					})

					input = webidl.converters.RequestInfo(input)
					init = webidl.converters.RequestInit(init)

					// https://html.spec.whatwg.org/multipage/webappapis.html#environment-settings-object
					this[kRealm] = {
						settingsObject: {
							baseUrl: getGlobalOrigin(),
							get origin() {
								return this.baseUrl?.origin
							},
							policyContainer: makePolicyContainer(),
						},
					}

					// 1. Let request be null.
					let request = null

					// 2. Let fallbackMode be null.
					let fallbackMode = null

					// 3. Let baseURL be thiss relevant settings objects API base URL.
					const baseUrl = this[kRealm].settingsObject.baseUrl

					// 4. Let signal be null.
					let signal = null

					// 5. If input is a string, then:
					if (typeof input === 'string') {
						// 1. Let parsedURL be the result of parsing input with baseURL.
						// 2. If parsedURL is failure, then throw a TypeError.
						let parsedURL
						try {
							parsedURL = new URL(input, baseUrl)
						} catch (err) {
							throw new TypeError('Failed to parse URL from ' + input, {
								cause: err,
							})
						}

						// 3. If parsedURL includes credentials, then throw a TypeError.
						if (parsedURL.username || parsedURL.password) {
							throw new TypeError(
								'Request cannot be constructed from a URL that includes credentials: ' +
									input,
							)
						}

						// 4. Set request to a new request whose URL is parsedURL.
						request = makeRequest({ urlList: [parsedURL] })

						// 5. Set fallbackMode to "cors".
						fallbackMode = 'cors'
					} else {
						// 6. Otherwise:

						// 7. Assert: input is a Request object.
						assert(input instanceof Request)

						// 8. Set request to inputs request.
						request = input[kState]

						// 9. Set signal to inputs signal.
						signal = input[kSignal]
					}

					// 7. Let origin be thiss relevant settings objects origin.
					const origin = this[kRealm].settingsObject.origin

					// 8. Let window be "client".
					let window = 'client'

					// 9. If requests window is an environment settings object and its origin
					// is same origin with origin, then set window to requests window.
					if (
						request.window?.constructor?.name === 'EnvironmentSettingsObject' &&
						sameOrigin(request.window, origin)
					) {
						window = request.window
					}

					// 10. If init["window"] exists and is non-null, then throw a TypeError.
					if (init.window != null) {
						throw new TypeError(`'window' option '${window}' must be null`)
					}

					// 11. If init["window"] exists, then set window to "no-window".
					if ('window' in init) {
						window = 'no-window'
					}

					// 12. Set request to a new request with the following properties:
					request = makeRequest({
						// URL requests URL.
						// undici implementation note: this is set as the first item in request's urlList in makeRequest
						// method requests method.
						method: request.method,
						// header list A copy of requests header list.
						// undici implementation note: headersList is cloned in makeRequest
						headersList: request.headersList,
						// unsafe-request flag Set.
						unsafeRequest: request.unsafeRequest,
						// client Thiss relevant settings object.
						client: this[kRealm].settingsObject,
						// window window.
						window,
						// priority requests priority.
						priority: request.priority,
						// origin requests origin. The propagation of the origin is only significant for navigation requests
						// being handled by a service worker. In this scenario a request can have an origin that is different
						// from the current client.
						origin: request.origin,
						// referrer requests referrer.
						referrer: request.referrer,
						// referrer policy requests referrer policy.
						referrerPolicy: request.referrerPolicy,
						// mode requests mode.
						mode: request.mode,
						// credentials mode requests credentials mode.
						credentials: request.credentials,
						// cache mode requests cache mode.
						cache: request.cache,
						// redirect mode requests redirect mode.
						redirect: request.redirect,
						// integrity metadata requests integrity metadata.
						integrity: request.integrity,
						// keepalive requests keepalive.
						keepalive: request.keepalive,
						// reload-navigation flag requests reload-navigation flag.
						reloadNavigation: request.reloadNavigation,
						// history-navigation flag requests history-navigation flag.
						historyNavigation: request.historyNavigation,
						// URL list A clone of requests URL list.
						urlList: [...request.urlList],
					})

					const initHasKey = Object.keys(init).length !== 0

					// 13. If init is not empty, then:
					if (initHasKey) {
						// 1. If requests mode is "navigate", then set it to "same-origin".
						if (request.mode === 'navigate') {
							request.mode = 'same-origin'
						}

						// 2. Unset requests reload-navigation flag.
						request.reloadNavigation = false

						// 3. Unset requests history-navigation flag.
						request.historyNavigation = false

						// 4. Set requests origin to "client".
						request.origin = 'client'

						// 5. Set requests referrer to "client"
						request.referrer = 'client'

						// 6. Set requests referrer policy to the empty string.
						request.referrerPolicy = ''

						// 7. Set requests URL to requests current URL.
						request.url = request.urlList[request.urlList.length - 1]

						// 8. Set requests URL list to  requests URL .
						request.urlList = [request.url]
					}

					// 14. If init["referrer"] exists, then:
					if (init.referrer !== undefined) {
						// 1. Let referrer be init["referrer"].
						const referrer = init.referrer

						// 2. If referrer is the empty string, then set requests referrer to "no-referrer".
						if (referrer === '') {
							request.referrer = 'no-referrer'
						} else {
							// 1. Let parsedReferrer be the result of parsing referrer with
							// baseURL.
							// 2. If parsedReferrer is failure, then throw a TypeError.
							let parsedReferrer
							try {
								parsedReferrer = new URL(referrer, baseUrl)
							} catch (err) {
								throw new TypeError(
									`Referrer "${referrer}" is not a valid URL.`,
									{ cause: err },
								)
							}

							// 3. If one of the following is true
							// - parsedReferrers scheme is "about" and path is the string "client"
							// - parsedReferrers origin is not same origin with origin
							// then set requests referrer to "client".
							if (
								(parsedReferrer.protocol === 'about:' &&
									parsedReferrer.hostname === 'client') ||
								(origin &&
									!sameOrigin(
										parsedReferrer,
										this[kRealm].settingsObject.baseUrl,
									))
							) {
								request.referrer = 'client'
							} else {
								// 4. Otherwise, set requests referrer to parsedReferrer.
								request.referrer = parsedReferrer
							}
						}
					}

					// 15. If init["referrerPolicy"] exists, then set requests referrer policy
					// to it.
					if (init.referrerPolicy !== undefined) {
						request.referrerPolicy = init.referrerPolicy
					}

					// 16. Let mode be init["mode"] if it exists, and fallbackMode otherwise.
					let mode
					if (init.mode !== undefined) {
						mode = init.mode
					} else {
						mode = fallbackMode
					}

					// 17. If mode is "navigate", then throw a TypeError.
					if (mode === 'navigate') {
						throw webidl.errors.exception({
							header: 'Request constructor',
							message: 'invalid request mode navigate.',
						})
					}

					// 18. If mode is non-null, set requests mode to mode.
					if (mode != null) {
						request.mode = mode
					}

					// 19. If init["credentials"] exists, then set requests credentials mode
					// to it.
					if (init.credentials !== undefined) {
						request.credentials = init.credentials
					}

					// 18. If init["cache"] exists, then set requests cache mode to it.
					if (init.cache !== undefined) {
						request.cache = init.cache
					}

					// 21. If requests cache mode is "only-if-cached" and requests mode is
					// not "same-origin", then throw a TypeError.
					if (
						request.cache === 'only-if-cached' &&
						request.mode !== 'same-origin'
					) {
						throw new TypeError(
							"'only-if-cached' can be set only with 'same-origin' mode",
						)
					}

					// 22. If init["redirect"] exists, then set requests redirect mode to it.
					if (init.redirect !== undefined) {
						request.redirect = init.redirect
					}

					// 23. If init["integrity"] exists, then set requests integrity metadata to it.
					if (init.integrity != null) {
						request.integrity = String(init.integrity)
					}

					// 24. If init["keepalive"] exists, then set requests keepalive to it.
					if (init.keepalive !== undefined) {
						request.keepalive = Boolean(init.keepalive)
					}

					// 25. If init["method"] exists, then:
					if (init.method !== undefined) {
						// 1. Let method be init["method"].
						let method = init.method

						// 2. If method is not a method or method is a forbidden method, then
						// throw a TypeError.
						if (!isValidHTTPToken(method)) {
							throw new TypeError(`'${method}' is not a valid HTTP method.`)
						}

						if (forbiddenMethodsSet.has(method.toUpperCase())) {
							throw new TypeError(`'${method}' HTTP method is unsupported.`)
						}

						// 3. Normalize method.
						method = normalizeMethodRecord[method] ?? normalizeMethod(method)

						// 4. Set requests method to method.
						request.method = method
					}

					// 26. If init["signal"] exists, then set signal to it.
					if (init.signal !== undefined) {
						signal = init.signal
					}

					// 27. Set thiss request to request.
					this[kState] = request

					// 28. Set thiss signal to a new AbortSignal object with thiss relevant
					// Realm.
					// TODO: could this be simplified with AbortSignal.any
					// (https://dom.spec.whatwg.org/#dom-abortsignal-any)
					const ac = new AbortController()
					this[kSignal] = ac.signal
					this[kSignal][kRealm] = this[kRealm]

					// 29. If signal is not null, then make thiss signal follow signal.
					if (signal != null) {
						if (
							!signal ||
							typeof signal.aborted !== 'boolean' ||
							typeof signal.addEventListener !== 'function'
						) {
							throw new TypeError(
								"Failed to construct 'Request': member signal is not of type AbortSignal.",
							)
						}

						if (signal.aborted) {
							ac.abort(signal.reason)
						} else {
							// Keep a strong ref to ac while request object
							// is alive. This is needed to prevent AbortController
							// from being prematurely garbage collected.
							// See, https://github.com/nodejs/undici/issues/1926.
							this[kAbortController] = ac

							const acRef = new WeakRef(ac)
							const abort = function () {
								const ac = acRef.deref()
								if (ac !== undefined) {
									ac.abort(this.reason)
								}
							}

							// Third-party AbortControllers may not work with these.
							// See, https://github.com/nodejs/undici/pull/1910#issuecomment-1464495619.
							try {
								// If the max amount of listeners is equal to the default, increase it
								// This is only available in node >= v19.9.0
								if (
									typeof getMaxListeners === 'function' &&
									getMaxListeners(signal) === defaultMaxListeners
								) {
									setMaxListeners(100, signal)
								} else if (
									getEventListeners(signal, 'abort').length >=
									defaultMaxListeners
								) {
									setMaxListeners(100, signal)
								}
							} catch {}

							util.addAbortListener(signal, abort)
							requestFinalizer.register(ac, { signal, abort })
						}
					}

					// 30. Set thiss headers to a new Headers object with thiss relevant
					// Realm, whose header list is requests header list and guard is
					// "request".
					this[kHeaders] = new Headers(kConstruct)
					this[kHeaders][kHeadersList] = request.headersList
					this[kHeaders][kGuard] = 'request'
					this[kHeaders][kRealm] = this[kRealm]

					// 31. If thiss requests mode is "no-cors", then:
					if (mode === 'no-cors') {
						// 1. If thiss requests method is not a CORS-safelisted method,
						// then throw a TypeError.
						if (!corsSafeListedMethodsSet.has(request.method)) {
							throw new TypeError(
								`'${request.method} is unsupported in no-cors mode.`,
							)
						}

						// 2. Set thiss headerss guard to "request-no-cors".
						this[kHeaders][kGuard] = 'request-no-cors'
					}

					// 32. If init is not empty, then:
					if (initHasKey) {
						/** @type {HeadersList} */
						const headersList = this[kHeaders][kHeadersList]
						// 1. Let headers be a copy of thiss headers and its associated header
						// list.
						// 2. If init["headers"] exists, then set headers to init["headers"].
						const headers =
							init.headers !== undefined
								? init.headers
								: new HeadersList(headersList)

						// 3. Empty thiss headerss header list.
						headersList.clear()

						// 4. If headers is a Headers object, then for each header in its header
						// list, append headers name/headers value to thiss headers.
						if (headers instanceof HeadersList) {
							for (const [key, val] of headers) {
								headersList.append(key, val)
							}
							// Note: Copy the `set-cookie` meta-data.
							headersList.cookies = headers.cookies
						} else {
							// 5. Otherwise, fill thiss headers with headers.
							fillHeaders(this[kHeaders], headers)
						}
					}

					// 33. Let inputBody be inputs requests body if input is a Request
					// object; otherwise null.
					const inputBody = input instanceof Request ? input[kState].body : null

					// 34. If either init["body"] exists and is non-null or inputBody is
					// non-null, and requests method is `GET` or `HEAD`, then throw a
					// TypeError.
					if (
						(init.body != null || inputBody != null) &&
						(request.method === 'GET' || request.method === 'HEAD')
					) {
						throw new TypeError(
							'Request with GET/HEAD method cannot have body.',
						)
					}

					// 35. Let initBody be null.
					let initBody = null

					// 36. If init["body"] exists and is non-null, then:
					if (init.body != null) {
						// 1. Let Content-Type be null.
						// 2. Set initBody and Content-Type to the result of extracting
						// init["body"], with keepalive set to requests keepalive.
						const [extractedBody, contentType] = extractBody(
							init.body,
							request.keepalive,
						)
						initBody = extractedBody

						// 3, If Content-Type is non-null and thiss headerss header list does
						// not contain `Content-Type`, then append `Content-Type`/Content-Type to
						// thiss headers.
						if (
							contentType &&
							!this[kHeaders][kHeadersList].contains('content-type')
						) {
							this[kHeaders].append('content-type', contentType)
						}
					}

					// 37. Let inputOrInitBody be initBody if it is non-null; otherwise
					// inputBody.
					const inputOrInitBody = initBody ?? inputBody

					// 38. If inputOrInitBody is non-null and inputOrInitBodys source is
					// null, then:
					if (inputOrInitBody != null && inputOrInitBody.source == null) {
						// 1. If initBody is non-null and init["duplex"] does not exist,
						//    then throw a TypeError.
						if (initBody != null && init.duplex == null) {
							throw new TypeError(
								'RequestInit: duplex option is required when sending a body.',
							)
						}

						// 2. If thiss requests mode is neither "same-origin" nor "cors",
						// then throw a TypeError.
						if (request.mode !== 'same-origin' && request.mode !== 'cors') {
							throw new TypeError(
								'If request is made from ReadableStream, mode should be "same-origin" or "cors"',
							)
						}

						// 3. Set thiss requests use-CORS-preflight flag.
						request.useCORSPreflightFlag = true
					}

					// 39. Let finalBody be inputOrInitBody.
					let finalBody = inputOrInitBody

					// 40. If initBody is null and inputBody is non-null, then:
					if (initBody == null && inputBody != null) {
						// 1. If input is unusable, then throw a TypeError.
						if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
							throw new TypeError(
								'Cannot construct a Request with a Request object that has already been used.',
							)
						}

						// 2. Set finalBody to the result of creating a proxy for inputBody.
						if (!TransformStream) {
							TransformStream = __nccwpck_require__(63774).TransformStream
						}

						// https://streams.spec.whatwg.org/#readablestream-create-a-proxy
						const identityTransform = new TransformStream()
						inputBody.stream.pipeThrough(identityTransform)
						finalBody = {
							source: inputBody.source,
							length: inputBody.length,
							stream: identityTransform.readable,
						}
					}

					// 41. Set thiss requests body to finalBody.
					this[kState].body = finalBody
				}

				// Returns requests HTTP method, which is "GET" by default.
				get method() {
					webidl.brandCheck(this, Request)

					// The method getter steps are to return thiss requests method.
					return this[kState].method
				}

				// Returns the URL of request as a string.
				get url() {
					webidl.brandCheck(this, Request)

					// The url getter steps are to return thiss requests URL, serialized.
					return URLSerializer(this[kState].url)
				}

				// Returns a Headers object consisting of the headers associated with request.
				// Note that headers added in the network layer by the user agent will not
				// be accounted for in this object, e.g., the "Host" header.
				get headers() {
					webidl.brandCheck(this, Request)

					// The headers getter steps are to return thiss headers.
					return this[kHeaders]
				}

				// Returns the kind of resource requested by request, e.g., "document"
				// or "script".
				get destination() {
					webidl.brandCheck(this, Request)

					// The destination getter are to return thiss requests destination.
					return this[kState].destination
				}

				// Returns the referrer of request. Its value can be a same-origin URL if
				// explicitly set in init, the empty string to indicate no referrer, and
				// "about:client" when defaulting to the globals default. This is used
				// during fetching to determine the value of the `Referer` header of the
				// request being made.
				get referrer() {
					webidl.brandCheck(this, Request)

					// 1. If thiss requests referrer is "no-referrer", then return the
					// empty string.
					if (this[kState].referrer === 'no-referrer') {
						return ''
					}

					// 2. If thiss requests referrer is "client", then return
					// "about:client".
					if (this[kState].referrer === 'client') {
						return 'about:client'
					}

					// Return thiss requests referrer, serialized.
					return this[kState].referrer.toString()
				}

				// Returns the referrer policy associated with request.
				// This is used during fetching to compute the value of the requests
				// referrer.
				get referrerPolicy() {
					webidl.brandCheck(this, Request)

					// The referrerPolicy getter steps are to return thiss requests referrer policy.
					return this[kState].referrerPolicy
				}

				// Returns the mode associated with request, which is a string indicating
				// whether the request will use CORS, or will be restricted to same-origin
				// URLs.
				get mode() {
					webidl.brandCheck(this, Request)

					// The mode getter steps are to return thiss requests mode.
					return this[kState].mode
				}

				// Returns the credentials mode associated with request,
				// which is a string indicating whether credentials will be sent with the
				// request always, never, or only when sent to a same-origin URL.
				get credentials() {
					// The credentials getter steps are to return thiss requests credentials mode.
					return this[kState].credentials
				}

				// Returns the cache mode associated with request,
				// which is a string indicating how the request will
				// interact with the browsers cache when fetching.
				get cache() {
					webidl.brandCheck(this, Request)

					// The cache getter steps are to return thiss requests cache mode.
					return this[kState].cache
				}

				// Returns the redirect mode associated with request,
				// which is a string indicating how redirects for the
				// request will be handled during fetching. A request
				// will follow redirects by default.
				get redirect() {
					webidl.brandCheck(this, Request)

					// The redirect getter steps are to return thiss requests redirect mode.
					return this[kState].redirect
				}

				// Returns requests subresource integrity metadata, which is a
				// cryptographic hash of the resource being fetched. Its value
				// consists of multiple hashes separated by whitespace. [SRI]
				get integrity() {
					webidl.brandCheck(this, Request)

					// The integrity getter steps are to return thiss requests integrity
					// metadata.
					return this[kState].integrity
				}

				// Returns a boolean indicating whether or not request can outlive the
				// global in which it was created.
				get keepalive() {
					webidl.brandCheck(this, Request)

					// The keepalive getter steps are to return thiss requests keepalive.
					return this[kState].keepalive
				}

				// Returns a boolean indicating whether or not request is for a reload
				// navigation.
				get isReloadNavigation() {
					webidl.brandCheck(this, Request)

					// The isReloadNavigation getter steps are to return true if thiss
					// requests reload-navigation flag is set; otherwise false.
					return this[kState].reloadNavigation
				}

				// Returns a boolean indicating whether or not request is for a history
				// navigation (a.k.a. back-foward navigation).
				get isHistoryNavigation() {
					webidl.brandCheck(this, Request)

					// The isHistoryNavigation getter steps are to return true if thiss requests
					// history-navigation flag is set; otherwise false.
					return this[kState].historyNavigation
				}

				// Returns the signal associated with request, which is an AbortSignal
				// object indicating whether or not request has been aborted, and its
				// abort event handler.
				get signal() {
					webidl.brandCheck(this, Request)

					// The signal getter steps are to return thiss signal.
					return this[kSignal]
				}

				get body() {
					webidl.brandCheck(this, Request)

					return this[kState].body ? this[kState].body.stream : null
				}

				get bodyUsed() {
					webidl.brandCheck(this, Request)

					return (
						!!this[kState].body && util.isDisturbed(this[kState].body.stream)
					)
				}

				get duplex() {
					webidl.brandCheck(this, Request)

					return 'half'
				}

				// Returns a clone of request.
				clone() {
					webidl.brandCheck(this, Request)

					// 1. If this is unusable, then throw a TypeError.
					if (this.bodyUsed || this.body?.locked) {
						throw new TypeError('unusable')
					}

					// 2. Let clonedRequest be the result of cloning thiss request.
					const clonedRequest = cloneRequest(this[kState])

					// 3. Let clonedRequestObject be the result of creating a Request object,
					// given clonedRequest, thiss headerss guard, and thiss relevant Realm.
					const clonedRequestObject = new Request(kConstruct)
					clonedRequestObject[kState] = clonedRequest
					clonedRequestObject[kRealm] = this[kRealm]
					clonedRequestObject[kHeaders] = new Headers(kConstruct)
					clonedRequestObject[kHeaders][kHeadersList] =
						clonedRequest.headersList
					clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard]
					clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm]

					// 4. Make clonedRequestObjects signal follow thiss signal.
					const ac = new AbortController()
					if (this.signal.aborted) {
						ac.abort(this.signal.reason)
					} else {
						util.addAbortListener(this.signal, () => {
							ac.abort(this.signal.reason)
						})
					}
					clonedRequestObject[kSignal] = ac.signal

					// 4. Return clonedRequestObject.
					return clonedRequestObject
				}
			}

			mixinBody(Request)

			function makeRequest(init) {
				// https://fetch.spec.whatwg.org/#requests
				const request = {
					method: 'GET',
					localURLsOnly: false,
					unsafeRequest: false,
					body: null,
					client: null,
					reservedClient: null,
					replacesClientId: '',
					window: 'client',
					keepalive: false,
					serviceWorkers: 'all',
					initiator: '',
					destination: '',
					priority: null,
					origin: 'client',
					policyContainer: 'client',
					referrer: 'client',
					referrerPolicy: '',
					mode: 'no-cors',
					useCORSPreflightFlag: false,
					credentials: 'same-origin',
					useCredentials: false,
					cache: 'default',
					redirect: 'follow',
					integrity: '',
					cryptoGraphicsNonceMetadata: '',
					parserMetadata: '',
					reloadNavigation: false,
					historyNavigation: false,
					userActivation: false,
					taintedOrigin: false,
					redirectCount: 0,
					responseTainting: 'basic',
					preventNoCacheCacheControlHeaderModification: false,
					done: false,
					timingAllowFailed: false,
					...init,
					headersList: init.headersList
						? new HeadersList(init.headersList)
						: new HeadersList(),
				}
				request.url = request.urlList[0]
				return request
			}

			// https://fetch.spec.whatwg.org/#concept-request-clone
			function cloneRequest(request) {
				// To clone a request request, run these steps:

				// 1. Let newRequest be a copy of request, except for its body.
				const newRequest = makeRequest({ ...request, body: null })

				// 2. If requests body is non-null, set newRequests body to the
				// result of cloning requests body.
				if (request.body != null) {
					newRequest.body = cloneBody(request.body)
				}

				// 3. Return newRequest.
				return newRequest
			}

			Object.defineProperties(Request.prototype, {
				method: kEnumerableProperty,
				url: kEnumerableProperty,
				headers: kEnumerableProperty,
				redirect: kEnumerableProperty,
				clone: kEnumerableProperty,
				signal: kEnumerableProperty,
				duplex: kEnumerableProperty,
				destination: kEnumerableProperty,
				body: kEnumerableProperty,
				bodyUsed: kEnumerableProperty,
				isHistoryNavigation: kEnumerableProperty,
				isReloadNavigation: kEnumerableProperty,
				keepalive: kEnumerableProperty,
				integrity: kEnumerableProperty,
				cache: kEnumerableProperty,
				credentials: kEnumerableProperty,
				attribute: kEnumerableProperty,
				referrerPolicy: kEnumerableProperty,
				referrer: kEnumerableProperty,
				mode: kEnumerableProperty,
				[Symbol.toStringTag]: {
					value: 'Request',
					configurable: true,
				},
			})

			webidl.converters.Request = webidl.interfaceConverter(Request)

			// https://fetch.spec.whatwg.org/#requestinfo
			webidl.converters.RequestInfo = function (V) {
				if (typeof V === 'string') {
					return webidl.converters.USVString(V)
				}

				if (V instanceof Request) {
					return webidl.converters.Request(V)
				}

				return webidl.converters.USVString(V)
			}

			webidl.converters.AbortSignal = webidl.interfaceConverter(AbortSignal)

			// https://fetch.spec.whatwg.org/#requestinit
			webidl.converters.RequestInit = webidl.dictionaryConverter([
				{
					key: 'method',
					converter: webidl.converters.ByteString,
				},
				{
					key: 'headers',
					converter: webidl.converters.HeadersInit,
				},
				{
					key: 'body',
					converter: webidl.nullableConverter(webidl.converters.BodyInit),
				},
				{
					key: 'referrer',
					converter: webidl.converters.USVString,
				},
				{
					key: 'referrerPolicy',
					converter: webidl.converters.DOMString,
					// https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
					allowedValues: referrerPolicy,
				},
				{
					key: 'mode',
					converter: webidl.converters.DOMString,
					// https://fetch.spec.whatwg.org/#concept-request-mode
					allowedValues: requestMode,
				},
				{
					key: 'credentials',
					converter: webidl.converters.DOMString,
					// https://fetch.spec.whatwg.org/#requestcredentials
					allowedValues: requestCredentials,
				},
				{
					key: 'cache',
					converter: webidl.converters.DOMString,
					// https://fetch.spec.whatwg.org/#requestcache
					allowedValues: requestCache,
				},
				{
					key: 'redirect',
					converter: webidl.converters.DOMString,
					// https://fetch.spec.whatwg.org/#requestredirect
					allowedValues: requestRedirect,
				},
				{
					key: 'integrity',
					converter: webidl.converters.DOMString,
				},
				{
					key: 'keepalive',
					converter: webidl.converters.boolean,
				},
				{
					key: 'signal',
					converter: webidl.nullableConverter((signal) =>
						webidl.converters.AbortSignal(signal, { strict: false }),
					),
				},
				{
					key: 'window',
					converter: webidl.converters.any,
				},
				{
					key: 'duplex',
					converter: webidl.converters.DOMString,
					allowedValues: requestDuplex,
				},
			])

			module.exports = { Request, makeRequest }

			/***/
		},

		/***/ 48676: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { Headers, HeadersList, fill } = __nccwpck_require__(26349)
			const { extractBody, cloneBody, mixinBody } = __nccwpck_require__(8923)
			const util = __nccwpck_require__(3440)
			const { kEnumerableProperty } = util
			const {
				isValidReasonPhrase,
				isCancelled,
				isAborted,
				isBlobLike,
				serializeJavascriptValueToJSONString,
				isErrorLike,
				isomorphicEncode,
			} = __nccwpck_require__(15523)
			const { redirectStatusSet, nullBodyStatus, DOMException } =
				__nccwpck_require__(87326)
			const { kState, kHeaders, kGuard, kRealm } = __nccwpck_require__(89710)
			const { webidl } = __nccwpck_require__(74222)
			const { FormData } = __nccwpck_require__(43073)
			const { getGlobalOrigin } = __nccwpck_require__(75628)
			const { URLSerializer } = __nccwpck_require__(94322)
			const { kHeadersList, kConstruct } = __nccwpck_require__(36443)
			const assert = __nccwpck_require__(42613)
			const { types } = __nccwpck_require__(39023)

			const ReadableStream =
				globalThis.ReadableStream || __nccwpck_require__(63774).ReadableStream
			const textEncoder = new TextEncoder('utf-8')

			// https://fetch.spec.whatwg.org/#response-class
			class Response {
				// Creates network error Response.
				static error() {
					// TODO
					const relevantRealm = { settingsObject: {} }

					// The static error() method steps are to return the result of creating a
					// Response object, given a new network error, "immutable", and thiss
					// relevant Realm.
					const responseObject = new Response()
					responseObject[kState] = makeNetworkError()
					responseObject[kRealm] = relevantRealm
					responseObject[kHeaders][kHeadersList] =
						responseObject[kState].headersList
					responseObject[kHeaders][kGuard] = 'immutable'
					responseObject[kHeaders][kRealm] = relevantRealm
					return responseObject
				}

				// https://fetch.spec.whatwg.org/#dom-response-json
				static json(data, init = {}) {
					webidl.argumentLengthCheck(arguments, 1, { header: 'Response.json' })

					if (init !== null) {
						init = webidl.converters.ResponseInit(init)
					}

					// 1. Let bytes the result of running serialize a JavaScript value to JSON bytes on data.
					const bytes = textEncoder.encode(
						serializeJavascriptValueToJSONString(data),
					)

					// 2. Let body be the result of extracting bytes.
					const body = extractBody(bytes)

					// 3. Let responseObject be the result of creating a Response object, given a new response,
					//    "response", and thiss relevant Realm.
					const relevantRealm = { settingsObject: {} }
					const responseObject = new Response()
					responseObject[kRealm] = relevantRealm
					responseObject[kHeaders][kGuard] = 'response'
					responseObject[kHeaders][kRealm] = relevantRealm

					// 4. Perform initialize a response given responseObject, init, and (body, "application/json").
					initializeResponse(responseObject, init, {
						body: body[0],
						type: 'application/json',
					})

					// 5. Return responseObject.
					return responseObject
				}

				// Creates a redirect Response that redirects to url with status status.
				static redirect(url, status = 302) {
					const relevantRealm = { settingsObject: {} }

					webidl.argumentLengthCheck(arguments, 1, {
						header: 'Response.redirect',
					})

					url = webidl.converters.USVString(url)
					status = webidl.converters['unsigned short'](status)

					// 1. Let parsedURL be the result of parsing url with current settings
					// objects API base URL.
					// 2. If parsedURL is failure, then throw a TypeError.
					// TODO: base-URL?
					let parsedURL
					try {
						parsedURL = new URL(url, getGlobalOrigin())
					} catch (err) {
						throw Object.assign(
							new TypeError('Failed to parse URL from ' + url),
							{
								cause: err,
							},
						)
					}

					// 3. If status is not a redirect status, then throw a RangeError.
					if (!redirectStatusSet.has(status)) {
						throw new RangeError('Invalid status code ' + status)
					}

					// 4. Let responseObject be the result of creating a Response object,
					// given a new response, "immutable", and thiss relevant Realm.
					const responseObject = new Response()
					responseObject[kRealm] = relevantRealm
					responseObject[kHeaders][kGuard] = 'immutable'
					responseObject[kHeaders][kRealm] = relevantRealm

					// 5. Set responseObjects responses status to status.
					responseObject[kState].status = status

					// 6. Let value be parsedURL, serialized and isomorphic encoded.
					const value = isomorphicEncode(URLSerializer(parsedURL))

					// 7. Append `Location`/value to responseObjects responses header list.
					responseObject[kState].headersList.append('location', value)

					// 8. Return responseObject.
					return responseObject
				}

				// https://fetch.spec.whatwg.org/#dom-response
				constructor(body = null, init = {}) {
					if (body !== null) {
						body = webidl.converters.BodyInit(body)
					}

					init = webidl.converters.ResponseInit(init)

					// TODO
					this[kRealm] = { settingsObject: {} }

					// 1. Set thiss response to a new response.
					this[kState] = makeResponse({})

					// 2. Set thiss headers to a new Headers object with thiss relevant
					// Realm, whose header list is thiss responses header list and guard
					// is "response".
					this[kHeaders] = new Headers(kConstruct)
					this[kHeaders][kGuard] = 'response'
					this[kHeaders][kHeadersList] = this[kState].headersList
					this[kHeaders][kRealm] = this[kRealm]

					// 3. Let bodyWithType be null.
					let bodyWithType = null

					// 4. If body is non-null, then set bodyWithType to the result of extracting body.
					if (body != null) {
						const [extractedBody, type] = extractBody(body)
						bodyWithType = { body: extractedBody, type }
					}

					// 5. Perform initialize a response given this, init, and bodyWithType.
					initializeResponse(this, init, bodyWithType)
				}

				// Returns responses type, e.g., "cors".
				get type() {
					webidl.brandCheck(this, Response)

					// The type getter steps are to return thiss responses type.
					return this[kState].type
				}

				// Returns responses URL, if it has one; otherwise the empty string.
				get url() {
					webidl.brandCheck(this, Response)

					const urlList = this[kState].urlList

					// The url getter steps are to return the empty string if thiss
					// responses URL is null; otherwise thiss responses URL,
					// serialized with exclude fragment set to true.
					const url = urlList[urlList.length - 1] ?? null

					if (url === null) {
						return ''
					}

					return URLSerializer(url, true)
				}

				// Returns whether response was obtained through a redirect.
				get redirected() {
					webidl.brandCheck(this, Response)

					// The redirected getter steps are to return true if thiss responses URL
					// list has more than one item; otherwise false.
					return this[kState].urlList.length > 1
				}

				// Returns responses status.
				get status() {
					webidl.brandCheck(this, Response)

					// The status getter steps are to return thiss responses status.
					return this[kState].status
				}

				// Returns whether responses status is an ok status.
				get ok() {
					webidl.brandCheck(this, Response)

					// The ok getter steps are to return true if thiss responses status is an
					// ok status; otherwise false.
					return this[kState].status >= 200 && this[kState].status <= 299
				}

				// Returns responses status message.
				get statusText() {
					webidl.brandCheck(this, Response)

					// The statusText getter steps are to return thiss responses status
					// message.
					return this[kState].statusText
				}

				// Returns responses headers as Headers.
				get headers() {
					webidl.brandCheck(this, Response)

					// The headers getter steps are to return thiss headers.
					return this[kHeaders]
				}

				get body() {
					webidl.brandCheck(this, Response)

					return this[kState].body ? this[kState].body.stream : null
				}

				get bodyUsed() {
					webidl.brandCheck(this, Response)

					return (
						!!this[kState].body && util.isDisturbed(this[kState].body.stream)
					)
				}

				// Returns a clone of response.
				clone() {
					webidl.brandCheck(this, Response)

					// 1. If this is unusable, then throw a TypeError.
					if (this.bodyUsed || (this.body && this.body.locked)) {
						throw webidl.errors.exception({
							header: 'Response.clone',
							message: 'Body has already been consumed.',
						})
					}

					// 2. Let clonedResponse be the result of cloning thiss response.
					const clonedResponse = cloneResponse(this[kState])

					// 3. Return the result of creating a Response object, given
					// clonedResponse, thiss headerss guard, and thiss relevant Realm.
					const clonedResponseObject = new Response()
					clonedResponseObject[kState] = clonedResponse
					clonedResponseObject[kRealm] = this[kRealm]
					clonedResponseObject[kHeaders][kHeadersList] =
						clonedResponse.headersList
					clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard]
					clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm]

					return clonedResponseObject
				}
			}

			mixinBody(Response)

			Object.defineProperties(Response.prototype, {
				type: kEnumerableProperty,
				url: kEnumerableProperty,
				status: kEnumerableProperty,
				ok: kEnumerableProperty,
				redirected: kEnumerableProperty,
				statusText: kEnumerableProperty,
				headers: kEnumerableProperty,
				clone: kEnumerableProperty,
				body: kEnumerableProperty,
				bodyUsed: kEnumerableProperty,
				[Symbol.toStringTag]: {
					value: 'Response',
					configurable: true,
				},
			})

			Object.defineProperties(Response, {
				json: kEnumerableProperty,
				redirect: kEnumerableProperty,
				error: kEnumerableProperty,
			})

			// https://fetch.spec.whatwg.org/#concept-response-clone
			function cloneResponse(response) {
				// To clone a response response, run these steps:

				// 1. If response is a filtered response, then return a new identical
				// filtered response whose internal response is a clone of responses
				// internal response.
				if (response.internalResponse) {
					return filterResponse(
						cloneResponse(response.internalResponse),
						response.type,
					)
				}

				// 2. Let newResponse be a copy of response, except for its body.
				const newResponse = makeResponse({ ...response, body: null })

				// 3. If responses body is non-null, then set newResponses body to the
				// result of cloning responses body.
				if (response.body != null) {
					newResponse.body = cloneBody(response.body)
				}

				// 4. Return newResponse.
				return newResponse
			}

			function makeResponse(init) {
				return {
					aborted: false,
					rangeRequested: false,
					timingAllowPassed: false,
					requestIncludesCredentials: false,
					type: 'default',
					status: 200,
					timingInfo: null,
					cacheState: '',
					statusText: '',
					...init,
					headersList: init.headersList
						? new HeadersList(init.headersList)
						: new HeadersList(),
					urlList: init.urlList ? [...init.urlList] : [],
				}
			}

			function makeNetworkError(reason) {
				const isError = isErrorLike(reason)
				return makeResponse({
					type: 'error',
					status: 0,
					error: isError ? reason : new Error(reason ? String(reason) : reason),
					aborted: reason && reason.name === 'AbortError',
				})
			}

			function makeFilteredResponse(response, state) {
				state = {
					internalResponse: response,
					...state,
				}

				return new Proxy(response, {
					get(target, p) {
						return p in state ? state[p] : target[p]
					},
					set(target, p, value) {
						assert(!(p in state))
						target[p] = value
						return true
					},
				})
			}

			// https://fetch.spec.whatwg.org/#concept-filtered-response
			function filterResponse(response, type) {
				// Set response to the following filtered response with response as its
				// internal response, depending on requests response tainting:
				if (type === 'basic') {
					// A basic filtered response is a filtered response whose type is "basic"
					// and header list excludes any headers in internal responses header list
					// whose name is a forbidden response-header name.

					// Note: undici does not implement forbidden response-header names
					return makeFilteredResponse(response, {
						type: 'basic',
						headersList: response.headersList,
					})
				} else if (type === 'cors') {
					// A CORS filtered response is a filtered response whose type is "cors"
					// and header list excludes any headers in internal responses header
					// list whose name is not a CORS-safelisted response-header name, given
					// internal responses CORS-exposed header-name list.

					// Note: undici does not implement CORS-safelisted response-header names
					return makeFilteredResponse(response, {
						type: 'cors',
						headersList: response.headersList,
					})
				} else if (type === 'opaque') {
					// An opaque filtered response is a filtered response whose type is
					// "opaque", URL list is the empty list, status is 0, status message
					// is the empty byte sequence, header list is empty, and body is null.

					return makeFilteredResponse(response, {
						type: 'opaque',
						urlList: Object.freeze([]),
						status: 0,
						statusText: '',
						body: null,
					})
				} else if (type === 'opaqueredirect') {
					// An opaque-redirect filtered response is a filtered response whose type
					// is "opaqueredirect", status is 0, status message is the empty byte
					// sequence, header list is empty, and body is null.

					return makeFilteredResponse(response, {
						type: 'opaqueredirect',
						status: 0,
						statusText: '',
						headersList: [],
						body: null,
					})
				} else {
					assert(false)
				}
			}

			// https://fetch.spec.whatwg.org/#appropriate-network-error
			function makeAppropriateNetworkError(fetchParams, err = null) {
				// 1. Assert: fetchParams is canceled.
				assert(isCancelled(fetchParams))

				// 2. Return an aborted network error if fetchParams is aborted;
				// otherwise return a network error.
				return isAborted(fetchParams)
					? makeNetworkError(
							Object.assign(
								new DOMException('The operation was aborted.', 'AbortError'),
								{ cause: err },
							),
						)
					: makeNetworkError(
							Object.assign(new DOMException('Request was cancelled.'), {
								cause: err,
							}),
						)
			}

			// https://whatpr.org/fetch/1392.html#initialize-a-response
			function initializeResponse(response, init, body) {
				// 1. If init["status"] is not in the range 200 to 599, inclusive, then
				//    throw a RangeError.
				if (init.status !== null && (init.status < 200 || init.status > 599)) {
					throw new RangeError(
						'init["status"] must be in the range of 200 to 599, inclusive.',
					)
				}

				// 2. If init["statusText"] does not match the reason-phrase token production,
				//    then throw a TypeError.
				if ('statusText' in init && init.statusText != null) {
					// See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:
					//   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )
					if (!isValidReasonPhrase(String(init.statusText))) {
						throw new TypeError('Invalid statusText')
					}
				}

				// 3. Set responses responses status to init["status"].
				if ('status' in init && init.status != null) {
					response[kState].status = init.status
				}

				// 4. Set responses responses status message to init["statusText"].
				if ('statusText' in init && init.statusText != null) {
					response[kState].statusText = init.statusText
				}

				// 5. If init["headers"] exists, then fill responses headers with init["headers"].
				if ('headers' in init && init.headers != null) {
					fill(response[kHeaders], init.headers)
				}

				// 6. If body was given, then:
				if (body) {
					// 1. If response's status is a null body status, then throw a TypeError.
					if (nullBodyStatus.includes(response.status)) {
						throw webidl.errors.exception({
							header: 'Response constructor',
							message: 'Invalid response status code ' + response.status,
						})
					}

					// 2. Set response's body to body's body.
					response[kState].body = body.body

					// 3. If body's type is non-null and response's header list does not contain
					//    `Content-Type`, then append (`Content-Type`, body's type) to response's header list.
					if (
						body.type != null &&
						!response[kState].headersList.contains('Content-Type')
					) {
						response[kState].headersList.append('content-type', body.type)
					}
				}
			}

			webidl.converters.ReadableStream =
				webidl.interfaceConverter(ReadableStream)

			webidl.converters.FormData = webidl.interfaceConverter(FormData)

			webidl.converters.URLSearchParams =
				webidl.interfaceConverter(URLSearchParams)

			// https://fetch.spec.whatwg.org/#typedefdef-xmlhttprequestbodyinit
			webidl.converters.XMLHttpRequestBodyInit = function (V) {
				if (typeof V === 'string') {
					return webidl.converters.USVString(V)
				}

				if (isBlobLike(V)) {
					return webidl.converters.Blob(V, { strict: false })
				}

				if (
					types.isArrayBuffer(V) ||
					types.isTypedArray(V) ||
					types.isDataView(V)
				) {
					return webidl.converters.BufferSource(V)
				}

				if (util.isFormDataLike(V)) {
					return webidl.converters.FormData(V, { strict: false })
				}

				if (V instanceof URLSearchParams) {
					return webidl.converters.URLSearchParams(V)
				}

				return webidl.converters.DOMString(V)
			}

			// https://fetch.spec.whatwg.org/#bodyinit
			webidl.converters.BodyInit = function (V) {
				if (V instanceof ReadableStream) {
					return webidl.converters.ReadableStream(V)
				}

				// Note: the spec doesn't include async iterables,
				// this is an undici extension.
				if (V?.[Symbol.asyncIterator]) {
					return V
				}

				return webidl.converters.XMLHttpRequestBodyInit(V)
			}

			webidl.converters.ResponseInit = webidl.dictionaryConverter([
				{
					key: 'status',
					converter: webidl.converters['unsigned short'],
					defaultValue: 200,
				},
				{
					key: 'statusText',
					converter: webidl.converters.ByteString,
					defaultValue: '',
				},
				{
					key: 'headers',
					converter: webidl.converters.HeadersInit,
				},
			])

			module.exports = {
				makeNetworkError,
				makeResponse,
				makeAppropriateNetworkError,
				filterResponse,
				Response,
				cloneResponse,
			}

			/***/
		},

		/***/ 89710: /***/ (module) => {
			'use strict'

			module.exports = {
				kUrl: Symbol('url'),
				kHeaders: Symbol('headers'),
				kSignal: Symbol('signal'),
				kState: Symbol('state'),
				kGuard: Symbol('guard'),
				kRealm: Symbol('realm'),
			}

			/***/
		},

		/***/ 15523: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const {
				redirectStatusSet,
				referrerPolicySet: referrerPolicyTokens,
				badPortsSet,
			} = __nccwpck_require__(87326)
			const { getGlobalOrigin } = __nccwpck_require__(75628)
			const { performance } = __nccwpck_require__(82987)
			const { isBlobLike, toUSVString, ReadableStreamFrom } =
				__nccwpck_require__(3440)
			const assert = __nccwpck_require__(42613)
			const { isUint8Array } = __nccwpck_require__(98253)

			let supportedHashes = []

			// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable
			/** @type {import('crypto')|undefined} */
			let crypto

			try {
				crypto = __nccwpck_require__(76982)
				const possibleRelevantHashes = ['sha256', 'sha384', 'sha512']
				supportedHashes = crypto
					.getHashes()
					.filter((hash) => possibleRelevantHashes.includes(hash))
				/* c8 ignore next 3 */
			} catch {}

			function responseURL(response) {
				// https://fetch.spec.whatwg.org/#responses
				// A response has an associated URL. It is a pointer to the last URL
				// in responses URL list and null if responses URL list is empty.
				const urlList = response.urlList
				const length = urlList.length
				return length === 0 ? null : urlList[length - 1].toString()
			}

			// https://fetch.spec.whatwg.org/#concept-response-location-url
			function responseLocationURL(response, requestFragment) {
				// 1. If responses status is not a redirect status, then return null.
				if (!redirectStatusSet.has(response.status)) {
					return null
				}

				// 2. Let location be the result of extracting header list values given
				// `Location` and responses header list.
				let location = response.headersList.get('location')

				// 3. If location is a header value, then set location to the result of
				//    parsing location with responses URL.
				if (location !== null && isValidHeaderValue(location)) {
					location = new URL(location, responseURL(response))
				}

				// 4. If location is a URL whose fragment is null, then set locations
				// fragment to requestFragment.
				if (location && !location.hash) {
					location.hash = requestFragment
				}

				// 5. Return location.
				return location
			}

			/** @returns {URL} */
			function requestCurrentURL(request) {
				return request.urlList[request.urlList.length - 1]
			}

			function requestBadPort(request) {
				// 1. Let url be requests current URL.
				const url = requestCurrentURL(request)

				// 2. If urls scheme is an HTTP(S) scheme and urls port is a bad port,
				// then return blocked.
				if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
					return 'blocked'
				}

				// 3. Return allowed.
				return 'allowed'
			}

			function isErrorLike(object) {
				return (
					object instanceof Error ||
					object?.constructor?.name === 'Error' ||
					object?.constructor?.name === 'DOMException'
				)
			}

			// Check whether |statusText| is a ByteString and
			// matches the Reason-Phrase token production.
			// RFC 2616: https://tools.ietf.org/html/rfc2616
			// RFC 7230: https://tools.ietf.org/html/rfc7230
			// "reason-phrase = *( HTAB / SP / VCHAR / obs-text )"
			// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116
			function isValidReasonPhrase(statusText) {
				for (let i = 0; i < statusText.length; ++i) {
					const c = statusText.charCodeAt(i)
					if (
						!(
							(
								c === 0x09 || // HTAB
								(c >= 0x20 && c <= 0x7e) || // SP / VCHAR
								(c >= 0x80 && c <= 0xff)
							) // obs-text
						)
					) {
						return false
					}
				}
				return true
			}

			/**
			 * @see https://tools.ietf.org/html/rfc7230#section-3.2.6
			 * @param {number} c
			 */
			function isTokenCharCode(c) {
				switch (c) {
					case 0x22:
					case 0x28:
					case 0x29:
					case 0x2c:
					case 0x2f:
					case 0x3a:
					case 0x3b:
					case 0x3c:
					case 0x3d:
					case 0x3e:
					case 0x3f:
					case 0x40:
					case 0x5b:
					case 0x5c:
					case 0x5d:
					case 0x7b:
					case 0x7d:
						// DQUOTE and "(),/:;<=>?@[\]{}"
						return false
					default:
						// VCHAR %x21-7E
						return c >= 0x21 && c <= 0x7e
				}
			}

			/**
			 * @param {string} characters
			 */
			function isValidHTTPToken(characters) {
				if (characters.length === 0) {
					return false
				}
				for (let i = 0; i < characters.length; ++i) {
					if (!isTokenCharCode(characters.charCodeAt(i))) {
						return false
					}
				}
				return true
			}

			/**
			 * @see https://fetch.spec.whatwg.org/#header-name
			 * @param {string} potentialValue
			 */
			function isValidHeaderName(potentialValue) {
				return isValidHTTPToken(potentialValue)
			}

			/**
			 * @see https://fetch.spec.whatwg.org/#header-value
			 * @param {string} potentialValue
			 */
			function isValidHeaderValue(potentialValue) {
				// - Has no leading or trailing HTTP tab or space bytes.
				// - Contains no 0x00 (NUL) or HTTP newline bytes.
				if (
					potentialValue.startsWith('\t') ||
					potentialValue.startsWith(' ') ||
					potentialValue.endsWith('\t') ||
					potentialValue.endsWith(' ')
				) {
					return false
				}

				if (
					potentialValue.includes('\0') ||
					potentialValue.includes('\r') ||
					potentialValue.includes('\n')
				) {
					return false
				}

				return true
			}

			// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect
			function setRequestReferrerPolicyOnRedirect(request, actualResponse) {
				//  Given a request request and a response actualResponse, this algorithm
				//  updates requests referrer policy according to the Referrer-Policy
				//  header (if any) in actualResponse.

				// 1. Let policy be the result of executing  8.1 Parse a referrer policy
				// from a Referrer-Policy header on actualResponse.

				// 8.1 Parse a referrer policy from a Referrer-Policy header
				// 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy` and responses header list.
				const { headersList } = actualResponse
				// 2. Let policy be the empty string.
				// 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty string, then set policy to token.
				// 4. Return policy.
				const policyHeader = (headersList.get('referrer-policy') ?? '').split(
					',',
				)

				// Note: As the referrer-policy can contain multiple policies
				// separated by comma, we need to loop through all of them
				// and pick the first valid one.
				// Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy#specify_a_fallback_policy
				let policy = ''
				if (policyHeader.length > 0) {
					// The right-most policy takes precedence.
					// The left-most policy is the fallback.
					for (let i = policyHeader.length; i !== 0; i--) {
						const token = policyHeader[i - 1].trim()
						if (referrerPolicyTokens.has(token)) {
							policy = token
							break
						}
					}
				}

				// 2. If policy is not the empty string, then set requests referrer policy to policy.
				if (policy !== '') {
					request.referrerPolicy = policy
				}
			}

			// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check
			function crossOriginResourcePolicyCheck() {
				// TODO
				return 'allowed'
			}

			// https://fetch.spec.whatwg.org/#concept-cors-check
			function corsCheck() {
				// TODO
				return 'success'
			}

			// https://fetch.spec.whatwg.org/#concept-tao-check
			function TAOCheck() {
				// TODO
				return 'success'
			}

			function appendFetchMetadata(httpRequest) {
				//  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header
				//  TODO

				//  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header

				//  1. Assert: rs url is a potentially trustworthy URL.
				//  TODO

				//  2. Let header be a Structured Header whose value is a token.
				let header = null

				//  3. Set headers value to rs mode.
				header = httpRequest.mode

				//  4. Set a structured field value `Sec-Fetch-Mode`/header in rs header list.
				httpRequest.headersList.set('sec-fetch-mode', header)

				//  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header
				//  TODO

				//  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header
				//  TODO
			}

			// https://fetch.spec.whatwg.org/#append-a-request-origin-header
			function appendRequestOriginHeader(request) {
				// 1. Let serializedOrigin be the result of byte-serializing a request origin with request.
				let serializedOrigin = request.origin

				// 2. If requests response tainting is "cors" or requests mode is "websocket", then append (`Origin`, serializedOrigin) to requests header list.
				if (
					request.responseTainting === 'cors' ||
					request.mode === 'websocket'
				) {
					if (serializedOrigin) {
						request.headersList.append('origin', serializedOrigin)
					}

					// 3. Otherwise, if requests method is neither `GET` nor `HEAD`, then:
				} else if (request.method !== 'GET' && request.method !== 'HEAD') {
					// 1. Switch on requests referrer policy:
					switch (request.referrerPolicy) {
						case 'no-referrer':
							// Set serializedOrigin to `null`.
							serializedOrigin = null
							break
						case 'no-referrer-when-downgrade':
						case 'strict-origin':
						case 'strict-origin-when-cross-origin':
							// If requests origin is a tuple origin, its scheme is "https", and requests current URLs scheme is not "https", then set serializedOrigin to `null`.
							if (
								request.origin &&
								urlHasHttpsScheme(request.origin) &&
								!urlHasHttpsScheme(requestCurrentURL(request))
							) {
								serializedOrigin = null
							}
							break
						case 'same-origin':
							// If requests origin is not same origin with requests current URLs origin, then set serializedOrigin to `null`.
							if (!sameOrigin(request, requestCurrentURL(request))) {
								serializedOrigin = null
							}
							break
						default:
						// Do nothing.
					}

					if (serializedOrigin) {
						// 2. Append (`Origin`, serializedOrigin) to requests header list.
						request.headersList.append('origin', serializedOrigin)
					}
				}
			}

			function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
				// TODO
				return performance.now()
			}

			// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info
			function createOpaqueTimingInfo(timingInfo) {
				return {
					startTime: timingInfo.startTime ?? 0,
					redirectStartTime: 0,
					redirectEndTime: 0,
					postRedirectStartTime: timingInfo.startTime ?? 0,
					finalServiceWorkerStartTime: 0,
					finalNetworkResponseStartTime: 0,
					finalNetworkRequestStartTime: 0,
					endTime: 0,
					encodedBodySize: 0,
					decodedBodySize: 0,
					finalConnectionTimingInfo: null,
				}
			}

			// https://html.spec.whatwg.org/multipage/origin.html#policy-container
			function makePolicyContainer() {
				// Note: the fetch spec doesn't make use of embedder policy or CSP list
				return {
					referrerPolicy: 'strict-origin-when-cross-origin',
				}
			}

			// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container
			function clonePolicyContainer(policyContainer) {
				return {
					referrerPolicy: policyContainer.referrerPolicy,
				}
			}

			// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer
			function determineRequestsReferrer(request) {
				// 1. Let policy be request's referrer policy.
				const policy = request.referrerPolicy

				// Note: policy cannot (shouldn't) be null or an empty string.
				assert(policy)

				// 2. Let environment be requests client.

				let referrerSource = null

				// 3. Switch on requests referrer:
				if (request.referrer === 'client') {
					// Note: node isn't a browser and doesn't implement document/iframes,
					// so we bypass this step and replace it with our own.

					const globalOrigin = getGlobalOrigin()

					if (!globalOrigin || globalOrigin.origin === 'null') {
						return 'no-referrer'
					}

					// note: we need to clone it as it's mutated
					referrerSource = new URL(globalOrigin)
				} else if (request.referrer instanceof URL) {
					// Let referrerSource be requests referrer.
					referrerSource = request.referrer
				}

				// 4. Let requests referrerURL be the result of stripping referrerSource for
				//    use as a referrer.
				let referrerURL = stripURLForReferrer(referrerSource)

				// 5. Let referrerOrigin be the result of stripping referrerSource for use as
				//    a referrer, with the origin-only flag set to true.
				const referrerOrigin = stripURLForReferrer(referrerSource, true)

				// 6. If the result of serializing referrerURL is a string whose length is
				//    greater than 4096, set referrerURL to referrerOrigin.
				if (referrerURL.toString().length > 4096) {
					referrerURL = referrerOrigin
				}

				const areSameOrigin = sameOrigin(request, referrerURL)
				const isNonPotentiallyTrustWorthy =
					isURLPotentiallyTrustworthy(referrerURL) &&
					!isURLPotentiallyTrustworthy(request.url)

				// 8. Execute the switch statements corresponding to the value of policy:
				switch (policy) {
					case 'origin':
						return referrerOrigin != null
							? referrerOrigin
							: stripURLForReferrer(referrerSource, true)
					case 'unsafe-url':
						return referrerURL
					case 'same-origin':
						return areSameOrigin ? referrerOrigin : 'no-referrer'
					case 'origin-when-cross-origin':
						return areSameOrigin ? referrerURL : referrerOrigin
					case 'strict-origin-when-cross-origin': {
						const currentURL = requestCurrentURL(request)

						// 1. If the origin of referrerURL and the origin of requests current
						//    URL are the same, then return referrerURL.
						if (sameOrigin(referrerURL, currentURL)) {
							return referrerURL
						}

						// 2. If referrerURL is a potentially trustworthy URL and requests
						//    current URL is not a potentially trustworthy URL, then return no
						//    referrer.
						if (
							isURLPotentiallyTrustworthy(referrerURL) &&
							!isURLPotentiallyTrustworthy(currentURL)
						) {
							return 'no-referrer'
						}

						// 3. Return referrerOrigin.
						return referrerOrigin
					}
					case 'strict-origin': // eslint-disable-line
					/**
					 * 1. If referrerURL is a potentially trustworthy URL and
					 * requests current URL is not a potentially trustworthy URL,
					 * then return no referrer.
					 * 2. Return referrerOrigin
					 */
					case 'no-referrer-when-downgrade': // eslint-disable-line
					/**
					 * 1. If referrerURL is a potentially trustworthy URL and
					 * requests current URL is not a potentially trustworthy URL,
					 * then return no referrer.
					 * 2. Return referrerOrigin
					 */

					default: // eslint-disable-line
						return isNonPotentiallyTrustWorthy ? 'no-referrer' : referrerOrigin
				}
			}

			/**
			 * @see https://w3c.github.io/webappsec-referrer-policy/#strip-url
			 * @param {URL} url
			 * @param {boolean|undefined} originOnly
			 */
			function stripURLForReferrer(url, originOnly) {
				// 1. Assert: url is a URL.
				assert(url instanceof URL)

				// 2. If urls scheme is a local scheme, then return no referrer.
				if (
					url.protocol === 'file:' ||
					url.protocol === 'about:' ||
					url.protocol === 'blank:'
				) {
					return 'no-referrer'
				}

				// 3. Set urls username to the empty string.
				url.username = ''

				// 4. Set urls password to the empty string.
				url.password = ''

				// 5. Set urls fragment to null.
				url.hash = ''

				// 6. If the origin-only flag is true, then:
				if (originOnly) {
					// 1. Set urls path to  the empty string .
					url.pathname = ''

					// 2. Set urls query to null.
					url.search = ''
				}

				// 7. Return url.
				return url
			}

			function isURLPotentiallyTrustworthy(url) {
				if (!(url instanceof URL)) {
					return false
				}

				// If child of about, return true
				if (url.href === 'about:blank' || url.href === 'about:srcdoc') {
					return true
				}

				// If scheme is data, return true
				if (url.protocol === 'data:') return true

				// If file, return true
				if (url.protocol === 'file:') return true

				return isOriginPotentiallyTrustworthy(url.origin)

				function isOriginPotentiallyTrustworthy(origin) {
					// If origin is explicitly null, return false
					if (origin == null || origin === 'null') return false

					const originAsURL = new URL(origin)

					// If secure, return true
					if (
						originAsURL.protocol === 'https:' ||
						originAsURL.protocol === 'wss:'
					) {
						return true
					}

					// If localhost or variants, return true
					if (
						/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(
							originAsURL.hostname,
						) ||
						originAsURL.hostname === 'localhost' ||
						originAsURL.hostname.includes('localhost.') ||
						originAsURL.hostname.endsWith('.localhost')
					) {
						return true
					}

					// If any other, return false
					return false
				}
			}

			/**
			 * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist
			 * @param {Uint8Array} bytes
			 * @param {string} metadataList
			 */
			function bytesMatch(bytes, metadataList) {
				// If node is not built with OpenSSL support, we cannot check
				// a request's integrity, so allow it by default (the spec will
				// allow requests if an invalid hash is given, as precedence).
				/* istanbul ignore if: only if node is built with --without-ssl */
				if (crypto === undefined) {
					return true
				}

				// 1. Let parsedMetadata be the result of parsing metadataList.
				const parsedMetadata = parseMetadata(metadataList)

				// 2. If parsedMetadata is no metadata, return true.
				if (parsedMetadata === 'no metadata') {
					return true
				}

				// 3. If response is not eligible for integrity validation, return false.
				// TODO

				// 4. If parsedMetadata is the empty set, return true.
				if (parsedMetadata.length === 0) {
					return true
				}

				// 5. Let metadata be the result of getting the strongest
				//    metadata from parsedMetadata.
				const strongest = getStrongestMetadata(parsedMetadata)
				const metadata = filterMetadataListByAlgorithm(
					parsedMetadata,
					strongest,
				)

				// 6. For each item in metadata:
				for (const item of metadata) {
					// 1. Let algorithm be the alg component of item.
					const algorithm = item.algo

					// 2. Let expectedValue be the val component of item.
					const expectedValue = item.hash

					// See https://github.com/web-platform-tests/wpt/commit/e4c5cc7a5e48093220528dfdd1c4012dc3837a0e
					// "be liberal with padding". This is annoying, and it's not even in the spec.

					// 3. Let actualValue be the result of applying algorithm to bytes.
					let actualValue = crypto
						.createHash(algorithm)
						.update(bytes)
						.digest('base64')

					if (actualValue[actualValue.length - 1] === '=') {
						if (actualValue[actualValue.length - 2] === '=') {
							actualValue = actualValue.slice(0, -2)
						} else {
							actualValue = actualValue.slice(0, -1)
						}
					}

					// 4. If actualValue is a case-sensitive match for expectedValue,
					//    return true.
					if (compareBase64Mixed(actualValue, expectedValue)) {
						return true
					}
				}

				// 7. Return false.
				return false
			}

			// https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options
			// https://www.w3.org/TR/CSP2/#source-list-syntax
			// https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1
			const parseHashWithOptions =
				/(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i

			/**
			 * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata
			 * @param {string} metadata
			 */
			function parseMetadata(metadata) {
				// 1. Let result be the empty set.
				/** @type {{ algo: string, hash: string }[]} */
				const result = []

				// 2. Let empty be equal to true.
				let empty = true

				// 3. For each token returned by splitting metadata on spaces:
				for (const token of metadata.split(' ')) {
					// 1. Set empty to false.
					empty = false

					// 2. Parse token as a hash-with-options.
					const parsedToken = parseHashWithOptions.exec(token)

					// 3. If token does not parse, continue to the next token.
					if (
						parsedToken === null ||
						parsedToken.groups === undefined ||
						parsedToken.groups.algo === undefined
					) {
						// Note: Chromium blocks the request at this point, but Firefox
						// gives a warning that an invalid integrity was given. The
						// correct behavior is to ignore these, and subsequently not
						// check the integrity of the resource.
						continue
					}

					// 4. Let algorithm be the hash-algo component of token.
					const algorithm = parsedToken.groups.algo.toLowerCase()

					// 5. If algorithm is a hash function recognized by the user
					//    agent, add the parsed token to result.
					if (supportedHashes.includes(algorithm)) {
						result.push(parsedToken.groups)
					}
				}

				// 4. Return no metadata if empty is true, otherwise return result.
				if (empty === true) {
					return 'no metadata'
				}

				return result
			}

			/**
			 * @param {{ algo: 'sha256' | 'sha384' | 'sha512' }[]} metadataList
			 */
			function getStrongestMetadata(metadataList) {
				// Let algorithm be the algo component of the first item in metadataList.
				// Can be sha256
				let algorithm = metadataList[0].algo
				// If the algorithm is sha512, then it is the strongest
				// and we can return immediately
				if (algorithm[3] === '5') {
					return algorithm
				}

				for (let i = 1; i < metadataList.length; ++i) {
					const metadata = metadataList[i]
					// If the algorithm is sha512, then it is the strongest
					// and we can break the loop immediately
					if (metadata.algo[3] === '5') {
						algorithm = 'sha512'
						break
						// If the algorithm is sha384, then a potential sha256 or sha384 is ignored
					} else if (algorithm[3] === '3') {
						continue
						// algorithm is sha256, check if algorithm is sha384 and if so, set it as
						// the strongest
					} else if (metadata.algo[3] === '3') {
						algorithm = 'sha384'
					}
				}
				return algorithm
			}

			function filterMetadataListByAlgorithm(metadataList, algorithm) {
				if (metadataList.length === 1) {
					return metadataList
				}

				let pos = 0
				for (let i = 0; i < metadataList.length; ++i) {
					if (metadataList[i].algo === algorithm) {
						metadataList[pos++] = metadataList[i]
					}
				}

				metadataList.length = pos

				return metadataList
			}

			/**
			 * Compares two base64 strings, allowing for base64url
			 * in the second string.
			 *
			 * @param {string} actualValue always base64
			 * @param {string} expectedValue base64 or base64url
			 * @returns {boolean}
			 */
			function compareBase64Mixed(actualValue, expectedValue) {
				if (actualValue.length !== expectedValue.length) {
					return false
				}
				for (let i = 0; i < actualValue.length; ++i) {
					if (actualValue[i] !== expectedValue[i]) {
						if (
							(actualValue[i] === '+' && expectedValue[i] === '-') ||
							(actualValue[i] === '/' && expectedValue[i] === '_')
						) {
							continue
						}
						return false
					}
				}

				return true
			}

			// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request
			function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {
				// TODO
			}

			/**
			 * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}
			 * @param {URL} A
			 * @param {URL} B
			 */
			function sameOrigin(A, B) {
				// 1. If A and B are the same opaque origin, then return true.
				if (A.origin === B.origin && A.origin === 'null') {
					return true
				}

				// 2. If A and B are both tuple origins and their schemes,
				//    hosts, and port are identical, then return true.
				if (
					A.protocol === B.protocol &&
					A.hostname === B.hostname &&
					A.port === B.port
				) {
					return true
				}

				// 3. Return false.
				return false
			}

			function createDeferredPromise() {
				let res
				let rej
				const promise = new Promise((resolve, reject) => {
					res = resolve
					rej = reject
				})

				return { promise, resolve: res, reject: rej }
			}

			function isAborted(fetchParams) {
				return fetchParams.controller.state === 'aborted'
			}

			function isCancelled(fetchParams) {
				return (
					fetchParams.controller.state === 'aborted' ||
					fetchParams.controller.state === 'terminated'
				)
			}

			const normalizeMethodRecord = {
				delete: 'DELETE',
				DELETE: 'DELETE',
				get: 'GET',
				GET: 'GET',
				head: 'HEAD',
				HEAD: 'HEAD',
				options: 'OPTIONS',
				OPTIONS: 'OPTIONS',
				post: 'POST',
				POST: 'POST',
				put: 'PUT',
				PUT: 'PUT',
			}

			// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.
			Object.setPrototypeOf(normalizeMethodRecord, null)

			/**
			 * @see https://fetch.spec.whatwg.org/#concept-method-normalize
			 * @param {string} method
			 */
			function normalizeMethod(method) {
				return normalizeMethodRecord[method.toLowerCase()] ?? method
			}

			// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string
			function serializeJavascriptValueToJSONString(value) {
				// 1. Let result be ? Call(%JSON.stringify%, undefined,  value ).
				const result = JSON.stringify(value)

				// 2. If result is undefined, then throw a TypeError.
				if (result === undefined) {
					throw new TypeError('Value is not JSON serializable')
				}

				// 3. Assert: result is a string.
				assert(typeof result === 'string')

				// 4. Return result.
				return result
			}

			// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object
			const esIteratorPrototype = Object.getPrototypeOf(
				Object.getPrototypeOf([][Symbol.iterator]()),
			)

			/**
			 * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object
			 * @param {() => unknown[]} iterator
			 * @param {string} name name of the instance
			 * @param {'key'|'value'|'key+value'} kind
			 */
			function makeIterator(iterator, name, kind) {
				const object = {
					index: 0,
					kind,
					target: iterator,
				}

				const i = {
					next() {
						// 1. Let interface be the interface for which the iterator prototype object exists.

						// 2. Let thisValue be the this value.

						// 3. Let object be ? ToObject(thisValue).

						// 4. If object is a platform object, then perform a security
						//    check, passing:

						// 5. If object is not a default iterator object for interface,
						//    then throw a TypeError.
						if (Object.getPrototypeOf(this) !== i) {
							throw new TypeError(
								`'next' called on an object that does not implement interface ${name} Iterator.`,
							)
						}

						// 6. Let index be objects index.
						// 7. Let kind be objects kind.
						// 8. Let values be objects target's value pairs to iterate over.
						const { index, kind, target } = object
						const values = target()

						// 9. Let len be the length of values.
						const len = values.length

						// 10. If index is greater than or equal to len, then return
						//     CreateIterResultObject(undefined, true).
						if (index >= len) {
							return { value: undefined, done: true }
						}

						// 11. Let pair be the entry in values at index index.
						const pair = values[index]

						// 12. Set objects index to index + 1.
						object.index = index + 1

						// 13. Return the iterator result for pair and kind.
						return iteratorResult(pair, kind)
					},
					// The class string of an iterator prototype object for a given interface is the
					// result of concatenating the identifier of the interface and the string " Iterator".
					[Symbol.toStringTag]: `${name} Iterator`,
				}

				// The [[Prototype]] internal slot of an iterator prototype object must be %IteratorPrototype%.
				Object.setPrototypeOf(i, esIteratorPrototype)
				// esIteratorPrototype needs to be the prototype of i
				// which is the prototype of an empty object. Yes, it's confusing.
				return Object.setPrototypeOf({}, i)
			}

			// https://webidl.spec.whatwg.org/#iterator-result
			function iteratorResult(pair, kind) {
				let result

				// 1. Let result be a value determined by the value of kind:
				switch (kind) {
					case 'key': {
						// 1. Let idlKey be pairs key.
						// 2. Let key be the result of converting idlKey to an
						//    ECMAScript value.
						// 3. result is key.
						result = pair[0]
						break
					}
					case 'value': {
						// 1. Let idlValue be pairs value.
						// 2. Let value be the result of converting idlValue to
						//    an ECMAScript value.
						// 3. result is value.
						result = pair[1]
						break
					}
					case 'key+value': {
						// 1. Let idlKey be pairs key.
						// 2. Let idlValue be pairs value.
						// 3. Let key be the result of converting idlKey to an
						//    ECMAScript value.
						// 4. Let value be the result of converting idlValue to
						//    an ECMAScript value.
						// 5. Let array be ! ArrayCreate(2).
						// 6. Call ! CreateDataProperty(array, "0", key).
						// 7. Call ! CreateDataProperty(array, "1", value).
						// 8. result is array.
						result = pair
						break
					}
				}

				// 2. Return CreateIterResultObject(result, false).
				return { value: result, done: false }
			}

			/**
			 * @see https://fetch.spec.whatwg.org/#body-fully-read
			 */
			async function fullyReadBody(body, processBody, processBodyError) {
				// 1. If taskDestination is null, then set taskDestination to
				//    the result of starting a new parallel queue.

				// 2. Let successSteps given a byte sequence bytes be to queue a
				//    fetch task to run processBody given bytes, with taskDestination.
				const successSteps = processBody

				// 3. Let errorSteps be to queue a fetch task to run processBodyError,
				//    with taskDestination.
				const errorSteps = processBodyError

				// 4. Let reader be the result of getting a reader for bodys stream.
				//    If that threw an exception, then run errorSteps with that
				//    exception and return.
				let reader

				try {
					reader = body.stream.getReader()
				} catch (e) {
					errorSteps(e)
					return
				}

				// 5. Read all bytes from reader, given successSteps and errorSteps.
				try {
					const result = await readAllBytes(reader)
					successSteps(result)
				} catch (e) {
					errorSteps(e)
				}
			}

			/** @type {ReadableStream} */
			let ReadableStream = globalThis.ReadableStream

			function isReadableStreamLike(stream) {
				if (!ReadableStream) {
					ReadableStream = __nccwpck_require__(63774).ReadableStream
				}

				return (
					stream instanceof ReadableStream ||
					(stream[Symbol.toStringTag] === 'ReadableStream' &&
						typeof stream.tee === 'function')
				)
			}

			const MAXIMUM_ARGUMENT_LENGTH = 65535

			/**
			 * @see https://infra.spec.whatwg.org/#isomorphic-decode
			 * @param {number[]|Uint8Array} input
			 */
			function isomorphicDecode(input) {
				// 1. To isomorphic decode a byte sequence input, return a string whose code point
				//    length is equal to inputs length and whose code points have the same values
				//    as the values of inputs bytes, in the same order.

				if (input.length < MAXIMUM_ARGUMENT_LENGTH) {
					return String.fromCharCode(...input)
				}

				return input.reduce(
					(previous, current) => previous + String.fromCharCode(current),
					'',
				)
			}

			/**
			 * @param {ReadableStreamController<Uint8Array>} controller
			 */
			function readableStreamClose(controller) {
				try {
					controller.close()
				} catch (err) {
					// TODO: add comment explaining why this error occurs.
					if (!err.message.includes('Controller is already closed')) {
						throw err
					}
				}
			}

			/**
			 * @see https://infra.spec.whatwg.org/#isomorphic-encode
			 * @param {string} input
			 */
			function isomorphicEncode(input) {
				// 1. Assert: input contains no code points greater than U+00FF.
				for (let i = 0; i < input.length; i++) {
					assert(input.charCodeAt(i) <= 0xff)
				}

				// 2. Return a byte sequence whose length is equal to inputs code
				//    point length and whose bytes have the same values as the
				//    values of inputs code points, in the same order
				return input
			}

			/**
			 * @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes
			 * @see https://streams.spec.whatwg.org/#read-loop
			 * @param {ReadableStreamDefaultReader} reader
			 */
			async function readAllBytes(reader) {
				const bytes = []
				let byteLength = 0

				while (true) {
					const { done, value: chunk } = await reader.read()

					if (done) {
						// 1. Call successSteps with bytes.
						return Buffer.concat(bytes, byteLength)
					}

					// 1. If chunk is not a Uint8Array object, call failureSteps
					//    with a TypeError and abort these steps.
					if (!isUint8Array(chunk)) {
						throw new TypeError('Received non-Uint8Array chunk')
					}

					// 2. Append the bytes represented by chunk to bytes.
					bytes.push(chunk)
					byteLength += chunk.length

					// 3. Read-loop given reader, bytes, successSteps, and failureSteps.
				}
			}

			/**
			 * @see https://fetch.spec.whatwg.org/#is-local
			 * @param {URL} url
			 */
			function urlIsLocal(url) {
				assert('protocol' in url) // ensure it's a url object

				const protocol = url.protocol

				return (
					protocol === 'about:' || protocol === 'blob:' || protocol === 'data:'
				)
			}

			/**
			 * @param {string|URL} url
			 */
			function urlHasHttpsScheme(url) {
				if (typeof url === 'string') {
					return url.startsWith('https:')
				}

				return url.protocol === 'https:'
			}

			/**
			 * @see https://fetch.spec.whatwg.org/#http-scheme
			 * @param {URL} url
			 */
			function urlIsHttpHttpsScheme(url) {
				assert('protocol' in url) // ensure it's a url object

				const protocol = url.protocol

				return protocol === 'http:' || protocol === 'https:'
			}

			/**
			 * Fetch supports node >= 16.8.0, but Object.hasOwn was added in v16.9.0.
			 */
			const hasOwn =
				Object.hasOwn ||
				((dict, key) => Object.prototype.hasOwnProperty.call(dict, key))

			module.exports = {
				isAborted,
				isCancelled,
				createDeferredPromise,
				ReadableStreamFrom,
				toUSVString,
				tryUpgradeRequestToAPotentiallyTrustworthyURL,
				coarsenedSharedCurrentTime,
				determineRequestsReferrer,
				makePolicyContainer,
				clonePolicyContainer,
				appendFetchMetadata,
				appendRequestOriginHeader,
				TAOCheck,
				corsCheck,
				crossOriginResourcePolicyCheck,
				createOpaqueTimingInfo,
				setRequestReferrerPolicyOnRedirect,
				isValidHTTPToken,
				requestBadPort,
				requestCurrentURL,
				responseURL,
				responseLocationURL,
				isBlobLike,
				isURLPotentiallyTrustworthy,
				isValidReasonPhrase,
				sameOrigin,
				normalizeMethod,
				serializeJavascriptValueToJSONString,
				makeIterator,
				isValidHeaderName,
				isValidHeaderValue,
				hasOwn,
				isErrorLike,
				fullyReadBody,
				bytesMatch,
				isReadableStreamLike,
				readableStreamClose,
				isomorphicEncode,
				isomorphicDecode,
				urlIsLocal,
				urlHasHttpsScheme,
				urlIsHttpHttpsScheme,
				readAllBytes,
				normalizeMethodRecord,
				parseMetadata,
			}

			/***/
		},

		/***/ 74222: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { types } = __nccwpck_require__(39023)
			const { hasOwn, toUSVString } = __nccwpck_require__(15523)

			/** @type {import('../../types/webidl').Webidl} */
			const webidl = {}
			webidl.converters = {}
			webidl.util = {}
			webidl.errors = {}

			webidl.errors.exception = function (message) {
				return new TypeError(`${message.header}: ${message.message}`)
			}

			webidl.errors.conversionFailed = function (context) {
				const plural = context.types.length === 1 ? '' : ' one of'
				const message =
					`${context.argument} could not be converted to` +
					`${plural}: ${context.types.join(', ')}.`

				return webidl.errors.exception({
					header: context.prefix,
					message,
				})
			}

			webidl.errors.invalidArgument = function (context) {
				return webidl.errors.exception({
					header: context.prefix,
					message: `"${context.value}" is an invalid ${context.type}.`,
				})
			}

			// https://webidl.spec.whatwg.org/#implements
			webidl.brandCheck = function (V, I, opts = undefined) {
				if (opts?.strict !== false && !(V instanceof I)) {
					throw new TypeError('Illegal invocation')
				} else {
					return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag]
				}
			}

			webidl.argumentLengthCheck = function ({ length }, min, ctx) {
				if (length < min) {
					throw webidl.errors.exception({
						message:
							`${min} argument${min !== 1 ? 's' : ''} required, ` +
							`but${length ? ' only' : ''} ${length} found.`,
						...ctx,
					})
				}
			}

			webidl.illegalConstructor = function () {
				throw webidl.errors.exception({
					header: 'TypeError',
					message: 'Illegal constructor',
				})
			}

			// https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values
			webidl.util.Type = function (V) {
				switch (typeof V) {
					case 'undefined':
						return 'Undefined'
					case 'boolean':
						return 'Boolean'
					case 'string':
						return 'String'
					case 'symbol':
						return 'Symbol'
					case 'number':
						return 'Number'
					case 'bigint':
						return 'BigInt'
					case 'function':
					case 'object': {
						if (V === null) {
							return 'Null'
						}

						return 'Object'
					}
				}
			}

			// https://webidl.spec.whatwg.org/#abstract-opdef-converttoint
			webidl.util.ConvertToInt = function (
				V,
				bitLength,
				signedness,
				opts = {},
			) {
				let upperBound
				let lowerBound

				// 1. If bitLength is 64, then:
				if (bitLength === 64) {
					// 1. Let upperBound be 2^53  1.
					upperBound = Math.pow(2, 53) - 1

					// 2. If signedness is "unsigned", then let lowerBound be 0.
					if (signedness === 'unsigned') {
						lowerBound = 0
					} else {
						// 3. Otherwise let lowerBound be 2^53 + 1.
						lowerBound = Math.pow(-2, 53) + 1
					}
				} else if (signedness === 'unsigned') {
					// 2. Otherwise, if signedness is "unsigned", then:

					// 1. Let lowerBound be 0.
					lowerBound = 0

					// 2. Let upperBound be 2^bitLength  1.
					upperBound = Math.pow(2, bitLength) - 1
				} else {
					// 3. Otherwise:

					// 1. Let lowerBound be -2^bitLength  1.
					lowerBound = Math.pow(-2, bitLength) - 1

					// 2. Let upperBound be 2^bitLength  1  1.
					upperBound = Math.pow(2, bitLength - 1) - 1
				}

				// 4. Let x be ? ToNumber(V).
				let x = Number(V)

				// 5. If x is 0, then set x to +0.
				if (x === 0) {
					x = 0
				}

				// 6. If the conversion is to an IDL type associated
				//    with the [EnforceRange] extended attribute, then:
				if (opts.enforceRange === true) {
					// 1. If x is NaN, +, or , then throw a TypeError.
					if (
						Number.isNaN(x) ||
						x === Number.POSITIVE_INFINITY ||
						x === Number.NEGATIVE_INFINITY
					) {
						throw webidl.errors.exception({
							header: 'Integer conversion',
							message: `Could not convert ${V} to an integer.`,
						})
					}

					// 2. Set x to IntegerPart(x).
					x = webidl.util.IntegerPart(x)

					// 3. If x < lowerBound or x > upperBound, then
					//    throw a TypeError.
					if (x < lowerBound || x > upperBound) {
						throw webidl.errors.exception({
							header: 'Integer conversion',
							message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`,
						})
					}

					// 4. Return x.
					return x
				}

				// 7. If x is not NaN and the conversion is to an IDL
				//    type associated with the [Clamp] extended
				//    attribute, then:
				if (!Number.isNaN(x) && opts.clamp === true) {
					// 1. Set x to min(max(x, lowerBound), upperBound).
					x = Math.min(Math.max(x, lowerBound), upperBound)

					// 2. Round x to the nearest integer, choosing the
					//    even integer if it lies halfway between two,
					//    and choosing +0 rather than 0.
					if (Math.floor(x) % 2 === 0) {
						x = Math.floor(x)
					} else {
						x = Math.ceil(x)
					}

					// 3. Return x.
					return x
				}

				// 8. If x is NaN, +0, +, or , then return +0.
				if (
					Number.isNaN(x) ||
					(x === 0 && Object.is(0, x)) ||
					x === Number.POSITIVE_INFINITY ||
					x === Number.NEGATIVE_INFINITY
				) {
					return 0
				}

				// 9. Set x to IntegerPart(x).
				x = webidl.util.IntegerPart(x)

				// 10. Set x to x modulo 2^bitLength.
				x = x % Math.pow(2, bitLength)

				// 11. If signedness is "signed" and x  2^bitLength  1,
				//    then return x  2^bitLength.
				if (signedness === 'signed' && x >= Math.pow(2, bitLength) - 1) {
					return x - Math.pow(2, bitLength)
				}

				// 12. Otherwise, return x.
				return x
			}

			// https://webidl.spec.whatwg.org/#abstract-opdef-integerpart
			webidl.util.IntegerPart = function (n) {
				// 1. Let r be floor(abs(n)).
				const r = Math.floor(Math.abs(n))

				// 2. If n < 0, then return -1  r.
				if (n < 0) {
					return -1 * r
				}

				// 3. Otherwise, return r.
				return r
			}

			// https://webidl.spec.whatwg.org/#es-sequence
			webidl.sequenceConverter = function (converter) {
				return (V) => {
					// 1. If Type(V) is not Object, throw a TypeError.
					if (webidl.util.Type(V) !== 'Object') {
						throw webidl.errors.exception({
							header: 'Sequence',
							message: `Value of type ${webidl.util.Type(V)} is not an Object.`,
						})
					}

					// 2. Let method be ? GetMethod(V, @@iterator).
					/** @type {Generator} */
					const method = V?.[Symbol.iterator]?.()
					const seq = []

					// 3. If method is undefined, throw a TypeError.
					if (method === undefined || typeof method.next !== 'function') {
						throw webidl.errors.exception({
							header: 'Sequence',
							message: 'Object is not an iterator.',
						})
					}

					// https://webidl.spec.whatwg.org/#create-sequence-from-iterable
					while (true) {
						const { done, value } = method.next()

						if (done) {
							break
						}

						seq.push(converter(value))
					}

					return seq
				}
			}

			// https://webidl.spec.whatwg.org/#es-to-record
			webidl.recordConverter = function (keyConverter, valueConverter) {
				return (O) => {
					// 1. If Type(O) is not Object, throw a TypeError.
					if (webidl.util.Type(O) !== 'Object') {
						throw webidl.errors.exception({
							header: 'Record',
							message: `Value of type ${webidl.util.Type(O)} is not an Object.`,
						})
					}

					// 2. Let result be a new empty instance of record<K, V>.
					const result = {}

					if (!types.isProxy(O)) {
						// Object.keys only returns enumerable properties
						const keys = Object.keys(O)

						for (const key of keys) {
							// 1. Let typedKey be key converted to an IDL value of type K.
							const typedKey = keyConverter(key)

							// 2. Let value be ? Get(O, key).
							// 3. Let typedValue be value converted to an IDL value of type V.
							const typedValue = valueConverter(O[key])

							// 4. Set result[typedKey] to typedValue.
							result[typedKey] = typedValue
						}

						// 5. Return result.
						return result
					}

					// 3. Let keys be ? O.[[OwnPropertyKeys]]().
					const keys = Reflect.ownKeys(O)

					// 4. For each key of keys.
					for (const key of keys) {
						// 1. Let desc be ? O.[[GetOwnProperty]](key).
						const desc = Reflect.getOwnPropertyDescriptor(O, key)

						// 2. If desc is not undefined and desc.[[Enumerable]] is true:
						if (desc?.enumerable) {
							// 1. Let typedKey be key converted to an IDL value of type K.
							const typedKey = keyConverter(key)

							// 2. Let value be ? Get(O, key).
							// 3. Let typedValue be value converted to an IDL value of type V.
							const typedValue = valueConverter(O[key])

							// 4. Set result[typedKey] to typedValue.
							result[typedKey] = typedValue
						}
					}

					// 5. Return result.
					return result
				}
			}

			webidl.interfaceConverter = function (i) {
				return (V, opts = {}) => {
					if (opts.strict !== false && !(V instanceof i)) {
						throw webidl.errors.exception({
							header: i.name,
							message: `Expected ${V} to be an instance of ${i.name}.`,
						})
					}

					return V
				}
			}

			webidl.dictionaryConverter = function (converters) {
				return (dictionary) => {
					const type = webidl.util.Type(dictionary)
					const dict = {}

					if (type === 'Null' || type === 'Undefined') {
						return dict
					} else if (type !== 'Object') {
						throw webidl.errors.exception({
							header: 'Dictionary',
							message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`,
						})
					}

					for (const options of converters) {
						const { key, defaultValue, required, converter } = options

						if (required === true) {
							if (!hasOwn(dictionary, key)) {
								throw webidl.errors.exception({
									header: 'Dictionary',
									message: `Missing required key "${key}".`,
								})
							}
						}

						let value = dictionary[key]
						const hasDefault = hasOwn(options, 'defaultValue')

						// Only use defaultValue if value is undefined and
						// a defaultValue options was provided.
						if (hasDefault && value !== null) {
							value = value ?? defaultValue
						}

						// A key can be optional and have no default value.
						// When this happens, do not perform a conversion,
						// and do not assign the key a value.
						if (required || hasDefault || value !== undefined) {
							value = converter(value)

							if (
								options.allowedValues &&
								!options.allowedValues.includes(value)
							) {
								throw webidl.errors.exception({
									header: 'Dictionary',
									message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(', ')}.`,
								})
							}

							dict[key] = value
						}
					}

					return dict
				}
			}

			webidl.nullableConverter = function (converter) {
				return (V) => {
					if (V === null) {
						return V
					}

					return converter(V)
				}
			}

			// https://webidl.spec.whatwg.org/#es-DOMString
			webidl.converters.DOMString = function (V, opts = {}) {
				// 1. If V is null and the conversion is to an IDL type
				//    associated with the [LegacyNullToEmptyString]
				//    extended attribute, then return the DOMString value
				//    that represents the empty string.
				if (V === null && opts.legacyNullToEmptyString) {
					return ''
				}

				// 2. Let x be ? ToString(V).
				if (typeof V === 'symbol') {
					throw new TypeError(
						'Could not convert argument of type symbol to string.',
					)
				}

				// 3. Return the IDL DOMString value that represents the
				//    same sequence of code units as the one the
				//    ECMAScript String value x represents.
				return String(V)
			}

			// https://webidl.spec.whatwg.org/#es-ByteString
			webidl.converters.ByteString = function (V) {
				// 1. Let x be ? ToString(V).
				// Note: DOMString converter perform ? ToString(V)
				const x = webidl.converters.DOMString(V)

				// 2. If the value of any element of x is greater than
				//    255, then throw a TypeError.
				for (let index = 0; index < x.length; index++) {
					if (x.charCodeAt(index) > 255) {
						throw new TypeError(
							'Cannot convert argument to a ByteString because the character at ' +
								`index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`,
						)
					}
				}

				// 3. Return an IDL ByteString value whose length is the
				//    length of x, and where the value of each element is
				//    the value of the corresponding element of x.
				return x
			}

			// https://webidl.spec.whatwg.org/#es-USVString
			webidl.converters.USVString = toUSVString

			// https://webidl.spec.whatwg.org/#es-boolean
			webidl.converters.boolean = function (V) {
				// 1. Let x be the result of computing ToBoolean(V).
				const x = Boolean(V)

				// 2. Return the IDL boolean value that is the one that represents
				//    the same truth value as the ECMAScript Boolean value x.
				return x
			}

			// https://webidl.spec.whatwg.org/#es-any
			webidl.converters.any = function (V) {
				return V
			}

			// https://webidl.spec.whatwg.org/#es-long-long
			webidl.converters['long long'] = function (V) {
				// 1. Let x be ? ConvertToInt(V, 64, "signed").
				const x = webidl.util.ConvertToInt(V, 64, 'signed')

				// 2. Return the IDL long long value that represents
				//    the same numeric value as x.
				return x
			}

			// https://webidl.spec.whatwg.org/#es-unsigned-long-long
			webidl.converters['unsigned long long'] = function (V) {
				// 1. Let x be ? ConvertToInt(V, 64, "unsigned").
				const x = webidl.util.ConvertToInt(V, 64, 'unsigned')

				// 2. Return the IDL unsigned long long value that
				//    represents the same numeric value as x.
				return x
			}

			// https://webidl.spec.whatwg.org/#es-unsigned-long
			webidl.converters['unsigned long'] = function (V) {
				// 1. Let x be ? ConvertToInt(V, 32, "unsigned").
				const x = webidl.util.ConvertToInt(V, 32, 'unsigned')

				// 2. Return the IDL unsigned long value that
				//    represents the same numeric value as x.
				return x
			}

			// https://webidl.spec.whatwg.org/#es-unsigned-short
			webidl.converters['unsigned short'] = function (V, opts) {
				// 1. Let x be ? ConvertToInt(V, 16, "unsigned").
				const x = webidl.util.ConvertToInt(V, 16, 'unsigned', opts)

				// 2. Return the IDL unsigned short value that represents
				//    the same numeric value as x.
				return x
			}

			// https://webidl.spec.whatwg.org/#idl-ArrayBuffer
			webidl.converters.ArrayBuffer = function (V, opts = {}) {
				// 1. If Type(V) is not Object, or V does not have an
				//    [[ArrayBufferData]] internal slot, then throw a
				//    TypeError.
				// see: https://tc39.es/ecma262/#sec-properties-of-the-arraybuffer-instances
				// see: https://tc39.es/ecma262/#sec-properties-of-the-sharedarraybuffer-instances
				if (webidl.util.Type(V) !== 'Object' || !types.isAnyArrayBuffer(V)) {
					throw webidl.errors.conversionFailed({
						prefix: `${V}`,
						argument: `${V}`,
						types: ['ArrayBuffer'],
					})
				}

				// 2. If the conversion is not to an IDL type associated
				//    with the [AllowShared] extended attribute, and
				//    IsSharedArrayBuffer(V) is true, then throw a
				//    TypeError.
				if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {
					throw webidl.errors.exception({
						header: 'ArrayBuffer',
						message: 'SharedArrayBuffer is not allowed.',
					})
				}

				// 3. If the conversion is not to an IDL type associated
				//    with the [AllowResizable] extended attribute, and
				//    IsResizableArrayBuffer(V) is true, then throw a
				//    TypeError.
				// Note: resizable ArrayBuffers are currently a proposal.

				// 4. Return the IDL ArrayBuffer value that is a
				//    reference to the same object as V.
				return V
			}

			webidl.converters.TypedArray = function (V, T, opts = {}) {
				// 1. Let T be the IDL type V is being converted to.

				// 2. If Type(V) is not Object, or V does not have a
				//    [[TypedArrayName]] internal slot with a value
				//    equal to Ts name, then throw a TypeError.
				if (
					webidl.util.Type(V) !== 'Object' ||
					!types.isTypedArray(V) ||
					V.constructor.name !== T.name
				) {
					throw webidl.errors.conversionFailed({
						prefix: `${T.name}`,
						argument: `${V}`,
						types: [T.name],
					})
				}

				// 3. If the conversion is not to an IDL type associated
				//    with the [AllowShared] extended attribute, and
				//    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is
				//    true, then throw a TypeError.
				if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
					throw webidl.errors.exception({
						header: 'ArrayBuffer',
						message: 'SharedArrayBuffer is not allowed.',
					})
				}

				// 4. If the conversion is not to an IDL type associated
				//    with the [AllowResizable] extended attribute, and
				//    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is
				//    true, then throw a TypeError.
				// Note: resizable array buffers are currently a proposal

				// 5. Return the IDL value of type T that is a reference
				//    to the same object as V.
				return V
			}

			webidl.converters.DataView = function (V, opts = {}) {
				// 1. If Type(V) is not Object, or V does not have a
				//    [[DataView]] internal slot, then throw a TypeError.
				if (webidl.util.Type(V) !== 'Object' || !types.isDataView(V)) {
					throw webidl.errors.exception({
						header: 'DataView',
						message: 'Object is not a DataView.',
					})
				}

				// 2. If the conversion is not to an IDL type associated
				//    with the [AllowShared] extended attribute, and
				//    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true,
				//    then throw a TypeError.
				if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
					throw webidl.errors.exception({
						header: 'ArrayBuffer',
						message: 'SharedArrayBuffer is not allowed.',
					})
				}

				// 3. If the conversion is not to an IDL type associated
				//    with the [AllowResizable] extended attribute, and
				//    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is
				//    true, then throw a TypeError.
				// Note: resizable ArrayBuffers are currently a proposal

				// 4. Return the IDL DataView value that is a reference
				//    to the same object as V.
				return V
			}

			// https://webidl.spec.whatwg.org/#BufferSource
			webidl.converters.BufferSource = function (V, opts = {}) {
				if (types.isAnyArrayBuffer(V)) {
					return webidl.converters.ArrayBuffer(V, opts)
				}

				if (types.isTypedArray(V)) {
					return webidl.converters.TypedArray(V, V.constructor)
				}

				if (types.isDataView(V)) {
					return webidl.converters.DataView(V, opts)
				}

				throw new TypeError(`Could not convert ${V} to a BufferSource.`)
			}

			webidl.converters['sequence<ByteString>'] = webidl.sequenceConverter(
				webidl.converters.ByteString,
			)

			webidl.converters['sequence<sequence<ByteString>>'] =
				webidl.sequenceConverter(webidl.converters['sequence<ByteString>'])

			webidl.converters['record<ByteString, ByteString>'] =
				webidl.recordConverter(
					webidl.converters.ByteString,
					webidl.converters.ByteString,
				)

			module.exports = {
				webidl,
			}

			/***/
		},

		/***/ 40396: /***/ (module) => {
			'use strict'

			/**
			 * @see https://encoding.spec.whatwg.org/#concept-encoding-get
			 * @param {string|undefined} label
			 */
			function getEncoding(label) {
				if (!label) {
					return 'failure'
				}

				// 1. Remove any leading and trailing ASCII whitespace from label.
				// 2. If label is an ASCII case-insensitive match for any of the
				//    labels listed in the table below, then return the
				//    corresponding encoding; otherwise return failure.
				switch (label.trim().toLowerCase()) {
					case 'unicode-1-1-utf-8':
					case 'unicode11utf8':
					case 'unicode20utf8':
					case 'utf-8':
					case 'utf8':
					case 'x-unicode20utf8':
						return 'UTF-8'
					case '866':
					case 'cp866':
					case 'csibm866':
					case 'ibm866':
						return 'IBM866'
					case 'csisolatin2':
					case 'iso-8859-2':
					case 'iso-ir-101':
					case 'iso8859-2':
					case 'iso88592':
					case 'iso_8859-2':
					case 'iso_8859-2:1987':
					case 'l2':
					case 'latin2':
						return 'ISO-8859-2'
					case 'csisolatin3':
					case 'iso-8859-3':
					case 'iso-ir-109':
					case 'iso8859-3':
					case 'iso88593':
					case 'iso_8859-3':
					case 'iso_8859-3:1988':
					case 'l3':
					case 'latin3':
						return 'ISO-8859-3'
					case 'csisolatin4':
					case 'iso-8859-4':
					case 'iso-ir-110':
					case 'iso8859-4':
					case 'iso88594':
					case 'iso_8859-4':
					case 'iso_8859-4:1988':
					case 'l4':
					case 'latin4':
						return 'ISO-8859-4'
					case 'csisolatincyrillic':
					case 'cyrillic':
					case 'iso-8859-5':
					case 'iso-ir-144':
					case 'iso8859-5':
					case 'iso88595':
					case 'iso_8859-5':
					case 'iso_8859-5:1988':
						return 'ISO-8859-5'
					case 'arabic':
					case 'asmo-708':
					case 'csiso88596e':
					case 'csiso88596i':
					case 'csisolatinarabic':
					case 'ecma-114':
					case 'iso-8859-6':
					case 'iso-8859-6-e':
					case 'iso-8859-6-i':
					case 'iso-ir-127':
					case 'iso8859-6':
					case 'iso88596':
					case 'iso_8859-6':
					case 'iso_8859-6:1987':
						return 'ISO-8859-6'
					case 'csisolatingreek':
					case 'ecma-118':
					case 'elot_928':
					case 'greek':
					case 'greek8':
					case 'iso-8859-7':
					case 'iso-ir-126':
					case 'iso8859-7':
					case 'iso88597':
					case 'iso_8859-7':
					case 'iso_8859-7:1987':
					case 'sun_eu_greek':
						return 'ISO-8859-7'
					case 'csiso88598e':
					case 'csisolatinhebrew':
					case 'hebrew':
					case 'iso-8859-8':
					case 'iso-8859-8-e':
					case 'iso-ir-138':
					case 'iso8859-8':
					case 'iso88598':
					case 'iso_8859-8':
					case 'iso_8859-8:1988':
					case 'visual':
						return 'ISO-8859-8'
					case 'csiso88598i':
					case 'iso-8859-8-i':
					case 'logical':
						return 'ISO-8859-8-I'
					case 'csisolatin6':
					case 'iso-8859-10':
					case 'iso-ir-157':
					case 'iso8859-10':
					case 'iso885910':
					case 'l6':
					case 'latin6':
						return 'ISO-8859-10'
					case 'iso-8859-13':
					case 'iso8859-13':
					case 'iso885913':
						return 'ISO-8859-13'
					case 'iso-8859-14':
					case 'iso8859-14':
					case 'iso885914':
						return 'ISO-8859-14'
					case 'csisolatin9':
					case 'iso-8859-15':
					case 'iso8859-15':
					case 'iso885915':
					case 'iso_8859-15':
					case 'l9':
						return 'ISO-8859-15'
					case 'iso-8859-16':
						return 'ISO-8859-16'
					case 'cskoi8r':
					case 'koi':
					case 'koi8':
					case 'koi8-r':
					case 'koi8_r':
						return 'KOI8-R'
					case 'koi8-ru':
					case 'koi8-u':
						return 'KOI8-U'
					case 'csmacintosh':
					case 'mac':
					case 'macintosh':
					case 'x-mac-roman':
						return 'macintosh'
					case 'iso-8859-11':
					case 'iso8859-11':
					case 'iso885911':
					case 'tis-620':
					case 'windows-874':
						return 'windows-874'
					case 'cp1250':
					case 'windows-1250':
					case 'x-cp1250':
						return 'windows-1250'
					case 'cp1251':
					case 'windows-1251':
					case 'x-cp1251':
						return 'windows-1251'
					case 'ansi_x3.4-1968':
					case 'ascii':
					case 'cp1252':
					case 'cp819':
					case 'csisolatin1':
					case 'ibm819':
					case 'iso-8859-1':
					case 'iso-ir-100':
					case 'iso8859-1':
					case 'iso88591':
					case 'iso_8859-1':
					case 'iso_8859-1:1987':
					case 'l1':
					case 'latin1':
					case 'us-ascii':
					case 'windows-1252':
					case 'x-cp1252':
						return 'windows-1252'
					case 'cp1253':
					case 'windows-1253':
					case 'x-cp1253':
						return 'windows-1253'
					case 'cp1254':
					case 'csisolatin5':
					case 'iso-8859-9':
					case 'iso-ir-148':
					case 'iso8859-9':
					case 'iso88599':
					case 'iso_8859-9':
					case 'iso_8859-9:1989':
					case 'l5':
					case 'latin5':
					case 'windows-1254':
					case 'x-cp1254':
						return 'windows-1254'
					case 'cp1255':
					case 'windows-1255':
					case 'x-cp1255':
						return 'windows-1255'
					case 'cp1256':
					case 'windows-1256':
					case 'x-cp1256':
						return 'windows-1256'
					case 'cp1257':
					case 'windows-1257':
					case 'x-cp1257':
						return 'windows-1257'
					case 'cp1258':
					case 'windows-1258':
					case 'x-cp1258':
						return 'windows-1258'
					case 'x-mac-cyrillic':
					case 'x-mac-ukrainian':
						return 'x-mac-cyrillic'
					case 'chinese':
					case 'csgb2312':
					case 'csiso58gb231280':
					case 'gb2312':
					case 'gb_2312':
					case 'gb_2312-80':
					case 'gbk':
					case 'iso-ir-58':
					case 'x-gbk':
						return 'GBK'
					case 'gb18030':
						return 'gb18030'
					case 'big5':
					case 'big5-hkscs':
					case 'cn-big5':
					case 'csbig5':
					case 'x-x-big5':
						return 'Big5'
					case 'cseucpkdfmtjapanese':
					case 'euc-jp':
					case 'x-euc-jp':
						return 'EUC-JP'
					case 'csiso2022jp':
					case 'iso-2022-jp':
						return 'ISO-2022-JP'
					case 'csshiftjis':
					case 'ms932':
					case 'ms_kanji':
					case 'shift-jis':
					case 'shift_jis':
					case 'sjis':
					case 'windows-31j':
					case 'x-sjis':
						return 'Shift_JIS'
					case 'cseuckr':
					case 'csksc56011987':
					case 'euc-kr':
					case 'iso-ir-149':
					case 'korean':
					case 'ks_c_5601-1987':
					case 'ks_c_5601-1989':
					case 'ksc5601':
					case 'ksc_5601':
					case 'windows-949':
						return 'EUC-KR'
					case 'csiso2022kr':
					case 'hz-gb-2312':
					case 'iso-2022-cn':
					case 'iso-2022-cn-ext':
					case 'iso-2022-kr':
					case 'replacement':
						return 'replacement'
					case 'unicodefffe':
					case 'utf-16be':
						return 'UTF-16BE'
					case 'csunicode':
					case 'iso-10646-ucs-2':
					case 'ucs-2':
					case 'unicode':
					case 'unicodefeff':
					case 'utf-16':
					case 'utf-16le':
						return 'UTF-16LE'
					case 'x-user-defined':
						return 'x-user-defined'
					default:
						return 'failure'
				}
			}

			module.exports = {
				getEncoding,
			}

			/***/
		},

		/***/ 82160: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { staticPropertyDescriptors, readOperation, fireAProgressEvent } =
				__nccwpck_require__(10165)
			const { kState, kError, kResult, kEvents, kAborted } =
				__nccwpck_require__(86812)
			const { webidl } = __nccwpck_require__(74222)
			const { kEnumerableProperty } = __nccwpck_require__(3440)

			class FileReader extends EventTarget {
				constructor() {
					super()

					this[kState] = 'empty'
					this[kResult] = null
					this[kError] = null
					this[kEvents] = {
						loadend: null,
						error: null,
						abort: null,
						load: null,
						progress: null,
						loadstart: null,
					}
				}

				/**
				 * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
				 * @param {import('buffer').Blob} blob
				 */
				readAsArrayBuffer(blob) {
					webidl.brandCheck(this, FileReader)

					webidl.argumentLengthCheck(arguments, 1, {
						header: 'FileReader.readAsArrayBuffer',
					})

					blob = webidl.converters.Blob(blob, { strict: false })

					// The readAsArrayBuffer(blob) method, when invoked,
					// must initiate a read operation for blob with ArrayBuffer.
					readOperation(this, blob, 'ArrayBuffer')
				}

				/**
				 * @see https://w3c.github.io/FileAPI/#readAsBinaryString
				 * @param {import('buffer').Blob} blob
				 */
				readAsBinaryString(blob) {
					webidl.brandCheck(this, FileReader)

					webidl.argumentLengthCheck(arguments, 1, {
						header: 'FileReader.readAsBinaryString',
					})

					blob = webidl.converters.Blob(blob, { strict: false })

					// The readAsBinaryString(blob) method, when invoked,
					// must initiate a read operation for blob with BinaryString.
					readOperation(this, blob, 'BinaryString')
				}

				/**
				 * @see https://w3c.github.io/FileAPI/#readAsDataText
				 * @param {import('buffer').Blob} blob
				 * @param {string?} encoding
				 */
				readAsText(blob, encoding = undefined) {
					webidl.brandCheck(this, FileReader)

					webidl.argumentLengthCheck(arguments, 1, {
						header: 'FileReader.readAsText',
					})

					blob = webidl.converters.Blob(blob, { strict: false })

					if (encoding !== undefined) {
						encoding = webidl.converters.DOMString(encoding)
					}

					// The readAsText(blob, encoding) method, when invoked,
					// must initiate a read operation for blob with Text and encoding.
					readOperation(this, blob, 'Text', encoding)
				}

				/**
				 * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
				 * @param {import('buffer').Blob} blob
				 */
				readAsDataURL(blob) {
					webidl.brandCheck(this, FileReader)

					webidl.argumentLengthCheck(arguments, 1, {
						header: 'FileReader.readAsDataURL',
					})

					blob = webidl.converters.Blob(blob, { strict: false })

					// The readAsDataURL(blob) method, when invoked, must
					// initiate a read operation for blob with DataURL.
					readOperation(this, blob, 'DataURL')
				}

				/**
				 * @see https://w3c.github.io/FileAPI/#dfn-abort
				 */
				abort() {
					// 1. If this's state is "empty" or if this's state is
					//    "done" set this's result to null and terminate
					//    this algorithm.
					if (this[kState] === 'empty' || this[kState] === 'done') {
						this[kResult] = null
						return
					}

					// 2. If this's state is "loading" set this's state to
					//    "done" and set this's result to null.
					if (this[kState] === 'loading') {
						this[kState] = 'done'
						this[kResult] = null
					}

					// 3. If there are any tasks from this on the file reading
					//    task source in an affiliated task queue, then remove
					//    those tasks from that task queue.
					this[kAborted] = true

					// 4. Terminate the algorithm for the read method being processed.
					// TODO

					// 5. Fire a progress event called abort at this.
					fireAProgressEvent('abort', this)

					// 6. If this's state is not "loading", fire a progress
					//    event called loadend at this.
					if (this[kState] !== 'loading') {
						fireAProgressEvent('loadend', this)
					}
				}

				/**
				 * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
				 */
				get readyState() {
					webidl.brandCheck(this, FileReader)

					switch (this[kState]) {
						case 'empty':
							return this.EMPTY
						case 'loading':
							return this.LOADING
						case 'done':
							return this.DONE
					}
				}

				/**
				 * @see https://w3c.github.io/FileAPI/#dom-filereader-result
				 */
				get result() {
					webidl.brandCheck(this, FileReader)

					// The result attributes getter, when invoked, must return
					// this's result.
					return this[kResult]
				}

				/**
				 * @see https://w3c.github.io/FileAPI/#dom-filereader-error
				 */
				get error() {
					webidl.brandCheck(this, FileReader)

					// The error attributes getter, when invoked, must return
					// this's error.
					return this[kError]
				}

				get onloadend() {
					webidl.brandCheck(this, FileReader)

					return this[kEvents].loadend
				}

				set onloadend(fn) {
					webidl.brandCheck(this, FileReader)

					if (this[kEvents].loadend) {
						this.removeEventListener('loadend', this[kEvents].loadend)
					}

					if (typeof fn === 'function') {
						this[kEvents].loadend = fn
						this.addEventListener('loadend', fn)
					} else {
						this[kEvents].loadend = null
					}
				}

				get onerror() {
					webidl.brandCheck(this, FileReader)

					return this[kEvents].error
				}

				set onerror(fn) {
					webidl.brandCheck(this, FileReader)

					if (this[kEvents].error) {
						this.removeEventListener('error', this[kEvents].error)
					}

					if (typeof fn === 'function') {
						this[kEvents].error = fn
						this.addEventListener('error', fn)
					} else {
						this[kEvents].error = null
					}
				}

				get onloadstart() {
					webidl.brandCheck(this, FileReader)

					return this[kEvents].loadstart
				}

				set onloadstart(fn) {
					webidl.brandCheck(this, FileReader)

					if (this[kEvents].loadstart) {
						this.removeEventListener('loadstart', this[kEvents].loadstart)
					}

					if (typeof fn === 'function') {
						this[kEvents].loadstart = fn
						this.addEventListener('loadstart', fn)
					} else {
						this[kEvents].loadstart = null
					}
				}

				get onprogress() {
					webidl.brandCheck(this, FileReader)

					return this[kEvents].progress
				}

				set onprogress(fn) {
					webidl.brandCheck(this, FileReader)

					if (this[kEvents].progress) {
						this.removeEventListener('progress', this[kEvents].progress)
					}

					if (typeof fn === 'function') {
						this[kEvents].progress = fn
						this.addEventListener('progress', fn)
					} else {
						this[kEvents].progress = null
					}
				}

				get onload() {
					webidl.brandCheck(this, FileReader)

					return this[kEvents].load
				}

				set onload(fn) {
					webidl.brandCheck(this, FileReader)

					if (this[kEvents].load) {
						this.removeEventListener('load', this[kEvents].load)
					}

					if (typeof fn === 'function') {
						this[kEvents].load = fn
						this.addEventListener('load', fn)
					} else {
						this[kEvents].load = null
					}
				}

				get onabort() {
					webidl.brandCheck(this, FileReader)

					return this[kEvents].abort
				}

				set onabort(fn) {
					webidl.brandCheck(this, FileReader)

					if (this[kEvents].abort) {
						this.removeEventListener('abort', this[kEvents].abort)
					}

					if (typeof fn === 'function') {
						this[kEvents].abort = fn
						this.addEventListener('abort', fn)
					} else {
						this[kEvents].abort = null
					}
				}
			}

			// https://w3c.github.io/FileAPI/#dom-filereader-empty
			FileReader.EMPTY = FileReader.prototype.EMPTY = 0
			// https://w3c.github.io/FileAPI/#dom-filereader-loading
			FileReader.LOADING = FileReader.prototype.LOADING = 1
			// https://w3c.github.io/FileAPI/#dom-filereader-done
			FileReader.DONE = FileReader.prototype.DONE = 2

			Object.defineProperties(FileReader.prototype, {
				EMPTY: staticPropertyDescriptors,
				LOADING: staticPropertyDescriptors,
				DONE: staticPropertyDescriptors,
				readAsArrayBuffer: kEnumerableProperty,
				readAsBinaryString: kEnumerableProperty,
				readAsText: kEnumerableProperty,
				readAsDataURL: kEnumerableProperty,
				abort: kEnumerableProperty,
				readyState: kEnumerableProperty,
				result: kEnumerableProperty,
				error: kEnumerableProperty,
				onloadstart: kEnumerableProperty,
				onprogress: kEnumerableProperty,
				onload: kEnumerableProperty,
				onabort: kEnumerableProperty,
				onerror: kEnumerableProperty,
				onloadend: kEnumerableProperty,
				[Symbol.toStringTag]: {
					value: 'FileReader',
					writable: false,
					enumerable: false,
					configurable: true,
				},
			})

			Object.defineProperties(FileReader, {
				EMPTY: staticPropertyDescriptors,
				LOADING: staticPropertyDescriptors,
				DONE: staticPropertyDescriptors,
			})

			module.exports = {
				FileReader,
			}

			/***/
		},

		/***/ 15976: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { webidl } = __nccwpck_require__(74222)

			const kState = Symbol('ProgressEvent state')

			/**
			 * @see https://xhr.spec.whatwg.org/#progressevent
			 */
			class ProgressEvent extends Event {
				constructor(type, eventInitDict = {}) {
					type = webidl.converters.DOMString(type)
					eventInitDict = webidl.converters.ProgressEventInit(
						eventInitDict ?? {},
					)

					super(type, eventInitDict)

					this[kState] = {
						lengthComputable: eventInitDict.lengthComputable,
						loaded: eventInitDict.loaded,
						total: eventInitDict.total,
					}
				}

				get lengthComputable() {
					webidl.brandCheck(this, ProgressEvent)

					return this[kState].lengthComputable
				}

				get loaded() {
					webidl.brandCheck(this, ProgressEvent)

					return this[kState].loaded
				}

				get total() {
					webidl.brandCheck(this, ProgressEvent)

					return this[kState].total
				}
			}

			webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
				{
					key: 'lengthComputable',
					converter: webidl.converters.boolean,
					defaultValue: false,
				},
				{
					key: 'loaded',
					converter: webidl.converters['unsigned long long'],
					defaultValue: 0,
				},
				{
					key: 'total',
					converter: webidl.converters['unsigned long long'],
					defaultValue: 0,
				},
				{
					key: 'bubbles',
					converter: webidl.converters.boolean,
					defaultValue: false,
				},
				{
					key: 'cancelable',
					converter: webidl.converters.boolean,
					defaultValue: false,
				},
				{
					key: 'composed',
					converter: webidl.converters.boolean,
					defaultValue: false,
				},
			])

			module.exports = {
				ProgressEvent,
			}

			/***/
		},

		/***/ 86812: /***/ (module) => {
			'use strict'

			module.exports = {
				kState: Symbol('FileReader state'),
				kResult: Symbol('FileReader result'),
				kError: Symbol('FileReader error'),
				kLastProgressEventFired: Symbol(
					'FileReader last progress event fired timestamp',
				),
				kEvents: Symbol('FileReader events'),
				kAborted: Symbol('FileReader aborted'),
			}

			/***/
		},

		/***/ 10165: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { kState, kError, kResult, kAborted, kLastProgressEventFired } =
				__nccwpck_require__(86812)
			const { ProgressEvent } = __nccwpck_require__(15976)
			const { getEncoding } = __nccwpck_require__(40396)
			const { DOMException } = __nccwpck_require__(87326)
			const { serializeAMimeType, parseMIMEType } = __nccwpck_require__(94322)
			const { types } = __nccwpck_require__(39023)
			const { StringDecoder } = __nccwpck_require__(13193)
			const { btoa } = __nccwpck_require__(20181)

			/** @type {PropertyDescriptor} */
			const staticPropertyDescriptors = {
				enumerable: true,
				writable: false,
				configurable: false,
			}

			/**
			 * @see https://w3c.github.io/FileAPI/#readOperation
			 * @param {import('./filereader').FileReader} fr
			 * @param {import('buffer').Blob} blob
			 * @param {string} type
			 * @param {string?} encodingName
			 */
			function readOperation(fr, blob, type, encodingName) {
				// 1. If frs state is "loading", throw an InvalidStateError
				//    DOMException.
				if (fr[kState] === 'loading') {
					throw new DOMException('Invalid state', 'InvalidStateError')
				}

				// 2. Set frs state to "loading".
				fr[kState] = 'loading'

				// 3. Set frs result to null.
				fr[kResult] = null

				// 4. Set frs error to null.
				fr[kError] = null

				// 5. Let stream be the result of calling get stream on blob.
				/** @type {import('stream/web').ReadableStream} */
				const stream = blob.stream()

				// 6. Let reader be the result of getting a reader from stream.
				const reader = stream.getReader()

				// 7. Let bytes be an empty byte sequence.
				/** @type {Uint8Array[]} */
				const bytes = []

				// 8. Let chunkPromise be the result of reading a chunk from
				//    stream with reader.
				let chunkPromise = reader.read()

				// 9. Let isFirstChunk be true.
				let isFirstChunk = true

				// 10. In parallel, while true:
				// Note: "In parallel" just means non-blocking
				// Note 2: readOperation itself cannot be async as double
				// reading the body would then reject the promise, instead
				// of throwing an error.
				;(async () => {
					while (!fr[kAborted]) {
						// 1. Wait for chunkPromise to be fulfilled or rejected.
						try {
							const { done, value } = await chunkPromise

							// 2. If chunkPromise is fulfilled, and isFirstChunk is
							//    true, queue a task to fire a progress event called
							//    loadstart at fr.
							if (isFirstChunk && !fr[kAborted]) {
								queueMicrotask(() => {
									fireAProgressEvent('loadstart', fr)
								})
							}

							// 3. Set isFirstChunk to false.
							isFirstChunk = false

							// 4. If chunkPromise is fulfilled with an object whose
							//    done property is false and whose value property is
							//    a Uint8Array object, run these steps:
							if (!done && types.isUint8Array(value)) {
								// 1. Let bs be the byte sequence represented by the
								//    Uint8Array object.

								// 2. Append bs to bytes.
								bytes.push(value)

								// 3. If roughly 50ms have passed since these steps
								//    were last invoked, queue a task to fire a
								//    progress event called progress at fr.
								if (
									(fr[kLastProgressEventFired] === undefined ||
										Date.now() - fr[kLastProgressEventFired] >= 50) &&
									!fr[kAborted]
								) {
									fr[kLastProgressEventFired] = Date.now()
									queueMicrotask(() => {
										fireAProgressEvent('progress', fr)
									})
								}

								// 4. Set chunkPromise to the result of reading a
								//    chunk from stream with reader.
								chunkPromise = reader.read()
							} else if (done) {
								// 5. Otherwise, if chunkPromise is fulfilled with an
								//    object whose done property is true, queue a task
								//    to run the following steps and abort this algorithm:
								queueMicrotask(() => {
									// 1. Set frs state to "done".
									fr[kState] = 'done'

									// 2. Let result be the result of package data given
									//    bytes, type, blobs type, and encodingName.
									try {
										const result = packageData(
											bytes,
											type,
											blob.type,
											encodingName,
										)

										// 4. Else:

										if (fr[kAborted]) {
											return
										}

										// 1. Set frs result to result.
										fr[kResult] = result

										// 2. Fire a progress event called load at the fr.
										fireAProgressEvent('load', fr)
									} catch (error) {
										// 3. If package data threw an exception error:

										// 1. Set frs error to error.
										fr[kError] = error

										// 2. Fire a progress event called error at fr.
										fireAProgressEvent('error', fr)
									}

									// 5. If frs state is not "loading", fire a progress
									//    event called loadend at the fr.
									if (fr[kState] !== 'loading') {
										fireAProgressEvent('loadend', fr)
									}
								})

								break
							}
						} catch (error) {
							if (fr[kAborted]) {
								return
							}

							// 6. Otherwise, if chunkPromise is rejected with an
							//    error error, queue a task to run the following
							//    steps and abort this algorithm:
							queueMicrotask(() => {
								// 1. Set frs state to "done".
								fr[kState] = 'done'

								// 2. Set frs error to error.
								fr[kError] = error

								// 3. Fire a progress event called error at fr.
								fireAProgressEvent('error', fr)

								// 4. If frs state is not "loading", fire a progress
								//    event called loadend at fr.
								if (fr[kState] !== 'loading') {
									fireAProgressEvent('loadend', fr)
								}
							})

							break
						}
					}
				})()
			}

			/**
			 * @see https://w3c.github.io/FileAPI/#fire-a-progress-event
			 * @see https://dom.spec.whatwg.org/#concept-event-fire
			 * @param {string} e The name of the event
			 * @param {import('./filereader').FileReader} reader
			 */
			function fireAProgressEvent(e, reader) {
				// The progress event e does not bubble. e.bubbles must be false
				// The progress event e is NOT cancelable. e.cancelable must be false
				const event = new ProgressEvent(e, {
					bubbles: false,
					cancelable: false,
				})

				reader.dispatchEvent(event)
			}

			/**
			 * @see https://w3c.github.io/FileAPI/#blob-package-data
			 * @param {Uint8Array[]} bytes
			 * @param {string} type
			 * @param {string?} mimeType
			 * @param {string?} encodingName
			 */
			function packageData(bytes, type, mimeType, encodingName) {
				// 1. A Blob has an associated package data algorithm, given
				//    bytes, a type, a optional mimeType, and a optional
				//    encodingName, which switches on type and runs the
				//    associated steps:

				switch (type) {
					case 'DataURL': {
						// 1. Return bytes as a DataURL [RFC2397] subject to
						//    the considerations below:
						//  * Use mimeType as part of the Data URL if it is
						//    available in keeping with the Data URL
						//    specification [RFC2397].
						//  * If mimeType is not available return a Data URL
						//    without a media-type. [RFC2397].

						// https://datatracker.ietf.org/doc/html/rfc2397#section-3
						// dataurl    := "data:" [ mediatype ] [ ";base64" ] "," data
						// mediatype  := [ type "/" subtype ] *( ";" parameter )
						// data       := *urlchar
						// parameter  := attribute "=" value
						let dataURL = 'data:'

						const parsed = parseMIMEType(mimeType || 'application/octet-stream')

						if (parsed !== 'failure') {
							dataURL += serializeAMimeType(parsed)
						}

						dataURL += ';base64,'

						const decoder = new StringDecoder('latin1')

						for (const chunk of bytes) {
							dataURL += btoa(decoder.write(chunk))
						}

						dataURL += btoa(decoder.end())

						return dataURL
					}
					case 'Text': {
						// 1. Let encoding be failure
						let encoding = 'failure'

						// 2. If the encodingName is present, set encoding to the
						//    result of getting an encoding from encodingName.
						if (encodingName) {
							encoding = getEncoding(encodingName)
						}

						// 3. If encoding is failure, and mimeType is present:
						if (encoding === 'failure' && mimeType) {
							// 1. Let type be the result of parse a MIME type
							//    given mimeType.
							const type = parseMIMEType(mimeType)

							// 2. If type is not failure, set encoding to the result
							//    of getting an encoding from types parameters["charset"].
							if (type !== 'failure') {
								encoding = getEncoding(type.parameters.get('charset'))
							}
						}

						// 4. If encoding is failure, then set encoding to UTF-8.
						if (encoding === 'failure') {
							encoding = 'UTF-8'
						}

						// 5. Decode bytes using fallback encoding encoding, and
						//    return the result.
						return decode(bytes, encoding)
					}
					case 'ArrayBuffer': {
						// Return a new ArrayBuffer whose contents are bytes.
						const sequence = combineByteSequences(bytes)

						return sequence.buffer
					}
					case 'BinaryString': {
						// Return bytes as a binary string, in which every byte
						//  is represented by a code unit of equal value [0..255].
						let binaryString = ''

						const decoder = new StringDecoder('latin1')

						for (const chunk of bytes) {
							binaryString += decoder.write(chunk)
						}

						binaryString += decoder.end()

						return binaryString
					}
				}
			}

			/**
			 * @see https://encoding.spec.whatwg.org/#decode
			 * @param {Uint8Array[]} ioQueue
			 * @param {string} encoding
			 */
			function decode(ioQueue, encoding) {
				const bytes = combineByteSequences(ioQueue)

				// 1. Let BOMEncoding be the result of BOM sniffing ioQueue.
				const BOMEncoding = BOMSniffing(bytes)

				let slice = 0

				// 2. If BOMEncoding is non-null:
				if (BOMEncoding !== null) {
					// 1. Set encoding to BOMEncoding.
					encoding = BOMEncoding

					// 2. Read three bytes from ioQueue, if BOMEncoding is
					//    UTF-8; otherwise read two bytes.
					//    (Do nothing with those bytes.)
					slice = BOMEncoding === 'UTF-8' ? 3 : 2
				}

				// 3. Process a queue with an instance of encodings
				//    decoder, ioQueue, output, and "replacement".

				// 4. Return output.

				const sliced = bytes.slice(slice)
				return new TextDecoder(encoding).decode(sliced)
			}

			/**
			 * @see https://encoding.spec.whatwg.org/#bom-sniff
			 * @param {Uint8Array} ioQueue
			 */
			function BOMSniffing(ioQueue) {
				// 1. Let BOM be the result of peeking 3 bytes from ioQueue,
				//    converted to a byte sequence.
				const [a, b, c] = ioQueue

				// 2. For each of the rows in the table below, starting with
				//    the first one and going down, if BOM starts with the
				//    bytes given in the first column, then return the
				//    encoding given in the cell in the second column of that
				//    row. Otherwise, return null.
				if (a === 0xef && b === 0xbb && c === 0xbf) {
					return 'UTF-8'
				} else if (a === 0xfe && b === 0xff) {
					return 'UTF-16BE'
				} else if (a === 0xff && b === 0xfe) {
					return 'UTF-16LE'
				}

				return null
			}

			/**
			 * @param {Uint8Array[]} sequences
			 */
			function combineByteSequences(sequences) {
				const size = sequences.reduce((a, b) => {
					return a + b.byteLength
				}, 0)

				let offset = 0

				return sequences.reduce((a, b) => {
					a.set(b, offset)
					offset += b.byteLength
					return a
				}, new Uint8Array(size))
			}

			module.exports = {
				staticPropertyDescriptors,
				readOperation,
				fireAProgressEvent,
			}

			/***/
		},

		/***/ 32581: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			// We include a version number for the Dispatcher API. In case of breaking changes,
			// this version number must be increased to avoid conflicts.
			const globalDispatcher = Symbol.for('undici.globalDispatcher.1')
			const { InvalidArgumentError } = __nccwpck_require__(68707)
			const Agent = __nccwpck_require__(59965)

			if (getGlobalDispatcher() === undefined) {
				setGlobalDispatcher(new Agent())
			}

			function setGlobalDispatcher(agent) {
				if (!agent || typeof agent.dispatch !== 'function') {
					throw new InvalidArgumentError('Argument agent must implement Agent')
				}
				Object.defineProperty(globalThis, globalDispatcher, {
					value: agent,
					writable: true,
					enumerable: false,
					configurable: false,
				})
			}

			function getGlobalDispatcher() {
				return globalThis[globalDispatcher]
			}

			module.exports = {
				setGlobalDispatcher,
				getGlobalDispatcher,
			}

			/***/
		},

		/***/ 78840: /***/ (module) => {
			'use strict'

			module.exports = class DecoratorHandler {
				constructor(handler) {
					this.handler = handler
				}

				onConnect(...args) {
					return this.handler.onConnect(...args)
				}

				onError(...args) {
					return this.handler.onError(...args)
				}

				onUpgrade(...args) {
					return this.handler.onUpgrade(...args)
				}

				onHeaders(...args) {
					return this.handler.onHeaders(...args)
				}

				onData(...args) {
					return this.handler.onData(...args)
				}

				onComplete(...args) {
					return this.handler.onComplete(...args)
				}

				onBodySent(...args) {
					return this.handler.onBodySent(...args)
				}
			}

			/***/
		},

		/***/ 48299: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const util = __nccwpck_require__(3440)
			const { kBodyUsed } = __nccwpck_require__(36443)
			const assert = __nccwpck_require__(42613)
			const { InvalidArgumentError } = __nccwpck_require__(68707)
			const EE = __nccwpck_require__(24434)

			const redirectableStatusCodes = [300, 301, 302, 303, 307, 308]

			const kBody = Symbol('body')

			class BodyAsyncIterable {
				constructor(body) {
					this[kBody] = body
					this[kBodyUsed] = false
				}

				async *[Symbol.asyncIterator]() {
					assert(!this[kBodyUsed], 'disturbed')
					this[kBodyUsed] = true
					yield* this[kBody]
				}
			}

			class RedirectHandler {
				constructor(dispatch, maxRedirections, opts, handler) {
					if (
						maxRedirections != null &&
						(!Number.isInteger(maxRedirections) || maxRedirections < 0)
					) {
						throw new InvalidArgumentError(
							'maxRedirections must be a positive number',
						)
					}

					util.validateHandler(handler, opts.method, opts.upgrade)

					this.dispatch = dispatch
					this.location = null
					this.abort = null
					this.opts = { ...opts, maxRedirections: 0 } // opts must be a copy
					this.maxRedirections = maxRedirections
					this.handler = handler
					this.history = []

					if (util.isStream(this.opts.body)) {
						// TODO (fix): Provide some way for the user to cache the file to e.g. /tmp
						// so that it can be dispatched again?
						// TODO (fix): Do we need 100-expect support to provide a way to do this properly?
						if (util.bodyLength(this.opts.body) === 0) {
							this.opts.body.on('data', function () {
								assert(false)
							})
						}

						if (typeof this.opts.body.readableDidRead !== 'boolean') {
							this.opts.body[kBodyUsed] = false
							EE.prototype.on.call(this.opts.body, 'data', function () {
								this[kBodyUsed] = true
							})
						}
					} else if (
						this.opts.body &&
						typeof this.opts.body.pipeTo === 'function'
					) {
						// TODO (fix): We can't access ReadableStream internal state
						// to determine whether or not it has been disturbed. This is just
						// a workaround.
						this.opts.body = new BodyAsyncIterable(this.opts.body)
					} else if (
						this.opts.body &&
						typeof this.opts.body !== 'string' &&
						!ArrayBuffer.isView(this.opts.body) &&
						util.isIterable(this.opts.body)
					) {
						// TODO: Should we allow re-using iterable if !this.opts.idempotent
						// or through some other flag?
						this.opts.body = new BodyAsyncIterable(this.opts.body)
					}
				}

				onConnect(abort) {
					this.abort = abort
					this.handler.onConnect(abort, { history: this.history })
				}

				onUpgrade(statusCode, headers, socket) {
					this.handler.onUpgrade(statusCode, headers, socket)
				}

				onError(error) {
					this.handler.onError(error)
				}

				onHeaders(statusCode, headers, resume, statusText) {
					this.location =
						this.history.length >= this.maxRedirections ||
						util.isDisturbed(this.opts.body)
							? null
							: parseLocation(statusCode, headers)

					if (this.opts.origin) {
						this.history.push(new URL(this.opts.path, this.opts.origin))
					}

					if (!this.location) {
						return this.handler.onHeaders(
							statusCode,
							headers,
							resume,
							statusText,
						)
					}

					const { origin, pathname, search } = util.parseURL(
						new URL(
							this.location,
							this.opts.origin && new URL(this.opts.path, this.opts.origin),
						),
					)
					const path = search ? `${pathname}${search}` : pathname

					// Remove headers referring to the original URL.
					// By default it is Host only, unless it's a 303 (see below), which removes also all Content-* headers.
					// https://tools.ietf.org/html/rfc7231#section-6.4
					this.opts.headers = cleanRequestHeaders(
						this.opts.headers,
						statusCode === 303,
						this.opts.origin !== origin,
					)
					this.opts.path = path
					this.opts.origin = origin
					this.opts.maxRedirections = 0
					this.opts.query = null

					// https://tools.ietf.org/html/rfc7231#section-6.4.4
					// In case of HTTP 303, always replace method to be either HEAD or GET
					if (statusCode === 303 && this.opts.method !== 'HEAD') {
						this.opts.method = 'GET'
						this.opts.body = null
					}
				}

				onData(chunk) {
					if (this.location) {
						/*
        https://tools.ietf.org/html/rfc7231#section-6.4

        TLDR: undici always ignores 3xx response bodies.

        Redirection is used to serve the requested resource from another URL, so it is assumes that
        no body is generated (and thus can be ignored). Even though generating a body is not prohibited.

        For status 301, 302, 303, 307 and 308 (the latter from RFC 7238), the specs mention that the body usually
        (which means it's optional and not mandated) contain just an hyperlink to the value of
        the Location response header, so the body can be ignored safely.

        For status 300, which is "Multiple Choices", the spec mentions both generating a Location
        response header AND a response body with the other possible location to follow.
        Since the spec explicitily chooses not to specify a format for such body and leave it to
        servers and browsers implementors, we ignore the body as there is no specified way to eventually parse it.
      */
					} else {
						return this.handler.onData(chunk)
					}
				}

				onComplete(trailers) {
					if (this.location) {
						/*
        https://tools.ietf.org/html/rfc7231#section-6.4

        TLDR: undici always ignores 3xx response trailers as they are not expected in case of redirections
        and neither are useful if present.

        See comment on onData method above for more detailed informations.
      */

						this.location = null
						this.abort = null

						this.dispatch(this.opts, this)
					} else {
						this.handler.onComplete(trailers)
					}
				}

				onBodySent(chunk) {
					if (this.handler.onBodySent) {
						this.handler.onBodySent(chunk)
					}
				}
			}

			function parseLocation(statusCode, headers) {
				if (redirectableStatusCodes.indexOf(statusCode) === -1) {
					return null
				}

				for (let i = 0; i < headers.length; i += 2) {
					if (headers[i].toString().toLowerCase() === 'location') {
						return headers[i + 1]
					}
				}
			}

			// https://tools.ietf.org/html/rfc7231#section-6.4.4
			function shouldRemoveHeader(header, removeContent, unknownOrigin) {
				if (header.length === 4) {
					return util.headerNameToString(header) === 'host'
				}
				if (
					removeContent &&
					util.headerNameToString(header).startsWith('content-')
				) {
					return true
				}
				if (
					unknownOrigin &&
					(header.length === 13 || header.length === 6 || header.length === 19)
				) {
					const name = util.headerNameToString(header)
					return (
						name === 'authorization' ||
						name === 'cookie' ||
						name === 'proxy-authorization'
					)
				}
				return false
			}

			// https://tools.ietf.org/html/rfc7231#section-6.4
			function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
				const ret = []
				if (Array.isArray(headers)) {
					for (let i = 0; i < headers.length; i += 2) {
						if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
							ret.push(headers[i], headers[i + 1])
						}
					}
				} else if (headers && typeof headers === 'object') {
					for (const key of Object.keys(headers)) {
						if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
							ret.push(key, headers[key])
						}
					}
				} else {
					assert(headers == null, 'headers must be an object or an array')
				}
				return ret
			}

			module.exports = RedirectHandler

			/***/
		},

		/***/ 53573: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			const assert = __nccwpck_require__(42613)

			const { kRetryHandlerDefaultRetry } = __nccwpck_require__(36443)
			const { RequestRetryError } = __nccwpck_require__(68707)
			const { isDisturbed, parseHeaders, parseRangeHeader } =
				__nccwpck_require__(3440)

			function calculateRetryAfterHeader(retryAfter) {
				const current = Date.now()
				const diff = new Date(retryAfter).getTime() - current

				return diff
			}

			class RetryHandler {
				constructor(opts, handlers) {
					const { retryOptions, ...dispatchOpts } = opts
					const {
						// Retry scoped
						retry: retryFn,
						maxRetries,
						maxTimeout,
						minTimeout,
						timeoutFactor,
						// Response scoped
						methods,
						errorCodes,
						retryAfter,
						statusCodes,
					} = retryOptions ?? {}

					this.dispatch = handlers.dispatch
					this.handler = handlers.handler
					this.opts = dispatchOpts
					this.abort = null
					this.aborted = false
					this.retryOpts = {
						retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],
						retryAfter: retryAfter ?? true,
						maxTimeout: maxTimeout ?? 30 * 1000, // 30s,
						timeout: minTimeout ?? 500, // .5s
						timeoutFactor: timeoutFactor ?? 2,
						maxRetries: maxRetries ?? 5,
						// What errors we should retry
						methods: methods ?? [
							'GET',
							'HEAD',
							'OPTIONS',
							'PUT',
							'DELETE',
							'TRACE',
						],
						// Indicates which errors to retry
						statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
						// List of errors to retry
						errorCodes: errorCodes ?? [
							'ECONNRESET',
							'ECONNREFUSED',
							'ENOTFOUND',
							'ENETDOWN',
							'ENETUNREACH',
							'EHOSTDOWN',
							'EHOSTUNREACH',
							'EPIPE',
						],
					}

					this.retryCount = 0
					this.start = 0
					this.end = null
					this.etag = null
					this.resume = null

					// Handle possible onConnect duplication
					this.handler.onConnect((reason) => {
						this.aborted = true
						if (this.abort) {
							this.abort(reason)
						} else {
							this.reason = reason
						}
					})
				}

				onRequestSent() {
					if (this.handler.onRequestSent) {
						this.handler.onRequestSent()
					}
				}

				onUpgrade(statusCode, headers, socket) {
					if (this.handler.onUpgrade) {
						this.handler.onUpgrade(statusCode, headers, socket)
					}
				}

				onConnect(abort) {
					if (this.aborted) {
						abort(this.reason)
					} else {
						this.abort = abort
					}
				}

				onBodySent(chunk) {
					if (this.handler.onBodySent) return this.handler.onBodySent(chunk)
				}

				static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
					const { statusCode, code, headers } = err
					const { method, retryOptions } = opts
					const {
						maxRetries,
						timeout,
						maxTimeout,
						timeoutFactor,
						statusCodes,
						errorCodes,
						methods,
					} = retryOptions
					let { counter, currentTimeout } = state

					currentTimeout =
						currentTimeout != null && currentTimeout > 0
							? currentTimeout
							: timeout

					// Any code that is not a Undici's originated and allowed to retry
					if (
						code &&
						code !== 'UND_ERR_REQ_RETRY' &&
						code !== 'UND_ERR_SOCKET' &&
						!errorCodes.includes(code)
					) {
						cb(err)
						return
					}

					// If a set of method are provided and the current method is not in the list
					if (Array.isArray(methods) && !methods.includes(method)) {
						cb(err)
						return
					}

					// If a set of status code are provided and the current status code is not in the list
					if (
						statusCode != null &&
						Array.isArray(statusCodes) &&
						!statusCodes.includes(statusCode)
					) {
						cb(err)
						return
					}

					// If we reached the max number of retries
					if (counter > maxRetries) {
						cb(err)
						return
					}

					let retryAfterHeader = headers != null && headers['retry-after']
					if (retryAfterHeader) {
						retryAfterHeader = Number(retryAfterHeader)
						retryAfterHeader = isNaN(retryAfterHeader)
							? calculateRetryAfterHeader(retryAfterHeader)
							: retryAfterHeader * 1e3 // Retry-After is in seconds
					}

					const retryTimeout =
						retryAfterHeader > 0
							? Math.min(retryAfterHeader, maxTimeout)
							: Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout)

					state.currentTimeout = retryTimeout

					setTimeout(() => cb(null), retryTimeout)
				}

				onHeaders(statusCode, rawHeaders, resume, statusMessage) {
					const headers = parseHeaders(rawHeaders)

					this.retryCount += 1

					if (statusCode >= 300) {
						this.abort(
							new RequestRetryError('Request failed', statusCode, {
								headers,
								count: this.retryCount,
							}),
						)
						return false
					}

					// Checkpoint for resume from where we left it
					if (this.resume != null) {
						this.resume = null

						if (statusCode !== 206) {
							return true
						}

						const contentRange = parseRangeHeader(headers['content-range'])
						// If no content range
						if (!contentRange) {
							this.abort(
								new RequestRetryError('Content-Range mismatch', statusCode, {
									headers,
									count: this.retryCount,
								}),
							)
							return false
						}

						// Let's start with a weak etag check
						if (this.etag != null && this.etag !== headers.etag) {
							this.abort(
								new RequestRetryError('ETag mismatch', statusCode, {
									headers,
									count: this.retryCount,
								}),
							)
							return false
						}

						const { start, size, end = size } = contentRange

						assert(this.start === start, 'content-range mismatch')
						assert(
							this.end == null || this.end === end,
							'content-range mismatch',
						)

						this.resume = resume
						return true
					}

					if (this.end == null) {
						if (statusCode === 206) {
							// First time we receive 206
							const range = parseRangeHeader(headers['content-range'])

							if (range == null) {
								return this.handler.onHeaders(
									statusCode,
									rawHeaders,
									resume,
									statusMessage,
								)
							}

							const { start, size, end = size } = range

							assert(
								start != null && Number.isFinite(start) && this.start !== start,
								'content-range mismatch',
							)
							assert(Number.isFinite(start))
							assert(
								end != null && Number.isFinite(end) && this.end !== end,
								'invalid content-length',
							)

							this.start = start
							this.end = end
						}

						// We make our best to checkpoint the body for further range headers
						if (this.end == null) {
							const contentLength = headers['content-length']
							this.end = contentLength != null ? Number(contentLength) : null
						}

						assert(Number.isFinite(this.start))
						assert(
							this.end == null || Number.isFinite(this.end),
							'invalid content-length',
						)

						this.resume = resume
						this.etag = headers.etag != null ? headers.etag : null

						return this.handler.onHeaders(
							statusCode,
							rawHeaders,
							resume,
							statusMessage,
						)
					}

					const err = new RequestRetryError('Request failed', statusCode, {
						headers,
						count: this.retryCount,
					})

					this.abort(err)

					return false
				}

				onData(chunk) {
					this.start += chunk.length

					return this.handler.onData(chunk)
				}

				onComplete(rawTrailers) {
					this.retryCount = 0
					return this.handler.onComplete(rawTrailers)
				}

				onError(err) {
					if (this.aborted || isDisturbed(this.opts.body)) {
						return this.handler.onError(err)
					}

					this.retryOpts.retry(
						err,
						{
							state: {
								counter: this.retryCount++,
								currentTimeout: this.retryAfter,
							},
							opts: { retryOptions: this.retryOpts, ...this.opts },
						},
						onRetry.bind(this),
					)

					function onRetry(err) {
						if (err != null || this.aborted || isDisturbed(this.opts.body)) {
							return this.handler.onError(err)
						}

						if (this.start !== 0) {
							this.opts = {
								...this.opts,
								headers: {
									...this.opts.headers,
									range: `bytes=${this.start}-${this.end ?? ''}`,
								},
							}
						}

						try {
							this.dispatch(this.opts, this)
						} catch (err) {
							this.handler.onError(err)
						}
					}
				}
			}

			module.exports = RetryHandler

			/***/
		},

		/***/ 64415: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const RedirectHandler = __nccwpck_require__(48299)

			function createRedirectInterceptor({
				maxRedirections: defaultMaxRedirections,
			}) {
				return (dispatch) => {
					return function Intercept(opts, handler) {
						const { maxRedirections = defaultMaxRedirections } = opts

						if (!maxRedirections) {
							return dispatch(opts, handler)
						}

						const redirectHandler = new RedirectHandler(
							dispatch,
							maxRedirections,
							opts,
							handler,
						)
						opts = { ...opts, maxRedirections: 0 } // Stop sub dispatcher from also redirecting.
						return dispatch(opts, redirectHandler)
					}
				}
			}

			module.exports = createRedirectInterceptor

			/***/
		},

		/***/ 52824: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', { value: true })
			exports.SPECIAL_HEADERS =
				exports.HEADER_STATE =
				exports.MINOR =
				exports.MAJOR =
				exports.CONNECTION_TOKEN_CHARS =
				exports.HEADER_CHARS =
				exports.TOKEN =
				exports.STRICT_TOKEN =
				exports.HEX =
				exports.URL_CHAR =
				exports.STRICT_URL_CHAR =
				exports.USERINFO_CHARS =
				exports.MARK =
				exports.ALPHANUM =
				exports.NUM =
				exports.HEX_MAP =
				exports.NUM_MAP =
				exports.ALPHA =
				exports.FINISH =
				exports.H_METHOD_MAP =
				exports.METHOD_MAP =
				exports.METHODS_RTSP =
				exports.METHODS_ICE =
				exports.METHODS_HTTP =
				exports.METHODS =
				exports.LENIENT_FLAGS =
				exports.FLAGS =
				exports.TYPE =
				exports.ERROR =
					void 0
			const utils_1 = __nccwpck_require__(50172)
			// C headers
			var ERROR
			;(function (ERROR) {
				ERROR[(ERROR['OK'] = 0)] = 'OK'
				ERROR[(ERROR['INTERNAL'] = 1)] = 'INTERNAL'
				ERROR[(ERROR['STRICT'] = 2)] = 'STRICT'
				ERROR[(ERROR['LF_EXPECTED'] = 3)] = 'LF_EXPECTED'
				ERROR[(ERROR['UNEXPECTED_CONTENT_LENGTH'] = 4)] =
					'UNEXPECTED_CONTENT_LENGTH'
				ERROR[(ERROR['CLOSED_CONNECTION'] = 5)] = 'CLOSED_CONNECTION'
				ERROR[(ERROR['INVALID_METHOD'] = 6)] = 'INVALID_METHOD'
				ERROR[(ERROR['INVALID_URL'] = 7)] = 'INVALID_URL'
				ERROR[(ERROR['INVALID_CONSTANT'] = 8)] = 'INVALID_CONSTANT'
				ERROR[(ERROR['INVALID_VERSION'] = 9)] = 'INVALID_VERSION'
				ERROR[(ERROR['INVALID_HEADER_TOKEN'] = 10)] = 'INVALID_HEADER_TOKEN'
				ERROR[(ERROR['INVALID_CONTENT_LENGTH'] = 11)] = 'INVALID_CONTENT_LENGTH'
				ERROR[(ERROR['INVALID_CHUNK_SIZE'] = 12)] = 'INVALID_CHUNK_SIZE'
				ERROR[(ERROR['INVALID_STATUS'] = 13)] = 'INVALID_STATUS'
				ERROR[(ERROR['INVALID_EOF_STATE'] = 14)] = 'INVALID_EOF_STATE'
				ERROR[(ERROR['INVALID_TRANSFER_ENCODING'] = 15)] =
					'INVALID_TRANSFER_ENCODING'
				ERROR[(ERROR['CB_MESSAGE_BEGIN'] = 16)] = 'CB_MESSAGE_BEGIN'
				ERROR[(ERROR['CB_HEADERS_COMPLETE'] = 17)] = 'CB_HEADERS_COMPLETE'
				ERROR[(ERROR['CB_MESSAGE_COMPLETE'] = 18)] = 'CB_MESSAGE_COMPLETE'
				ERROR[(ERROR['CB_CHUNK_HEADER'] = 19)] = 'CB_CHUNK_HEADER'
				ERROR[(ERROR['CB_CHUNK_COMPLETE'] = 20)] = 'CB_CHUNK_COMPLETE'
				ERROR[(ERROR['PAUSED'] = 21)] = 'PAUSED'
				ERROR[(ERROR['PAUSED_UPGRADE'] = 22)] = 'PAUSED_UPGRADE'
				ERROR[(ERROR['PAUSED_H2_UPGRADE'] = 23)] = 'PAUSED_H2_UPGRADE'
				ERROR[(ERROR['USER'] = 24)] = 'USER'
			})((ERROR = exports.ERROR || (exports.ERROR = {})))
			var TYPE
			;(function (TYPE) {
				TYPE[(TYPE['BOTH'] = 0)] = 'BOTH'
				TYPE[(TYPE['REQUEST'] = 1)] = 'REQUEST'
				TYPE[(TYPE['RESPONSE'] = 2)] = 'RESPONSE'
			})((TYPE = exports.TYPE || (exports.TYPE = {})))
			var FLAGS
			;(function (FLAGS) {
				FLAGS[(FLAGS['CONNECTION_KEEP_ALIVE'] = 1)] = 'CONNECTION_KEEP_ALIVE'
				FLAGS[(FLAGS['CONNECTION_CLOSE'] = 2)] = 'CONNECTION_CLOSE'
				FLAGS[(FLAGS['CONNECTION_UPGRADE'] = 4)] = 'CONNECTION_UPGRADE'
				FLAGS[(FLAGS['CHUNKED'] = 8)] = 'CHUNKED'
				FLAGS[(FLAGS['UPGRADE'] = 16)] = 'UPGRADE'
				FLAGS[(FLAGS['CONTENT_LENGTH'] = 32)] = 'CONTENT_LENGTH'
				FLAGS[(FLAGS['SKIPBODY'] = 64)] = 'SKIPBODY'
				FLAGS[(FLAGS['TRAILING'] = 128)] = 'TRAILING'
				// 1 << 8 is unused
				FLAGS[(FLAGS['TRANSFER_ENCODING'] = 512)] = 'TRANSFER_ENCODING'
			})((FLAGS = exports.FLAGS || (exports.FLAGS = {})))
			var LENIENT_FLAGS
			;(function (LENIENT_FLAGS) {
				LENIENT_FLAGS[(LENIENT_FLAGS['HEADERS'] = 1)] = 'HEADERS'
				LENIENT_FLAGS[(LENIENT_FLAGS['CHUNKED_LENGTH'] = 2)] = 'CHUNKED_LENGTH'
				LENIENT_FLAGS[(LENIENT_FLAGS['KEEP_ALIVE'] = 4)] = 'KEEP_ALIVE'
			})(
				(LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {})),
			)
			var METHODS
			;(function (METHODS) {
				METHODS[(METHODS['DELETE'] = 0)] = 'DELETE'
				METHODS[(METHODS['GET'] = 1)] = 'GET'
				METHODS[(METHODS['HEAD'] = 2)] = 'HEAD'
				METHODS[(METHODS['POST'] = 3)] = 'POST'
				METHODS[(METHODS['PUT'] = 4)] = 'PUT'
				/* pathological */
				METHODS[(METHODS['CONNECT'] = 5)] = 'CONNECT'
				METHODS[(METHODS['OPTIONS'] = 6)] = 'OPTIONS'
				METHODS[(METHODS['TRACE'] = 7)] = 'TRACE'
				/* WebDAV */
				METHODS[(METHODS['COPY'] = 8)] = 'COPY'
				METHODS[(METHODS['LOCK'] = 9)] = 'LOCK'
				METHODS[(METHODS['MKCOL'] = 10)] = 'MKCOL'
				METHODS[(METHODS['MOVE'] = 11)] = 'MOVE'
				METHODS[(METHODS['PROPFIND'] = 12)] = 'PROPFIND'
				METHODS[(METHODS['PROPPATCH'] = 13)] = 'PROPPATCH'
				METHODS[(METHODS['SEARCH'] = 14)] = 'SEARCH'
				METHODS[(METHODS['UNLOCK'] = 15)] = 'UNLOCK'
				METHODS[(METHODS['BIND'] = 16)] = 'BIND'
				METHODS[(METHODS['REBIND'] = 17)] = 'REBIND'
				METHODS[(METHODS['UNBIND'] = 18)] = 'UNBIND'
				METHODS[(METHODS['ACL'] = 19)] = 'ACL'
				/* subversion */
				METHODS[(METHODS['REPORT'] = 20)] = 'REPORT'
				METHODS[(METHODS['MKACTIVITY'] = 21)] = 'MKACTIVITY'
				METHODS[(METHODS['CHECKOUT'] = 22)] = 'CHECKOUT'
				METHODS[(METHODS['MERGE'] = 23)] = 'MERGE'
				/* upnp */
				METHODS[(METHODS['M-SEARCH'] = 24)] = 'M-SEARCH'
				METHODS[(METHODS['NOTIFY'] = 25)] = 'NOTIFY'
				METHODS[(METHODS['SUBSCRIBE'] = 26)] = 'SUBSCRIBE'
				METHODS[(METHODS['UNSUBSCRIBE'] = 27)] = 'UNSUBSCRIBE'
				/* RFC-5789 */
				METHODS[(METHODS['PATCH'] = 28)] = 'PATCH'
				METHODS[(METHODS['PURGE'] = 29)] = 'PURGE'
				/* CalDAV */
				METHODS[(METHODS['MKCALENDAR'] = 30)] = 'MKCALENDAR'
				/* RFC-2068, section 19.6.1.2 */
				METHODS[(METHODS['LINK'] = 31)] = 'LINK'
				METHODS[(METHODS['UNLINK'] = 32)] = 'UNLINK'
				/* icecast */
				METHODS[(METHODS['SOURCE'] = 33)] = 'SOURCE'
				/* RFC-7540, section 11.6 */
				METHODS[(METHODS['PRI'] = 34)] = 'PRI'
				/* RFC-2326 RTSP */
				METHODS[(METHODS['DESCRIBE'] = 35)] = 'DESCRIBE'
				METHODS[(METHODS['ANNOUNCE'] = 36)] = 'ANNOUNCE'
				METHODS[(METHODS['SETUP'] = 37)] = 'SETUP'
				METHODS[(METHODS['PLAY'] = 38)] = 'PLAY'
				METHODS[(METHODS['PAUSE'] = 39)] = 'PAUSE'
				METHODS[(METHODS['TEARDOWN'] = 40)] = 'TEARDOWN'
				METHODS[(METHODS['GET_PARAMETER'] = 41)] = 'GET_PARAMETER'
				METHODS[(METHODS['SET_PARAMETER'] = 42)] = 'SET_PARAMETER'
				METHODS[(METHODS['REDIRECT'] = 43)] = 'REDIRECT'
				METHODS[(METHODS['RECORD'] = 44)] = 'RECORD'
				/* RAOP */
				METHODS[(METHODS['FLUSH'] = 45)] = 'FLUSH'
			})((METHODS = exports.METHODS || (exports.METHODS = {})))
			exports.METHODS_HTTP = [
				METHODS.DELETE,
				METHODS.GET,
				METHODS.HEAD,
				METHODS.POST,
				METHODS.PUT,
				METHODS.CONNECT,
				METHODS.OPTIONS,
				METHODS.TRACE,
				METHODS.COPY,
				METHODS.LOCK,
				METHODS.MKCOL,
				METHODS.MOVE,
				METHODS.PROPFIND,
				METHODS.PROPPATCH,
				METHODS.SEARCH,
				METHODS.UNLOCK,
				METHODS.BIND,
				METHODS.REBIND,
				METHODS.UNBIND,
				METHODS.ACL,
				METHODS.REPORT,
				METHODS.MKACTIVITY,
				METHODS.CHECKOUT,
				METHODS.MERGE,
				METHODS['M-SEARCH'],
				METHODS.NOTIFY,
				METHODS.SUBSCRIBE,
				METHODS.UNSUBSCRIBE,
				METHODS.PATCH,
				METHODS.PURGE,
				METHODS.MKCALENDAR,
				METHODS.LINK,
				METHODS.UNLINK,
				METHODS.PRI,
				// TODO(indutny): should we allow it with HTTP?
				METHODS.SOURCE,
			]
			exports.METHODS_ICE = [METHODS.SOURCE]
			exports.METHODS_RTSP = [
				METHODS.OPTIONS,
				METHODS.DESCRIBE,
				METHODS.ANNOUNCE,
				METHODS.SETUP,
				METHODS.PLAY,
				METHODS.PAUSE,
				METHODS.TEARDOWN,
				METHODS.GET_PARAMETER,
				METHODS.SET_PARAMETER,
				METHODS.REDIRECT,
				METHODS.RECORD,
				METHODS.FLUSH,
				// For AirPlay
				METHODS.GET,
				METHODS.POST,
			]
			exports.METHOD_MAP = utils_1.enumToMap(METHODS)
			exports.H_METHOD_MAP = {}
			Object.keys(exports.METHOD_MAP).forEach((key) => {
				if (/^H/.test(key)) {
					exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key]
				}
			})
			var FINISH
			;(function (FINISH) {
				FINISH[(FINISH['SAFE'] = 0)] = 'SAFE'
				FINISH[(FINISH['SAFE_WITH_CB'] = 1)] = 'SAFE_WITH_CB'
				FINISH[(FINISH['UNSAFE'] = 2)] = 'UNSAFE'
			})((FINISH = exports.FINISH || (exports.FINISH = {})))
			exports.ALPHA = []
			for (let i = 'A'.charCodeAt(0); i <= 'Z'.charCodeAt(0); i++) {
				// Upper case
				exports.ALPHA.push(String.fromCharCode(i))
				// Lower case
				exports.ALPHA.push(String.fromCharCode(i + 0x20))
			}
			exports.NUM_MAP = {
				0: 0,
				1: 1,
				2: 2,
				3: 3,
				4: 4,
				5: 5,
				6: 6,
				7: 7,
				8: 8,
				9: 9,
			}
			exports.HEX_MAP = {
				0: 0,
				1: 1,
				2: 2,
				3: 3,
				4: 4,
				5: 5,
				6: 6,
				7: 7,
				8: 8,
				9: 9,
				A: 0xa,
				B: 0xb,
				C: 0xc,
				D: 0xd,
				E: 0xe,
				F: 0xf,
				a: 0xa,
				b: 0xb,
				c: 0xc,
				d: 0xd,
				e: 0xe,
				f: 0xf,
			}
			exports.NUM = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
			exports.ALPHANUM = exports.ALPHA.concat(exports.NUM)
			exports.MARK = ['-', '_', '.', '!', '~', '*', "'", '(', ')']
			exports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat([
				'%',
				';',
				':',
				'&',
				'=',
				'+',
				'$',
				',',
			])
			// TODO(indutny): use RFC
			exports.STRICT_URL_CHAR = [
				'!',
				'"',
				'$',
				'%',
				'&',
				"'",
				'(',
				')',
				'*',
				'+',
				',',
				'-',
				'.',
				'/',
				':',
				';',
				'<',
				'=',
				'>',
				'@',
				'[',
				'\\',
				']',
				'^',
				'_',
				'`',
				'{',
				'|',
				'}',
				'~',
			].concat(exports.ALPHANUM)
			exports.URL_CHAR = exports.STRICT_URL_CHAR.concat(['\t', '\f'])
			// All characters with 0x80 bit set to 1
			for (let i = 0x80; i <= 0xff; i++) {
				exports.URL_CHAR.push(i)
			}
			exports.HEX = exports.NUM.concat([
				'a',
				'b',
				'c',
				'd',
				'e',
				'f',
				'A',
				'B',
				'C',
				'D',
				'E',
				'F',
			])
			/* Tokens as defined by rfc 2616. Also lowercases them.
			 *        token       = 1*<any CHAR except CTLs or separators>
			 *     separators     = "(" | ")" | "<" | ">" | "@"
			 *                    | "," | ";" | ":" | "\" | <">
			 *                    | "/" | "[" | "]" | "?" | "="
			 *                    | "{" | "}" | SP | HT
			 */
			exports.STRICT_TOKEN = [
				'!',
				'#',
				'$',
				'%',
				'&',
				"'",
				'*',
				'+',
				'-',
				'.',
				'^',
				'_',
				'`',
				'|',
				'~',
			].concat(exports.ALPHANUM)
			exports.TOKEN = exports.STRICT_TOKEN.concat([' '])
			/*
			 * Verify that a char is a valid visible (printable) US-ASCII
			 * character or %x80-FF
			 */
			exports.HEADER_CHARS = ['\t']
			for (let i = 32; i <= 255; i++) {
				if (i !== 127) {
					exports.HEADER_CHARS.push(i)
				}
			}
			// ',' = \x44
			exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter(
				(c) => c !== 44,
			)
			exports.MAJOR = exports.NUM_MAP
			exports.MINOR = exports.MAJOR
			var HEADER_STATE
			;(function (HEADER_STATE) {
				HEADER_STATE[(HEADER_STATE['GENERAL'] = 0)] = 'GENERAL'
				HEADER_STATE[(HEADER_STATE['CONNECTION'] = 1)] = 'CONNECTION'
				HEADER_STATE[(HEADER_STATE['CONTENT_LENGTH'] = 2)] = 'CONTENT_LENGTH'
				HEADER_STATE[(HEADER_STATE['TRANSFER_ENCODING'] = 3)] =
					'TRANSFER_ENCODING'
				HEADER_STATE[(HEADER_STATE['UPGRADE'] = 4)] = 'UPGRADE'
				HEADER_STATE[(HEADER_STATE['CONNECTION_KEEP_ALIVE'] = 5)] =
					'CONNECTION_KEEP_ALIVE'
				HEADER_STATE[(HEADER_STATE['CONNECTION_CLOSE'] = 6)] =
					'CONNECTION_CLOSE'
				HEADER_STATE[(HEADER_STATE['CONNECTION_UPGRADE'] = 7)] =
					'CONNECTION_UPGRADE'
				HEADER_STATE[(HEADER_STATE['TRANSFER_ENCODING_CHUNKED'] = 8)] =
					'TRANSFER_ENCODING_CHUNKED'
			})((HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {})))
			exports.SPECIAL_HEADERS = {
				connection: HEADER_STATE.CONNECTION,
				'content-length': HEADER_STATE.CONTENT_LENGTH,
				'proxy-connection': HEADER_STATE.CONNECTION,
				'transfer-encoding': HEADER_STATE.TRANSFER_ENCODING,
				upgrade: HEADER_STATE.UPGRADE,
			}
			//# sourceMappingURL=constants.js.map

			/***/
		},

		/***/ 63870: /***/ (module) => {
			module.exports =
				'AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJsbGh0dHBfc3RhdHVzX25hbWUAIRpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAiIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAjHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACQkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACUYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mAD8JFwEAQQELEQECAwQFCwYHNTk3MS8tJyspCsLgAkUCAAsIABCIgICAAAsZACAAEMKAgIAAGiAAIAI2AjggACABOgAoCxwAIAAgAC8BMiAALQAuIAAQwYCAgAAQgICAgAALKgEBf0HAABDGgICAACIBEMKAgIAAGiABQYCIgIAANgI4IAEgADoAKCABCwoAIAAQyICAgAALBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LRQEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABDCgICAABogACAENgI4IAAgAzoAKCAAIAI6AC0gACABNgIYCxEAIAAgASABIAJqEMOAgIAACxAAIABBAEHcABDMgICAABoLZwEBf0EAIQECQCAAKAIMDQACQAJAAkACQCAALQAvDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgARGAgICAAAAiAQ0DC0EADwsQyoCAgAAACyAAQcOWgIAANgIQQQ4hAQsgAQseAAJAIAAoAgwNACAAQdGbgIAANgIQIABBFTYCDAsLFgACQCAAKAIMQRVHDQAgAEEANgIMCwsWAAJAIAAoAgxBFkcNACAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsiAAJAIABBJEkNABDKgICAAAALIABBAnRBoLOAgABqKAIACyIAAkAgAEEuSQ0AEMqAgIAAAAsgAEECdEGwtICAAGooAgAL7gsBAX9B66iAgAAhAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBnH9qDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0Hhp4CAAA8LQaShgIAADwtBy6yAgAAPC0H+sYCAAA8LQcCkgIAADwtBq6SAgAAPC0GNqICAAA8LQeKmgIAADwtBgLCAgAAPC0G5r4CAAA8LQdekgIAADwtB75+AgAAPC0Hhn4CAAA8LQfqfgIAADwtB8qCAgAAPC0Gor4CAAA8LQa6ygIAADwtBiLCAgAAPC0Hsp4CAAA8LQYKigIAADwtBjp2AgAAPC0HQroCAAA8LQcqjgIAADwtBxbKAgAAPC0HfnICAAA8LQdKcgIAADwtBxKCAgAAPC0HXoICAAA8LQaKfgIAADwtB7a6AgAAPC0GrsICAAA8LQdSlgIAADwtBzK6AgAAPC0H6roCAAA8LQfyrgIAADwtB0rCAgAAPC0HxnYCAAA8LQbuggIAADwtB96uAgAAPC0GQsYCAAA8LQdexgIAADwtBoq2AgAAPC0HUp4CAAA8LQeCrgIAADwtBn6yAgAAPC0HrsYCAAA8LQdWfgIAADwtByrGAgAAPC0HepYCAAA8LQdSegIAADwtB9JyAgAAPC0GnsoCAAA8LQbGdgIAADwtBoJ2AgAAPC0G5sYCAAA8LQbywgIAADwtBkqGAgAAPC0GzpoCAAA8LQemsgIAADwtBrJ6AgAAPC0HUq4CAAA8LQfemgIAADwtBgKaAgAAPC0GwoYCAAA8LQf6egIAADwtBjaOAgAAPC0GJrYCAAA8LQfeigIAADwtBoLGAgAAPC0Gun4CAAA8LQcalgIAADwtB6J6AgAAPC0GTooCAAA8LQcKvgIAADwtBw52AgAAPC0GLrICAAA8LQeGdgIAADwtBja+AgAAPC0HqoYCAAA8LQbStgIAADwtB0q+AgAAPC0HfsoCAAA8LQdKygIAADwtB8LCAgAAPC0GpooCAAA8LQfmjgIAADwtBmZ6AgAAPC0G1rICAAA8LQZuwgIAADwtBkrKAgAAPC0G2q4CAAA8LQcKigIAADwtB+LKAgAAPC0GepYCAAA8LQdCigIAADwtBup6AgAAPC0GBnoCAAA8LEMqAgIAAAAtB1qGAgAAhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAgAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCBCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQcaRgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIwIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAggiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2ioCAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCNCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIMIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZqAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAjgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCECIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZWQgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAI8IgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAhQiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEGqm4CAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCQCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIYIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZOAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCJCIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIsIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAigiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2iICAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCUCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIcIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBwpmAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCICIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZSUgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAJMIgRFDQAgACAEEYCAgIAAACEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAlQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCWCIERQ0AIAAgBBGAgICAAAAhAwsgAwtFAQF/AkACQCAALwEwQRRxQRRHDQBBASEDIAAtAChBAUYNASAALwEyQeUARiEDDAELIAAtAClBBUYhAwsgACADOgAuQQAL/gEBA39BASEDAkAgAC8BMCIEQQhxDQAgACkDIEIAUiEDCwJAAkAgAC0ALkUNAEEBIQUgAC0AKUEFRg0BQQEhBSAEQcAAcUUgA3FBAUcNAQtBACEFIARBwABxDQBBAiEFIARB//8DcSIDQQhxDQACQCADQYAEcUUNAAJAIAAtAChBAUcNACAALQAtQQpxDQBBBQ8LQQQPCwJAIANBIHENAAJAIAAtAChBAUYNACAALwEyQf//A3EiAEGcf2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQShxRQ0CIANBiARxQYAERg0CC0EADwtBAEEDIAApAyBQGyEFCyAFC2IBAn9BACEBAkAgAC0AKEEBRg0AIAAvATJB//8DcSICQZx/akHkAEkNACACQcwBRg0AIAJBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhASAAQYgEcUGABEYNACAAQShxRSEBCyABC6cBAQN/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQMgAC8BMCIEQQJxRQ0BDAILQQAhAyAALwEwIgRBAXFFDQELQQEhAyAALQAoQQFGDQAgAC8BMkH//wNxIgVBnH9qQeQASQ0AIAVBzAFGDQAgBUGwAkYNACAEQcAAcQ0AQQAhAyAEQYgEcUGABEYNACAEQShxQQBHIQMLIABBADsBMCAAQQA6AC8gAwuZAQECfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEBIAAvATAiAkECcUUNAQwCC0EAIQEgAC8BMCICQQFxRQ0BC0EBIQEgAC0AKEEBRg0AIAAvATJB//8DcSIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC1kAIABBGGpCADcDACAAQgA3AwAgAEE4akIANwMAIABBMGpCADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwHLAcoBuAHJAbkByAG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAQDcAQtBACEQDMYBC0EOIRAMxQELQQ0hEAzEAQtBDyEQDMMBC0EQIRAMwgELQRMhEAzBAQtBFCEQDMABC0EVIRAMvwELQRYhEAy+AQtBFyEQDL0BC0EYIRAMvAELQRkhEAy7AQtBGiEQDLoBC0EbIRAMuQELQRwhEAy4AQtBCCEQDLcBC0EdIRAMtgELQSAhEAy1AQtBHyEQDLQBC0EHIRAMswELQSEhEAyyAQtBIiEQDLEBC0EeIRAMsAELQSMhEAyvAQtBEiEQDK4BC0ERIRAMrQELQSQhEAysAQtBJSEQDKsBC0EmIRAMqgELQSchEAypAQtBwwEhEAyoAQtBKSEQDKcBC0ErIRAMpgELQSwhEAylAQtBLSEQDKQBC0EuIRAMowELQS8hEAyiAQtBxAEhEAyhAQtBMCEQDKABC0E0IRAMnwELQQwhEAyeAQtBMSEQDJ0BC0EyIRAMnAELQTMhEAybAQtBOSEQDJoBC0E1IRAMmQELQcUBIRAMmAELQQshEAyXAQtBOiEQDJYBC0E2IRAMlQELQQohEAyUAQtBNyEQDJMBC0E4IRAMkgELQTwhEAyRAQtBOyEQDJABC0E9IRAMjwELQQkhEAyOAQtBKCEQDI0BC0E+IRAMjAELQT8hEAyLAQtBwAAhEAyKAQtBwQAhEAyJAQtBwgAhEAyIAQtBwwAhEAyHAQtBxAAhEAyGAQtBxQAhEAyFAQtBxgAhEAyEAQtBKiEQDIMBC0HHACEQDIIBC0HIACEQDIEBC0HJACEQDIABC0HKACEQDH8LQcsAIRAMfgtBzQAhEAx9C0HMACEQDHwLQc4AIRAMewtBzwAhEAx6C0HQACEQDHkLQdEAIRAMeAtB0gAhEAx3C0HTACEQDHYLQdQAIRAMdQtB1gAhEAx0C0HVACEQDHMLQQYhEAxyC0HXACEQDHELQQUhEAxwC0HYACEQDG8LQQQhEAxuC0HZACEQDG0LQdoAIRAMbAtB2wAhEAxrC0HcACEQDGoLQQMhEAxpC0HdACEQDGgLQd4AIRAMZwtB3wAhEAxmC0HhACEQDGULQeAAIRAMZAtB4gAhEAxjC0HjACEQDGILQQIhEAxhC0HkACEQDGALQeUAIRAMXwtB5gAhEAxeC0HnACEQDF0LQegAIRAMXAtB6QAhEAxbC0HqACEQDFoLQesAIRAMWQtB7AAhEAxYC0HtACEQDFcLQe4AIRAMVgtB7wAhEAxVC0HwACEQDFQLQfEAIRAMUwtB8gAhEAxSC0HzACEQDFELQfQAIRAMUAtB9QAhEAxPC0H2ACEQDE4LQfcAIRAMTQtB+AAhEAxMC0H5ACEQDEsLQfoAIRAMSgtB+wAhEAxJC0H8ACEQDEgLQf0AIRAMRwtB/gAhEAxGC0H/ACEQDEULQYABIRAMRAtBgQEhEAxDC0GCASEQDEILQYMBIRAMQQtBhAEhEAxAC0GFASEQDD8LQYYBIRAMPgtBhwEhEAw9C0GIASEQDDwLQYkBIRAMOwtBigEhEAw6C0GLASEQDDkLQYwBIRAMOAtBjQEhEAw3C0GOASEQDDYLQY8BIRAMNQtBkAEhEAw0C0GRASEQDDMLQZIBIRAMMgtBkwEhEAwxC0GUASEQDDALQZUBIRAMLwtBlgEhEAwuC0GXASEQDC0LQZgBIRAMLAtBmQEhEAwrC0GaASEQDCoLQZsBIRAMKQtBnAEhEAwoC0GdASEQDCcLQZ4BIRAMJgtBnwEhEAwlC0GgASEQDCQLQaEBIRAMIwtBogEhEAwiC0GjASEQDCELQaQBIRAMIAtBpQEhEAwfC0GmASEQDB4LQacBIRAMHQtBqAEhEAwcC0GpASEQDBsLQaoBIRAMGgtBqwEhEAwZC0GsASEQDBgLQa0BIRAMFwtBrgEhEAwWC0EBIRAMFQtBrwEhEAwUC0GwASEQDBMLQbEBIRAMEgtBswEhEAwRC0GyASEQDBALQbQBIRAMDwtBtQEhEAwOC0G2ASEQDA0LQbcBIRAMDAtBuAEhEAwLC0G5ASEQDAoLQboBIRAMCQtBuwEhEAwIC0HGASEQDAcLQbwBIRAMBgtBvQEhEAwFC0G+ASEQDAQLQb8BIRAMAwtBwAEhEAwCC0HCASEQDAELQcEBIRALA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAQDscBAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxweHyAhIyUoP0BBREVGR0hJSktMTU9QUVJT3gNXWVtcXWBiZWZnaGlqa2xtb3BxcnN0dXZ3eHl6e3x9foABggGFAYYBhwGJAYsBjAGNAY4BjwGQAZEBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBuAG5AboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBxwHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAdUB1gHXAdgB2QHaAdsB3AHdAd4B4AHhAeIB4wHkAeUB5gHnAegB6QHqAesB7AHtAe4B7wHwAfEB8gHzAZkCpAKwAv4C/gILIAEiBCACRw3zAUHdASEQDP8DCyABIhAgAkcN3QFBwwEhEAz+AwsgASIBIAJHDZABQfcAIRAM/QMLIAEiASACRw2GAUHvACEQDPwDCyABIgEgAkcNf0HqACEQDPsDCyABIgEgAkcNe0HoACEQDPoDCyABIgEgAkcNeEHmACEQDPkDCyABIgEgAkcNGkEYIRAM+AMLIAEiASACRw0UQRIhEAz3AwsgASIBIAJHDVlBxQAhEAz2AwsgASIBIAJHDUpBPyEQDPUDCyABIgEgAkcNSEE8IRAM9AMLIAEiASACRw1BQTEhEAzzAwsgAC0ALkEBRg3rAwyHAgsgACABIgEgAhDAgICAAEEBRw3mASAAQgA3AyAM5wELIAAgASIBIAIQtICAgAAiEA3nASABIQEM9QILAkAgASIBIAJHDQBBBiEQDPADCyAAIAFBAWoiASACELuAgIAAIhAN6AEgASEBDDELIABCADcDIEESIRAM1QMLIAEiECACRw0rQR0hEAztAwsCQCABIgEgAkYNACABQQFqIQFBECEQDNQDC0EHIRAM7AMLIABCACAAKQMgIhEgAiABIhBrrSISfSITIBMgEVYbNwMgIBEgElYiFEUN5QFBCCEQDOsDCwJAIAEiASACRg0AIABBiYCAgAA2AgggACABNgIEIAEhAUEUIRAM0gMLQQkhEAzqAwsgASEBIAApAyBQDeQBIAEhAQzyAgsCQCABIgEgAkcNAEELIRAM6QMLIAAgAUEBaiIBIAIQtoCAgAAiEA3lASABIQEM8gILIAAgASIBIAIQuICAgAAiEA3lASABIQEM8gILIAAgASIBIAIQuICAgAAiEA3mASABIQEMDQsgACABIgEgAhC6gICAACIQDecBIAEhAQzwAgsCQCABIgEgAkcNAEEPIRAM5QMLIAEtAAAiEEE7Rg0IIBBBDUcN6AEgAUEBaiEBDO8CCyAAIAEiASACELqAgIAAIhAN6AEgASEBDPICCwNAAkAgAS0AAEHwtYCAAGotAAAiEEEBRg0AIBBBAkcN6wEgACgCBCEQIABBADYCBCAAIBAgAUEBaiIBELmAgIAAIhAN6gEgASEBDPQCCyABQQFqIgEgAkcNAAtBEiEQDOIDCyAAIAEiASACELqAgIAAIhAN6QEgASEBDAoLIAEiASACRw0GQRshEAzgAwsCQCABIgEgAkcNAEEWIRAM4AMLIABBioCAgAA2AgggACABNgIEIAAgASACELiAgIAAIhAN6gEgASEBQSAhEAzGAwsCQCABIgEgAkYNAANAAkAgAS0AAEHwt4CAAGotAAAiEEECRg0AAkAgEEF/ag4E5QHsAQDrAewBCyABQQFqIQFBCCEQDMgDCyABQQFqIgEgAkcNAAtBFSEQDN8DC0EVIRAM3gMLA0ACQCABLQAAQfC5gIAAai0AACIQQQJGDQAgEEF/ag4E3gHsAeAB6wHsAQsgAUEBaiIBIAJHDQALQRghEAzdAwsCQCABIgEgAkYNACAAQYuAgIAANgIIIAAgATYCBCABIQFBByEQDMQDC0EZIRAM3AMLIAFBAWohAQwCCwJAIAEiFCACRw0AQRohEAzbAwsgFCEBAkAgFC0AAEFzag4U3QLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gIA7gILQQAhECAAQQA2AhwgAEGvi4CAADYCECAAQQI2AgwgACAUQQFqNgIUDNoDCwJAIAEtAAAiEEE7Rg0AIBBBDUcN6AEgAUEBaiEBDOUCCyABQQFqIQELQSIhEAy/AwsCQCABIhAgAkcNAEEcIRAM2AMLQgAhESAQIQEgEC0AAEFQag435wHmAQECAwQFBgcIAAAAAAAAAAkKCwwNDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADxAREhMUAAtBHiEQDL0DC0ICIREM5QELQgMhEQzkAQtCBCERDOMBC0IFIREM4gELQgYhEQzhAQtCByERDOABC0IIIREM3wELQgkhEQzeAQtCCiERDN0BC0ILIREM3AELQgwhEQzbAQtCDSERDNoBC0IOIREM2QELQg8hEQzYAQtCCiERDNcBC0ILIREM1gELQgwhEQzVAQtCDSERDNQBC0IOIREM0wELQg8hEQzSAQtCACERAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAQLQAAQVBqDjflAeQBAAECAwQFBgfmAeYB5gHmAeYB5gHmAQgJCgsMDeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gEODxAREhPmAQtCAiERDOQBC0IDIREM4wELQgQhEQziAQtCBSERDOEBC0IGIREM4AELQgchEQzfAQtCCCERDN4BC0IJIREM3QELQgohEQzcAQtCCyERDNsBC0IMIREM2gELQg0hEQzZAQtCDiERDNgBC0IPIREM1wELQgohEQzWAQtCCyERDNUBC0IMIREM1AELQg0hEQzTAQtCDiERDNIBC0IPIREM0QELIABCACAAKQMgIhEgAiABIhBrrSISfSITIBMgEVYbNwMgIBEgElYiFEUN0gFBHyEQDMADCwJAIAEiASACRg0AIABBiYCAgAA2AgggACABNgIEIAEhAUEkIRAMpwMLQSAhEAy/AwsgACABIhAgAhC+gICAAEF/ag4FtgEAxQIB0QHSAQtBESEQDKQDCyAAQQE6AC8gECEBDLsDCyABIgEgAkcN0gFBJCEQDLsDCyABIg0gAkcNHkHGACEQDLoDCyAAIAEiASACELKAgIAAIhAN1AEgASEBDLUBCyABIhAgAkcNJkHQACEQDLgDCwJAIAEiASACRw0AQSghEAy4AwsgAEEANgIEIABBjICAgAA2AgggACABIAEQsYCAgAAiEA3TASABIQEM2AELAkAgASIQIAJHDQBBKSEQDLcDCyAQLQAAIgFBIEYNFCABQQlHDdMBIBBBAWohAQwVCwJAIAEiASACRg0AIAFBAWohAQwXC0EqIRAMtQMLAkAgASIQIAJHDQBBKyEQDLUDCwJAIBAtAAAiAUEJRg0AIAFBIEcN1QELIAAtACxBCEYN0wEgECEBDJEDCwJAIAEiASACRw0AQSwhEAy0AwsgAS0AAEEKRw3VASABQQFqIQEMyQILIAEiDiACRw3VAUEvIRAMsgMLA0ACQCABLQAAIhBBIEYNAAJAIBBBdmoOBADcAdwBANoBCyABIQEM4AELIAFBAWoiASACRw0AC0ExIRAMsQMLQTIhECABIhQgAkYNsAMgAiAUayAAKAIAIgFqIRUgFCABa0EDaiEWAkADQCAULQAAIhdBIHIgFyAXQb9/akH/AXFBGkkbQf8BcSABQfC7gIAAai0AAEcNAQJAIAFBA0cNAEEGIQEMlgMLIAFBAWohASAUQQFqIhQgAkcNAAsgACAVNgIADLEDCyAAQQA2AgAgFCEBDNkBC0EzIRAgASIUIAJGDa8DIAIgFGsgACgCACIBaiEVIBQgAWtBCGohFgJAA0AgFC0AACIXQSByIBcgF0G/f2pB/wFxQRpJG0H/AXEgAUH0u4CAAGotAABHDQECQCABQQhHDQBBBSEBDJUDCyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFTYCAAywAwsgAEEANgIAIBQhAQzYAQtBNCEQIAEiFCACRg2uAyACIBRrIAAoAgAiAWohFSAUIAFrQQVqIRYCQANAIBQtAAAiF0EgciAXIBdBv39qQf8BcUEaSRtB/wFxIAFB0MKAgABqLQAARw0BAkAgAUEFRw0AQQchAQyUAwsgAUEBaiEBIBRBAWoiFCACRw0ACyAAIBU2AgAMrwMLIABBADYCACAUIQEM1wELAkAgASIBIAJGDQADQAJAIAEtAABBgL6AgABqLQAAIhBBAUYNACAQQQJGDQogASEBDN0BCyABQQFqIgEgAkcNAAtBMCEQDK4DC0EwIRAMrQMLAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgRg0AIBBBdmoOBNkB2gHaAdkB2gELIAFBAWoiASACRw0AC0E4IRAMrQMLQTghEAysAwsDQAJAIAEtAAAiEEEgRg0AIBBBCUcNAwsgAUEBaiIBIAJHDQALQTwhEAyrAwsDQAJAIAEtAAAiEEEgRg0AAkACQCAQQXZqDgTaAQEB2gEACyAQQSxGDdsBCyABIQEMBAsgAUEBaiIBIAJHDQALQT8hEAyqAwsgASEBDNsBC0HAACEQIAEiFCACRg2oAyACIBRrIAAoAgAiAWohFiAUIAFrQQZqIRcCQANAIBQtAABBIHIgAUGAwICAAGotAABHDQEgAUEGRg2OAyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFjYCAAypAwsgAEEANgIAIBQhAQtBNiEQDI4DCwJAIAEiDyACRw0AQcEAIRAMpwMLIABBjICAgAA2AgggACAPNgIEIA8hASAALQAsQX9qDgTNAdUB1wHZAYcDCyABQQFqIQEMzAELAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgciAQIBBBv39qQf8BcUEaSRtB/wFxIhBBCUYNACAQQSBGDQACQAJAAkACQCAQQZ1/ag4TAAMDAwMDAwMBAwMDAwMDAwMDAgMLIAFBAWohAUExIRAMkQMLIAFBAWohAUEyIRAMkAMLIAFBAWohAUEzIRAMjwMLIAEhAQzQAQsgAUEBaiIBIAJHDQALQTUhEAylAwtBNSEQDKQDCwJAIAEiASACRg0AA0ACQCABLQAAQYC8gIAAai0AAEEBRg0AIAEhAQzTAQsgAUEBaiIBIAJHDQALQT0hEAykAwtBPSEQDKMDCyAAIAEiASACELCAgIAAIhAN1gEgASEBDAELIBBBAWohAQtBPCEQDIcDCwJAIAEiASACRw0AQcIAIRAMoAMLAkADQAJAIAEtAABBd2oOGAAC/gL+AoQD/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4CAP4CCyABQQFqIgEgAkcNAAtBwgAhEAygAwsgAUEBaiEBIAAtAC1BAXFFDb0BIAEhAQtBLCEQDIUDCyABIgEgAkcN0wFBxAAhEAydAwsDQAJAIAEtAABBkMCAgABqLQAAQQFGDQAgASEBDLcCCyABQQFqIgEgAkcNAAtBxQAhEAycAwsgDS0AACIQQSBGDbMBIBBBOkcNgQMgACgCBCEBIABBADYCBCAAIAEgDRCvgICAACIBDdABIA1BAWohAQyzAgtBxwAhECABIg0gAkYNmgMgAiANayAAKAIAIgFqIRYgDSABa0EFaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGQwoCAAGotAABHDYADIAFBBUYN9AIgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMmgMLQcgAIRAgASINIAJGDZkDIAIgDWsgACgCACIBaiEWIA0gAWtBCWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBlsKAgABqLQAARw3/AgJAIAFBCUcNAEECIQEM9QILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJkDCwJAIAEiDSACRw0AQckAIRAMmQMLAkACQCANLQAAIgFBIHIgASABQb9/akH/AXFBGkkbQf8BcUGSf2oOBwCAA4ADgAOAA4ADAYADCyANQQFqIQFBPiEQDIADCyANQQFqIQFBPyEQDP8CC0HKACEQIAEiDSACRg2XAyACIA1rIAAoAgAiAWohFiANIAFrQQFqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQaDCgIAAai0AAEcN/QIgAUEBRg3wAiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyXAwtBywAhECABIg0gAkYNlgMgAiANayAAKAIAIgFqIRYgDSABa0EOaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGiwoCAAGotAABHDfwCIAFBDkYN8AIgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMlgMLQcwAIRAgASINIAJGDZUDIAIgDWsgACgCACIBaiEWIA0gAWtBD2ohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBwMKAgABqLQAARw37AgJAIAFBD0cNAEEDIQEM8QILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJUDC0HNACEQIAEiDSACRg2UAyACIA1rIAAoAgAiAWohFiANIAFrQQVqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQdDCgIAAai0AAEcN+gICQCABQQVHDQBBBCEBDPACCyABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyUAwsCQCABIg0gAkcNAEHOACEQDJQDCwJAAkACQAJAIA0tAAAiAUEgciABIAFBv39qQf8BcUEaSRtB/wFxQZ1/ag4TAP0C/QL9Av0C/QL9Av0C/QL9Av0C/QL9AgH9Av0C/QICA/0CCyANQQFqIQFBwQAhEAz9AgsgDUEBaiEBQcIAIRAM/AILIA1BAWohAUHDACEQDPsCCyANQQFqIQFBxAAhEAz6AgsCQCABIgEgAkYNACAAQY2AgIAANgIIIAAgATYCBCABIQFBxQAhEAz6AgtBzwAhEAySAwsgECEBAkACQCAQLQAAQXZqDgQBqAKoAgCoAgsgEEEBaiEBC0EnIRAM+AILAkAgASIBIAJHDQBB0QAhEAyRAwsCQCABLQAAQSBGDQAgASEBDI0BCyABQQFqIQEgAC0ALUEBcUUNxwEgASEBDIwBCyABIhcgAkcNyAFB0gAhEAyPAwtB0wAhECABIhQgAkYNjgMgAiAUayAAKAIAIgFqIRYgFCABa0EBaiEXA0AgFC0AACABQdbCgIAAai0AAEcNzAEgAUEBRg3HASABQQFqIQEgFEEBaiIUIAJHDQALIAAgFjYCAAyOAwsCQCABIgEgAkcNAEHVACEQDI4DCyABLQAAQQpHDcwBIAFBAWohAQzHAQsCQCABIgEgAkcNAEHWACEQDI0DCwJAAkAgAS0AAEF2ag4EAM0BzQEBzQELIAFBAWohAQzHAQsgAUEBaiEBQcoAIRAM8wILIAAgASIBIAIQroCAgAAiEA3LASABIQFBzQAhEAzyAgsgAC0AKUEiRg2FAwymAgsCQCABIgEgAkcNAEHbACEQDIoDC0EAIRRBASEXQQEhFkEAIRACQAJAAkACQAJAAkACQAJAAkAgAS0AAEFQag4K1AHTAQABAgMEBQYI1QELQQIhEAwGC0EDIRAMBQtBBCEQDAQLQQUhEAwDC0EGIRAMAgtBByEQDAELQQghEAtBACEXQQAhFkEAIRQMzAELQQkhEEEBIRRBACEXQQAhFgzLAQsCQCABIgEgAkcNAEHdACEQDIkDCyABLQAAQS5HDcwBIAFBAWohAQymAgsgASIBIAJHDcwBQd8AIRAMhwMLAkAgASIBIAJGDQAgAEGOgICAADYCCCAAIAE2AgQgASEBQdAAIRAM7gILQeAAIRAMhgMLQeEAIRAgASIBIAJGDYUDIAIgAWsgACgCACIUaiEWIAEgFGtBA2ohFwNAIAEtAAAgFEHiwoCAAGotAABHDc0BIBRBA0YNzAEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMhQMLQeIAIRAgASIBIAJGDYQDIAIgAWsgACgCACIUaiEWIAEgFGtBAmohFwNAIAEtAAAgFEHmwoCAAGotAABHDcwBIBRBAkYNzgEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMhAMLQeMAIRAgASIBIAJGDYMDIAIgAWsgACgCACIUaiEWIAEgFGtBA2ohFwNAIAEtAAAgFEHpwoCAAGotAABHDcsBIBRBA0YNzgEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMgwMLAkAgASIBIAJHDQBB5QAhEAyDAwsgACABQQFqIgEgAhCogICAACIQDc0BIAEhAUHWACEQDOkCCwJAIAEiASACRg0AA0ACQCABLQAAIhBBIEYNAAJAAkACQCAQQbh/ag4LAAHPAc8BzwHPAc8BzwHPAc8BAs8BCyABQQFqIQFB0gAhEAztAgsgAUEBaiEBQdMAIRAM7AILIAFBAWohAUHUACEQDOsCCyABQQFqIgEgAkcNAAtB5AAhEAyCAwtB5AAhEAyBAwsDQAJAIAEtAABB8MKAgABqLQAAIhBBAUYNACAQQX5qDgPPAdAB0QHSAQsgAUEBaiIBIAJHDQALQeYAIRAMgAMLAkAgASIBIAJGDQAgAUEBaiEBDAMLQecAIRAM/wILA0ACQCABLQAAQfDEgIAAai0AACIQQQFGDQACQCAQQX5qDgTSAdMB1AEA1QELIAEhAUHXACEQDOcCCyABQQFqIgEgAkcNAAtB6AAhEAz+AgsCQCABIgEgAkcNAEHpACEQDP4CCwJAIAEtAAAiEEF2ag4augHVAdUBvAHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHKAdUB1QEA0wELIAFBAWohAQtBBiEQDOMCCwNAAkAgAS0AAEHwxoCAAGotAABBAUYNACABIQEMngILIAFBAWoiASACRw0AC0HqACEQDPsCCwJAIAEiASACRg0AIAFBAWohAQwDC0HrACEQDPoCCwJAIAEiASACRw0AQewAIRAM+gILIAFBAWohAQwBCwJAIAEiASACRw0AQe0AIRAM+QILIAFBAWohAQtBBCEQDN4CCwJAIAEiFCACRw0AQe4AIRAM9wILIBQhAQJAAkACQCAULQAAQfDIgIAAai0AAEF/ag4H1AHVAdYBAJwCAQLXAQsgFEEBaiEBDAoLIBRBAWohAQzNAQtBACEQIABBADYCHCAAQZuSgIAANgIQIABBBzYCDCAAIBRBAWo2AhQM9gILAkADQAJAIAEtAABB8MiAgABqLQAAIhBBBEYNAAJAAkAgEEF/ag4H0gHTAdQB2QEABAHZAQsgASEBQdoAIRAM4AILIAFBAWohAUHcACEQDN8CCyABQQFqIgEgAkcNAAtB7wAhEAz2AgsgAUEBaiEBDMsBCwJAIAEiFCACRw0AQfAAIRAM9QILIBQtAABBL0cN1AEgFEEBaiEBDAYLAkAgASIUIAJHDQBB8QAhEAz0AgsCQCAULQAAIgFBL0cNACAUQQFqIQFB3QAhEAzbAgsgAUF2aiIEQRZLDdMBQQEgBHRBiYCAAnFFDdMBDMoCCwJAIAEiASACRg0AIAFBAWohAUHeACEQDNoCC0HyACEQDPICCwJAIAEiFCACRw0AQfQAIRAM8gILIBQhAQJAIBQtAABB8MyAgABqLQAAQX9qDgPJApQCANQBC0HhACEQDNgCCwJAIAEiFCACRg0AA0ACQCAULQAAQfDKgIAAai0AACIBQQNGDQACQCABQX9qDgLLAgDVAQsgFCEBQd8AIRAM2gILIBRBAWoiFCACRw0AC0HzACEQDPECC0HzACEQDPACCwJAIAEiASACRg0AIABBj4CAgAA2AgggACABNgIEIAEhAUHgACEQDNcCC0H1ACEQDO8CCwJAIAEiASACRw0AQfYAIRAM7wILIABBj4CAgAA2AgggACABNgIEIAEhAQtBAyEQDNQCCwNAIAEtAABBIEcNwwIgAUEBaiIBIAJHDQALQfcAIRAM7AILAkAgASIBIAJHDQBB+AAhEAzsAgsgAS0AAEEgRw3OASABQQFqIQEM7wELIAAgASIBIAIQrICAgAAiEA3OASABIQEMjgILAkAgASIEIAJHDQBB+gAhEAzqAgsgBC0AAEHMAEcN0QEgBEEBaiEBQRMhEAzPAQsCQCABIgQgAkcNAEH7ACEQDOkCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRADQCAELQAAIAFB8M6AgABqLQAARw3QASABQQVGDc4BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQfsAIRAM6AILAkAgASIEIAJHDQBB/AAhEAzoAgsCQAJAIAQtAABBvX9qDgwA0QHRAdEB0QHRAdEB0QHRAdEB0QEB0QELIARBAWohAUHmACEQDM8CCyAEQQFqIQFB5wAhEAzOAgsCQCABIgQgAkcNAEH9ACEQDOcCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDc8BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH9ACEQDOcCCyAAQQA2AgAgEEEBaiEBQRAhEAzMAQsCQCABIgQgAkcNAEH+ACEQDOYCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUH2zoCAAGotAABHDc4BIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH+ACEQDOYCCyAAQQA2AgAgEEEBaiEBQRYhEAzLAQsCQCABIgQgAkcNAEH/ACEQDOUCCyACIARrIAAoAgAiAWohFCAEIAFrQQNqIRACQANAIAQtAAAgAUH8zoCAAGotAABHDc0BIAFBA0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH/ACEQDOUCCyAAQQA2AgAgEEEBaiEBQQUhEAzKAQsCQCABIgQgAkcNAEGAASEQDOQCCyAELQAAQdkARw3LASAEQQFqIQFBCCEQDMkBCwJAIAEiBCACRw0AQYEBIRAM4wILAkACQCAELQAAQbJ/ag4DAMwBAcwBCyAEQQFqIQFB6wAhEAzKAgsgBEEBaiEBQewAIRAMyQILAkAgASIEIAJHDQBBggEhEAziAgsCQAJAIAQtAABBuH9qDggAywHLAcsBywHLAcsBAcsBCyAEQQFqIQFB6gAhEAzJAgsgBEEBaiEBQe0AIRAMyAILAkAgASIEIAJHDQBBgwEhEAzhAgsgAiAEayAAKAIAIgFqIRAgBCABa0ECaiEUAkADQCAELQAAIAFBgM+AgABqLQAARw3JASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBA2AgBBgwEhEAzhAgtBACEQIABBADYCACAUQQFqIQEMxgELAkAgASIEIAJHDQBBhAEhEAzgAgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBg8+AgABqLQAARw3IASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBhAEhEAzgAgsgAEEANgIAIBBBAWohAUEjIRAMxQELAkAgASIEIAJHDQBBhQEhEAzfAgsCQAJAIAQtAABBtH9qDggAyAHIAcgByAHIAcgBAcgBCyAEQQFqIQFB7wAhEAzGAgsgBEEBaiEBQfAAIRAMxQILAkAgASIEIAJHDQBBhgEhEAzeAgsgBC0AAEHFAEcNxQEgBEEBaiEBDIMCCwJAIAEiBCACRw0AQYcBIRAM3QILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQYjPgIAAai0AAEcNxQEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYcBIRAM3QILIABBADYCACAQQQFqIQFBLSEQDMIBCwJAIAEiBCACRw0AQYgBIRAM3AILIAIgBGsgACgCACIBaiEUIAQgAWtBCGohEAJAA0AgBC0AACABQdDPgIAAai0AAEcNxAEgAUEIRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYgBIRAM3AILIABBADYCACAQQQFqIQFBKSEQDMEBCwJAIAEiASACRw0AQYkBIRAM2wILQQEhECABLQAAQd8ARw3AASABQQFqIQEMgQILAkAgASIEIAJHDQBBigEhEAzaAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQA0AgBC0AACABQYzPgIAAai0AAEcNwQEgAUEBRg2vAiABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGKASEQDNkCCwJAIAEiBCACRw0AQYsBIRAM2QILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQY7PgIAAai0AAEcNwQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYsBIRAM2QILIABBADYCACAQQQFqIQFBAiEQDL4BCwJAIAEiBCACRw0AQYwBIRAM2AILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfDPgIAAai0AAEcNwAEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYwBIRAM2AILIABBADYCACAQQQFqIQFBHyEQDL0BCwJAIAEiBCACRw0AQY0BIRAM1wILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfLPgIAAai0AAEcNvwEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQY0BIRAM1wILIABBADYCACAQQQFqIQFBCSEQDLwBCwJAIAEiBCACRw0AQY4BIRAM1gILAkACQCAELQAAQbd/ag4HAL8BvwG/Ab8BvwEBvwELIARBAWohAUH4ACEQDL0CCyAEQQFqIQFB+QAhEAy8AgsCQCABIgQgAkcNAEGPASEQDNUCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGRz4CAAGotAABHDb0BIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGPASEQDNUCCyAAQQA2AgAgEEEBaiEBQRghEAy6AQsCQCABIgQgAkcNAEGQASEQDNQCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUGXz4CAAGotAABHDbwBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGQASEQDNQCCyAAQQA2AgAgEEEBaiEBQRchEAy5AQsCQCABIgQgAkcNAEGRASEQDNMCCyACIARrIAAoAgAiAWohFCAEIAFrQQZqIRACQANAIAQtAAAgAUGaz4CAAGotAABHDbsBIAFBBkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGRASEQDNMCCyAAQQA2AgAgEEEBaiEBQRUhEAy4AQsCQCABIgQgAkcNAEGSASEQDNICCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGhz4CAAGotAABHDboBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGSASEQDNICCyAAQQA2AgAgEEEBaiEBQR4hEAy3AQsCQCABIgQgAkcNAEGTASEQDNECCyAELQAAQcwARw24ASAEQQFqIQFBCiEQDLYBCwJAIAQgAkcNAEGUASEQDNACCwJAAkAgBC0AAEG/f2oODwC5AbkBuQG5AbkBuQG5AbkBuQG5AbkBuQG5AQG5AQsgBEEBaiEBQf4AIRAMtwILIARBAWohAUH/ACEQDLYCCwJAIAQgAkcNAEGVASEQDM8CCwJAAkAgBC0AAEG/f2oOAwC4AQG4AQsgBEEBaiEBQf0AIRAMtgILIARBAWohBEGAASEQDLUCCwJAIAQgAkcNAEGWASEQDM4CCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUGnz4CAAGotAABHDbYBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGWASEQDM4CCyAAQQA2AgAgEEEBaiEBQQshEAyzAQsCQCAEIAJHDQBBlwEhEAzNAgsCQAJAAkACQCAELQAAQVNqDiMAuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AQG4AbgBuAG4AbgBArgBuAG4AQO4AQsgBEEBaiEBQfsAIRAMtgILIARBAWohAUH8ACEQDLUCCyAEQQFqIQRBgQEhEAy0AgsgBEEBaiEEQYIBIRAMswILAkAgBCACRw0AQZgBIRAMzAILIAIgBGsgACgCACIBaiEUIAQgAWtBBGohEAJAA0AgBC0AACABQanPgIAAai0AAEcNtAEgAUEERg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZgBIRAMzAILIABBADYCACAQQQFqIQFBGSEQDLEBCwJAIAQgAkcNAEGZASEQDMsCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGuz4CAAGotAABHDbMBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGZASEQDMsCCyAAQQA2AgAgEEEBaiEBQQYhEAywAQsCQCAEIAJHDQBBmgEhEAzKAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBtM+AgABqLQAARw2yASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmgEhEAzKAgsgAEEANgIAIBBBAWohAUEcIRAMrwELAkAgBCACRw0AQZsBIRAMyQILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQbbPgIAAai0AAEcNsQEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZsBIRAMyQILIABBADYCACAQQQFqIQFBJyEQDK4BCwJAIAQgAkcNAEGcASEQDMgCCwJAAkAgBC0AAEGsf2oOAgABsQELIARBAWohBEGGASEQDK8CCyAEQQFqIQRBhwEhEAyuAgsCQCAEIAJHDQBBnQEhEAzHAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBuM+AgABqLQAARw2vASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBnQEhEAzHAgsgAEEANgIAIBBBAWohAUEmIRAMrAELAkAgBCACRw0AQZ4BIRAMxgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQbrPgIAAai0AAEcNrgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZ4BIRAMxgILIABBADYCACAQQQFqIQFBAyEQDKsBCwJAIAQgAkcNAEGfASEQDMUCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDa0BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGfASEQDMUCCyAAQQA2AgAgEEEBaiEBQQwhEAyqAQsCQCAEIAJHDQBBoAEhEAzEAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFBvM+AgABqLQAARw2sASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBoAEhEAzEAgsgAEEANgIAIBBBAWohAUENIRAMqQELAkAgBCACRw0AQaEBIRAMwwILAkACQCAELQAAQbp/ag4LAKwBrAGsAawBrAGsAawBrAGsAQGsAQsgBEEBaiEEQYsBIRAMqgILIARBAWohBEGMASEQDKkCCwJAIAQgAkcNAEGiASEQDMICCyAELQAAQdAARw2pASAEQQFqIQQM6QELAkAgBCACRw0AQaMBIRAMwQILAkACQCAELQAAQbd/ag4HAaoBqgGqAaoBqgEAqgELIARBAWohBEGOASEQDKgCCyAEQQFqIQFBIiEQDKYBCwJAIAQgAkcNAEGkASEQDMACCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUHAz4CAAGotAABHDagBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGkASEQDMACCyAAQQA2AgAgEEEBaiEBQR0hEAylAQsCQCAEIAJHDQBBpQEhEAy/AgsCQAJAIAQtAABBrn9qDgMAqAEBqAELIARBAWohBEGQASEQDKYCCyAEQQFqIQFBBCEQDKQBCwJAIAQgAkcNAEGmASEQDL4CCwJAAkACQAJAAkAgBC0AAEG/f2oOFQCqAaoBqgGqAaoBqgGqAaoBqgGqAQGqAaoBAqoBqgEDqgGqAQSqAQsgBEEBaiEEQYgBIRAMqAILIARBAWohBEGJASEQDKcCCyAEQQFqIQRBigEhEAymAgsgBEEBaiEEQY8BIRAMpQILIARBAWohBEGRASEQDKQCCwJAIAQgAkcNAEGnASEQDL0CCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDaUBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGnASEQDL0CCyAAQQA2AgAgEEEBaiEBQREhEAyiAQsCQCAEIAJHDQBBqAEhEAy8AgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBws+AgABqLQAARw2kASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBqAEhEAy8AgsgAEEANgIAIBBBAWohAUEsIRAMoQELAkAgBCACRw0AQakBIRAMuwILIAIgBGsgACgCACIBaiEUIAQgAWtBBGohEAJAA0AgBC0AACABQcXPgIAAai0AAEcNowEgAUEERg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQakBIRAMuwILIABBADYCACAQQQFqIQFBKyEQDKABCwJAIAQgAkcNAEGqASEQDLoCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHKz4CAAGotAABHDaIBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGqASEQDLoCCyAAQQA2AgAgEEEBaiEBQRQhEAyfAQsCQCAEIAJHDQBBqwEhEAy5AgsCQAJAAkACQCAELQAAQb5/ag4PAAECpAGkAaQBpAGkAaQBpAGkAaQBpAGkAQOkAQsgBEEBaiEEQZMBIRAMogILIARBAWohBEGUASEQDKECCyAEQQFqIQRBlQEhEAygAgsgBEEBaiEEQZYBIRAMnwILAkAgBCACRw0AQawBIRAMuAILIAQtAABBxQBHDZ8BIARBAWohBAzgAQsCQCAEIAJHDQBBrQEhEAy3AgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBzc+AgABqLQAARw2fASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBrQEhEAy3AgsgAEEANgIAIBBBAWohAUEOIRAMnAELAkAgBCACRw0AQa4BIRAMtgILIAQtAABB0ABHDZ0BIARBAWohAUElIRAMmwELAkAgBCACRw0AQa8BIRAMtQILIAIgBGsgACgCACIBaiEUIAQgAWtBCGohEAJAA0AgBC0AACABQdDPgIAAai0AAEcNnQEgAUEIRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQa8BIRAMtQILIABBADYCACAQQQFqIQFBKiEQDJoBCwJAIAQgAkcNAEGwASEQDLQCCwJAAkAgBC0AAEGrf2oOCwCdAZ0BnQGdAZ0BnQGdAZ0BnQEBnQELIARBAWohBEGaASEQDJsCCyAEQQFqIQRBmwEhEAyaAgsCQCAEIAJHDQBBsQEhEAyzAgsCQAJAIAQtAABBv39qDhQAnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBAZwBCyAEQQFqIQRBmQEhEAyaAgsgBEEBaiEEQZwBIRAMmQILAkAgBCACRw0AQbIBIRAMsgILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQdnPgIAAai0AAEcNmgEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbIBIRAMsgILIABBADYCACAQQQFqIQFBISEQDJcBCwJAIAQgAkcNAEGzASEQDLECCyACIARrIAAoAgAiAWohFCAEIAFrQQZqIRACQANAIAQtAAAgAUHdz4CAAGotAABHDZkBIAFBBkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGzASEQDLECCyAAQQA2AgAgEEEBaiEBQRohEAyWAQsCQCAEIAJHDQBBtAEhEAywAgsCQAJAAkAgBC0AAEG7f2oOEQCaAZoBmgGaAZoBmgGaAZoBmgEBmgGaAZoBmgGaAQKaAQsgBEEBaiEEQZ0BIRAMmAILIARBAWohBEGeASEQDJcCCyAEQQFqIQRBnwEhEAyWAgsCQCAEIAJHDQBBtQEhEAyvAgsgAiAEayAAKAIAIgFqIRQgBCABa0EFaiEQAkADQCAELQAAIAFB5M+AgABqLQAARw2XASABQQVGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBtQEhEAyvAgsgAEEANgIAIBBBAWohAUEoIRAMlAELAkAgBCACRw0AQbYBIRAMrgILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQerPgIAAai0AAEcNlgEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbYBIRAMrgILIABBADYCACAQQQFqIQFBByEQDJMBCwJAIAQgAkcNAEG3ASEQDK0CCwJAAkAgBC0AAEG7f2oODgCWAZYBlgGWAZYBlgGWAZYBlgGWAZYBlgEBlgELIARBAWohBEGhASEQDJQCCyAEQQFqIQRBogEhEAyTAgsCQCAEIAJHDQBBuAEhEAysAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFB7c+AgABqLQAARw2UASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBuAEhEAysAgsgAEEANgIAIBBBAWohAUESIRAMkQELAkAgBCACRw0AQbkBIRAMqwILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfDPgIAAai0AAEcNkwEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbkBIRAMqwILIABBADYCACAQQQFqIQFBICEQDJABCwJAIAQgAkcNAEG6ASEQDKoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUHyz4CAAGotAABHDZIBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG6ASEQDKoCCyAAQQA2AgAgEEEBaiEBQQ8hEAyPAQsCQCAEIAJHDQBBuwEhEAypAgsCQAJAIAQtAABBt39qDgcAkgGSAZIBkgGSAQGSAQsgBEEBaiEEQaUBIRAMkAILIARBAWohBEGmASEQDI8CCwJAIAQgAkcNAEG8ASEQDKgCCyACIARrIAAoAgAiAWohFCAEIAFrQQdqIRACQANAIAQtAAAgAUH0z4CAAGotAABHDZABIAFBB0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG8ASEQDKgCCyAAQQA2AgAgEEEBaiEBQRshEAyNAQsCQCAEIAJHDQBBvQEhEAynAgsCQAJAAkAgBC0AAEG+f2oOEgCRAZEBkQGRAZEBkQGRAZEBkQEBkQGRAZEBkQGRAZEBApEBCyAEQQFqIQRBpAEhEAyPAgsgBEEBaiEEQacBIRAMjgILIARBAWohBEGoASEQDI0CCwJAIAQgAkcNAEG+ASEQDKYCCyAELQAAQc4ARw2NASAEQQFqIQQMzwELAkAgBCACRw0AQb8BIRAMpQILAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBC0AAEG/f2oOFQABAgOcAQQFBpwBnAGcAQcICQoLnAEMDQ4PnAELIARBAWohAUHoACEQDJoCCyAEQQFqIQFB6QAhEAyZAgsgBEEBaiEBQe4AIRAMmAILIARBAWohAUHyACEQDJcCCyAEQQFqIQFB8wAhEAyWAgsgBEEBaiEBQfYAIRAMlQILIARBAWohAUH3ACEQDJQCCyAEQQFqIQFB+gAhEAyTAgsgBEEBaiEEQYMBIRAMkgILIARBAWohBEGEASEQDJECCyAEQQFqIQRBhQEhEAyQAgsgBEEBaiEEQZIBIRAMjwILIARBAWohBEGYASEQDI4CCyAEQQFqIQRBoAEhEAyNAgsgBEEBaiEEQaMBIRAMjAILIARBAWohBEGqASEQDIsCCwJAIAQgAkYNACAAQZCAgIAANgIIIAAgBDYCBEGrASEQDIsCC0HAASEQDKMCCyAAIAUgAhCqgICAACIBDYsBIAUhAQxcCwJAIAYgAkYNACAGQQFqIQUMjQELQcIBIRAMoQILA0ACQCAQLQAAQXZqDgSMAQAAjwEACyAQQQFqIhAgAkcNAAtBwwEhEAygAgsCQCAHIAJGDQAgAEGRgICAADYCCCAAIAc2AgQgByEBQQEhEAyHAgtBxAEhEAyfAgsCQCAHIAJHDQBBxQEhEAyfAgsCQAJAIActAABBdmoOBAHOAc4BAM4BCyAHQQFqIQYMjQELIAdBAWohBQyJAQsCQCAHIAJHDQBBxgEhEAyeAgsCQAJAIActAABBdmoOFwGPAY8BAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAQCPAQsgB0EBaiEHC0GwASEQDIQCCwJAIAggAkcNAEHIASEQDJ0CCyAILQAAQSBHDY0BIABBADsBMiAIQQFqIQFBswEhEAyDAgsgASEXAkADQCAXIgcgAkYNASAHLQAAQVBqQf8BcSIQQQpPDcwBAkAgAC8BMiIUQZkzSw0AIAAgFEEKbCIUOwEyIBBB//8DcyAUQf7/A3FJDQAgB0EBaiEXIAAgFCAQaiIQOwEyIBBB//8DcUHoB0kNAQsLQQAhECAAQQA2AhwgAEHBiYCAADYCECAAQQ02AgwgACAHQQFqNgIUDJwCC0HHASEQDJsCCyAAIAggAhCugICAACIQRQ3KASAQQRVHDYwBIABByAE2AhwgACAINgIUIABByZeAgAA2AhAgAEEVNgIMQQAhEAyaAgsCQCAJIAJHDQBBzAEhEAyaAgtBACEUQQEhF0EBIRZBACEQAkACQAJAAkACQAJAAkACQAJAIAktAABBUGoOCpYBlQEAAQIDBAUGCJcBC0ECIRAMBgtBAyEQDAULQQQhEAwEC0EFIRAMAwtBBiEQDAILQQchEAwBC0EIIRALQQAhF0EAIRZBACEUDI4BC0EJIRBBASEUQQAhF0EAIRYMjQELAkAgCiACRw0AQc4BIRAMmQILIAotAABBLkcNjgEgCkEBaiEJDMoBCyALIAJHDY4BQdABIRAMlwILAkAgCyACRg0AIABBjoCAgAA2AgggACALNgIEQbcBIRAM/gELQdEBIRAMlgILAkAgBCACRw0AQdIBIRAMlgILIAIgBGsgACgCACIQaiEUIAQgEGtBBGohCwNAIAQtAAAgEEH8z4CAAGotAABHDY4BIBBBBEYN6QEgEEEBaiEQIARBAWoiBCACRw0ACyAAIBQ2AgBB0gEhEAyVAgsgACAMIAIQrICAgAAiAQ2NASAMIQEMuAELAkAgBCACRw0AQdQBIRAMlAILIAIgBGsgACgCACIQaiEUIAQgEGtBAWohDANAIAQtAAAgEEGB0ICAAGotAABHDY8BIBBBAUYNjgEgEEEBaiEQIARBAWoiBCACRw0ACyAAIBQ2AgBB1AEhEAyTAgsCQCAEIAJHDQBB1gEhEAyTAgsgAiAEayAAKAIAIhBqIRQgBCAQa0ECaiELA0AgBC0AACAQQYPQgIAAai0AAEcNjgEgEEECRg2QASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHWASEQDJICCwJAIAQgAkcNAEHXASEQDJICCwJAAkAgBC0AAEG7f2oOEACPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BAY8BCyAEQQFqIQRBuwEhEAz5AQsgBEEBaiEEQbwBIRAM+AELAkAgBCACRw0AQdgBIRAMkQILIAQtAABByABHDYwBIARBAWohBAzEAQsCQCAEIAJGDQAgAEGQgICAADYCCCAAIAQ2AgRBvgEhEAz3AQtB2QEhEAyPAgsCQCAEIAJHDQBB2gEhEAyPAgsgBC0AAEHIAEYNwwEgAEEBOgAoDLkBCyAAQQI6AC8gACAEIAIQpoCAgAAiEA2NAUHCASEQDPQBCyAALQAoQX9qDgK3AbkBuAELA0ACQCAELQAAQXZqDgQAjgGOAQCOAQsgBEEBaiIEIAJHDQALQd0BIRAMiwILIABBADoALyAALQAtQQRxRQ2EAgsgAEEAOgAvIABBAToANCABIQEMjAELIBBBFUYN2gEgAEEANgIcIAAgATYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAMiAILAkAgACAQIAIQtICAgAAiBA0AIBAhAQyBAgsCQCAEQRVHDQAgAEEDNgIcIAAgEDYCFCAAQbCYgIAANgIQIABBFTYCDEEAIRAMiAILIABBADYCHCAAIBA2AhQgAEGnjoCAADYCECAAQRI2AgxBACEQDIcCCyAQQRVGDdYBIABBADYCHCAAIAE2AhQgAEHajYCAADYCECAAQRQ2AgxBACEQDIYCCyAAKAIEIRcgAEEANgIEIBAgEadqIhYhASAAIBcgECAWIBQbIhAQtYCAgAAiFEUNjQEgAEEHNgIcIAAgEDYCFCAAIBQ2AgxBACEQDIUCCyAAIAAvATBBgAFyOwEwIAEhAQtBKiEQDOoBCyAQQRVGDdEBIABBADYCHCAAIAE2AhQgAEGDjICAADYCECAAQRM2AgxBACEQDIICCyAQQRVGDc8BIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDIECCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyNAQsgAEEMNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDIACCyAQQRVGDcwBIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDP8BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyMAQsgAEENNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDP4BCyAQQRVGDckBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDP0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQuYCAgAAiEA0AIAFBAWohAQyLAQsgAEEONgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPwBCyAAQQA2AhwgACABNgIUIABBwJWAgAA2AhAgAEECNgIMQQAhEAz7AQsgEEEVRg3FASAAQQA2AhwgACABNgIUIABBxoyAgAA2AhAgAEEjNgIMQQAhEAz6AQsgAEEQNgIcIAAgATYCFCAAIBA2AgxBACEQDPkBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQuYCAgAAiBA0AIAFBAWohAQzxAQsgAEERNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPgBCyAQQRVGDcEBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDPcBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQuYCAgAAiEA0AIAFBAWohAQyIAQsgAEETNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPYBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQuYCAgAAiBA0AIAFBAWohAQztAQsgAEEUNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPUBCyAQQRVGDb0BIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDPQBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyGAQsgAEEWNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPMBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQt4CAgAAiBA0AIAFBAWohAQzpAQsgAEEXNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPIBCyAAQQA2AhwgACABNgIUIABBzZOAgAA2AhAgAEEMNgIMQQAhEAzxAQtCASERCyAQQQFqIQECQCAAKQMgIhJC//////////8PVg0AIAAgEkIEhiARhDcDICABIQEMhAELIABBADYCHCAAIAE2AhQgAEGtiYCAADYCECAAQQw2AgxBACEQDO8BCyAAQQA2AhwgACAQNgIUIABBzZOAgAA2AhAgAEEMNgIMQQAhEAzuAQsgACgCBCEXIABBADYCBCAQIBGnaiIWIQEgACAXIBAgFiAUGyIQELWAgIAAIhRFDXMgAEEFNgIcIAAgEDYCFCAAIBQ2AgxBACEQDO0BCyAAQQA2AhwgACAQNgIUIABBqpyAgAA2AhAgAEEPNgIMQQAhEAzsAQsgACAQIAIQtICAgAAiAQ0BIBAhAQtBDiEQDNEBCwJAIAFBFUcNACAAQQI2AhwgACAQNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAzqAQsgAEEANgIcIAAgEDYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAM6QELIAFBAWohEAJAIAAvATAiAUGAAXFFDQACQCAAIBAgAhC7gICAACIBDQAgECEBDHALIAFBFUcNugEgAEEFNgIcIAAgEDYCFCAAQfmXgIAANgIQIABBFTYCDEEAIRAM6QELAkAgAUGgBHFBoARHDQAgAC0ALUECcQ0AIABBADYCHCAAIBA2AhQgAEGWk4CAADYCECAAQQQ2AgxBACEQDOkBCyAAIBAgAhC9gICAABogECEBAkACQAJAAkACQCAAIBAgAhCzgICAAA4WAgEABAQEBAQEBAQEBAQEBAQEBAQEAwQLIABBAToALgsgACAALwEwQcAAcjsBMCAQIQELQSYhEAzRAQsgAEEjNgIcIAAgEDYCFCAAQaWWgIAANgIQIABBFTYCDEEAIRAM6QELIABBADYCHCAAIBA2AhQgAEHVi4CAADYCECAAQRE2AgxBACEQDOgBCyAALQAtQQFxRQ0BQcMBIRAMzgELAkAgDSACRg0AA0ACQCANLQAAQSBGDQAgDSEBDMQBCyANQQFqIg0gAkcNAAtBJSEQDOcBC0ElIRAM5gELIAAoAgQhBCAAQQA2AgQgACAEIA0Qr4CAgAAiBEUNrQEgAEEmNgIcIAAgBDYCDCAAIA1BAWo2AhRBACEQDOUBCyAQQRVGDasBIABBADYCHCAAIAE2AhQgAEH9jYCAADYCECAAQR02AgxBACEQDOQBCyAAQSc2AhwgACABNgIUIAAgEDYCDEEAIRAM4wELIBAhAUEBIRQCQAJAAkACQAJAAkACQCAALQAsQX5qDgcGBQUDAQIABQsgACAALwEwQQhyOwEwDAMLQQIhFAwBC0EEIRQLIABBAToALCAAIAAvATAgFHI7ATALIBAhAQtBKyEQDMoBCyAAQQA2AhwgACAQNgIUIABBq5KAgAA2AhAgAEELNgIMQQAhEAziAQsgAEEANgIcIAAgATYCFCAAQeGPgIAANgIQIABBCjYCDEEAIRAM4QELIABBADoALCAQIQEMvQELIBAhAUEBIRQCQAJAAkACQAJAIAAtACxBe2oOBAMBAgAFCyAAIAAvATBBCHI7ATAMAwtBAiEUDAELQQQhFAsgAEEBOgAsIAAgAC8BMCAUcjsBMAsgECEBC0EpIRAMxQELIABBADYCHCAAIAE2AhQgAEHwlICAADYCECAAQQM2AgxBACEQDN0BCwJAIA4tAABBDUcNACAAKAIEIQEgAEEANgIEAkAgACABIA4QsYCAgAAiAQ0AIA5BAWohAQx1CyAAQSw2AhwgACABNgIMIAAgDkEBajYCFEEAIRAM3QELIAAtAC1BAXFFDQFBxAEhEAzDAQsCQCAOIAJHDQBBLSEQDNwBCwJAAkADQAJAIA4tAABBdmoOBAIAAAMACyAOQQFqIg4gAkcNAAtBLSEQDN0BCyAAKAIEIQEgAEEANgIEAkAgACABIA4QsYCAgAAiAQ0AIA4hAQx0CyAAQSw2AhwgACAONgIUIAAgATYCDEEAIRAM3AELIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDkEBaiEBDHMLIABBLDYCHCAAIAE2AgwgACAOQQFqNgIUQQAhEAzbAQsgACgCBCEEIABBADYCBCAAIAQgDhCxgICAACIEDaABIA4hAQzOAQsgEEEsRw0BIAFBAWohEEEBIQECQAJAAkACQAJAIAAtACxBe2oOBAMBAgQACyAQIQEMBAtBAiEBDAELQQQhAQsgAEEBOgAsIAAgAC8BMCABcjsBMCAQIQEMAQsgACAALwEwQQhyOwEwIBAhAQtBOSEQDL8BCyAAQQA6ACwgASEBC0E0IRAMvQELIAAgAC8BMEEgcjsBMCABIQEMAgsgACgCBCEEIABBADYCBAJAIAAgBCABELGAgIAAIgQNACABIQEMxwELIABBNzYCHCAAIAE2AhQgACAENgIMQQAhEAzUAQsgAEEIOgAsIAEhAQtBMCEQDLkBCwJAIAAtAChBAUYNACABIQEMBAsgAC0ALUEIcUUNkwEgASEBDAMLIAAtADBBIHENlAFBxQEhEAy3AQsCQCAPIAJGDQACQANAAkAgDy0AAEFQaiIBQf8BcUEKSQ0AIA8hAUE1IRAMugELIAApAyAiEUKZs+bMmbPmzBlWDQEgACARQgp+IhE3AyAgESABrUL/AYMiEkJ/hVYNASAAIBEgEnw3AyAgD0EBaiIPIAJHDQALQTkhEAzRAQsgACgCBCECIABBADYCBCAAIAIgD0EBaiIEELGAgIAAIgINlQEgBCEBDMMBC0E5IRAMzwELAkAgAC8BMCIBQQhxRQ0AIAAtAChBAUcNACAALQAtQQhxRQ2QAQsgACABQff7A3FBgARyOwEwIA8hAQtBNyEQDLQBCyAAIAAvATBBEHI7ATAMqwELIBBBFUYNiwEgAEEANgIcIAAgATYCFCAAQfCOgIAANgIQIABBHDYCDEEAIRAMywELIABBwwA2AhwgACABNgIMIAAgDUEBajYCFEEAIRAMygELAkAgAS0AAEE6Rw0AIAAoAgQhECAAQQA2AgQCQCAAIBAgARCvgICAACIQDQAgAUEBaiEBDGMLIABBwwA2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAMygELIABBADYCHCAAIAE2AhQgAEGxkYCAADYCECAAQQo2AgxBACEQDMkBCyAAQQA2AhwgACABNgIUIABBoJmAgAA2AhAgAEEeNgIMQQAhEAzIAQsgAEEANgIACyAAQYASOwEqIAAgF0EBaiIBIAIQqICAgAAiEA0BIAEhAQtBxwAhEAysAQsgEEEVRw2DASAAQdEANgIcIAAgATYCFCAAQeOXgIAANgIQIABBFTYCDEEAIRAMxAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDF4LIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMwwELIABBADYCHCAAIBQ2AhQgAEHBqICAADYCECAAQQc2AgwgAEEANgIAQQAhEAzCAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMXQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAzBAQtBACEQIABBADYCHCAAIAE2AhQgAEGAkYCAADYCECAAQQk2AgwMwAELIBBBFUYNfSAAQQA2AhwgACABNgIUIABBlI2AgAA2AhAgAEEhNgIMQQAhEAy/AQtBASEWQQAhF0EAIRRBASEQCyAAIBA6ACsgAUEBaiEBAkACQCAALQAtQRBxDQACQAJAAkAgAC0AKg4DAQACBAsgFkUNAwwCCyAUDQEMAgsgF0UNAQsgACgCBCEQIABBADYCBAJAIAAgECABEK2AgIAAIhANACABIQEMXAsgAEHYADYCHCAAIAE2AhQgACAQNgIMQQAhEAy+AQsgACgCBCEEIABBADYCBAJAIAAgBCABEK2AgIAAIgQNACABIQEMrQELIABB2QA2AhwgACABNgIUIAAgBDYCDEEAIRAMvQELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKsBCyAAQdoANgIcIAAgATYCFCAAIAQ2AgxBACEQDLwBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQypAQsgAEHcADYCHCAAIAE2AhQgACAENgIMQQAhEAy7AQsCQCABLQAAQVBqIhBB/wFxQQpPDQAgACAQOgAqIAFBAWohAUHPACEQDKIBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQynAQsgAEHeADYCHCAAIAE2AhQgACAENgIMQQAhEAy6AQsgAEEANgIAIBdBAWohAQJAIAAtAClBI08NACABIQEMWQsgAEEANgIcIAAgATYCFCAAQdOJgIAANgIQIABBCDYCDEEAIRAMuQELIABBADYCAAtBACEQIABBADYCHCAAIAE2AhQgAEGQs4CAADYCECAAQQg2AgwMtwELIABBADYCACAXQQFqIQECQCAALQApQSFHDQAgASEBDFYLIABBADYCHCAAIAE2AhQgAEGbioCAADYCECAAQQg2AgxBACEQDLYBCyAAQQA2AgAgF0EBaiEBAkAgAC0AKSIQQV1qQQtPDQAgASEBDFULAkAgEEEGSw0AQQEgEHRBygBxRQ0AIAEhAQxVC0EAIRAgAEEANgIcIAAgATYCFCAAQfeJgIAANgIQIABBCDYCDAy1AQsgEEEVRg1xIABBADYCHCAAIAE2AhQgAEG5jYCAADYCECAAQRo2AgxBACEQDLQBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxUCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLMBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdIANgIcIAAgATYCFCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAUNgIUIAAgATYCDEEAIRAMogELIABBADYCHCAAIBQ2AhQgAEHDj4CAADYCECAAQQc2AgxBACEQDKEBCyAAQQA2AhwgACABNgIUIABBw4+AgAA2AhAgAEEHNgIMQQAhEAygAQtBACEQIABBADYCHCAAIBQ2AhQgAEGMnICAADYCECAAQQc2AgwMnwELIABBADYCHCAAIBQ2AhQgAEGMnICAADYCECAAQQc2AgxBACEQDJ4BCyAAQQA2AhwgACAUNgIUIABB/pGAgAA2AhAgAEEHNgIMQQAhEAydAQsgAEEANgIcIAAgATYCFCAAQY6bgIAANgIQIABBBjYCDEEAIRAMnAELIBBBFUYNVyAAQQA2AhwgACABNgIUIABBzI6AgAA2AhAgAEEgNgIMQQAhEAybAQsgAEEANgIAIBBBAWohAUEkIRALIAAgEDoAKSAAKAIEIRAgAEEANgIEIAAgECABEKuAgIAAIhANVCABIQEMPgsgAEEANgIAC0EAIRAgAEEANgIcIAAgBDYCFCAAQfGbgIAANgIQIABBBjYCDAyXAQsgAUEVRg1QIABBADYCHCAAIAU2AhQgAEHwjICAADYCECAAQRs2AgxBACEQDJYBCyAAKAIEIQUgAEEANgIEIAAgBSAQEKmAgIAAIgUNASAQQQFqIQULQa0BIRAMewsgAEHBATYCHCAAIAU2AgwgACAQQQFqNgIUQQAhEAyTAQsgACgCBCEGIABBADYCBCAAIAYgEBCpgICAACIGDQEgEEEBaiEGC0GuASEQDHgLIABBwgE2AhwgACAGNgIMIAAgEEEBajYCFEEAIRAMkAELIABBADYCHCAAIAc2AhQgAEGXi4CAADYCECAAQQ02AgxBACEQDI8BCyAAQQA2AhwgACAINgIUIABB45CAgAA2AhAgAEEJNgIMQQAhEAyOAQsgAEEANgIcIAAgCDYCFCAAQZSNgIAANgIQIABBITYCDEEAIRAMjQELQQEhFkEAIRdBACEUQQEhEAsgACAQOgArIAlBAWohCAJAAkAgAC0ALUEQcQ0AAkACQAJAIAAtACoOAwEAAgQLIBZFDQMMAgsgFA0BDAILIBdFDQELIAAoAgQhECAAQQA2AgQgACAQIAgQrYCAgAAiEEUNPSAAQckBNgIcIAAgCDYCFCAAIBA2AgxBACEQDIwBCyAAKAIEIQQgAEEANgIEIAAgBCAIEK2AgIAAIgRFDXYgAEHKATYCHCAAIAg2AhQgACAENgIMQQAhEAyLAQsgACgCBCEEIABBADYCBCAAIAQgCRCtgICAACIERQ10IABBywE2AhwgACAJNgIUIAAgBDYCDEEAIRAMigELIAAoAgQhBCAAQQA2AgQgACAEIAoQrYCAgAAiBEUNciAAQc0BNgIcIAAgCjYCFCAAIAQ2AgxBACEQDIkBCwJAIAstAABBUGoiEEH/AXFBCk8NACAAIBA6ACogC0EBaiEKQbYBIRAMcAsgACgCBCEEIABBADYCBCAAIAQgCxCtgICAACIERQ1wIABBzwE2AhwgACALNgIUIAAgBDYCDEEAIRAMiAELIABBADYCHCAAIAQ2AhQgAEGQs4CAADYCECAAQQg2AgwgAEEANgIAQQAhEAyHAQsgAUEVRg0/IABBADYCHCAAIAw2AhQgAEHMjoCAADYCECAAQSA2AgxBACEQDIYBCyAAQYEEOwEoIAAoAgQhECAAQgA3AwAgACAQIAxBAWoiDBCrgICAACIQRQ04IABB0wE2AhwgACAMNgIUIAAgEDYCDEEAIRAMhQELIABBADYCAAtBACEQIABBADYCHCAAIAQ2AhQgAEHYm4CAADYCECAAQQg2AgwMgwELIAAoAgQhECAAQgA3AwAgACAQIAtBAWoiCxCrgICAACIQDQFBxgEhEAxpCyAAQQI6ACgMVQsgAEHVATYCHCAAIAs2AhQgACAQNgIMQQAhEAyAAQsgEEEVRg03IABBADYCHCAAIAQ2AhQgAEGkjICAADYCECAAQRA2AgxBACEQDH8LIAAtADRBAUcNNCAAIAQgAhC8gICAACIQRQ00IBBBFUcNNSAAQdwBNgIcIAAgBDYCFCAAQdWWgIAANgIQIABBFTYCDEEAIRAMfgtBACEQIABBADYCHCAAQa+LgIAANgIQIABBAjYCDCAAIBRBAWo2AhQMfQtBACEQDGMLQQIhEAxiC0ENIRAMYQtBDyEQDGALQSUhEAxfC0ETIRAMXgtBFSEQDF0LQRYhEAxcC0EXIRAMWwtBGCEQDFoLQRkhEAxZC0EaIRAMWAtBGyEQDFcLQRwhEAxWC0EdIRAMVQtBHyEQDFQLQSEhEAxTC0EjIRAMUgtBxgAhEAxRC0EuIRAMUAtBLyEQDE8LQTshEAxOC0E9IRAMTQtByAAhEAxMC0HJACEQDEsLQcsAIRAMSgtBzAAhEAxJC0HOACEQDEgLQdEAIRAMRwtB1QAhEAxGC0HYACEQDEULQdkAIRAMRAtB2wAhEAxDC0HkACEQDEILQeUAIRAMQQtB8QAhEAxAC0H0ACEQDD8LQY0BIRAMPgtBlwEhEAw9C0GpASEQDDwLQawBIRAMOwtBwAEhEAw6C0G5ASEQDDkLQa8BIRAMOAtBsQEhEAw3C0GyASEQDDYLQbQBIRAMNQtBtQEhEAw0C0G6ASEQDDMLQb0BIRAMMgtBvwEhEAwxC0HBASEQDDALIABBADYCHCAAIAQ2AhQgAEHpi4CAADYCECAAQR82AgxBACEQDEgLIABB2wE2AhwgACAENgIUIABB+paAgAA2AhAgAEEVNgIMQQAhEAxHCyAAQfgANgIcIAAgDDYCFCAAQcqYgIAANgIQIABBFTYCDEEAIRAMRgsgAEHRADYCHCAAIAU2AhQgAEGwl4CAADYCECAAQRU2AgxBACEQDEULIABB+QA2AhwgACABNgIUIAAgEDYCDEEAIRAMRAsgAEH4ADYCHCAAIAE2AhQgAEHKmICAADYCECAAQRU2AgxBACEQDEMLIABB5AA2AhwgACABNgIUIABB45eAgAA2AhAgAEEVNgIMQQAhEAxCCyAAQdcANgIcIAAgATYCFCAAQcmXgIAANgIQIABBFTYCDEEAIRAMQQsgAEEANgIcIAAgATYCFCAAQbmNgIAANgIQIABBGjYCDEEAIRAMQAsgAEHCADYCHCAAIAE2AhQgAEHjmICAADYCECAAQRU2AgxBACEQDD8LIABBADYCBCAAIA8gDxCxgICAACIERQ0BIABBOjYCHCAAIAQ2AgwgACAPQQFqNgIUQQAhEAw+CyAAKAIEIQQgAEEANgIEAkAgACAEIAEQsYCAgAAiBEUNACAAQTs2AhwgACAENgIMIAAgAUEBajYCFEEAIRAMPgsgAUEBaiEBDC0LIA9BAWohAQwtCyAAQQA2AhwgACAPNgIUIABB5JKAgAA2AhAgAEEENgIMQQAhEAw7CyAAQTY2AhwgACAENgIUIAAgAjYCDEEAIRAMOgsgAEEuNgIcIAAgDjYCFCAAIAQ2AgxBACEQDDkLIABB0AA2AhwgACABNgIUIABBkZiAgAA2AhAgAEEVNgIMQQAhEAw4CyANQQFqIQEMLAsgAEEVNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAIRAMNgsgAEEbNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAIRAMNQsgAEEPNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAIRAMNAsgAEELNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAIRAMMwsgAEEaNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAIRAMMgsgAEELNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAIRAMMQsgAEEKNgIcIAAgATYCFCAAQeSWgIAANgIQIABBFTYCDEEAIRAMMAsgAEEeNgIcIAAgATYCFCAAQfmXgIAANgIQIABBFTYCDEEAIRAMLwsgAEEANgIcIAAgEDYCFCAAQdqNgIAANgIQIABBFDYCDEEAIRAMLgsgAEEENgIcIAAgATYCFCAAQbCYgIAANgIQIABBFTYCDEEAIRAMLQsgAEEANgIAIAtBAWohCwtBuAEhEAwSCyAAQQA2AgAgEEEBaiEBQfUAIRAMEQsgASEBAkAgAC0AKUEFRw0AQeMAIRAMEQtB4gAhEAwQC0EAIRAgAEEANgIcIABB5JGAgAA2AhAgAEEHNgIMIAAgFEEBajYCFAwoCyAAQQA2AgAgF0EBaiEBQcAAIRAMDgtBASEBCyAAIAE6ACwgAEEANgIAIBdBAWohAQtBKCEQDAsLIAEhAQtBOCEQDAkLAkAgASIPIAJGDQADQAJAIA8tAABBgL6AgABqLQAAIgFBAUYNACABQQJHDQMgD0EBaiEBDAQLIA9BAWoiDyACRw0AC0E+IRAMIgtBPiEQDCELIABBADoALCAPIQEMAQtBCyEQDAYLQTohEAwFCyABQQFqIQFBLSEQDAQLIAAgAToALCAAQQA2AgAgFkEBaiEBQQwhEAwDCyAAQQA2AgAgF0EBaiEBQQohEAwCCyAAQQA2AgALIABBADoALCANIQFBCSEQDAALC0EAIRAgAEEANgIcIAAgCzYCFCAAQc2QgIAANgIQIABBCTYCDAwXC0EAIRAgAEEANgIcIAAgCjYCFCAAQemKgIAANgIQIABBCTYCDAwWC0EAIRAgAEEANgIcIAAgCTYCFCAAQbeQgIAANgIQIABBCTYCDAwVC0EAIRAgAEEANgIcIAAgCDYCFCAAQZyRgIAANgIQIABBCTYCDAwUC0EAIRAgAEEANgIcIAAgATYCFCAAQc2QgIAANgIQIABBCTYCDAwTC0EAIRAgAEEANgIcIAAgATYCFCAAQemKgIAANgIQIABBCTYCDAwSC0EAIRAgAEEANgIcIAAgATYCFCAAQbeQgIAANgIQIABBCTYCDAwRC0EAIRAgAEEANgIcIAAgATYCFCAAQZyRgIAANgIQIABBCTYCDAwQC0EAIRAgAEEANgIcIAAgATYCFCAAQZeVgIAANgIQIABBDzYCDAwPC0EAIRAgAEEANgIcIAAgATYCFCAAQZeVgIAANgIQIABBDzYCDAwOC0EAIRAgAEEANgIcIAAgATYCFCAAQcCSgIAANgIQIABBCzYCDAwNC0EAIRAgAEEANgIcIAAgATYCFCAAQZWJgIAANgIQIABBCzYCDAwMC0EAIRAgAEEANgIcIAAgATYCFCAAQeGPgIAANgIQIABBCjYCDAwLC0EAIRAgAEEANgIcIAAgATYCFCAAQfuPgIAANgIQIABBCjYCDAwKC0EAIRAgAEEANgIcIAAgATYCFCAAQfGZgIAANgIQIABBAjYCDAwJC0EAIRAgAEEANgIcIAAgATYCFCAAQcSUgIAANgIQIABBAjYCDAwIC0EAIRAgAEEANgIcIAAgATYCFCAAQfKVgIAANgIQIABBAjYCDAwHCyAAQQI2AhwgACABNgIUIABBnJqAgAA2AhAgAEEWNgIMQQAhEAwGC0EBIRAMBQtB1AAhECABIgQgAkYNBCADQQhqIAAgBCACQdjCgIAAQQoQxYCAgAAgAygCDCEEIAMoAggOAwEEAgALEMqAgIAAAAsgAEEANgIcIABBtZqAgAA2AhAgAEEXNgIMIAAgBEEBajYCFEEAIRAMAgsgAEEANgIcIAAgBDYCFCAAQcqagIAANgIQIABBCTYCDEEAIRAMAQsCQCABIgQgAkcNAEEiIRAMAQsgAEGJgICAADYCCCAAIAQ2AgRBISEQCyADQRBqJICAgIAAIBALrwEBAn8gASgCACEGAkACQCACIANGDQAgBCAGaiEEIAYgA2ogAmshByACIAZBf3MgBWoiBmohBQNAAkAgAi0AACAELQAARg0AQQIhBAwDCwJAIAYNAEEAIQQgBSECDAMLIAZBf2ohBiAEQQFqIQQgAkEBaiICIANHDQALIAchBiADIQILIABBATYCACABIAY2AgAgACACNgIEDwsgAUEANgIAIAAgBDYCACAAIAI2AgQLCgAgABDHgICAAAvyNgELfyOAgICAAEEQayIBJICAgIAAAkBBACgCoNCAgAANAEEAEMuAgIAAQYDUhIAAayICQdkASQ0AQQAhAwJAQQAoAuDTgIAAIgQNAEEAQn83AuzTgIAAQQBCgICEgICAwAA3AuTTgIAAQQAgAUEIakFwcUHYqtWqBXMiBDYC4NOAgABBAEEANgL004CAAEEAQQA2AsTTgIAAC0EAIAI2AszTgIAAQQBBgNSEgAA2AsjTgIAAQQBBgNSEgAA2ApjQgIAAQQAgBDYCrNCAgABBAEF/NgKo0ICAAANAIANBxNCAgABqIANBuNCAgABqIgQ2AgAgBCADQbDQgIAAaiIFNgIAIANBvNCAgABqIAU2AgAgA0HM0ICAAGogA0HA0ICAAGoiBTYCACAFIAQ2AgAgA0HU0ICAAGogA0HI0ICAAGoiBDYCACAEIAU2AgAgA0HQ0ICAAGogBDYCACADQSBqIgNBgAJHDQALQYDUhIAAQXhBgNSEgABrQQ9xQQBBgNSEgABBCGpBD3EbIgNqIgRBBGogAkFIaiIFIANrIgNBAXI2AgBBAEEAKALw04CAADYCpNCAgABBACADNgKU0ICAAEEAIAQ2AqDQgIAAQYDUhIAAIAVqQTg2AgQLAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB7AFLDQACQEEAKAKI0ICAACIGQRAgAEETakFwcSAAQQtJGyICQQN2IgR2IgNBA3FFDQACQAJAIANBAXEgBHJBAXMiBUEDdCIEQbDQgIAAaiIDIARBuNCAgABqKAIAIgQoAggiAkcNAEEAIAZBfiAFd3E2AojQgIAADAELIAMgAjYCCCACIAM2AgwLIARBCGohAyAEIAVBA3QiBUEDcjYCBCAEIAVqIgQgBCgCBEEBcjYCBAwMCyACQQAoApDQgIAAIgdNDQECQCADRQ0AAkACQCADIAR0QQIgBHQiA0EAIANrcnEiA0EAIANrcUF/aiIDIANBDHZBEHEiA3YiBEEFdkEIcSIFIANyIAQgBXYiA0ECdkEEcSIEciADIAR2IgNBAXZBAnEiBHIgAyAEdiIDQQF2QQFxIgRyIAMgBHZqIgRBA3QiA0Gw0ICAAGoiBSADQbjQgIAAaigCACIDKAIIIgBHDQBBACAGQX4gBHdxIgY2AojQgIAADAELIAUgADYCCCAAIAU2AgwLIAMgAkEDcjYCBCADIARBA3QiBGogBCACayIFNgIAIAMgAmoiACAFQQFyNgIEAkAgB0UNACAHQXhxQbDQgIAAaiECQQAoApzQgIAAIQQCQAJAIAZBASAHQQN2dCIIcQ0AQQAgBiAIcjYCiNCAgAAgAiEIDAELIAIoAgghCAsgCCAENgIMIAIgBDYCCCAEIAI2AgwgBCAINgIICyADQQhqIQNBACAANgKc0ICAAEEAIAU2ApDQgIAADAwLQQAoAozQgIAAIglFDQEgCUEAIAlrcUF/aiIDIANBDHZBEHEiA3YiBEEFdkEIcSIFIANyIAQgBXYiA0ECdkEEcSIEciADIAR2IgNBAXZBAnEiBHIgAyAEdiIDQQF2QQFxIgRyIAMgBHZqQQJ0QbjSgIAAaigCACIAKAIEQXhxIAJrIQQgACEFAkADQAJAIAUoAhAiAw0AIAVBFGooAgAiA0UNAgsgAygCBEF4cSACayIFIAQgBSAESSIFGyEEIAMgACAFGyEAIAMhBQwACwsgACgCGCEKAkAgACgCDCIIIABGDQAgACgCCCIDQQAoApjQgIAASRogCCADNgIIIAMgCDYCDAwLCwJAIABBFGoiBSgCACIDDQAgACgCECIDRQ0DIABBEGohBQsDQCAFIQsgAyIIQRRqIgUoAgAiAw0AIAhBEGohBSAIKAIQIgMNAAsgC0EANgIADAoLQX8hAiAAQb9/Sw0AIABBE2oiA0FwcSECQQAoAozQgIAAIgdFDQBBACELAkAgAkGAAkkNAEEfIQsgAkH///8HSw0AIANBCHYiAyADQYD+P2pBEHZBCHEiA3QiBCAEQYDgH2pBEHZBBHEiBHQiBSAFQYCAD2pBEHZBAnEiBXRBD3YgAyAEciAFcmsiA0EBdCACIANBFWp2QQFxckEcaiELC0EAIAJrIQQCQAJAAkACQCALQQJ0QbjSgIAAaigCACIFDQBBACEDQQAhCAwBC0EAIQMgAkEAQRkgC0EBdmsgC0EfRht0IQBBACEIA0ACQCAFKAIEQXhxIAJrIgYgBE8NACAGIQQgBSEIIAYNAEEAIQQgBSEIIAUhAwwDCyADIAVBFGooAgAiBiAGIAUgAEEddkEEcWpBEGooAgAiBUYbIAMgBhshAyAAQQF0IQAgBQ0ACwsCQCADIAhyDQBBACEIQQIgC3QiA0EAIANrciAHcSIDRQ0DIANBACADa3FBf2oiAyADQQx2QRBxIgN2IgVBBXZBCHEiACADciAFIAB2IgNBAnZBBHEiBXIgAyAFdiIDQQF2QQJxIgVyIAMgBXYiA0EBdkEBcSIFciADIAV2akECdEG40oCAAGooAgAhAwsgA0UNAQsDQCADKAIEQXhxIAJrIgYgBEkhAAJAIAMoAhAiBQ0AIANBFGooAgAhBQsgBiAEIAAbIQQgAyAIIAAbIQggBSEDIAUNAAsLIAhFDQAgBEEAKAKQ0ICAACACa08NACAIKAIYIQsCQCAIKAIMIgAgCEYNACAIKAIIIgNBACgCmNCAgABJGiAAIAM2AgggAyAANgIMDAkLAkAgCEEUaiIFKAIAIgMNACAIKAIQIgNFDQMgCEEQaiEFCwNAIAUhBiADIgBBFGoiBSgCACIDDQAgAEEQaiEFIAAoAhAiAw0ACyAGQQA2AgAMCAsCQEEAKAKQ0ICAACIDIAJJDQBBACgCnNCAgAAhBAJAAkAgAyACayIFQRBJDQAgBCACaiIAIAVBAXI2AgRBACAFNgKQ0ICAAEEAIAA2ApzQgIAAIAQgA2ogBTYCACAEIAJBA3I2AgQMAQsgBCADQQNyNgIEIAQgA2oiAyADKAIEQQFyNgIEQQBBADYCnNCAgABBAEEANgKQ0ICAAAsgBEEIaiEDDAoLAkBBACgClNCAgAAiACACTQ0AQQAoAqDQgIAAIgMgAmoiBCAAIAJrIgVBAXI2AgRBACAFNgKU0ICAAEEAIAQ2AqDQgIAAIAMgAkEDcjYCBCADQQhqIQMMCgsCQAJAQQAoAuDTgIAARQ0AQQAoAujTgIAAIQQMAQtBAEJ/NwLs04CAAEEAQoCAhICAgMAANwLk04CAAEEAIAFBDGpBcHFB2KrVqgVzNgLg04CAAEEAQQA2AvTTgIAAQQBBADYCxNOAgABBgIAEIQQLQQAhAwJAIAQgAkHHAGoiB2oiBkEAIARrIgtxIgggAksNAEEAQTA2AvjTgIAADAoLAkBBACgCwNOAgAAiA0UNAAJAQQAoArjTgIAAIgQgCGoiBSAETQ0AIAUgA00NAQtBACEDQQBBMDYC+NOAgAAMCgtBAC0AxNOAgABBBHENBAJAAkACQEEAKAKg0ICAACIERQ0AQcjTgIAAIQMDQAJAIAMoAgAiBSAESw0AIAUgAygCBGogBEsNAwsgAygCCCIDDQALC0EAEMuAgIAAIgBBf0YNBSAIIQYCQEEAKALk04CAACIDQX9qIgQgAHFFDQAgCCAAayAEIABqQQAgA2txaiEGCyAGIAJNDQUgBkH+////B0sNBQJAQQAoAsDTgIAAIgNFDQBBACgCuNOAgAAiBCAGaiIFIARNDQYgBSADSw0GCyAGEMuAgIAAIgMgAEcNAQwHCyAGIABrIAtxIgZB/v///wdLDQQgBhDLgICAACIAIAMoAgAgAygCBGpGDQMgACEDCwJAIANBf0YNACACQcgAaiAGTQ0AAkAgByAGa0EAKALo04CAACIEakEAIARrcSIEQf7///8HTQ0AIAMhAAwHCwJAIAQQy4CAgABBf0YNACAEIAZqIQYgAyEADAcLQQAgBmsQy4CAgAAaDAQLIAMhACADQX9HDQUMAwtBACEIDAcLQQAhAAwFCyAAQX9HDQILQQBBACgCxNOAgABBBHI2AsTTgIAACyAIQf7///8HSw0BIAgQy4CAgAAhAEEAEMuAgIAAIQMgAEF/Rg0BIANBf0YNASAAIANPDQEgAyAAayIGIAJBOGpNDQELQQBBACgCuNOAgAAgBmoiAzYCuNOAgAACQCADQQAoArzTgIAATQ0AQQAgAzYCvNOAgAALAkACQAJAAkBBACgCoNCAgAAiBEUNAEHI04CAACEDA0AgACADKAIAIgUgAygCBCIIakYNAiADKAIIIgMNAAwDCwsCQAJAQQAoApjQgIAAIgNFDQAgACADTw0BC0EAIAA2ApjQgIAAC0EAIQNBACAGNgLM04CAAEEAIAA2AsjTgIAAQQBBfzYCqNCAgABBAEEAKALg04CAADYCrNCAgABBAEEANgLU04CAAANAIANBxNCAgABqIANBuNCAgABqIgQ2AgAgBCADQbDQgIAAaiIFNgIAIANBvNCAgABqIAU2AgAgA0HM0ICAAGogA0HA0ICAAGoiBTYCACAFIAQ2AgAgA0HU0ICAAGogA0HI0ICAAGoiBDYCACAEIAU2AgAgA0HQ0ICAAGogBDYCACADQSBqIgNBgAJHDQALIABBeCAAa0EPcUEAIABBCGpBD3EbIgNqIgQgBkFIaiIFIANrIgNBAXI2AgRBAEEAKALw04CAADYCpNCAgABBACADNgKU0ICAAEEAIAQ2AqDQgIAAIAAgBWpBODYCBAwCCyADLQAMQQhxDQAgBCAFSQ0AIAQgAE8NACAEQXggBGtBD3FBACAEQQhqQQ9xGyIFaiIAQQAoApTQgIAAIAZqIgsgBWsiBUEBcjYCBCADIAggBmo2AgRBAEEAKALw04CAADYCpNCAgABBACAFNgKU0ICAAEEAIAA2AqDQgIAAIAQgC2pBODYCBAwBCwJAIABBACgCmNCAgAAiCE8NAEEAIAA2ApjQgIAAIAAhCAsgACAGaiEFQcjTgIAAIQMCQAJAAkACQAJAAkACQANAIAMoAgAgBUYNASADKAIIIgMNAAwCCwsgAy0ADEEIcUUNAQtByNOAgAAhAwNAAkAgAygCACIFIARLDQAgBSADKAIEaiIFIARLDQMLIAMoAgghAwwACwsgAyAANgIAIAMgAygCBCAGajYCBCAAQXggAGtBD3FBACAAQQhqQQ9xG2oiCyACQQNyNgIEIAVBeCAFa0EPcUEAIAVBCGpBD3EbaiIGIAsgAmoiAmshAwJAIAYgBEcNAEEAIAI2AqDQgIAAQQBBACgClNCAgAAgA2oiAzYClNCAgAAgAiADQQFyNgIEDAMLAkAgBkEAKAKc0ICAAEcNAEEAIAI2ApzQgIAAQQBBACgCkNCAgAAgA2oiAzYCkNCAgAAgAiADQQFyNgIEIAIgA2ogAzYCAAwDCwJAIAYoAgQiBEEDcUEBRw0AIARBeHEhBwJAAkAgBEH/AUsNACAGKAIIIgUgBEEDdiIIQQN0QbDQgIAAaiIARhoCQCAGKAIMIgQgBUcNAEEAQQAoAojQgIAAQX4gCHdxNgKI0ICAAAwCCyAEIABGGiAEIAU2AgggBSAENgIMDAELIAYoAhghCQJAAkAgBigCDCIAIAZGDQAgBigCCCIEIAhJGiAAIAQ2AgggBCAANgIMDAELAkAgBkEUaiIEKAIAIgUNACAGQRBqIgQoAgAiBQ0AQQAhAAwBCwNAIAQhCCAFIgBBFGoiBCgCACIFDQAgAEEQaiEEIAAoAhAiBQ0ACyAIQQA2AgALIAlFDQACQAJAIAYgBigCHCIFQQJ0QbjSgIAAaiIEKAIARw0AIAQgADYCACAADQFBAEEAKAKM0ICAAEF+IAV3cTYCjNCAgAAMAgsgCUEQQRQgCSgCECAGRhtqIAA2AgAgAEUNAQsgACAJNgIYAkAgBigCECIERQ0AIAAgBDYCECAEIAA2AhgLIAYoAhQiBEUNACAAQRRqIAQ2AgAgBCAANgIYCyAHIANqIQMgBiAHaiIGKAIEIQQLIAYgBEF+cTYCBCACIANqIAM2AgAgAiADQQFyNgIEAkAgA0H/AUsNACADQXhxQbDQgIAAaiEEAkACQEEAKAKI0ICAACIFQQEgA0EDdnQiA3ENAEEAIAUgA3I2AojQgIAAIAQhAwwBCyAEKAIIIQMLIAMgAjYCDCAEIAI2AgggAiAENgIMIAIgAzYCCAwDC0EfIQQCQCADQf///wdLDQAgA0EIdiIEIARBgP4/akEQdkEIcSIEdCIFIAVBgOAfakEQdkEEcSIFdCIAIABBgIAPakEQdkECcSIAdEEPdiAEIAVyIAByayIEQQF0IAMgBEEVanZBAXFyQRxqIQQLIAIgBDYCHCACQgA3AhAgBEECdEG40oCAAGohBQJAQQAoAozQgIAAIgBBASAEdCIIcQ0AIAUgAjYCAEEAIAAgCHI2AozQgIAAIAIgBTYCGCACIAI2AgggAiACNgIMDAMLIANBAEEZIARBAXZrIARBH0YbdCEEIAUoAgAhAANAIAAiBSgCBEF4cSADRg0CIARBHXYhACAEQQF0IQQgBSAAQQRxakEQaiIIKAIAIgANAAsgCCACNgIAIAIgBTYCGCACIAI2AgwgAiACNgIIDAILIABBeCAAa0EPcUEAIABBCGpBD3EbIgNqIgsgBkFIaiIIIANrIgNBAXI2AgQgACAIakE4NgIEIAQgBUE3IAVrQQ9xQQAgBUFJakEPcRtqQUFqIgggCCAEQRBqSRsiCEEjNgIEQQBBACgC8NOAgAA2AqTQgIAAQQAgAzYClNCAgABBACALNgKg0ICAACAIQRBqQQApAtDTgIAANwIAIAhBACkCyNOAgAA3AghBACAIQQhqNgLQ04CAAEEAIAY2AszTgIAAQQAgADYCyNOAgABBAEEANgLU04CAACAIQSRqIQMDQCADQQc2AgAgA0EEaiIDIAVJDQALIAggBEYNAyAIIAgoAgRBfnE2AgQgCCAIIARrIgA2AgAgBCAAQQFyNgIEAkAgAEH/AUsNACAAQXhxQbDQgIAAaiEDAkACQEEAKAKI0ICAACIFQQEgAEEDdnQiAHENAEEAIAUgAHI2AojQgIAAIAMhBQwBCyADKAIIIQULIAUgBDYCDCADIAQ2AgggBCADNgIMIAQgBTYCCAwEC0EfIQMCQCAAQf///wdLDQAgAEEIdiIDIANBgP4/akEQdkEIcSIDdCIFIAVBgOAfakEQdkEEcSIFdCIIIAhBgIAPakEQdkECcSIIdEEPdiADIAVyIAhyayIDQQF0IAAgA0EVanZBAXFyQRxqIQMLIAQgAzYCHCAEQgA3AhAgA0ECdEG40oCAAGohBQJAQQAoAozQgIAAIghBASADdCIGcQ0AIAUgBDYCAEEAIAggBnI2AozQgIAAIAQgBTYCGCAEIAQ2AgggBCAENgIMDAQLIABBAEEZIANBAXZrIANBH0YbdCEDIAUoAgAhCANAIAgiBSgCBEF4cSAARg0DIANBHXYhCCADQQF0IQMgBSAIQQRxakEQaiIGKAIAIggNAAsgBiAENgIAIAQgBTYCGCAEIAQ2AgwgBCAENgIIDAMLIAUoAggiAyACNgIMIAUgAjYCCCACQQA2AhggAiAFNgIMIAIgAzYCCAsgC0EIaiEDDAULIAUoAggiAyAENgIMIAUgBDYCCCAEQQA2AhggBCAFNgIMIAQgAzYCCAtBACgClNCAgAAiAyACTQ0AQQAoAqDQgIAAIgQgAmoiBSADIAJrIgNBAXI2AgRBACADNgKU0ICAAEEAIAU2AqDQgIAAIAQgAkEDcjYCBCAEQQhqIQMMAwtBACEDQQBBMDYC+NOAgAAMAgsCQCALRQ0AAkACQCAIIAgoAhwiBUECdEG40oCAAGoiAygCAEcNACADIAA2AgAgAA0BQQAgB0F+IAV3cSIHNgKM0ICAAAwCCyALQRBBFCALKAIQIAhGG2ogADYCACAARQ0BCyAAIAs2AhgCQCAIKAIQIgNFDQAgACADNgIQIAMgADYCGAsgCEEUaigCACIDRQ0AIABBFGogAzYCACADIAA2AhgLAkACQCAEQQ9LDQAgCCAEIAJqIgNBA3I2AgQgCCADaiIDIAMoAgRBAXI2AgQMAQsgCCACaiIAIARBAXI2AgQgCCACQQNyNgIEIAAgBGogBDYCAAJAIARB/wFLDQAgBEF4cUGw0ICAAGohAwJAAkBBACgCiNCAgAAiBUEBIARBA3Z0IgRxDQBBACAFIARyNgKI0ICAACADIQQMAQsgAygCCCEECyAEIAA2AgwgAyAANgIIIAAgAzYCDCAAIAQ2AggMAQtBHyEDAkAgBEH///8HSw0AIARBCHYiAyADQYD+P2pBEHZBCHEiA3QiBSAFQYDgH2pBEHZBBHEiBXQiAiACQYCAD2pBEHZBAnEiAnRBD3YgAyAFciACcmsiA0EBdCAEIANBFWp2QQFxckEcaiEDCyAAIAM2AhwgAEIANwIQIANBAnRBuNKAgABqIQUCQCAHQQEgA3QiAnENACAFIAA2AgBBACAHIAJyNgKM0ICAACAAIAU2AhggACAANgIIIAAgADYCDAwBCyAEQQBBGSADQQF2ayADQR9GG3QhAyAFKAIAIQICQANAIAIiBSgCBEF4cSAERg0BIANBHXYhAiADQQF0IQMgBSACQQRxakEQaiIGKAIAIgINAAsgBiAANgIAIAAgBTYCGCAAIAA2AgwgACAANgIIDAELIAUoAggiAyAANgIMIAUgADYCCCAAQQA2AhggACAFNgIMIAAgAzYCCAsgCEEIaiEDDAELAkAgCkUNAAJAAkAgACAAKAIcIgVBAnRBuNKAgABqIgMoAgBHDQAgAyAINgIAIAgNAUEAIAlBfiAFd3E2AozQgIAADAILIApBEEEUIAooAhAgAEYbaiAINgIAIAhFDQELIAggCjYCGAJAIAAoAhAiA0UNACAIIAM2AhAgAyAINgIYCyAAQRRqKAIAIgNFDQAgCEEUaiADNgIAIAMgCDYCGAsCQAJAIARBD0sNACAAIAQgAmoiA0EDcjYCBCAAIANqIgMgAygCBEEBcjYCBAwBCyAAIAJqIgUgBEEBcjYCBCAAIAJBA3I2AgQgBSAEaiAENgIAAkAgB0UNACAHQXhxQbDQgIAAaiECQQAoApzQgIAAIQMCQAJAQQEgB0EDdnQiCCAGcQ0AQQAgCCAGcjYCiNCAgAAgAiEIDAELIAIoAgghCAsgCCADNgIMIAIgAzYCCCADIAI2AgwgAyAINgIIC0EAIAU2ApzQgIAAQQAgBDYCkNCAgAALIABBCGohAwsgAUEQaiSAgICAACADCwoAIAAQyYCAgAAL4g0BB38CQCAARQ0AIABBeGoiASAAQXxqKAIAIgJBeHEiAGohAwJAIAJBAXENACACQQNxRQ0BIAEgASgCACICayIBQQAoApjQgIAAIgRJDQEgAiAAaiEAAkAgAUEAKAKc0ICAAEYNAAJAIAJB/wFLDQAgASgCCCIEIAJBA3YiBUEDdEGw0ICAAGoiBkYaAkAgASgCDCICIARHDQBBAEEAKAKI0ICAAEF+IAV3cTYCiNCAgAAMAwsgAiAGRhogAiAENgIIIAQgAjYCDAwCCyABKAIYIQcCQAJAIAEoAgwiBiABRg0AIAEoAggiAiAESRogBiACNgIIIAIgBjYCDAwBCwJAIAFBFGoiAigCACIEDQAgAUEQaiICKAIAIgQNAEEAIQYMAQsDQCACIQUgBCIGQRRqIgIoAgAiBA0AIAZBEGohAiAGKAIQIgQNAAsgBUEANgIACyAHRQ0BAkACQCABIAEoAhwiBEECdEG40oCAAGoiAigCAEcNACACIAY2AgAgBg0BQQBBACgCjNCAgABBfiAEd3E2AozQgIAADAMLIAdBEEEUIAcoAhAgAUYbaiAGNgIAIAZFDQILIAYgBzYCGAJAIAEoAhAiAkUNACAGIAI2AhAgAiAGNgIYCyABKAIUIgJFDQEgBkEUaiACNgIAIAIgBjYCGAwBCyADKAIEIgJBA3FBA0cNACADIAJBfnE2AgRBACAANgKQ0ICAACABIABqIAA2AgAgASAAQQFyNgIEDwsgASADTw0AIAMoAgQiAkEBcUUNAAJAAkAgAkECcQ0AAkAgA0EAKAKg0ICAAEcNAEEAIAE2AqDQgIAAQQBBACgClNCAgAAgAGoiADYClNCAgAAgASAAQQFyNgIEIAFBACgCnNCAgABHDQNBAEEANgKQ0ICAAEEAQQA2ApzQgIAADwsCQCADQQAoApzQgIAARw0AQQAgATYCnNCAgABBAEEAKAKQ0ICAACAAaiIANgKQ0ICAACABIABBAXI2AgQgASAAaiAANgIADwsgAkF4cSAAaiEAAkACQCACQf8BSw0AIAMoAggiBCACQQN2IgVBA3RBsNCAgABqIgZGGgJAIAMoAgwiAiAERw0AQQBBACgCiNCAgABBfiAFd3E2AojQgIAADAILIAIgBkYaIAIgBDYCCCAEIAI2AgwMAQsgAygCGCEHAkACQCADKAIMIgYgA0YNACADKAIIIgJBACgCmNCAgABJGiAGIAI2AgggAiAGNgIMDAELAkAgA0EUaiICKAIAIgQNACADQRBqIgIoAgAiBA0AQQAhBgwBCwNAIAIhBSAEIgZBFGoiAigCACIEDQAgBkEQaiECIAYoAhAiBA0ACyAFQQA2AgALIAdFDQACQAJAIAMgAygCHCIEQQJ0QbjSgIAAaiICKAIARw0AIAIgBjYCACAGDQFBAEEAKAKM0ICAAEF+IAR3cTYCjNCAgAAMAgsgB0EQQRQgBygCECADRhtqIAY2AgAgBkUNAQsgBiAHNgIYAkAgAygCECICRQ0AIAYgAjYCECACIAY2AhgLIAMoAhQiAkUNACAGQRRqIAI2AgAgAiAGNgIYCyABIABqIAA2AgAgASAAQQFyNgIEIAFBACgCnNCAgABHDQFBACAANgKQ0ICAAA8LIAMgAkF+cTYCBCABIABqIAA2AgAgASAAQQFyNgIECwJAIABB/wFLDQAgAEF4cUGw0ICAAGohAgJAAkBBACgCiNCAgAAiBEEBIABBA3Z0IgBxDQBBACAEIAByNgKI0ICAACACIQAMAQsgAigCCCEACyAAIAE2AgwgAiABNgIIIAEgAjYCDCABIAA2AggPC0EfIQICQCAAQf///wdLDQAgAEEIdiICIAJBgP4/akEQdkEIcSICdCIEIARBgOAfakEQdkEEcSIEdCIGIAZBgIAPakEQdkECcSIGdEEPdiACIARyIAZyayICQQF0IAAgAkEVanZBAXFyQRxqIQILIAEgAjYCHCABQgA3AhAgAkECdEG40oCAAGohBAJAAkBBACgCjNCAgAAiBkEBIAJ0IgNxDQAgBCABNgIAQQAgBiADcjYCjNCAgAAgASAENgIYIAEgATYCCCABIAE2AgwMAQsgAEEAQRkgAkEBdmsgAkEfRht0IQIgBCgCACEGAkADQCAGIgQoAgRBeHEgAEYNASACQR12IQYgAkEBdCECIAQgBkEEcWpBEGoiAygCACIGDQALIAMgATYCACABIAQ2AhggASABNgIMIAEgATYCCAwBCyAEKAIIIgAgATYCDCAEIAE2AgggAUEANgIYIAEgBDYCDCABIAA2AggLQQBBACgCqNCAgABBf2oiAUF/IAEbNgKo0ICAAAsLBAAAAAtOAAJAIAANAD8AQRB0DwsCQCAAQf//A3ENACAAQX9MDQACQCAAQRB2QAAiAEF/Rw0AQQBBMDYC+NOAgABBfw8LIABBEHQPCxDKgICAAAAL8gICA38BfgJAIAJFDQAgACABOgAAIAIgAGoiA0F/aiABOgAAIAJBA0kNACAAIAE6AAIgACABOgABIANBfWogAToAACADQX5qIAE6AAAgAkEHSQ0AIAAgAToAAyADQXxqIAE6AAAgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIFayICQSBJDQAgAa1CgYCAgBB+IQYgAyAFaiEBA0AgASAGNwMYIAEgBjcDECABIAY3AwggASAGNwMAIAFBIGohASACQWBqIgJBH0sNAAsLIAALC45IAQBBgAgLhkgBAAAAAgAAAAMAAAAAAAAAAAAAAAQAAAAFAAAAAAAAAAAAAAAGAAAABwAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEludmFsaWQgY2hhciBpbiB1cmwgcXVlcnkAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9ib2R5AENvbnRlbnQtTGVuZ3RoIG92ZXJmbG93AENodW5rIHNpemUgb3ZlcmZsb3cAUmVzcG9uc2Ugb3ZlcmZsb3cASW52YWxpZCBtZXRob2QgZm9yIEhUVFAveC54IHJlcXVlc3QASW52YWxpZCBtZXRob2QgZm9yIFJUU1AveC54IHJlcXVlc3QARXhwZWN0ZWQgU09VUkNFIG1ldGhvZCBmb3IgSUNFL3gueCByZXF1ZXN0AEludmFsaWQgY2hhciBpbiB1cmwgZnJhZ21lbnQgc3RhcnQARXhwZWN0ZWQgZG90AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fc3RhdHVzAEludmFsaWQgcmVzcG9uc2Ugc3RhdHVzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fcmVzZXRgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8='

			/***/
		},

		/***/ 53434: /***/ (module) => {
			module.exports =
				'AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJsbGh0dHBfc3RhdHVzX25hbWUAIRpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAiIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAjHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACQkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACUYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mAD8JFwEAQQELEQECAwQFCwYHNTk3MS8tJyspCrLgAkUCAAsIABCIgICAAAsZACAAEMKAgIAAGiAAIAI2AjggACABOgAoCxwAIAAgAC8BMiAALQAuIAAQwYCAgAAQgICAgAALKgEBf0HAABDGgICAACIBEMKAgIAAGiABQYCIgIAANgI4IAEgADoAKCABCwoAIAAQyICAgAALBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LRQEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABDCgICAABogACAENgI4IAAgAzoAKCAAIAI6AC0gACABNgIYCxEAIAAgASABIAJqEMOAgIAACxAAIABBAEHcABDMgICAABoLZwEBf0EAIQECQCAAKAIMDQACQAJAAkACQCAALQAvDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgARGAgICAAAAiAQ0DC0EADwsQyoCAgAAACyAAQcOWgIAANgIQQQ4hAQsgAQseAAJAIAAoAgwNACAAQdGbgIAANgIQIABBFTYCDAsLFgACQCAAKAIMQRVHDQAgAEEANgIMCwsWAAJAIAAoAgxBFkcNACAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsiAAJAIABBJEkNABDKgICAAAALIABBAnRBoLOAgABqKAIACyIAAkAgAEEuSQ0AEMqAgIAAAAsgAEECdEGwtICAAGooAgAL7gsBAX9B66iAgAAhAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBnH9qDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0Hhp4CAAA8LQaShgIAADwtBy6yAgAAPC0H+sYCAAA8LQcCkgIAADwtBq6SAgAAPC0GNqICAAA8LQeKmgIAADwtBgLCAgAAPC0G5r4CAAA8LQdekgIAADwtB75+AgAAPC0Hhn4CAAA8LQfqfgIAADwtB8qCAgAAPC0Gor4CAAA8LQa6ygIAADwtBiLCAgAAPC0Hsp4CAAA8LQYKigIAADwtBjp2AgAAPC0HQroCAAA8LQcqjgIAADwtBxbKAgAAPC0HfnICAAA8LQdKcgIAADwtBxKCAgAAPC0HXoICAAA8LQaKfgIAADwtB7a6AgAAPC0GrsICAAA8LQdSlgIAADwtBzK6AgAAPC0H6roCAAA8LQfyrgIAADwtB0rCAgAAPC0HxnYCAAA8LQbuggIAADwtB96uAgAAPC0GQsYCAAA8LQdexgIAADwtBoq2AgAAPC0HUp4CAAA8LQeCrgIAADwtBn6yAgAAPC0HrsYCAAA8LQdWfgIAADwtByrGAgAAPC0HepYCAAA8LQdSegIAADwtB9JyAgAAPC0GnsoCAAA8LQbGdgIAADwtBoJ2AgAAPC0G5sYCAAA8LQbywgIAADwtBkqGAgAAPC0GzpoCAAA8LQemsgIAADwtBrJ6AgAAPC0HUq4CAAA8LQfemgIAADwtBgKaAgAAPC0GwoYCAAA8LQf6egIAADwtBjaOAgAAPC0GJrYCAAA8LQfeigIAADwtBoLGAgAAPC0Gun4CAAA8LQcalgIAADwtB6J6AgAAPC0GTooCAAA8LQcKvgIAADwtBw52AgAAPC0GLrICAAA8LQeGdgIAADwtBja+AgAAPC0HqoYCAAA8LQbStgIAADwtB0q+AgAAPC0HfsoCAAA8LQdKygIAADwtB8LCAgAAPC0GpooCAAA8LQfmjgIAADwtBmZ6AgAAPC0G1rICAAA8LQZuwgIAADwtBkrKAgAAPC0G2q4CAAA8LQcKigIAADwtB+LKAgAAPC0GepYCAAA8LQdCigIAADwtBup6AgAAPC0GBnoCAAA8LEMqAgIAAAAtB1qGAgAAhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAgAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCBCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQcaRgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIwIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAggiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2ioCAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCNCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIMIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZqAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAjgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCECIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZWQgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAI8IgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAhQiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEGqm4CAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCQCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIYIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZOAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCJCIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIsIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAigiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2iICAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCUCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIcIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBwpmAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCICIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZSUgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAJMIgRFDQAgACAEEYCAgIAAACEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAlQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCWCIERQ0AIAAgBBGAgICAAAAhAwsgAwtFAQF/AkACQCAALwEwQRRxQRRHDQBBASEDIAAtAChBAUYNASAALwEyQeUARiEDDAELIAAtAClBBUYhAwsgACADOgAuQQAL/gEBA39BASEDAkAgAC8BMCIEQQhxDQAgACkDIEIAUiEDCwJAAkAgAC0ALkUNAEEBIQUgAC0AKUEFRg0BQQEhBSAEQcAAcUUgA3FBAUcNAQtBACEFIARBwABxDQBBAiEFIARB//8DcSIDQQhxDQACQCADQYAEcUUNAAJAIAAtAChBAUcNACAALQAtQQpxDQBBBQ8LQQQPCwJAIANBIHENAAJAIAAtAChBAUYNACAALwEyQf//A3EiAEGcf2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQShxRQ0CIANBiARxQYAERg0CC0EADwtBAEEDIAApAyBQGyEFCyAFC2IBAn9BACEBAkAgAC0AKEEBRg0AIAAvATJB//8DcSICQZx/akHkAEkNACACQcwBRg0AIAJBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhASAAQYgEcUGABEYNACAAQShxRSEBCyABC6cBAQN/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQMgAC8BMCIEQQJxRQ0BDAILQQAhAyAALwEwIgRBAXFFDQELQQEhAyAALQAoQQFGDQAgAC8BMkH//wNxIgVBnH9qQeQASQ0AIAVBzAFGDQAgBUGwAkYNACAEQcAAcQ0AQQAhAyAEQYgEcUGABEYNACAEQShxQQBHIQMLIABBADsBMCAAQQA6AC8gAwuZAQECfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEBIAAvATAiAkECcUUNAQwCC0EAIQEgAC8BMCICQQFxRQ0BC0EBIQEgAC0AKEEBRg0AIAAvATJB//8DcSIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC0kBAXsgAEEQav0MAAAAAAAAAAAAAAAAAAAAACIB/QsDACAAIAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AcsBygG4AckBuQHIAboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBANwBC0EAIRAMxgELQQ4hEAzFAQtBDSEQDMQBC0EPIRAMwwELQRAhEAzCAQtBEyEQDMEBC0EUIRAMwAELQRUhEAy/AQtBFiEQDL4BC0EXIRAMvQELQRghEAy8AQtBGSEQDLsBC0EaIRAMugELQRshEAy5AQtBHCEQDLgBC0EIIRAMtwELQR0hEAy2AQtBICEQDLUBC0EfIRAMtAELQQchEAyzAQtBISEQDLIBC0EiIRAMsQELQR4hEAywAQtBIyEQDK8BC0ESIRAMrgELQREhEAytAQtBJCEQDKwBC0ElIRAMqwELQSYhEAyqAQtBJyEQDKkBC0HDASEQDKgBC0EpIRAMpwELQSshEAymAQtBLCEQDKUBC0EtIRAMpAELQS4hEAyjAQtBLyEQDKIBC0HEASEQDKEBC0EwIRAMoAELQTQhEAyfAQtBDCEQDJ4BC0ExIRAMnQELQTIhEAycAQtBMyEQDJsBC0E5IRAMmgELQTUhEAyZAQtBxQEhEAyYAQtBCyEQDJcBC0E6IRAMlgELQTYhEAyVAQtBCiEQDJQBC0E3IRAMkwELQTghEAySAQtBPCEQDJEBC0E7IRAMkAELQT0hEAyPAQtBCSEQDI4BC0EoIRAMjQELQT4hEAyMAQtBPyEQDIsBC0HAACEQDIoBC0HBACEQDIkBC0HCACEQDIgBC0HDACEQDIcBC0HEACEQDIYBC0HFACEQDIUBC0HGACEQDIQBC0EqIRAMgwELQccAIRAMggELQcgAIRAMgQELQckAIRAMgAELQcoAIRAMfwtBywAhEAx+C0HNACEQDH0LQcwAIRAMfAtBzgAhEAx7C0HPACEQDHoLQdAAIRAMeQtB0QAhEAx4C0HSACEQDHcLQdMAIRAMdgtB1AAhEAx1C0HWACEQDHQLQdUAIRAMcwtBBiEQDHILQdcAIRAMcQtBBSEQDHALQdgAIRAMbwtBBCEQDG4LQdkAIRAMbQtB2gAhEAxsC0HbACEQDGsLQdwAIRAMagtBAyEQDGkLQd0AIRAMaAtB3gAhEAxnC0HfACEQDGYLQeEAIRAMZQtB4AAhEAxkC0HiACEQDGMLQeMAIRAMYgtBAiEQDGELQeQAIRAMYAtB5QAhEAxfC0HmACEQDF4LQecAIRAMXQtB6AAhEAxcC0HpACEQDFsLQeoAIRAMWgtB6wAhEAxZC0HsACEQDFgLQe0AIRAMVwtB7gAhEAxWC0HvACEQDFULQfAAIRAMVAtB8QAhEAxTC0HyACEQDFILQfMAIRAMUQtB9AAhEAxQC0H1ACEQDE8LQfYAIRAMTgtB9wAhEAxNC0H4ACEQDEwLQfkAIRAMSwtB+gAhEAxKC0H7ACEQDEkLQfwAIRAMSAtB/QAhEAxHC0H+ACEQDEYLQf8AIRAMRQtBgAEhEAxEC0GBASEQDEMLQYIBIRAMQgtBgwEhEAxBC0GEASEQDEALQYUBIRAMPwtBhgEhEAw+C0GHASEQDD0LQYgBIRAMPAtBiQEhEAw7C0GKASEQDDoLQYsBIRAMOQtBjAEhEAw4C0GNASEQDDcLQY4BIRAMNgtBjwEhEAw1C0GQASEQDDQLQZEBIRAMMwtBkgEhEAwyC0GTASEQDDELQZQBIRAMMAtBlQEhEAwvC0GWASEQDC4LQZcBIRAMLQtBmAEhEAwsC0GZASEQDCsLQZoBIRAMKgtBmwEhEAwpC0GcASEQDCgLQZ0BIRAMJwtBngEhEAwmC0GfASEQDCULQaABIRAMJAtBoQEhEAwjC0GiASEQDCILQaMBIRAMIQtBpAEhEAwgC0GlASEQDB8LQaYBIRAMHgtBpwEhEAwdC0GoASEQDBwLQakBIRAMGwtBqgEhEAwaC0GrASEQDBkLQawBIRAMGAtBrQEhEAwXC0GuASEQDBYLQQEhEAwVC0GvASEQDBQLQbABIRAMEwtBsQEhEAwSC0GzASEQDBELQbIBIRAMEAtBtAEhEAwPC0G1ASEQDA4LQbYBIRAMDQtBtwEhEAwMC0G4ASEQDAsLQbkBIRAMCgtBugEhEAwJC0G7ASEQDAgLQcYBIRAMBwtBvAEhEAwGC0G9ASEQDAULQb4BIRAMBAtBvwEhEAwDC0HAASEQDAILQcIBIRAMAQtBwQEhEAsDQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB4fICEjJSg/QEFERUZHSElKS0xNT1BRUlPeA1dZW1xdYGJlZmdoaWprbG1vcHFyc3R1dnd4eXp7fH1+gAGCAYUBhgGHAYkBiwGMAY0BjgGPAZABkQGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwG4AbkBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgHHAcgByQHKAcsBzAHNAc4BzwHQAdEB0gHTAdQB1QHWAdcB2AHZAdoB2wHcAd0B3gHgAeEB4gHjAeQB5QHmAecB6AHpAeoB6wHsAe0B7gHvAfAB8QHyAfMBmQKkArAC/gL+AgsgASIEIAJHDfMBQd0BIRAM/wMLIAEiECACRw3dAUHDASEQDP4DCyABIgEgAkcNkAFB9wAhEAz9AwsgASIBIAJHDYYBQe8AIRAM/AMLIAEiASACRw1/QeoAIRAM+wMLIAEiASACRw17QegAIRAM+gMLIAEiASACRw14QeYAIRAM+QMLIAEiASACRw0aQRghEAz4AwsgASIBIAJHDRRBEiEQDPcDCyABIgEgAkcNWUHFACEQDPYDCyABIgEgAkcNSkE/IRAM9QMLIAEiASACRw1IQTwhEAz0AwsgASIBIAJHDUFBMSEQDPMDCyAALQAuQQFGDesDDIcCCyAAIAEiASACEMCAgIAAQQFHDeYBIABCADcDIAznAQsgACABIgEgAhC0gICAACIQDecBIAEhAQz1AgsCQCABIgEgAkcNAEEGIRAM8AMLIAAgAUEBaiIBIAIQu4CAgAAiEA3oASABIQEMMQsgAEIANwMgQRIhEAzVAwsgASIQIAJHDStBHSEQDO0DCwJAIAEiASACRg0AIAFBAWohAUEQIRAM1AMLQQchEAzsAwsgAEIAIAApAyAiESACIAEiEGutIhJ9IhMgEyARVhs3AyAgESASViIURQ3lAUEIIRAM6wMLAkAgASIBIAJGDQAgAEGJgICAADYCCCAAIAE2AgQgASEBQRQhEAzSAwtBCSEQDOoDCyABIQEgACkDIFAN5AEgASEBDPICCwJAIAEiASACRw0AQQshEAzpAwsgACABQQFqIgEgAhC2gICAACIQDeUBIAEhAQzyAgsgACABIgEgAhC4gICAACIQDeUBIAEhAQzyAgsgACABIgEgAhC4gICAACIQDeYBIAEhAQwNCyAAIAEiASACELqAgIAAIhAN5wEgASEBDPACCwJAIAEiASACRw0AQQ8hEAzlAwsgAS0AACIQQTtGDQggEEENRw3oASABQQFqIQEM7wILIAAgASIBIAIQuoCAgAAiEA3oASABIQEM8gILA0ACQCABLQAAQfC1gIAAai0AACIQQQFGDQAgEEECRw3rASAAKAIEIRAgAEEANgIEIAAgECABQQFqIgEQuYCAgAAiEA3qASABIQEM9AILIAFBAWoiASACRw0AC0ESIRAM4gMLIAAgASIBIAIQuoCAgAAiEA3pASABIQEMCgsgASIBIAJHDQZBGyEQDOADCwJAIAEiASACRw0AQRYhEAzgAwsgAEGKgICAADYCCCAAIAE2AgQgACABIAIQuICAgAAiEA3qASABIQFBICEQDMYDCwJAIAEiASACRg0AA0ACQCABLQAAQfC3gIAAai0AACIQQQJGDQACQCAQQX9qDgTlAewBAOsB7AELIAFBAWohAUEIIRAMyAMLIAFBAWoiASACRw0AC0EVIRAM3wMLQRUhEAzeAwsDQAJAIAEtAABB8LmAgABqLQAAIhBBAkYNACAQQX9qDgTeAewB4AHrAewBCyABQQFqIgEgAkcNAAtBGCEQDN0DCwJAIAEiASACRg0AIABBi4CAgAA2AgggACABNgIEIAEhAUEHIRAMxAMLQRkhEAzcAwsgAUEBaiEBDAILAkAgASIUIAJHDQBBGiEQDNsDCyAUIQECQCAULQAAQXNqDhTdAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAgDuAgtBACEQIABBADYCHCAAQa+LgIAANgIQIABBAjYCDCAAIBRBAWo2AhQM2gMLAkAgAS0AACIQQTtGDQAgEEENRw3oASABQQFqIQEM5QILIAFBAWohAQtBIiEQDL8DCwJAIAEiECACRw0AQRwhEAzYAwtCACERIBAhASAQLQAAQVBqDjfnAeYBAQIDBAUGBwgAAAAAAAAACQoLDA0OAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPEBESExQAC0EeIRAMvQMLQgIhEQzlAQtCAyERDOQBC0IEIREM4wELQgUhEQziAQtCBiERDOEBC0IHIREM4AELQgghEQzfAQtCCSERDN4BC0IKIREM3QELQgshEQzcAQtCDCERDNsBC0INIREM2gELQg4hEQzZAQtCDyERDNgBC0IKIREM1wELQgshEQzWAQtCDCERDNUBC0INIREM1AELQg4hEQzTAQtCDyERDNIBC0IAIRECQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAtAABBUGoON+UB5AEAAQIDBAUGB+YB5gHmAeYB5gHmAeYBCAkKCwwN5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAQ4PEBESE+YBC0ICIREM5AELQgMhEQzjAQtCBCERDOIBC0IFIREM4QELQgYhEQzgAQtCByERDN8BC0IIIREM3gELQgkhEQzdAQtCCiERDNwBC0ILIREM2wELQgwhEQzaAQtCDSERDNkBC0IOIREM2AELQg8hEQzXAQtCCiERDNYBC0ILIREM1QELQgwhEQzUAQtCDSERDNMBC0IOIREM0gELQg8hEQzRAQsgAEIAIAApAyAiESACIAEiEGutIhJ9IhMgEyARVhs3AyAgESASViIURQ3SAUEfIRAMwAMLAkAgASIBIAJGDQAgAEGJgICAADYCCCAAIAE2AgQgASEBQSQhEAynAwtBICEQDL8DCyAAIAEiECACEL6AgIAAQX9qDgW2AQDFAgHRAdIBC0ERIRAMpAMLIABBAToALyAQIQEMuwMLIAEiASACRw3SAUEkIRAMuwMLIAEiDSACRw0eQcYAIRAMugMLIAAgASIBIAIQsoCAgAAiEA3UASABIQEMtQELIAEiECACRw0mQdAAIRAMuAMLAkAgASIBIAJHDQBBKCEQDLgDCyAAQQA2AgQgAEGMgICAADYCCCAAIAEgARCxgICAACIQDdMBIAEhAQzYAQsCQCABIhAgAkcNAEEpIRAMtwMLIBAtAAAiAUEgRg0UIAFBCUcN0wEgEEEBaiEBDBULAkAgASIBIAJGDQAgAUEBaiEBDBcLQSohEAy1AwsCQCABIhAgAkcNAEErIRAMtQMLAkAgEC0AACIBQQlGDQAgAUEgRw3VAQsgAC0ALEEIRg3TASAQIQEMkQMLAkAgASIBIAJHDQBBLCEQDLQDCyABLQAAQQpHDdUBIAFBAWohAQzJAgsgASIOIAJHDdUBQS8hEAyyAwsDQAJAIAEtAAAiEEEgRg0AAkAgEEF2ag4EANwB3AEA2gELIAEhAQzgAQsgAUEBaiIBIAJHDQALQTEhEAyxAwtBMiEQIAEiFCACRg2wAyACIBRrIAAoAgAiAWohFSAUIAFrQQNqIRYCQANAIBQtAAAiF0EgciAXIBdBv39qQf8BcUEaSRtB/wFxIAFB8LuAgABqLQAARw0BAkAgAUEDRw0AQQYhAQyWAwsgAUEBaiEBIBRBAWoiFCACRw0ACyAAIBU2AgAMsQMLIABBADYCACAUIQEM2QELQTMhECABIhQgAkYNrwMgAiAUayAAKAIAIgFqIRUgFCABa0EIaiEWAkADQCAULQAAIhdBIHIgFyAXQb9/akH/AXFBGkkbQf8BcSABQfS7gIAAai0AAEcNAQJAIAFBCEcNAEEFIQEMlQMLIAFBAWohASAUQQFqIhQgAkcNAAsgACAVNgIADLADCyAAQQA2AgAgFCEBDNgBC0E0IRAgASIUIAJGDa4DIAIgFGsgACgCACIBaiEVIBQgAWtBBWohFgJAA0AgFC0AACIXQSByIBcgF0G/f2pB/wFxQRpJG0H/AXEgAUHQwoCAAGotAABHDQECQCABQQVHDQBBByEBDJQDCyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFTYCAAyvAwsgAEEANgIAIBQhAQzXAQsCQCABIgEgAkYNAANAAkAgAS0AAEGAvoCAAGotAAAiEEEBRg0AIBBBAkYNCiABIQEM3QELIAFBAWoiASACRw0AC0EwIRAMrgMLQTAhEAytAwsCQCABIgEgAkYNAANAAkAgAS0AACIQQSBGDQAgEEF2ag4E2QHaAdoB2QHaAQsgAUEBaiIBIAJHDQALQTghEAytAwtBOCEQDKwDCwNAAkAgAS0AACIQQSBGDQAgEEEJRw0DCyABQQFqIgEgAkcNAAtBPCEQDKsDCwNAAkAgAS0AACIQQSBGDQACQAJAIBBBdmoOBNoBAQHaAQALIBBBLEYN2wELIAEhAQwECyABQQFqIgEgAkcNAAtBPyEQDKoDCyABIQEM2wELQcAAIRAgASIUIAJGDagDIAIgFGsgACgCACIBaiEWIBQgAWtBBmohFwJAA0AgFC0AAEEgciABQYDAgIAAai0AAEcNASABQQZGDY4DIAFBAWohASAUQQFqIhQgAkcNAAsgACAWNgIADKkDCyAAQQA2AgAgFCEBC0E2IRAMjgMLAkAgASIPIAJHDQBBwQAhEAynAwsgAEGMgICAADYCCCAAIA82AgQgDyEBIAAtACxBf2oOBM0B1QHXAdkBhwMLIAFBAWohAQzMAQsCQCABIgEgAkYNAANAAkAgAS0AACIQQSByIBAgEEG/f2pB/wFxQRpJG0H/AXEiEEEJRg0AIBBBIEYNAAJAAkACQAJAIBBBnX9qDhMAAwMDAwMDAwEDAwMDAwMDAwMCAwsgAUEBaiEBQTEhEAyRAwsgAUEBaiEBQTIhEAyQAwsgAUEBaiEBQTMhEAyPAwsgASEBDNABCyABQQFqIgEgAkcNAAtBNSEQDKUDC0E1IRAMpAMLAkAgASIBIAJGDQADQAJAIAEtAABBgLyAgABqLQAAQQFGDQAgASEBDNMBCyABQQFqIgEgAkcNAAtBPSEQDKQDC0E9IRAMowMLIAAgASIBIAIQsICAgAAiEA3WASABIQEMAQsgEEEBaiEBC0E8IRAMhwMLAkAgASIBIAJHDQBBwgAhEAygAwsCQANAAkAgAS0AAEF3ag4YAAL+Av4ChAP+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gIA/gILIAFBAWoiASACRw0AC0HCACEQDKADCyABQQFqIQEgAC0ALUEBcUUNvQEgASEBC0EsIRAMhQMLIAEiASACRw3TAUHEACEQDJ0DCwNAAkAgAS0AAEGQwICAAGotAABBAUYNACABIQEMtwILIAFBAWoiASACRw0AC0HFACEQDJwDCyANLQAAIhBBIEYNswEgEEE6Rw2BAyAAKAIEIQEgAEEANgIEIAAgASANEK+AgIAAIgEN0AEgDUEBaiEBDLMCC0HHACEQIAEiDSACRg2aAyACIA1rIAAoAgAiAWohFiANIAFrQQVqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQZDCgIAAai0AAEcNgAMgAUEFRg30AiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyaAwtByAAhECABIg0gAkYNmQMgAiANayAAKAIAIgFqIRYgDSABa0EJaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGWwoCAAGotAABHDf8CAkAgAUEJRw0AQQIhAQz1AgsgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMmQMLAkAgASINIAJHDQBByQAhEAyZAwsCQAJAIA0tAAAiAUEgciABIAFBv39qQf8BcUEaSRtB/wFxQZJ/ag4HAIADgAOAA4ADgAMBgAMLIA1BAWohAUE+IRAMgAMLIA1BAWohAUE/IRAM/wILQcoAIRAgASINIAJGDZcDIAIgDWsgACgCACIBaiEWIA0gAWtBAWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBoMKAgABqLQAARw39AiABQQFGDfACIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJcDC0HLACEQIAEiDSACRg2WAyACIA1rIAAoAgAiAWohFiANIAFrQQ5qIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQaLCgIAAai0AAEcN/AIgAUEORg3wAiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyWAwtBzAAhECABIg0gAkYNlQMgAiANayAAKAIAIgFqIRYgDSABa0EPaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUHAwoCAAGotAABHDfsCAkAgAUEPRw0AQQMhAQzxAgsgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMlQMLQc0AIRAgASINIAJGDZQDIAIgDWsgACgCACIBaiEWIA0gAWtBBWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFB0MKAgABqLQAARw36AgJAIAFBBUcNAEEEIQEM8AILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJQDCwJAIAEiDSACRw0AQc4AIRAMlAMLAkACQAJAAkAgDS0AACIBQSByIAEgAUG/f2pB/wFxQRpJG0H/AXFBnX9qDhMA/QL9Av0C/QL9Av0C/QL9Av0C/QL9Av0CAf0C/QL9AgID/QILIA1BAWohAUHBACEQDP0CCyANQQFqIQFBwgAhEAz8AgsgDUEBaiEBQcMAIRAM+wILIA1BAWohAUHEACEQDPoCCwJAIAEiASACRg0AIABBjYCAgAA2AgggACABNgIEIAEhAUHFACEQDPoCC0HPACEQDJIDCyAQIQECQAJAIBAtAABBdmoOBAGoAqgCAKgCCyAQQQFqIQELQSchEAz4AgsCQCABIgEgAkcNAEHRACEQDJEDCwJAIAEtAABBIEYNACABIQEMjQELIAFBAWohASAALQAtQQFxRQ3HASABIQEMjAELIAEiFyACRw3IAUHSACEQDI8DC0HTACEQIAEiFCACRg2OAyACIBRrIAAoAgAiAWohFiAUIAFrQQFqIRcDQCAULQAAIAFB1sKAgABqLQAARw3MASABQQFGDccBIAFBAWohASAUQQFqIhQgAkcNAAsgACAWNgIADI4DCwJAIAEiASACRw0AQdUAIRAMjgMLIAEtAABBCkcNzAEgAUEBaiEBDMcBCwJAIAEiASACRw0AQdYAIRAMjQMLAkACQCABLQAAQXZqDgQAzQHNAQHNAQsgAUEBaiEBDMcBCyABQQFqIQFBygAhEAzzAgsgACABIgEgAhCugICAACIQDcsBIAEhAUHNACEQDPICCyAALQApQSJGDYUDDKYCCwJAIAEiASACRw0AQdsAIRAMigMLQQAhFEEBIRdBASEWQQAhEAJAAkACQAJAAkACQAJAAkACQCABLQAAQVBqDgrUAdMBAAECAwQFBgjVAQtBAiEQDAYLQQMhEAwFC0EEIRAMBAtBBSEQDAMLQQYhEAwCC0EHIRAMAQtBCCEQC0EAIRdBACEWQQAhFAzMAQtBCSEQQQEhFEEAIRdBACEWDMsBCwJAIAEiASACRw0AQd0AIRAMiQMLIAEtAABBLkcNzAEgAUEBaiEBDKYCCyABIgEgAkcNzAFB3wAhEAyHAwsCQCABIgEgAkYNACAAQY6AgIAANgIIIAAgATYCBCABIQFB0AAhEAzuAgtB4AAhEAyGAwtB4QAhECABIgEgAkYNhQMgAiABayAAKAIAIhRqIRYgASAUa0EDaiEXA0AgAS0AACAUQeLCgIAAai0AAEcNzQEgFEEDRg3MASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyFAwtB4gAhECABIgEgAkYNhAMgAiABayAAKAIAIhRqIRYgASAUa0ECaiEXA0AgAS0AACAUQebCgIAAai0AAEcNzAEgFEECRg3OASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyEAwtB4wAhECABIgEgAkYNgwMgAiABayAAKAIAIhRqIRYgASAUa0EDaiEXA0AgAS0AACAUQenCgIAAai0AAEcNywEgFEEDRg3OASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyDAwsCQCABIgEgAkcNAEHlACEQDIMDCyAAIAFBAWoiASACEKiAgIAAIhANzQEgASEBQdYAIRAM6QILAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgRg0AAkACQAJAIBBBuH9qDgsAAc8BzwHPAc8BzwHPAc8BzwECzwELIAFBAWohAUHSACEQDO0CCyABQQFqIQFB0wAhEAzsAgsgAUEBaiEBQdQAIRAM6wILIAFBAWoiASACRw0AC0HkACEQDIIDC0HkACEQDIEDCwNAAkAgAS0AAEHwwoCAAGotAAAiEEEBRg0AIBBBfmoOA88B0AHRAdIBCyABQQFqIgEgAkcNAAtB5gAhEAyAAwsCQCABIgEgAkYNACABQQFqIQEMAwtB5wAhEAz/AgsDQAJAIAEtAABB8MSAgABqLQAAIhBBAUYNAAJAIBBBfmoOBNIB0wHUAQDVAQsgASEBQdcAIRAM5wILIAFBAWoiASACRw0AC0HoACEQDP4CCwJAIAEiASACRw0AQekAIRAM/gILAkAgAS0AACIQQXZqDhq6AdUB1QG8AdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAcoB1QHVAQDTAQsgAUEBaiEBC0EGIRAM4wILA0ACQCABLQAAQfDGgIAAai0AAEEBRg0AIAEhAQyeAgsgAUEBaiIBIAJHDQALQeoAIRAM+wILAkAgASIBIAJGDQAgAUEBaiEBDAMLQesAIRAM+gILAkAgASIBIAJHDQBB7AAhEAz6AgsgAUEBaiEBDAELAkAgASIBIAJHDQBB7QAhEAz5AgsgAUEBaiEBC0EEIRAM3gILAkAgASIUIAJHDQBB7gAhEAz3AgsgFCEBAkACQAJAIBQtAABB8MiAgABqLQAAQX9qDgfUAdUB1gEAnAIBAtcBCyAUQQFqIQEMCgsgFEEBaiEBDM0BC0EAIRAgAEEANgIcIABBm5KAgAA2AhAgAEEHNgIMIAAgFEEBajYCFAz2AgsCQANAAkAgAS0AAEHwyICAAGotAAAiEEEERg0AAkACQCAQQX9qDgfSAdMB1AHZAQAEAdkBCyABIQFB2gAhEAzgAgsgAUEBaiEBQdwAIRAM3wILIAFBAWoiASACRw0AC0HvACEQDPYCCyABQQFqIQEMywELAkAgASIUIAJHDQBB8AAhEAz1AgsgFC0AAEEvRw3UASAUQQFqIQEMBgsCQCABIhQgAkcNAEHxACEQDPQCCwJAIBQtAAAiAUEvRw0AIBRBAWohAUHdACEQDNsCCyABQXZqIgRBFksN0wFBASAEdEGJgIACcUUN0wEMygILAkAgASIBIAJGDQAgAUEBaiEBQd4AIRAM2gILQfIAIRAM8gILAkAgASIUIAJHDQBB9AAhEAzyAgsgFCEBAkAgFC0AAEHwzICAAGotAABBf2oOA8kClAIA1AELQeEAIRAM2AILAkAgASIUIAJGDQADQAJAIBQtAABB8MqAgABqLQAAIgFBA0YNAAJAIAFBf2oOAssCANUBCyAUIQFB3wAhEAzaAgsgFEEBaiIUIAJHDQALQfMAIRAM8QILQfMAIRAM8AILAkAgASIBIAJGDQAgAEGPgICAADYCCCAAIAE2AgQgASEBQeAAIRAM1wILQfUAIRAM7wILAkAgASIBIAJHDQBB9gAhEAzvAgsgAEGPgICAADYCCCAAIAE2AgQgASEBC0EDIRAM1AILA0AgAS0AAEEgRw3DAiABQQFqIgEgAkcNAAtB9wAhEAzsAgsCQCABIgEgAkcNAEH4ACEQDOwCCyABLQAAQSBHDc4BIAFBAWohAQzvAQsgACABIgEgAhCsgICAACIQDc4BIAEhAQyOAgsCQCABIgQgAkcNAEH6ACEQDOoCCyAELQAAQcwARw3RASAEQQFqIQFBEyEQDM8BCwJAIAEiBCACRw0AQfsAIRAM6QILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEANAIAQtAAAgAUHwzoCAAGotAABHDdABIAFBBUYNzgEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBB+wAhEAzoAgsCQCABIgQgAkcNAEH8ACEQDOgCCwJAAkAgBC0AAEG9f2oODADRAdEB0QHRAdEB0QHRAdEB0QHRAQHRAQsgBEEBaiEBQeYAIRAMzwILIARBAWohAUHnACEQDM4CCwJAIAEiBCACRw0AQf0AIRAM5wILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNzwEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf0AIRAM5wILIABBADYCACAQQQFqIQFBECEQDMwBCwJAIAEiBCACRw0AQf4AIRAM5gILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQfbOgIAAai0AAEcNzgEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf4AIRAM5gILIABBADYCACAQQQFqIQFBFiEQDMsBCwJAIAEiBCACRw0AQf8AIRAM5QILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQfzOgIAAai0AAEcNzQEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf8AIRAM5QILIABBADYCACAQQQFqIQFBBSEQDMoBCwJAIAEiBCACRw0AQYABIRAM5AILIAQtAABB2QBHDcsBIARBAWohAUEIIRAMyQELAkAgASIEIAJHDQBBgQEhEAzjAgsCQAJAIAQtAABBsn9qDgMAzAEBzAELIARBAWohAUHrACEQDMoCCyAEQQFqIQFB7AAhEAzJAgsCQCABIgQgAkcNAEGCASEQDOICCwJAAkAgBC0AAEG4f2oOCADLAcsBywHLAcsBywEBywELIARBAWohAUHqACEQDMkCCyAEQQFqIQFB7QAhEAzIAgsCQCABIgQgAkcNAEGDASEQDOECCyACIARrIAAoAgAiAWohECAEIAFrQQJqIRQCQANAIAQtAAAgAUGAz4CAAGotAABHDckBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgEDYCAEGDASEQDOECC0EAIRAgAEEANgIAIBRBAWohAQzGAQsCQCABIgQgAkcNAEGEASEQDOACCyACIARrIAAoAgAiAWohFCAEIAFrQQRqIRACQANAIAQtAAAgAUGDz4CAAGotAABHDcgBIAFBBEYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGEASEQDOACCyAAQQA2AgAgEEEBaiEBQSMhEAzFAQsCQCABIgQgAkcNAEGFASEQDN8CCwJAAkAgBC0AAEG0f2oOCADIAcgByAHIAcgByAEByAELIARBAWohAUHvACEQDMYCCyAEQQFqIQFB8AAhEAzFAgsCQCABIgQgAkcNAEGGASEQDN4CCyAELQAAQcUARw3FASAEQQFqIQEMgwILAkAgASIEIAJHDQBBhwEhEAzdAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFBiM+AgABqLQAARw3FASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBhwEhEAzdAgsgAEEANgIAIBBBAWohAUEtIRAMwgELAkAgASIEIAJHDQBBiAEhEAzcAgsgAiAEayAAKAIAIgFqIRQgBCABa0EIaiEQAkADQCAELQAAIAFB0M+AgABqLQAARw3EASABQQhGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBiAEhEAzcAgsgAEEANgIAIBBBAWohAUEpIRAMwQELAkAgASIBIAJHDQBBiQEhEAzbAgtBASEQIAEtAABB3wBHDcABIAFBAWohAQyBAgsCQCABIgQgAkcNAEGKASEQDNoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRADQCAELQAAIAFBjM+AgABqLQAARw3BASABQQFGDa8CIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYoBIRAM2QILAkAgASIEIAJHDQBBiwEhEAzZAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBjs+AgABqLQAARw3BASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBiwEhEAzZAgsgAEEANgIAIBBBAWohAUECIRAMvgELAkAgASIEIAJHDQBBjAEhEAzYAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8M+AgABqLQAARw3AASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBjAEhEAzYAgsgAEEANgIAIBBBAWohAUEfIRAMvQELAkAgASIEIAJHDQBBjQEhEAzXAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8s+AgABqLQAARw2/ASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBjQEhEAzXAgsgAEEANgIAIBBBAWohAUEJIRAMvAELAkAgASIEIAJHDQBBjgEhEAzWAgsCQAJAIAQtAABBt39qDgcAvwG/Ab8BvwG/AQG/AQsgBEEBaiEBQfgAIRAMvQILIARBAWohAUH5ACEQDLwCCwJAIAEiBCACRw0AQY8BIRAM1QILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQZHPgIAAai0AAEcNvQEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQY8BIRAM1QILIABBADYCACAQQQFqIQFBGCEQDLoBCwJAIAEiBCACRw0AQZABIRAM1AILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQZfPgIAAai0AAEcNvAEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZABIRAM1AILIABBADYCACAQQQFqIQFBFyEQDLkBCwJAIAEiBCACRw0AQZEBIRAM0wILIAIgBGsgACgCACIBaiEUIAQgAWtBBmohEAJAA0AgBC0AACABQZrPgIAAai0AAEcNuwEgAUEGRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZEBIRAM0wILIABBADYCACAQQQFqIQFBFSEQDLgBCwJAIAEiBCACRw0AQZIBIRAM0gILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQaHPgIAAai0AAEcNugEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZIBIRAM0gILIABBADYCACAQQQFqIQFBHiEQDLcBCwJAIAEiBCACRw0AQZMBIRAM0QILIAQtAABBzABHDbgBIARBAWohAUEKIRAMtgELAkAgBCACRw0AQZQBIRAM0AILAkACQCAELQAAQb9/ag4PALkBuQG5AbkBuQG5AbkBuQG5AbkBuQG5AbkBAbkBCyAEQQFqIQFB/gAhEAy3AgsgBEEBaiEBQf8AIRAMtgILAkAgBCACRw0AQZUBIRAMzwILAkACQCAELQAAQb9/ag4DALgBAbgBCyAEQQFqIQFB/QAhEAy2AgsgBEEBaiEEQYABIRAMtQILAkAgBCACRw0AQZYBIRAMzgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQafPgIAAai0AAEcNtgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZYBIRAMzgILIABBADYCACAQQQFqIQFBCyEQDLMBCwJAIAQgAkcNAEGXASEQDM0CCwJAAkACQAJAIAQtAABBU2oOIwC4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBAbgBuAG4AbgBuAECuAG4AbgBA7gBCyAEQQFqIQFB+wAhEAy2AgsgBEEBaiEBQfwAIRAMtQILIARBAWohBEGBASEQDLQCCyAEQQFqIQRBggEhEAyzAgsCQCAEIAJHDQBBmAEhEAzMAgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBqc+AgABqLQAARw20ASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmAEhEAzMAgsgAEEANgIAIBBBAWohAUEZIRAMsQELAkAgBCACRw0AQZkBIRAMywILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQa7PgIAAai0AAEcNswEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZkBIRAMywILIABBADYCACAQQQFqIQFBBiEQDLABCwJAIAQgAkcNAEGaASEQDMoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUG0z4CAAGotAABHDbIBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGaASEQDMoCCyAAQQA2AgAgEEEBaiEBQRwhEAyvAQsCQCAEIAJHDQBBmwEhEAzJAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBts+AgABqLQAARw2xASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmwEhEAzJAgsgAEEANgIAIBBBAWohAUEnIRAMrgELAkAgBCACRw0AQZwBIRAMyAILAkACQCAELQAAQax/ag4CAAGxAQsgBEEBaiEEQYYBIRAMrwILIARBAWohBEGHASEQDK4CCwJAIAQgAkcNAEGdASEQDMcCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUG4z4CAAGotAABHDa8BIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGdASEQDMcCCyAAQQA2AgAgEEEBaiEBQSYhEAysAQsCQCAEIAJHDQBBngEhEAzGAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBus+AgABqLQAARw2uASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBngEhEAzGAgsgAEEANgIAIBBBAWohAUEDIRAMqwELAkAgBCACRw0AQZ8BIRAMxQILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNrQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZ8BIRAMxQILIABBADYCACAQQQFqIQFBDCEQDKoBCwJAIAQgAkcNAEGgASEQDMQCCyACIARrIAAoAgAiAWohFCAEIAFrQQNqIRACQANAIAQtAAAgAUG8z4CAAGotAABHDawBIAFBA0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGgASEQDMQCCyAAQQA2AgAgEEEBaiEBQQ0hEAypAQsCQCAEIAJHDQBBoQEhEAzDAgsCQAJAIAQtAABBun9qDgsArAGsAawBrAGsAawBrAGsAawBAawBCyAEQQFqIQRBiwEhEAyqAgsgBEEBaiEEQYwBIRAMqQILAkAgBCACRw0AQaIBIRAMwgILIAQtAABB0ABHDakBIARBAWohBAzpAQsCQCAEIAJHDQBBowEhEAzBAgsCQAJAIAQtAABBt39qDgcBqgGqAaoBqgGqAQCqAQsgBEEBaiEEQY4BIRAMqAILIARBAWohAUEiIRAMpgELAkAgBCACRw0AQaQBIRAMwAILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQcDPgIAAai0AAEcNqAEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQaQBIRAMwAILIABBADYCACAQQQFqIQFBHSEQDKUBCwJAIAQgAkcNAEGlASEQDL8CCwJAAkAgBC0AAEGuf2oOAwCoAQGoAQsgBEEBaiEEQZABIRAMpgILIARBAWohAUEEIRAMpAELAkAgBCACRw0AQaYBIRAMvgILAkACQAJAAkACQCAELQAAQb9/ag4VAKoBqgGqAaoBqgGqAaoBqgGqAaoBAaoBqgECqgGqAQOqAaoBBKoBCyAEQQFqIQRBiAEhEAyoAgsgBEEBaiEEQYkBIRAMpwILIARBAWohBEGKASEQDKYCCyAEQQFqIQRBjwEhEAylAgsgBEEBaiEEQZEBIRAMpAILAkAgBCACRw0AQacBIRAMvQILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNpQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQacBIRAMvQILIABBADYCACAQQQFqIQFBESEQDKIBCwJAIAQgAkcNAEGoASEQDLwCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHCz4CAAGotAABHDaQBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGoASEQDLwCCyAAQQA2AgAgEEEBaiEBQSwhEAyhAQsCQCAEIAJHDQBBqQEhEAy7AgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBxc+AgABqLQAARw2jASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBqQEhEAy7AgsgAEEANgIAIBBBAWohAUErIRAMoAELAkAgBCACRw0AQaoBIRAMugILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQcrPgIAAai0AAEcNogEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQaoBIRAMugILIABBADYCACAQQQFqIQFBFCEQDJ8BCwJAIAQgAkcNAEGrASEQDLkCCwJAAkACQAJAIAQtAABBvn9qDg8AAQKkAaQBpAGkAaQBpAGkAaQBpAGkAaQBA6QBCyAEQQFqIQRBkwEhEAyiAgsgBEEBaiEEQZQBIRAMoQILIARBAWohBEGVASEQDKACCyAEQQFqIQRBlgEhEAyfAgsCQCAEIAJHDQBBrAEhEAy4AgsgBC0AAEHFAEcNnwEgBEEBaiEEDOABCwJAIAQgAkcNAEGtASEQDLcCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHNz4CAAGotAABHDZ8BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGtASEQDLcCCyAAQQA2AgAgEEEBaiEBQQ4hEAycAQsCQCAEIAJHDQBBrgEhEAy2AgsgBC0AAEHQAEcNnQEgBEEBaiEBQSUhEAybAQsCQCAEIAJHDQBBrwEhEAy1AgsgAiAEayAAKAIAIgFqIRQgBCABa0EIaiEQAkADQCAELQAAIAFB0M+AgABqLQAARw2dASABQQhGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBrwEhEAy1AgsgAEEANgIAIBBBAWohAUEqIRAMmgELAkAgBCACRw0AQbABIRAMtAILAkACQCAELQAAQat/ag4LAJ0BnQGdAZ0BnQGdAZ0BnQGdAQGdAQsgBEEBaiEEQZoBIRAMmwILIARBAWohBEGbASEQDJoCCwJAIAQgAkcNAEGxASEQDLMCCwJAAkAgBC0AAEG/f2oOFACcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAEBnAELIARBAWohBEGZASEQDJoCCyAEQQFqIQRBnAEhEAyZAgsCQCAEIAJHDQBBsgEhEAyyAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFB2c+AgABqLQAARw2aASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBsgEhEAyyAgsgAEEANgIAIBBBAWohAUEhIRAMlwELAkAgBCACRw0AQbMBIRAMsQILIAIgBGsgACgCACIBaiEUIAQgAWtBBmohEAJAA0AgBC0AACABQd3PgIAAai0AAEcNmQEgAUEGRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbMBIRAMsQILIABBADYCACAQQQFqIQFBGiEQDJYBCwJAIAQgAkcNAEG0ASEQDLACCwJAAkACQCAELQAAQbt/ag4RAJoBmgGaAZoBmgGaAZoBmgGaAQGaAZoBmgGaAZoBApoBCyAEQQFqIQRBnQEhEAyYAgsgBEEBaiEEQZ4BIRAMlwILIARBAWohBEGfASEQDJYCCwJAIAQgAkcNAEG1ASEQDK8CCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUHkz4CAAGotAABHDZcBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG1ASEQDK8CCyAAQQA2AgAgEEEBaiEBQSghEAyUAQsCQCAEIAJHDQBBtgEhEAyuAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFB6s+AgABqLQAARw2WASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBtgEhEAyuAgsgAEEANgIAIBBBAWohAUEHIRAMkwELAkAgBCACRw0AQbcBIRAMrQILAkACQCAELQAAQbt/ag4OAJYBlgGWAZYBlgGWAZYBlgGWAZYBlgGWAQGWAQsgBEEBaiEEQaEBIRAMlAILIARBAWohBEGiASEQDJMCCwJAIAQgAkcNAEG4ASEQDKwCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDZQBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG4ASEQDKwCCyAAQQA2AgAgEEEBaiEBQRIhEAyRAQsCQCAEIAJHDQBBuQEhEAyrAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8M+AgABqLQAARw2TASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBuQEhEAyrAgsgAEEANgIAIBBBAWohAUEgIRAMkAELAkAgBCACRw0AQboBIRAMqgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfLPgIAAai0AAEcNkgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQboBIRAMqgILIABBADYCACAQQQFqIQFBDyEQDI8BCwJAIAQgAkcNAEG7ASEQDKkCCwJAAkAgBC0AAEG3f2oOBwCSAZIBkgGSAZIBAZIBCyAEQQFqIQRBpQEhEAyQAgsgBEEBaiEEQaYBIRAMjwILAkAgBCACRw0AQbwBIRAMqAILIAIgBGsgACgCACIBaiEUIAQgAWtBB2ohEAJAA0AgBC0AACABQfTPgIAAai0AAEcNkAEgAUEHRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbwBIRAMqAILIABBADYCACAQQQFqIQFBGyEQDI0BCwJAIAQgAkcNAEG9ASEQDKcCCwJAAkACQCAELQAAQb5/ag4SAJEBkQGRAZEBkQGRAZEBkQGRAQGRAZEBkQGRAZEBkQECkQELIARBAWohBEGkASEQDI8CCyAEQQFqIQRBpwEhEAyOAgsgBEEBaiEEQagBIRAMjQILAkAgBCACRw0AQb4BIRAMpgILIAQtAABBzgBHDY0BIARBAWohBAzPAQsCQCAEIAJHDQBBvwEhEAylAgsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAELQAAQb9/ag4VAAECA5wBBAUGnAGcAZwBBwgJCgucAQwNDg+cAQsgBEEBaiEBQegAIRAMmgILIARBAWohAUHpACEQDJkCCyAEQQFqIQFB7gAhEAyYAgsgBEEBaiEBQfIAIRAMlwILIARBAWohAUHzACEQDJYCCyAEQQFqIQFB9gAhEAyVAgsgBEEBaiEBQfcAIRAMlAILIARBAWohAUH6ACEQDJMCCyAEQQFqIQRBgwEhEAySAgsgBEEBaiEEQYQBIRAMkQILIARBAWohBEGFASEQDJACCyAEQQFqIQRBkgEhEAyPAgsgBEEBaiEEQZgBIRAMjgILIARBAWohBEGgASEQDI0CCyAEQQFqIQRBowEhEAyMAgsgBEEBaiEEQaoBIRAMiwILAkAgBCACRg0AIABBkICAgAA2AgggACAENgIEQasBIRAMiwILQcABIRAMowILIAAgBSACEKqAgIAAIgENiwEgBSEBDFwLAkAgBiACRg0AIAZBAWohBQyNAQtBwgEhEAyhAgsDQAJAIBAtAABBdmoOBIwBAACPAQALIBBBAWoiECACRw0AC0HDASEQDKACCwJAIAcgAkYNACAAQZGAgIAANgIIIAAgBzYCBCAHIQFBASEQDIcCC0HEASEQDJ8CCwJAIAcgAkcNAEHFASEQDJ8CCwJAAkAgBy0AAEF2ag4EAc4BzgEAzgELIAdBAWohBgyNAQsgB0EBaiEFDIkBCwJAIAcgAkcNAEHGASEQDJ4CCwJAAkAgBy0AAEF2ag4XAY8BjwEBjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BAI8BCyAHQQFqIQcLQbABIRAMhAILAkAgCCACRw0AQcgBIRAMnQILIAgtAABBIEcNjQEgAEEAOwEyIAhBAWohAUGzASEQDIMCCyABIRcCQANAIBciByACRg0BIActAABBUGpB/wFxIhBBCk8NzAECQCAALwEyIhRBmTNLDQAgACAUQQpsIhQ7ATIgEEH//wNzIBRB/v8DcUkNACAHQQFqIRcgACAUIBBqIhA7ATIgEEH//wNxQegHSQ0BCwtBACEQIABBADYCHCAAQcGJgIAANgIQIABBDTYCDCAAIAdBAWo2AhQMnAILQccBIRAMmwILIAAgCCACEK6AgIAAIhBFDcoBIBBBFUcNjAEgAEHIATYCHCAAIAg2AhQgAEHJl4CAADYCECAAQRU2AgxBACEQDJoCCwJAIAkgAkcNAEHMASEQDJoCC0EAIRRBASEXQQEhFkEAIRACQAJAAkACQAJAAkACQAJAAkAgCS0AAEFQag4KlgGVAQABAgMEBQYIlwELQQIhEAwGC0EDIRAMBQtBBCEQDAQLQQUhEAwDC0EGIRAMAgtBByEQDAELQQghEAtBACEXQQAhFkEAIRQMjgELQQkhEEEBIRRBACEXQQAhFgyNAQsCQCAKIAJHDQBBzgEhEAyZAgsgCi0AAEEuRw2OASAKQQFqIQkMygELIAsgAkcNjgFB0AEhEAyXAgsCQCALIAJGDQAgAEGOgICAADYCCCAAIAs2AgRBtwEhEAz+AQtB0QEhEAyWAgsCQCAEIAJHDQBB0gEhEAyWAgsgAiAEayAAKAIAIhBqIRQgBCAQa0EEaiELA0AgBC0AACAQQfzPgIAAai0AAEcNjgEgEEEERg3pASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHSASEQDJUCCyAAIAwgAhCsgICAACIBDY0BIAwhAQy4AQsCQCAEIAJHDQBB1AEhEAyUAgsgAiAEayAAKAIAIhBqIRQgBCAQa0EBaiEMA0AgBC0AACAQQYHQgIAAai0AAEcNjwEgEEEBRg2OASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHUASEQDJMCCwJAIAQgAkcNAEHWASEQDJMCCyACIARrIAAoAgAiEGohFCAEIBBrQQJqIQsDQCAELQAAIBBBg9CAgABqLQAARw2OASAQQQJGDZABIBBBAWohECAEQQFqIgQgAkcNAAsgACAUNgIAQdYBIRAMkgILAkAgBCACRw0AQdcBIRAMkgILAkACQCAELQAAQbt/ag4QAI8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwEBjwELIARBAWohBEG7ASEQDPkBCyAEQQFqIQRBvAEhEAz4AQsCQCAEIAJHDQBB2AEhEAyRAgsgBC0AAEHIAEcNjAEgBEEBaiEEDMQBCwJAIAQgAkYNACAAQZCAgIAANgIIIAAgBDYCBEG+ASEQDPcBC0HZASEQDI8CCwJAIAQgAkcNAEHaASEQDI8CCyAELQAAQcgARg3DASAAQQE6ACgMuQELIABBAjoALyAAIAQgAhCmgICAACIQDY0BQcIBIRAM9AELIAAtAChBf2oOArcBuQG4AQsDQAJAIAQtAABBdmoOBACOAY4BAI4BCyAEQQFqIgQgAkcNAAtB3QEhEAyLAgsgAEEAOgAvIAAtAC1BBHFFDYQCCyAAQQA6AC8gAEEBOgA0IAEhAQyMAQsgEEEVRg3aASAAQQA2AhwgACABNgIUIABBp46AgAA2AhAgAEESNgIMQQAhEAyIAgsCQCAAIBAgAhC0gICAACIEDQAgECEBDIECCwJAIARBFUcNACAAQQM2AhwgACAQNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAyIAgsgAEEANgIcIAAgEDYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAMhwILIBBBFUYN1gEgAEEANgIcIAAgATYCFCAAQdqNgIAANgIQIABBFDYCDEEAIRAMhgILIAAoAgQhFyAAQQA2AgQgECARp2oiFiEBIAAgFyAQIBYgFBsiEBC1gICAACIURQ2NASAAQQc2AhwgACAQNgIUIAAgFDYCDEEAIRAMhQILIAAgAC8BMEGAAXI7ATAgASEBC0EqIRAM6gELIBBBFUYN0QEgAEEANgIcIAAgATYCFCAAQYOMgIAANgIQIABBEzYCDEEAIRAMggILIBBBFUYNzwEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAMgQILIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDI0BCyAAQQw2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAMgAILIBBBFUYNzAEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAM/wELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDIwBCyAAQQ02AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM/gELIBBBFUYNyQEgAEEANgIcIAAgATYCFCAAQcaMgIAANgIQIABBIzYCDEEAIRAM/QELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC5gICAACIQDQAgAUEBaiEBDIsBCyAAQQ42AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM/AELIABBADYCHCAAIAE2AhQgAEHAlYCAADYCECAAQQI2AgxBACEQDPsBCyAQQRVGDcUBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDPoBCyAAQRA2AhwgACABNgIUIAAgEDYCDEEAIRAM+QELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC5gICAACIEDQAgAUEBaiEBDPEBCyAAQRE2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM+AELIBBBFUYNwQEgAEEANgIcIAAgATYCFCAAQcaMgIAANgIQIABBIzYCDEEAIRAM9wELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC5gICAACIQDQAgAUEBaiEBDIgBCyAAQRM2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM9gELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC5gICAACIEDQAgAUEBaiEBDO0BCyAAQRQ2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM9QELIBBBFUYNvQEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAM9AELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDIYBCyAAQRY2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM8wELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC3gICAACIEDQAgAUEBaiEBDOkBCyAAQRc2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM8gELIABBADYCHCAAIAE2AhQgAEHNk4CAADYCECAAQQw2AgxBACEQDPEBC0IBIRELIBBBAWohAQJAIAApAyAiEkL//////////w9WDQAgACASQgSGIBGENwMgIAEhAQyEAQsgAEEANgIcIAAgATYCFCAAQa2JgIAANgIQIABBDDYCDEEAIRAM7wELIABBADYCHCAAIBA2AhQgAEHNk4CAADYCECAAQQw2AgxBACEQDO4BCyAAKAIEIRcgAEEANgIEIBAgEadqIhYhASAAIBcgECAWIBQbIhAQtYCAgAAiFEUNcyAAQQU2AhwgACAQNgIUIAAgFDYCDEEAIRAM7QELIABBADYCHCAAIBA2AhQgAEGqnICAADYCECAAQQ82AgxBACEQDOwBCyAAIBAgAhC0gICAACIBDQEgECEBC0EOIRAM0QELAkAgAUEVRw0AIABBAjYCHCAAIBA2AhQgAEGwmICAADYCECAAQRU2AgxBACEQDOoBCyAAQQA2AhwgACAQNgIUIABBp46AgAA2AhAgAEESNgIMQQAhEAzpAQsgAUEBaiEQAkAgAC8BMCIBQYABcUUNAAJAIAAgECACELuAgIAAIgENACAQIQEMcAsgAUEVRw26ASAAQQU2AhwgACAQNgIUIABB+ZeAgAA2AhAgAEEVNgIMQQAhEAzpAQsCQCABQaAEcUGgBEcNACAALQAtQQJxDQAgAEEANgIcIAAgEDYCFCAAQZaTgIAANgIQIABBBDYCDEEAIRAM6QELIAAgECACEL2AgIAAGiAQIQECQAJAAkACQAJAIAAgECACELOAgIAADhYCAQAEBAQEBAQEBAQEBAQEBAQEBAQDBAsgAEEBOgAuCyAAIAAvATBBwAByOwEwIBAhAQtBJiEQDNEBCyAAQSM2AhwgACAQNgIUIABBpZaAgAA2AhAgAEEVNgIMQQAhEAzpAQsgAEEANgIcIAAgEDYCFCAAQdWLgIAANgIQIABBETYCDEEAIRAM6AELIAAtAC1BAXFFDQFBwwEhEAzOAQsCQCANIAJGDQADQAJAIA0tAABBIEYNACANIQEMxAELIA1BAWoiDSACRw0AC0ElIRAM5wELQSUhEAzmAQsgACgCBCEEIABBADYCBCAAIAQgDRCvgICAACIERQ2tASAAQSY2AhwgACAENgIMIAAgDUEBajYCFEEAIRAM5QELIBBBFUYNqwEgAEEANgIcIAAgATYCFCAAQf2NgIAANgIQIABBHTYCDEEAIRAM5AELIABBJzYCHCAAIAE2AhQgACAQNgIMQQAhEAzjAQsgECEBQQEhFAJAAkACQAJAAkACQAJAIAAtACxBfmoOBwYFBQMBAgAFCyAAIAAvATBBCHI7ATAMAwtBAiEUDAELQQQhFAsgAEEBOgAsIAAgAC8BMCAUcjsBMAsgECEBC0ErIRAMygELIABBADYCHCAAIBA2AhQgAEGrkoCAADYCECAAQQs2AgxBACEQDOIBCyAAQQA2AhwgACABNgIUIABB4Y+AgAA2AhAgAEEKNgIMQQAhEAzhAQsgAEEAOgAsIBAhAQy9AQsgECEBQQEhFAJAAkACQAJAAkAgAC0ALEF7ag4EAwECAAULIAAgAC8BMEEIcjsBMAwDC0ECIRQMAQtBBCEUCyAAQQE6ACwgACAALwEwIBRyOwEwCyAQIQELQSkhEAzFAQsgAEEANgIcIAAgATYCFCAAQfCUgIAANgIQIABBAzYCDEEAIRAM3QELAkAgDi0AAEENRw0AIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDkEBaiEBDHULIABBLDYCHCAAIAE2AgwgACAOQQFqNgIUQQAhEAzdAQsgAC0ALUEBcUUNAUHEASEQDMMBCwJAIA4gAkcNAEEtIRAM3AELAkACQANAAkAgDi0AAEF2ag4EAgAAAwALIA5BAWoiDiACRw0AC0EtIRAM3QELIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDiEBDHQLIABBLDYCHCAAIA42AhQgACABNgIMQQAhEAzcAQsgACgCBCEBIABBADYCBAJAIAAgASAOELGAgIAAIgENACAOQQFqIQEMcwsgAEEsNgIcIAAgATYCDCAAIA5BAWo2AhRBACEQDNsBCyAAKAIEIQQgAEEANgIEIAAgBCAOELGAgIAAIgQNoAEgDiEBDM4BCyAQQSxHDQEgAUEBaiEQQQEhAQJAAkACQAJAAkAgAC0ALEF7ag4EAwECBAALIBAhAQwEC0ECIQEMAQtBBCEBCyAAQQE6ACwgACAALwEwIAFyOwEwIBAhAQwBCyAAIAAvATBBCHI7ATAgECEBC0E5IRAMvwELIABBADoALCABIQELQTQhEAy9AQsgACAALwEwQSByOwEwIAEhAQwCCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQsYCAgAAiBA0AIAEhAQzHAQsgAEE3NgIcIAAgATYCFCAAIAQ2AgxBACEQDNQBCyAAQQg6ACwgASEBC0EwIRAMuQELAkAgAC0AKEEBRg0AIAEhAQwECyAALQAtQQhxRQ2TASABIQEMAwsgAC0AMEEgcQ2UAUHFASEQDLcBCwJAIA8gAkYNAAJAA0ACQCAPLQAAQVBqIgFB/wFxQQpJDQAgDyEBQTUhEAy6AQsgACkDICIRQpmz5syZs+bMGVYNASAAIBFCCn4iETcDICARIAGtQv8BgyISQn+FVg0BIAAgESASfDcDICAPQQFqIg8gAkcNAAtBOSEQDNEBCyAAKAIEIQIgAEEANgIEIAAgAiAPQQFqIgQQsYCAgAAiAg2VASAEIQEMwwELQTkhEAzPAQsCQCAALwEwIgFBCHFFDQAgAC0AKEEBRw0AIAAtAC1BCHFFDZABCyAAIAFB9/sDcUGABHI7ATAgDyEBC0E3IRAMtAELIAAgAC8BMEEQcjsBMAyrAQsgEEEVRg2LASAAQQA2AhwgACABNgIUIABB8I6AgAA2AhAgAEEcNgIMQQAhEAzLAQsgAEHDADYCHCAAIAE2AgwgACANQQFqNgIUQQAhEAzKAQsCQCABLQAAQTpHDQAgACgCBCEQIABBADYCBAJAIAAgECABEK+AgIAAIhANACABQQFqIQEMYwsgAEHDADYCHCAAIBA2AgwgACABQQFqNgIUQQAhEAzKAQsgAEEANgIcIAAgATYCFCAAQbGRgIAANgIQIABBCjYCDEEAIRAMyQELIABBADYCHCAAIAE2AhQgAEGgmYCAADYCECAAQR42AgxBACEQDMgBCyAAQQA2AgALIABBgBI7ASogACAXQQFqIgEgAhCogICAACIQDQEgASEBC0HHACEQDKwBCyAQQRVHDYMBIABB0QA2AhwgACABNgIUIABB45eAgAA2AhAgAEEVNgIMQQAhEAzEAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMXgsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAzDAQsgAEEANgIcIAAgFDYCFCAAQcGogIAANgIQIABBBzYCDCAAQQA2AgBBACEQDMIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxdCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDMEBC0EAIRAgAEEANgIcIAAgATYCFCAAQYCRgIAANgIQIABBCTYCDAzAAQsgEEEVRg19IABBADYCHCAAIAE2AhQgAEGUjYCAADYCECAAQSE2AgxBACEQDL8BC0EBIRZBACEXQQAhFEEBIRALIAAgEDoAKyABQQFqIQECQAJAIAAtAC1BEHENAAJAAkACQCAALQAqDgMBAAIECyAWRQ0DDAILIBQNAQwCCyAXRQ0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQrYCAgAAiEA0AIAEhAQxcCyAAQdgANgIcIAAgATYCFCAAIBA2AgxBACEQDL4BCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQytAQsgAEHZADYCHCAAIAE2AhQgACAENgIMQQAhEAy9AQsgACgCBCEEIABBADYCBAJAIAAgBCABEK2AgIAAIgQNACABIQEMqwELIABB2gA2AhwgACABNgIUIAAgBDYCDEEAIRAMvAELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKkBCyAAQdwANgIcIAAgATYCFCAAIAQ2AgxBACEQDLsBCwJAIAEtAABBUGoiEEH/AXFBCk8NACAAIBA6ACogAUEBaiEBQc8AIRAMogELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKcBCyAAQd4ANgIcIAAgATYCFCAAIAQ2AgxBACEQDLoBCyAAQQA2AgAgF0EBaiEBAkAgAC0AKUEjTw0AIAEhAQxZCyAAQQA2AhwgACABNgIUIABB04mAgAA2AhAgAEEINgIMQQAhEAy5AQsgAEEANgIAC0EAIRAgAEEANgIcIAAgATYCFCAAQZCzgIAANgIQIABBCDYCDAy3AQsgAEEANgIAIBdBAWohAQJAIAAtAClBIUcNACABIQEMVgsgAEEANgIcIAAgATYCFCAAQZuKgIAANgIQIABBCDYCDEEAIRAMtgELIABBADYCACAXQQFqIQECQCAALQApIhBBXWpBC08NACABIQEMVQsCQCAQQQZLDQBBASAQdEHKAHFFDQAgASEBDFULQQAhECAAQQA2AhwgACABNgIUIABB94mAgAA2AhAgAEEINgIMDLUBCyAQQRVGDXEgAEEANgIcIAAgATYCFCAAQbmNgIAANgIQIABBGjYCDEEAIRAMtAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDFQLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMswELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDE0LIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMsgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDE0LIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMsQELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDFELIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMsAELIABBADYCHCAAIAE2AhQgAEHGioCAADYCECAAQQc2AgxBACEQDK8BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxJCyAAQdIANgIcIAAgATYCFCAAIBA2AgxBACEQDK4BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxJCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDK0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDKwBCyAAQQA2AhwgACABNgIUIABB3IiAgAA2AhAgAEEHNgIMQQAhEAyrAQsgEEE/Rw0BIAFBAWohAQtBBSEQDJABC0EAIRAgAEEANgIcIAAgATYCFCAAQf2SgIAANgIQIABBBzYCDAyoAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMQgsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAynAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMQgsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAymAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMRgsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAylAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMPwsgAEHSADYCHCAAIBQ2AhQgACABNgIMQQAhEAykAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMPwsgAEHTADYCHCAAIBQ2AhQgACABNgIMQQAhEAyjAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMQwsgAEHlADYCHCAAIBQ2AhQgACABNgIMQQAhEAyiAQsgAEEANgIcIAAgFDYCFCAAQcOPgIAANgIQIABBBzYCDEEAIRAMoQELIABBADYCHCAAIAE2AhQgAEHDj4CAADYCECAAQQc2AgxBACEQDKABC0EAIRAgAEEANgIcIAAgFDYCFCAAQYycgIAANgIQIABBBzYCDAyfAQsgAEEANgIcIAAgFDYCFCAAQYycgIAANgIQIABBBzYCDEEAIRAMngELIABBADYCHCAAIBQ2AhQgAEH+kYCAADYCECAAQQc2AgxBACEQDJ0BCyAAQQA2AhwgACABNgIUIABBjpuAgAA2AhAgAEEGNgIMQQAhEAycAQsgEEEVRg1XIABBADYCHCAAIAE2AhQgAEHMjoCAADYCECAAQSA2AgxBACEQDJsBCyAAQQA2AgAgEEEBaiEBQSQhEAsgACAQOgApIAAoAgQhECAAQQA2AgQgACAQIAEQq4CAgAAiEA1UIAEhAQw+CyAAQQA2AgALQQAhECAAQQA2AhwgACAENgIUIABB8ZuAgAA2AhAgAEEGNgIMDJcBCyABQRVGDVAgAEEANgIcIAAgBTYCFCAAQfCMgIAANgIQIABBGzYCDEEAIRAMlgELIAAoAgQhBSAAQQA2AgQgACAFIBAQqYCAgAAiBQ0BIBBBAWohBQtBrQEhEAx7CyAAQcEBNgIcIAAgBTYCDCAAIBBBAWo2AhRBACEQDJMBCyAAKAIEIQYgAEEANgIEIAAgBiAQEKmAgIAAIgYNASAQQQFqIQYLQa4BIRAMeAsgAEHCATYCHCAAIAY2AgwgACAQQQFqNgIUQQAhEAyQAQsgAEEANgIcIAAgBzYCFCAAQZeLgIAANgIQIABBDTYCDEEAIRAMjwELIABBADYCHCAAIAg2AhQgAEHjkICAADYCECAAQQk2AgxBACEQDI4BCyAAQQA2AhwgACAINgIUIABBlI2AgAA2AhAgAEEhNgIMQQAhEAyNAQtBASEWQQAhF0EAIRRBASEQCyAAIBA6ACsgCUEBaiEIAkACQCAALQAtQRBxDQACQAJAAkAgAC0AKg4DAQACBAsgFkUNAwwCCyAUDQEMAgsgF0UNAQsgACgCBCEQIABBADYCBCAAIBAgCBCtgICAACIQRQ09IABByQE2AhwgACAINgIUIAAgEDYCDEEAIRAMjAELIAAoAgQhBCAAQQA2AgQgACAEIAgQrYCAgAAiBEUNdiAAQcoBNgIcIAAgCDYCFCAAIAQ2AgxBACEQDIsBCyAAKAIEIQQgAEEANgIEIAAgBCAJEK2AgIAAIgRFDXQgAEHLATYCHCAAIAk2AhQgACAENgIMQQAhEAyKAQsgACgCBCEEIABBADYCBCAAIAQgChCtgICAACIERQ1yIABBzQE2AhwgACAKNgIUIAAgBDYCDEEAIRAMiQELAkAgCy0AAEFQaiIQQf8BcUEKTw0AIAAgEDoAKiALQQFqIQpBtgEhEAxwCyAAKAIEIQQgAEEANgIEIAAgBCALEK2AgIAAIgRFDXAgAEHPATYCHCAAIAs2AhQgACAENgIMQQAhEAyIAQsgAEEANgIcIAAgBDYCFCAAQZCzgIAANgIQIABBCDYCDCAAQQA2AgBBACEQDIcBCyABQRVGDT8gAEEANgIcIAAgDDYCFCAAQcyOgIAANgIQIABBIDYCDEEAIRAMhgELIABBgQQ7ASggACgCBCEQIABCADcDACAAIBAgDEEBaiIMEKuAgIAAIhBFDTggAEHTATYCHCAAIAw2AhQgACAQNgIMQQAhEAyFAQsgAEEANgIAC0EAIRAgAEEANgIcIAAgBDYCFCAAQdibgIAANgIQIABBCDYCDAyDAQsgACgCBCEQIABCADcDACAAIBAgC0EBaiILEKuAgIAAIhANAUHGASEQDGkLIABBAjoAKAxVCyAAQdUBNgIcIAAgCzYCFCAAIBA2AgxBACEQDIABCyAQQRVGDTcgAEEANgIcIAAgBDYCFCAAQaSMgIAANgIQIABBEDYCDEEAIRAMfwsgAC0ANEEBRw00IAAgBCACELyAgIAAIhBFDTQgEEEVRw01IABB3AE2AhwgACAENgIUIABB1ZaAgAA2AhAgAEEVNgIMQQAhEAx+C0EAIRAgAEEANgIcIABBr4uAgAA2AhAgAEECNgIMIAAgFEEBajYCFAx9C0EAIRAMYwtBAiEQDGILQQ0hEAxhC0EPIRAMYAtBJSEQDF8LQRMhEAxeC0EVIRAMXQtBFiEQDFwLQRchEAxbC0EYIRAMWgtBGSEQDFkLQRohEAxYC0EbIRAMVwtBHCEQDFYLQR0hEAxVC0EfIRAMVAtBISEQDFMLQSMhEAxSC0HGACEQDFELQS4hEAxQC0EvIRAMTwtBOyEQDE4LQT0hEAxNC0HIACEQDEwLQckAIRAMSwtBywAhEAxKC0HMACEQDEkLQc4AIRAMSAtB0QAhEAxHC0HVACEQDEYLQdgAIRAMRQtB2QAhEAxEC0HbACEQDEMLQeQAIRAMQgtB5QAhEAxBC0HxACEQDEALQfQAIRAMPwtBjQEhEAw+C0GXASEQDD0LQakBIRAMPAtBrAEhEAw7C0HAASEQDDoLQbkBIRAMOQtBrwEhEAw4C0GxASEQDDcLQbIBIRAMNgtBtAEhEAw1C0G1ASEQDDQLQboBIRAMMwtBvQEhEAwyC0G/ASEQDDELQcEBIRAMMAsgAEEANgIcIAAgBDYCFCAAQemLgIAANgIQIABBHzYCDEEAIRAMSAsgAEHbATYCHCAAIAQ2AhQgAEH6loCAADYCECAAQRU2AgxBACEQDEcLIABB+AA2AhwgACAMNgIUIABBypiAgAA2AhAgAEEVNgIMQQAhEAxGCyAAQdEANgIcIAAgBTYCFCAAQbCXgIAANgIQIABBFTYCDEEAIRAMRQsgAEH5ADYCHCAAIAE2AhQgACAQNgIMQQAhEAxECyAAQfgANgIcIAAgATYCFCAAQcqYgIAANgIQIABBFTYCDEEAIRAMQwsgAEHkADYCHCAAIAE2AhQgAEHjl4CAADYCECAAQRU2AgxBACEQDEILIABB1wA2AhwgACABNgIUIABByZeAgAA2AhAgAEEVNgIMQQAhEAxBCyAAQQA2AhwgACABNgIUIABBuY2AgAA2AhAgAEEaNgIMQQAhEAxACyAAQcIANgIcIAAgATYCFCAAQeOYgIAANgIQIABBFTYCDEEAIRAMPwsgAEEANgIEIAAgDyAPELGAgIAAIgRFDQEgAEE6NgIcIAAgBDYCDCAAIA9BAWo2AhRBACEQDD4LIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCxgICAACIERQ0AIABBOzYCHCAAIAQ2AgwgACABQQFqNgIUQQAhEAw+CyABQQFqIQEMLQsgD0EBaiEBDC0LIABBADYCHCAAIA82AhQgAEHkkoCAADYCECAAQQQ2AgxBACEQDDsLIABBNjYCHCAAIAQ2AhQgACACNgIMQQAhEAw6CyAAQS42AhwgACAONgIUIAAgBDYCDEEAIRAMOQsgAEHQADYCHCAAIAE2AhQgAEGRmICAADYCECAAQRU2AgxBACEQDDgLIA1BAWohAQwsCyAAQRU2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAw2CyAAQRs2AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAw1CyAAQQ82AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAw0CyAAQQs2AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAwzCyAAQRo2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAwyCyAAQQs2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAwxCyAAQQo2AhwgACABNgIUIABB5JaAgAA2AhAgAEEVNgIMQQAhEAwwCyAAQR42AhwgACABNgIUIABB+ZeAgAA2AhAgAEEVNgIMQQAhEAwvCyAAQQA2AhwgACAQNgIUIABB2o2AgAA2AhAgAEEUNgIMQQAhEAwuCyAAQQQ2AhwgACABNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAwtCyAAQQA2AgAgC0EBaiELC0G4ASEQDBILIABBADYCACAQQQFqIQFB9QAhEAwRCyABIQECQCAALQApQQVHDQBB4wAhEAwRC0HiACEQDBALQQAhECAAQQA2AhwgAEHkkYCAADYCECAAQQc2AgwgACAUQQFqNgIUDCgLIABBADYCACAXQQFqIQFBwAAhEAwOC0EBIQELIAAgAToALCAAQQA2AgAgF0EBaiEBC0EoIRAMCwsgASEBC0E4IRAMCQsCQCABIg8gAkYNAANAAkAgDy0AAEGAvoCAAGotAAAiAUEBRg0AIAFBAkcNAyAPQQFqIQEMBAsgD0EBaiIPIAJHDQALQT4hEAwiC0E+IRAMIQsgAEEAOgAsIA8hAQwBC0ELIRAMBgtBOiEQDAULIAFBAWohAUEtIRAMBAsgACABOgAsIABBADYCACAWQQFqIQFBDCEQDAMLIABBADYCACAXQQFqIQFBCiEQDAILIABBADYCAAsgAEEAOgAsIA0hAUEJIRAMAAsLQQAhECAAQQA2AhwgACALNgIUIABBzZCAgAA2AhAgAEEJNgIMDBcLQQAhECAAQQA2AhwgACAKNgIUIABB6YqAgAA2AhAgAEEJNgIMDBYLQQAhECAAQQA2AhwgACAJNgIUIABBt5CAgAA2AhAgAEEJNgIMDBULQQAhECAAQQA2AhwgACAINgIUIABBnJGAgAA2AhAgAEEJNgIMDBQLQQAhECAAQQA2AhwgACABNgIUIABBzZCAgAA2AhAgAEEJNgIMDBMLQQAhECAAQQA2AhwgACABNgIUIABB6YqAgAA2AhAgAEEJNgIMDBILQQAhECAAQQA2AhwgACABNgIUIABBt5CAgAA2AhAgAEEJNgIMDBELQQAhECAAQQA2AhwgACABNgIUIABBnJGAgAA2AhAgAEEJNgIMDBALQQAhECAAQQA2AhwgACABNgIUIABBl5WAgAA2AhAgAEEPNgIMDA8LQQAhECAAQQA2AhwgACABNgIUIABBl5WAgAA2AhAgAEEPNgIMDA4LQQAhECAAQQA2AhwgACABNgIUIABBwJKAgAA2AhAgAEELNgIMDA0LQQAhECAAQQA2AhwgACABNgIUIABBlYmAgAA2AhAgAEELNgIMDAwLQQAhECAAQQA2AhwgACABNgIUIABB4Y+AgAA2AhAgAEEKNgIMDAsLQQAhECAAQQA2AhwgACABNgIUIABB+4+AgAA2AhAgAEEKNgIMDAoLQQAhECAAQQA2AhwgACABNgIUIABB8ZmAgAA2AhAgAEECNgIMDAkLQQAhECAAQQA2AhwgACABNgIUIABBxJSAgAA2AhAgAEECNgIMDAgLQQAhECAAQQA2AhwgACABNgIUIABB8pWAgAA2AhAgAEECNgIMDAcLIABBAjYCHCAAIAE2AhQgAEGcmoCAADYCECAAQRY2AgxBACEQDAYLQQEhEAwFC0HUACEQIAEiBCACRg0EIANBCGogACAEIAJB2MKAgABBChDFgICAACADKAIMIQQgAygCCA4DAQQCAAsQyoCAgAAACyAAQQA2AhwgAEG1moCAADYCECAAQRc2AgwgACAEQQFqNgIUQQAhEAwCCyAAQQA2AhwgACAENgIUIABBypqAgAA2AhAgAEEJNgIMQQAhEAwBCwJAIAEiBCACRw0AQSIhEAwBCyAAQYmAgIAANgIIIAAgBDYCBEEhIRALIANBEGokgICAgAAgEAuvAQECfyABKAIAIQYCQAJAIAIgA0YNACAEIAZqIQQgBiADaiACayEHIAIgBkF/cyAFaiIGaiEFA0ACQCACLQAAIAQtAABGDQBBAiEEDAMLAkAgBg0AQQAhBCAFIQIMAwsgBkF/aiEGIARBAWohBCACQQFqIgIgA0cNAAsgByEGIAMhAgsgAEEBNgIAIAEgBjYCACAAIAI2AgQPCyABQQA2AgAgACAENgIAIAAgAjYCBAsKACAAEMeAgIAAC/I2AQt/I4CAgIAAQRBrIgEkgICAgAACQEEAKAKg0ICAAA0AQQAQy4CAgABBgNSEgABrIgJB2QBJDQBBACEDAkBBACgC4NOAgAAiBA0AQQBCfzcC7NOAgABBAEKAgISAgIDAADcC5NOAgABBACABQQhqQXBxQdiq1aoFcyIENgLg04CAAEEAQQA2AvTTgIAAQQBBADYCxNOAgAALQQAgAjYCzNOAgABBAEGA1ISAADYCyNOAgABBAEGA1ISAADYCmNCAgABBACAENgKs0ICAAEEAQX82AqjQgIAAA0AgA0HE0ICAAGogA0G40ICAAGoiBDYCACAEIANBsNCAgABqIgU2AgAgA0G80ICAAGogBTYCACADQczQgIAAaiADQcDQgIAAaiIFNgIAIAUgBDYCACADQdTQgIAAaiADQcjQgIAAaiIENgIAIAQgBTYCACADQdDQgIAAaiAENgIAIANBIGoiA0GAAkcNAAtBgNSEgABBeEGA1ISAAGtBD3FBAEGA1ISAAEEIakEPcRsiA2oiBEEEaiACQUhqIgUgA2siA0EBcjYCAEEAQQAoAvDTgIAANgKk0ICAAEEAIAM2ApTQgIAAQQAgBDYCoNCAgABBgNSEgAAgBWpBODYCBAsCQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEHsAUsNAAJAQQAoAojQgIAAIgZBECAAQRNqQXBxIABBC0kbIgJBA3YiBHYiA0EDcUUNAAJAAkAgA0EBcSAEckEBcyIFQQN0IgRBsNCAgABqIgMgBEG40ICAAGooAgAiBCgCCCICRw0AQQAgBkF+IAV3cTYCiNCAgAAMAQsgAyACNgIIIAIgAzYCDAsgBEEIaiEDIAQgBUEDdCIFQQNyNgIEIAQgBWoiBCAEKAIEQQFyNgIEDAwLIAJBACgCkNCAgAAiB00NAQJAIANFDQACQAJAIAMgBHRBAiAEdCIDQQAgA2tycSIDQQAgA2txQX9qIgMgA0EMdkEQcSIDdiIEQQV2QQhxIgUgA3IgBCAFdiIDQQJ2QQRxIgRyIAMgBHYiA0EBdkECcSIEciADIAR2IgNBAXZBAXEiBHIgAyAEdmoiBEEDdCIDQbDQgIAAaiIFIANBuNCAgABqKAIAIgMoAggiAEcNAEEAIAZBfiAEd3EiBjYCiNCAgAAMAQsgBSAANgIIIAAgBTYCDAsgAyACQQNyNgIEIAMgBEEDdCIEaiAEIAJrIgU2AgAgAyACaiIAIAVBAXI2AgQCQCAHRQ0AIAdBeHFBsNCAgABqIQJBACgCnNCAgAAhBAJAAkAgBkEBIAdBA3Z0IghxDQBBACAGIAhyNgKI0ICAACACIQgMAQsgAigCCCEICyAIIAQ2AgwgAiAENgIIIAQgAjYCDCAEIAg2AggLIANBCGohA0EAIAA2ApzQgIAAQQAgBTYCkNCAgAAMDAtBACgCjNCAgAAiCUUNASAJQQAgCWtxQX9qIgMgA0EMdkEQcSIDdiIEQQV2QQhxIgUgA3IgBCAFdiIDQQJ2QQRxIgRyIAMgBHYiA0EBdkECcSIEciADIAR2IgNBAXZBAXEiBHIgAyAEdmpBAnRBuNKAgABqKAIAIgAoAgRBeHEgAmshBCAAIQUCQANAAkAgBSgCECIDDQAgBUEUaigCACIDRQ0CCyADKAIEQXhxIAJrIgUgBCAFIARJIgUbIQQgAyAAIAUbIQAgAyEFDAALCyAAKAIYIQoCQCAAKAIMIgggAEYNACAAKAIIIgNBACgCmNCAgABJGiAIIAM2AgggAyAINgIMDAsLAkAgAEEUaiIFKAIAIgMNACAAKAIQIgNFDQMgAEEQaiEFCwNAIAUhCyADIghBFGoiBSgCACIDDQAgCEEQaiEFIAgoAhAiAw0ACyALQQA2AgAMCgtBfyECIABBv39LDQAgAEETaiIDQXBxIQJBACgCjNCAgAAiB0UNAEEAIQsCQCACQYACSQ0AQR8hCyACQf///wdLDQAgA0EIdiIDIANBgP4/akEQdkEIcSIDdCIEIARBgOAfakEQdkEEcSIEdCIFIAVBgIAPakEQdkECcSIFdEEPdiADIARyIAVyayIDQQF0IAIgA0EVanZBAXFyQRxqIQsLQQAgAmshBAJAAkACQAJAIAtBAnRBuNKAgABqKAIAIgUNAEEAIQNBACEIDAELQQAhAyACQQBBGSALQQF2ayALQR9GG3QhAEEAIQgDQAJAIAUoAgRBeHEgAmsiBiAETw0AIAYhBCAFIQggBg0AQQAhBCAFIQggBSEDDAMLIAMgBUEUaigCACIGIAYgBSAAQR12QQRxakEQaigCACIFRhsgAyAGGyEDIABBAXQhACAFDQALCwJAIAMgCHINAEEAIQhBAiALdCIDQQAgA2tyIAdxIgNFDQMgA0EAIANrcUF/aiIDIANBDHZBEHEiA3YiBUEFdkEIcSIAIANyIAUgAHYiA0ECdkEEcSIFciADIAV2IgNBAXZBAnEiBXIgAyAFdiIDQQF2QQFxIgVyIAMgBXZqQQJ0QbjSgIAAaigCACEDCyADRQ0BCwNAIAMoAgRBeHEgAmsiBiAESSEAAkAgAygCECIFDQAgA0EUaigCACEFCyAGIAQgABshBCADIAggABshCCAFIQMgBQ0ACwsgCEUNACAEQQAoApDQgIAAIAJrTw0AIAgoAhghCwJAIAgoAgwiACAIRg0AIAgoAggiA0EAKAKY0ICAAEkaIAAgAzYCCCADIAA2AgwMCQsCQCAIQRRqIgUoAgAiAw0AIAgoAhAiA0UNAyAIQRBqIQULA0AgBSEGIAMiAEEUaiIFKAIAIgMNACAAQRBqIQUgACgCECIDDQALIAZBADYCAAwICwJAQQAoApDQgIAAIgMgAkkNAEEAKAKc0ICAACEEAkACQCADIAJrIgVBEEkNACAEIAJqIgAgBUEBcjYCBEEAIAU2ApDQgIAAQQAgADYCnNCAgAAgBCADaiAFNgIAIAQgAkEDcjYCBAwBCyAEIANBA3I2AgQgBCADaiIDIAMoAgRBAXI2AgRBAEEANgKc0ICAAEEAQQA2ApDQgIAACyAEQQhqIQMMCgsCQEEAKAKU0ICAACIAIAJNDQBBACgCoNCAgAAiAyACaiIEIAAgAmsiBUEBcjYCBEEAIAU2ApTQgIAAQQAgBDYCoNCAgAAgAyACQQNyNgIEIANBCGohAwwKCwJAAkBBACgC4NOAgABFDQBBACgC6NOAgAAhBAwBC0EAQn83AuzTgIAAQQBCgICEgICAwAA3AuTTgIAAQQAgAUEMakFwcUHYqtWqBXM2AuDTgIAAQQBBADYC9NOAgABBAEEANgLE04CAAEGAgAQhBAtBACEDAkAgBCACQccAaiIHaiIGQQAgBGsiC3EiCCACSw0AQQBBMDYC+NOAgAAMCgsCQEEAKALA04CAACIDRQ0AAkBBACgCuNOAgAAiBCAIaiIFIARNDQAgBSADTQ0BC0EAIQNBAEEwNgL404CAAAwKC0EALQDE04CAAEEEcQ0EAkACQAJAQQAoAqDQgIAAIgRFDQBByNOAgAAhAwNAAkAgAygCACIFIARLDQAgBSADKAIEaiAESw0DCyADKAIIIgMNAAsLQQAQy4CAgAAiAEF/Rg0FIAghBgJAQQAoAuTTgIAAIgNBf2oiBCAAcUUNACAIIABrIAQgAGpBACADa3FqIQYLIAYgAk0NBSAGQf7///8HSw0FAkBBACgCwNOAgAAiA0UNAEEAKAK404CAACIEIAZqIgUgBE0NBiAFIANLDQYLIAYQy4CAgAAiAyAARw0BDAcLIAYgAGsgC3EiBkH+////B0sNBCAGEMuAgIAAIgAgAygCACADKAIEakYNAyAAIQMLAkAgA0F/Rg0AIAJByABqIAZNDQACQCAHIAZrQQAoAujTgIAAIgRqQQAgBGtxIgRB/v///wdNDQAgAyEADAcLAkAgBBDLgICAAEF/Rg0AIAQgBmohBiADIQAMBwtBACAGaxDLgICAABoMBAsgAyEAIANBf0cNBQwDC0EAIQgMBwtBACEADAULIABBf0cNAgtBAEEAKALE04CAAEEEcjYCxNOAgAALIAhB/v///wdLDQEgCBDLgICAACEAQQAQy4CAgAAhAyAAQX9GDQEgA0F/Rg0BIAAgA08NASADIABrIgYgAkE4ak0NAQtBAEEAKAK404CAACAGaiIDNgK404CAAAJAIANBACgCvNOAgABNDQBBACADNgK804CAAAsCQAJAAkACQEEAKAKg0ICAACIERQ0AQcjTgIAAIQMDQCAAIAMoAgAiBSADKAIEIghqRg0CIAMoAggiAw0ADAMLCwJAAkBBACgCmNCAgAAiA0UNACAAIANPDQELQQAgADYCmNCAgAALQQAhA0EAIAY2AszTgIAAQQAgADYCyNOAgABBAEF/NgKo0ICAAEEAQQAoAuDTgIAANgKs0ICAAEEAQQA2AtTTgIAAA0AgA0HE0ICAAGogA0G40ICAAGoiBDYCACAEIANBsNCAgABqIgU2AgAgA0G80ICAAGogBTYCACADQczQgIAAaiADQcDQgIAAaiIFNgIAIAUgBDYCACADQdTQgIAAaiADQcjQgIAAaiIENgIAIAQgBTYCACADQdDQgIAAaiAENgIAIANBIGoiA0GAAkcNAAsgAEF4IABrQQ9xQQAgAEEIakEPcRsiA2oiBCAGQUhqIgUgA2siA0EBcjYCBEEAQQAoAvDTgIAANgKk0ICAAEEAIAM2ApTQgIAAQQAgBDYCoNCAgAAgACAFakE4NgIEDAILIAMtAAxBCHENACAEIAVJDQAgBCAATw0AIARBeCAEa0EPcUEAIARBCGpBD3EbIgVqIgBBACgClNCAgAAgBmoiCyAFayIFQQFyNgIEIAMgCCAGajYCBEEAQQAoAvDTgIAANgKk0ICAAEEAIAU2ApTQgIAAQQAgADYCoNCAgAAgBCALakE4NgIEDAELAkAgAEEAKAKY0ICAACIITw0AQQAgADYCmNCAgAAgACEICyAAIAZqIQVByNOAgAAhAwJAAkACQAJAAkACQAJAA0AgAygCACAFRg0BIAMoAggiAw0ADAILCyADLQAMQQhxRQ0BC0HI04CAACEDA0ACQCADKAIAIgUgBEsNACAFIAMoAgRqIgUgBEsNAwsgAygCCCEDDAALCyADIAA2AgAgAyADKAIEIAZqNgIEIABBeCAAa0EPcUEAIABBCGpBD3EbaiILIAJBA3I2AgQgBUF4IAVrQQ9xQQAgBUEIakEPcRtqIgYgCyACaiICayEDAkAgBiAERw0AQQAgAjYCoNCAgABBAEEAKAKU0ICAACADaiIDNgKU0ICAACACIANBAXI2AgQMAwsCQCAGQQAoApzQgIAARw0AQQAgAjYCnNCAgABBAEEAKAKQ0ICAACADaiIDNgKQ0ICAACACIANBAXI2AgQgAiADaiADNgIADAMLAkAgBigCBCIEQQNxQQFHDQAgBEF4cSEHAkACQCAEQf8BSw0AIAYoAggiBSAEQQN2IghBA3RBsNCAgABqIgBGGgJAIAYoAgwiBCAFRw0AQQBBACgCiNCAgABBfiAId3E2AojQgIAADAILIAQgAEYaIAQgBTYCCCAFIAQ2AgwMAQsgBigCGCEJAkACQCAGKAIMIgAgBkYNACAGKAIIIgQgCEkaIAAgBDYCCCAEIAA2AgwMAQsCQCAGQRRqIgQoAgAiBQ0AIAZBEGoiBCgCACIFDQBBACEADAELA0AgBCEIIAUiAEEUaiIEKAIAIgUNACAAQRBqIQQgACgCECIFDQALIAhBADYCAAsgCUUNAAJAAkAgBiAGKAIcIgVBAnRBuNKAgABqIgQoAgBHDQAgBCAANgIAIAANAUEAQQAoAozQgIAAQX4gBXdxNgKM0ICAAAwCCyAJQRBBFCAJKAIQIAZGG2ogADYCACAARQ0BCyAAIAk2AhgCQCAGKAIQIgRFDQAgACAENgIQIAQgADYCGAsgBigCFCIERQ0AIABBFGogBDYCACAEIAA2AhgLIAcgA2ohAyAGIAdqIgYoAgQhBAsgBiAEQX5xNgIEIAIgA2ogAzYCACACIANBAXI2AgQCQCADQf8BSw0AIANBeHFBsNCAgABqIQQCQAJAQQAoAojQgIAAIgVBASADQQN2dCIDcQ0AQQAgBSADcjYCiNCAgAAgBCEDDAELIAQoAgghAwsgAyACNgIMIAQgAjYCCCACIAQ2AgwgAiADNgIIDAMLQR8hBAJAIANB////B0sNACADQQh2IgQgBEGA/j9qQRB2QQhxIgR0IgUgBUGA4B9qQRB2QQRxIgV0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAQgBXIgAHJrIgRBAXQgAyAEQRVqdkEBcXJBHGohBAsgAiAENgIcIAJCADcCECAEQQJ0QbjSgIAAaiEFAkBBACgCjNCAgAAiAEEBIAR0IghxDQAgBSACNgIAQQAgACAIcjYCjNCAgAAgAiAFNgIYIAIgAjYCCCACIAI2AgwMAwsgA0EAQRkgBEEBdmsgBEEfRht0IQQgBSgCACEAA0AgACIFKAIEQXhxIANGDQIgBEEddiEAIARBAXQhBCAFIABBBHFqQRBqIggoAgAiAA0ACyAIIAI2AgAgAiAFNgIYIAIgAjYCDCACIAI2AggMAgsgAEF4IABrQQ9xQQAgAEEIakEPcRsiA2oiCyAGQUhqIgggA2siA0EBcjYCBCAAIAhqQTg2AgQgBCAFQTcgBWtBD3FBACAFQUlqQQ9xG2pBQWoiCCAIIARBEGpJGyIIQSM2AgRBAEEAKALw04CAADYCpNCAgABBACADNgKU0ICAAEEAIAs2AqDQgIAAIAhBEGpBACkC0NOAgAA3AgAgCEEAKQLI04CAADcCCEEAIAhBCGo2AtDTgIAAQQAgBjYCzNOAgABBACAANgLI04CAAEEAQQA2AtTTgIAAIAhBJGohAwNAIANBBzYCACADQQRqIgMgBUkNAAsgCCAERg0DIAggCCgCBEF+cTYCBCAIIAggBGsiADYCACAEIABBAXI2AgQCQCAAQf8BSw0AIABBeHFBsNCAgABqIQMCQAJAQQAoAojQgIAAIgVBASAAQQN2dCIAcQ0AQQAgBSAAcjYCiNCAgAAgAyEFDAELIAMoAgghBQsgBSAENgIMIAMgBDYCCCAEIAM2AgwgBCAFNgIIDAQLQR8hAwJAIABB////B0sNACAAQQh2IgMgA0GA/j9qQRB2QQhxIgN0IgUgBUGA4B9qQRB2QQRxIgV0IgggCEGAgA9qQRB2QQJxIgh0QQ92IAMgBXIgCHJrIgNBAXQgACADQRVqdkEBcXJBHGohAwsgBCADNgIcIARCADcCECADQQJ0QbjSgIAAaiEFAkBBACgCjNCAgAAiCEEBIAN0IgZxDQAgBSAENgIAQQAgCCAGcjYCjNCAgAAgBCAFNgIYIAQgBDYCCCAEIAQ2AgwMBAsgAEEAQRkgA0EBdmsgA0EfRht0IQMgBSgCACEIA0AgCCIFKAIEQXhxIABGDQMgA0EddiEIIANBAXQhAyAFIAhBBHFqQRBqIgYoAgAiCA0ACyAGIAQ2AgAgBCAFNgIYIAQgBDYCDCAEIAQ2AggMAwsgBSgCCCIDIAI2AgwgBSACNgIIIAJBADYCGCACIAU2AgwgAiADNgIICyALQQhqIQMMBQsgBSgCCCIDIAQ2AgwgBSAENgIIIARBADYCGCAEIAU2AgwgBCADNgIIC0EAKAKU0ICAACIDIAJNDQBBACgCoNCAgAAiBCACaiIFIAMgAmsiA0EBcjYCBEEAIAM2ApTQgIAAQQAgBTYCoNCAgAAgBCACQQNyNgIEIARBCGohAwwDC0EAIQNBAEEwNgL404CAAAwCCwJAIAtFDQACQAJAIAggCCgCHCIFQQJ0QbjSgIAAaiIDKAIARw0AIAMgADYCACAADQFBACAHQX4gBXdxIgc2AozQgIAADAILIAtBEEEUIAsoAhAgCEYbaiAANgIAIABFDQELIAAgCzYCGAJAIAgoAhAiA0UNACAAIAM2AhAgAyAANgIYCyAIQRRqKAIAIgNFDQAgAEEUaiADNgIAIAMgADYCGAsCQAJAIARBD0sNACAIIAQgAmoiA0EDcjYCBCAIIANqIgMgAygCBEEBcjYCBAwBCyAIIAJqIgAgBEEBcjYCBCAIIAJBA3I2AgQgACAEaiAENgIAAkAgBEH/AUsNACAEQXhxQbDQgIAAaiEDAkACQEEAKAKI0ICAACIFQQEgBEEDdnQiBHENAEEAIAUgBHI2AojQgIAAIAMhBAwBCyADKAIIIQQLIAQgADYCDCADIAA2AgggACADNgIMIAAgBDYCCAwBC0EfIQMCQCAEQf///wdLDQAgBEEIdiIDIANBgP4/akEQdkEIcSIDdCIFIAVBgOAfakEQdkEEcSIFdCICIAJBgIAPakEQdkECcSICdEEPdiADIAVyIAJyayIDQQF0IAQgA0EVanZBAXFyQRxqIQMLIAAgAzYCHCAAQgA3AhAgA0ECdEG40oCAAGohBQJAIAdBASADdCICcQ0AIAUgADYCAEEAIAcgAnI2AozQgIAAIAAgBTYCGCAAIAA2AgggACAANgIMDAELIARBAEEZIANBAXZrIANBH0YbdCEDIAUoAgAhAgJAA0AgAiIFKAIEQXhxIARGDQEgA0EddiECIANBAXQhAyAFIAJBBHFqQRBqIgYoAgAiAg0ACyAGIAA2AgAgACAFNgIYIAAgADYCDCAAIAA2AggMAQsgBSgCCCIDIAA2AgwgBSAANgIIIABBADYCGCAAIAU2AgwgACADNgIICyAIQQhqIQMMAQsCQCAKRQ0AAkACQCAAIAAoAhwiBUECdEG40oCAAGoiAygCAEcNACADIAg2AgAgCA0BQQAgCUF+IAV3cTYCjNCAgAAMAgsgCkEQQRQgCigCECAARhtqIAg2AgAgCEUNAQsgCCAKNgIYAkAgACgCECIDRQ0AIAggAzYCECADIAg2AhgLIABBFGooAgAiA0UNACAIQRRqIAM2AgAgAyAINgIYCwJAAkAgBEEPSw0AIAAgBCACaiIDQQNyNgIEIAAgA2oiAyADKAIEQQFyNgIEDAELIAAgAmoiBSAEQQFyNgIEIAAgAkEDcjYCBCAFIARqIAQ2AgACQCAHRQ0AIAdBeHFBsNCAgABqIQJBACgCnNCAgAAhAwJAAkBBASAHQQN2dCIIIAZxDQBBACAIIAZyNgKI0ICAACACIQgMAQsgAigCCCEICyAIIAM2AgwgAiADNgIIIAMgAjYCDCADIAg2AggLQQAgBTYCnNCAgABBACAENgKQ0ICAAAsgAEEIaiEDCyABQRBqJICAgIAAIAMLCgAgABDJgICAAAviDQEHfwJAIABFDQAgAEF4aiIBIABBfGooAgAiAkF4cSIAaiEDAkAgAkEBcQ0AIAJBA3FFDQEgASABKAIAIgJrIgFBACgCmNCAgAAiBEkNASACIABqIQACQCABQQAoApzQgIAARg0AAkAgAkH/AUsNACABKAIIIgQgAkEDdiIFQQN0QbDQgIAAaiIGRhoCQCABKAIMIgIgBEcNAEEAQQAoAojQgIAAQX4gBXdxNgKI0ICAAAwDCyACIAZGGiACIAQ2AgggBCACNgIMDAILIAEoAhghBwJAAkAgASgCDCIGIAFGDQAgASgCCCICIARJGiAGIAI2AgggAiAGNgIMDAELAkAgAUEUaiICKAIAIgQNACABQRBqIgIoAgAiBA0AQQAhBgwBCwNAIAIhBSAEIgZBFGoiAigCACIEDQAgBkEQaiECIAYoAhAiBA0ACyAFQQA2AgALIAdFDQECQAJAIAEgASgCHCIEQQJ0QbjSgIAAaiICKAIARw0AIAIgBjYCACAGDQFBAEEAKAKM0ICAAEF+IAR3cTYCjNCAgAAMAwsgB0EQQRQgBygCECABRhtqIAY2AgAgBkUNAgsgBiAHNgIYAkAgASgCECICRQ0AIAYgAjYCECACIAY2AhgLIAEoAhQiAkUNASAGQRRqIAI2AgAgAiAGNgIYDAELIAMoAgQiAkEDcUEDRw0AIAMgAkF+cTYCBEEAIAA2ApDQgIAAIAEgAGogADYCACABIABBAXI2AgQPCyABIANPDQAgAygCBCICQQFxRQ0AAkACQCACQQJxDQACQCADQQAoAqDQgIAARw0AQQAgATYCoNCAgABBAEEAKAKU0ICAACAAaiIANgKU0ICAACABIABBAXI2AgQgAUEAKAKc0ICAAEcNA0EAQQA2ApDQgIAAQQBBADYCnNCAgAAPCwJAIANBACgCnNCAgABHDQBBACABNgKc0ICAAEEAQQAoApDQgIAAIABqIgA2ApDQgIAAIAEgAEEBcjYCBCABIABqIAA2AgAPCyACQXhxIABqIQACQAJAIAJB/wFLDQAgAygCCCIEIAJBA3YiBUEDdEGw0ICAAGoiBkYaAkAgAygCDCICIARHDQBBAEEAKAKI0ICAAEF+IAV3cTYCiNCAgAAMAgsgAiAGRhogAiAENgIIIAQgAjYCDAwBCyADKAIYIQcCQAJAIAMoAgwiBiADRg0AIAMoAggiAkEAKAKY0ICAAEkaIAYgAjYCCCACIAY2AgwMAQsCQCADQRRqIgIoAgAiBA0AIANBEGoiAigCACIEDQBBACEGDAELA0AgAiEFIAQiBkEUaiICKAIAIgQNACAGQRBqIQIgBigCECIEDQALIAVBADYCAAsgB0UNAAJAAkAgAyADKAIcIgRBAnRBuNKAgABqIgIoAgBHDQAgAiAGNgIAIAYNAUEAQQAoAozQgIAAQX4gBHdxNgKM0ICAAAwCCyAHQRBBFCAHKAIQIANGG2ogBjYCACAGRQ0BCyAGIAc2AhgCQCADKAIQIgJFDQAgBiACNgIQIAIgBjYCGAsgAygCFCICRQ0AIAZBFGogAjYCACACIAY2AhgLIAEgAGogADYCACABIABBAXI2AgQgAUEAKAKc0ICAAEcNAUEAIAA2ApDQgIAADwsgAyACQX5xNgIEIAEgAGogADYCACABIABBAXI2AgQLAkAgAEH/AUsNACAAQXhxQbDQgIAAaiECAkACQEEAKAKI0ICAACIEQQEgAEEDdnQiAHENAEEAIAQgAHI2AojQgIAAIAIhAAwBCyACKAIIIQALIAAgATYCDCACIAE2AgggASACNgIMIAEgADYCCA8LQR8hAgJAIABB////B0sNACAAQQh2IgIgAkGA/j9qQRB2QQhxIgJ0IgQgBEGA4B9qQRB2QQRxIgR0IgYgBkGAgA9qQRB2QQJxIgZ0QQ92IAIgBHIgBnJrIgJBAXQgACACQRVqdkEBcXJBHGohAgsgASACNgIcIAFCADcCECACQQJ0QbjSgIAAaiEEAkACQEEAKAKM0ICAACIGQQEgAnQiA3ENACAEIAE2AgBBACAGIANyNgKM0ICAACABIAQ2AhggASABNgIIIAEgATYCDAwBCyAAQQBBGSACQQF2ayACQR9GG3QhAiAEKAIAIQYCQANAIAYiBCgCBEF4cSAARg0BIAJBHXYhBiACQQF0IQIgBCAGQQRxakEQaiIDKAIAIgYNAAsgAyABNgIAIAEgBDYCGCABIAE2AgwgASABNgIIDAELIAQoAggiACABNgIMIAQgATYCCCABQQA2AhggASAENgIMIAEgADYCCAtBAEEAKAKo0ICAAEF/aiIBQX8gARs2AqjQgIAACwsEAAAAC04AAkAgAA0APwBBEHQPCwJAIABB//8DcQ0AIABBf0wNAAJAIABBEHZAACIAQX9HDQBBAEEwNgL404CAAEF/DwsgAEEQdA8LEMqAgIAAAAvyAgIDfwF+AkAgAkUNACAAIAE6AAAgAiAAaiIDQX9qIAE6AAAgAkEDSQ0AIAAgAToAAiAAIAE6AAEgA0F9aiABOgAAIANBfmogAToAACACQQdJDQAgACABOgADIANBfGogAToAACACQQlJDQAgAEEAIABrQQNxIgRqIgMgAUH/AXFBgYKECGwiATYCACADIAIgBGtBfHEiBGoiAkF8aiABNgIAIARBCUkNACADIAE2AgggAyABNgIEIAJBeGogATYCACACQXRqIAE2AgAgBEEZSQ0AIAMgATYCGCADIAE2AhQgAyABNgIQIAMgATYCDCACQXBqIAE2AgAgAkFsaiABNgIAIAJBaGogATYCACACQWRqIAE2AgAgBCADQQRxQRhyIgVrIgJBIEkNACABrUKBgICAEH4hBiADIAVqIQEDQCABIAY3AxggASAGNwMQIAEgBjcDCCABIAY3AwAgAUEgaiEBIAJBYGoiAkEfSw0ACwsgAAsLjkgBAEGACAuGSAEAAAACAAAAAwAAAAAAAAAAAAAABAAAAAUAAAAAAAAAAAAAAAYAAAAHAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9yZXNldGAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2hlYWRlcmAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfYmVnaW5gIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw=='

			/***/
		},

		/***/ 50172: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', { value: true })
			exports.enumToMap = void 0
			function enumToMap(obj) {
				const res = {}
				Object.keys(obj).forEach((key) => {
					const value = obj[key]
					if (typeof value === 'number') {
						res[key] = value
					}
				})
				return res
			}
			exports.enumToMap = enumToMap
			//# sourceMappingURL=utils.js.map

			/***/
		},

		/***/ 47501: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { kClients } = __nccwpck_require__(36443)
			const Agent = __nccwpck_require__(59965)
			const {
				kAgent,
				kMockAgentSet,
				kMockAgentGet,
				kDispatches,
				kIsMockActive,
				kNetConnect,
				kGetNetConnect,
				kOptions,
				kFactory,
			} = __nccwpck_require__(91117)
			const MockClient = __nccwpck_require__(47365)
			const MockPool = __nccwpck_require__(94004)
			const { matchValue, buildMockOptions } = __nccwpck_require__(53397)
			const { InvalidArgumentError, UndiciError } = __nccwpck_require__(68707)
			const Dispatcher = __nccwpck_require__(28611)
			const Pluralizer = __nccwpck_require__(91529)
			const PendingInterceptorsFormatter = __nccwpck_require__(56142)

			class FakeWeakRef {
				constructor(value) {
					this.value = value
				}

				deref() {
					return this.value
				}
			}

			class MockAgent extends Dispatcher {
				constructor(opts) {
					super(opts)

					this[kNetConnect] = true
					this[kIsMockActive] = true

					// Instantiate Agent and encapsulate
					if (opts && opts.agent && typeof opts.agent.dispatch !== 'function') {
						throw new InvalidArgumentError(
							'Argument opts.agent must implement Agent',
						)
					}
					const agent = opts && opts.agent ? opts.agent : new Agent(opts)
					this[kAgent] = agent

					this[kClients] = agent[kClients]
					this[kOptions] = buildMockOptions(opts)
				}

				get(origin) {
					let dispatcher = this[kMockAgentGet](origin)

					if (!dispatcher) {
						dispatcher = this[kFactory](origin)
						this[kMockAgentSet](origin, dispatcher)
					}
					return dispatcher
				}

				dispatch(opts, handler) {
					// Call MockAgent.get to perform additional setup before dispatching as normal
					this.get(opts.origin)
					return this[kAgent].dispatch(opts, handler)
				}

				async close() {
					await this[kAgent].close()
					this[kClients].clear()
				}

				deactivate() {
					this[kIsMockActive] = false
				}

				activate() {
					this[kIsMockActive] = true
				}

				enableNetConnect(matcher) {
					if (
						typeof matcher === 'string' ||
						typeof matcher === 'function' ||
						matcher instanceof RegExp
					) {
						if (Array.isArray(this[kNetConnect])) {
							this[kNetConnect].push(matcher)
						} else {
							this[kNetConnect] = [matcher]
						}
					} else if (typeof matcher === 'undefined') {
						this[kNetConnect] = true
					} else {
						throw new InvalidArgumentError(
							'Unsupported matcher. Must be one of String|Function|RegExp.',
						)
					}
				}

				disableNetConnect() {
					this[kNetConnect] = false
				}

				// This is required to bypass issues caused by using global symbols - see:
				// https://github.com/nodejs/undici/issues/1447
				get isMockActive() {
					return this[kIsMockActive]
				}

				[kMockAgentSet](origin, dispatcher) {
					this[kClients].set(origin, new FakeWeakRef(dispatcher))
				}

				[kFactory](origin) {
					const mockOptions = Object.assign({ agent: this }, this[kOptions])
					return this[kOptions] && this[kOptions].connections === 1
						? new MockClient(origin, mockOptions)
						: new MockPool(origin, mockOptions)
				}

				[kMockAgentGet](origin) {
					// First check if we can immediately find it
					const ref = this[kClients].get(origin)
					if (ref) {
						return ref.deref()
					}

					// If the origin is not a string create a dummy parent pool and return to user
					if (typeof origin !== 'string') {
						const dispatcher = this[kFactory]('http://localhost:9999')
						this[kMockAgentSet](origin, dispatcher)
						return dispatcher
					}

					// If we match, create a pool and assign the same dispatches
					for (const [keyMatcher, nonExplicitRef] of Array.from(
						this[kClients],
					)) {
						const nonExplicitDispatcher = nonExplicitRef.deref()
						if (
							nonExplicitDispatcher &&
							typeof keyMatcher !== 'string' &&
							matchValue(keyMatcher, origin)
						) {
							const dispatcher = this[kFactory](origin)
							this[kMockAgentSet](origin, dispatcher)
							dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches]
							return dispatcher
						}
					}
				}

				[kGetNetConnect]() {
					return this[kNetConnect]
				}

				pendingInterceptors() {
					const mockAgentClients = this[kClients]

					return Array.from(mockAgentClients.entries())
						.flatMap(([origin, scope]) =>
							scope
								.deref()
								[kDispatches].map((dispatch) => ({ ...dispatch, origin })),
						)
						.filter(({ pending }) => pending)
				}

				assertNoPendingInterceptors({
					pendingInterceptorsFormatter = new PendingInterceptorsFormatter(),
				} = {}) {
					const pending = this.pendingInterceptors()

					if (pending.length === 0) {
						return
					}

					const pluralizer = new Pluralizer(
						'interceptor',
						'interceptors',
					).pluralize(pending.length)

					throw new UndiciError(
						`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim(),
					)
				}
			}

			module.exports = MockAgent

			/***/
		},

		/***/ 47365: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { promisify } = __nccwpck_require__(39023)
			const Client = __nccwpck_require__(86197)
			const { buildMockDispatch } = __nccwpck_require__(53397)
			const {
				kDispatches,
				kMockAgent,
				kClose,
				kOriginalClose,
				kOrigin,
				kOriginalDispatch,
				kConnected,
			} = __nccwpck_require__(91117)
			const { MockInterceptor } = __nccwpck_require__(31511)
			const Symbols = __nccwpck_require__(36443)
			const { InvalidArgumentError } = __nccwpck_require__(68707)

			/**
			 * MockClient provides an API that extends the Client to influence the mockDispatches.
			 */
			class MockClient extends Client {
				constructor(origin, opts) {
					super(origin, opts)

					if (
						!opts ||
						!opts.agent ||
						typeof opts.agent.dispatch !== 'function'
					) {
						throw new InvalidArgumentError(
							'Argument opts.agent must implement Agent',
						)
					}

					this[kMockAgent] = opts.agent
					this[kOrigin] = origin
					this[kDispatches] = []
					this[kConnected] = 1
					this[kOriginalDispatch] = this.dispatch
					this[kOriginalClose] = this.close.bind(this)

					this.dispatch = buildMockDispatch.call(this)
					this.close = this[kClose]
				}

				get [Symbols.kConnected]() {
					return this[kConnected]
				}

				/**
				 * Sets up the base interceptor for mocking replies from undici.
				 */
				intercept(opts) {
					return new MockInterceptor(opts, this[kDispatches])
				}

				async [kClose]() {
					await promisify(this[kOriginalClose])()
					this[kConnected] = 0
					this[kMockAgent][Symbols.kClients].delete(this[kOrigin])
				}
			}

			module.exports = MockClient

			/***/
		},

		/***/ 52429: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { UndiciError } = __nccwpck_require__(68707)

			class MockNotMatchedError extends UndiciError {
				constructor(message) {
					super(message)
					Error.captureStackTrace(this, MockNotMatchedError)
					this.name = 'MockNotMatchedError'
					this.message =
						message ||
						'The request does not match any registered mock dispatches'
					this.code = 'UND_MOCK_ERR_MOCK_NOT_MATCHED'
				}
			}

			module.exports = {
				MockNotMatchedError,
			}

			/***/
		},

		/***/ 31511: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { getResponseData, buildKey, addMockDispatch } =
				__nccwpck_require__(53397)
			const {
				kDispatches,
				kDispatchKey,
				kDefaultHeaders,
				kDefaultTrailers,
				kContentLength,
				kMockDispatch,
			} = __nccwpck_require__(91117)
			const { InvalidArgumentError } = __nccwpck_require__(68707)
			const { buildURL } = __nccwpck_require__(3440)

			/**
			 * Defines the scope API for an interceptor reply
			 */
			class MockScope {
				constructor(mockDispatch) {
					this[kMockDispatch] = mockDispatch
				}

				/**
				 * Delay a reply by a set amount in ms.
				 */
				delay(waitInMs) {
					if (
						typeof waitInMs !== 'number' ||
						!Number.isInteger(waitInMs) ||
						waitInMs <= 0
					) {
						throw new InvalidArgumentError(
							'waitInMs must be a valid integer > 0',
						)
					}

					this[kMockDispatch].delay = waitInMs
					return this
				}

				/**
				 * For a defined reply, never mark as consumed.
				 */
				persist() {
					this[kMockDispatch].persist = true
					return this
				}

				/**
				 * Allow one to define a reply for a set amount of matching requests.
				 */
				times(repeatTimes) {
					if (
						typeof repeatTimes !== 'number' ||
						!Number.isInteger(repeatTimes) ||
						repeatTimes <= 0
					) {
						throw new InvalidArgumentError(
							'repeatTimes must be a valid integer > 0',
						)
					}

					this[kMockDispatch].times = repeatTimes
					return this
				}
			}

			/**
			 * Defines an interceptor for a Mock
			 */
			class MockInterceptor {
				constructor(opts, mockDispatches) {
					if (typeof opts !== 'object') {
						throw new InvalidArgumentError('opts must be an object')
					}
					if (typeof opts.path === 'undefined') {
						throw new InvalidArgumentError('opts.path must be defined')
					}
					if (typeof opts.method === 'undefined') {
						opts.method = 'GET'
					}
					// See https://github.com/nodejs/undici/issues/1245
					// As per RFC 3986, clients are not supposed to send URI
					// fragments to servers when they retrieve a document,
					if (typeof opts.path === 'string') {
						if (opts.query) {
							opts.path = buildURL(opts.path, opts.query)
						} else {
							// Matches https://github.com/nodejs/undici/blob/main/lib/fetch/index.js#L1811
							const parsedURL = new URL(opts.path, 'data://')
							opts.path = parsedURL.pathname + parsedURL.search
						}
					}
					if (typeof opts.method === 'string') {
						opts.method = opts.method.toUpperCase()
					}

					this[kDispatchKey] = buildKey(opts)
					this[kDispatches] = mockDispatches
					this[kDefaultHeaders] = {}
					this[kDefaultTrailers] = {}
					this[kContentLength] = false
				}

				createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
					const responseData = getResponseData(data)
					const contentLength = this[kContentLength]
						? { 'content-length': responseData.length }
						: {}
					const headers = {
						...this[kDefaultHeaders],
						...contentLength,
						...responseOptions.headers,
					}
					const trailers = {
						...this[kDefaultTrailers],
						...responseOptions.trailers,
					}

					return { statusCode, data, headers, trailers }
				}

				validateReplyParameters(statusCode, data, responseOptions) {
					if (typeof statusCode === 'undefined') {
						throw new InvalidArgumentError('statusCode must be defined')
					}
					if (typeof data === 'undefined') {
						throw new InvalidArgumentError('data must be defined')
					}
					if (typeof responseOptions !== 'object') {
						throw new InvalidArgumentError('responseOptions must be an object')
					}
				}

				/**
				 * Mock an undici request with a defined reply.
				 */
				reply(replyData) {
					// Values of reply aren't available right now as they
					// can only be available when the reply callback is invoked.
					if (typeof replyData === 'function') {
						// We'll first wrap the provided callback in another function,
						// this function will properly resolve the data from the callback
						// when invoked.
						const wrappedDefaultsCallback = (opts) => {
							// Our reply options callback contains the parameter for statusCode, data and options.
							const resolvedData = replyData(opts)

							// Check if it is in the right format
							if (typeof resolvedData !== 'object') {
								throw new InvalidArgumentError(
									'reply options callback must return an object',
								)
							}

							const {
								statusCode,
								data = '',
								responseOptions = {},
							} = resolvedData
							this.validateReplyParameters(statusCode, data, responseOptions)
							// Since the values can be obtained immediately we return them
							// from this higher order function that will be resolved later.
							return {
								...this.createMockScopeDispatchData(
									statusCode,
									data,
									responseOptions,
								),
							}
						}

						// Add usual dispatch data, but this time set the data parameter to function that will eventually provide data.
						const newMockDispatch = addMockDispatch(
							this[kDispatches],
							this[kDispatchKey],
							wrappedDefaultsCallback,
						)
						return new MockScope(newMockDispatch)
					}

					// We can have either one or three parameters, if we get here,
					// we should have 1-3 parameters. So we spread the arguments of
					// this function to obtain the parameters, since replyData will always
					// just be the statusCode.
					const [statusCode, data = '', responseOptions = {}] = [...arguments]
					this.validateReplyParameters(statusCode, data, responseOptions)

					// Send in-already provided data like usual
					const dispatchData = this.createMockScopeDispatchData(
						statusCode,
						data,
						responseOptions,
					)
					const newMockDispatch = addMockDispatch(
						this[kDispatches],
						this[kDispatchKey],
						dispatchData,
					)
					return new MockScope(newMockDispatch)
				}

				/**
				 * Mock an undici request with a defined error.
				 */
				replyWithError(error) {
					if (typeof error === 'undefined') {
						throw new InvalidArgumentError('error must be defined')
					}

					const newMockDispatch = addMockDispatch(
						this[kDispatches],
						this[kDispatchKey],
						{ error },
					)
					return new MockScope(newMockDispatch)
				}

				/**
				 * Set default reply headers on the interceptor for subsequent replies
				 */
				defaultReplyHeaders(headers) {
					if (typeof headers === 'undefined') {
						throw new InvalidArgumentError('headers must be defined')
					}

					this[kDefaultHeaders] = headers
					return this
				}

				/**
				 * Set default reply trailers on the interceptor for subsequent replies
				 */
				defaultReplyTrailers(trailers) {
					if (typeof trailers === 'undefined') {
						throw new InvalidArgumentError('trailers must be defined')
					}

					this[kDefaultTrailers] = trailers
					return this
				}

				/**
				 * Set reply content length header for replies on the interceptor
				 */
				replyContentLength() {
					this[kContentLength] = true
					return this
				}
			}

			module.exports.MockInterceptor = MockInterceptor
			module.exports.MockScope = MockScope

			/***/
		},

		/***/ 94004: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { promisify } = __nccwpck_require__(39023)
			const Pool = __nccwpck_require__(35076)
			const { buildMockDispatch } = __nccwpck_require__(53397)
			const {
				kDispatches,
				kMockAgent,
				kClose,
				kOriginalClose,
				kOrigin,
				kOriginalDispatch,
				kConnected,
			} = __nccwpck_require__(91117)
			const { MockInterceptor } = __nccwpck_require__(31511)
			const Symbols = __nccwpck_require__(36443)
			const { InvalidArgumentError } = __nccwpck_require__(68707)

			/**
			 * MockPool provides an API that extends the Pool to influence the mockDispatches.
			 */
			class MockPool extends Pool {
				constructor(origin, opts) {
					super(origin, opts)

					if (
						!opts ||
						!opts.agent ||
						typeof opts.agent.dispatch !== 'function'
					) {
						throw new InvalidArgumentError(
							'Argument opts.agent must implement Agent',
						)
					}

					this[kMockAgent] = opts.agent
					this[kOrigin] = origin
					this[kDispatches] = []
					this[kConnected] = 1
					this[kOriginalDispatch] = this.dispatch
					this[kOriginalClose] = this.close.bind(this)

					this.dispatch = buildMockDispatch.call(this)
					this.close = this[kClose]
				}

				get [Symbols.kConnected]() {
					return this[kConnected]
				}

				/**
				 * Sets up the base interceptor for mocking replies from undici.
				 */
				intercept(opts) {
					return new MockInterceptor(opts, this[kDispatches])
				}

				async [kClose]() {
					await promisify(this[kOriginalClose])()
					this[kConnected] = 0
					this[kMockAgent][Symbols.kClients].delete(this[kOrigin])
				}
			}

			module.exports = MockPool

			/***/
		},

		/***/ 91117: /***/ (module) => {
			'use strict'

			module.exports = {
				kAgent: Symbol('agent'),
				kOptions: Symbol('options'),
				kFactory: Symbol('factory'),
				kDispatches: Symbol('dispatches'),
				kDispatchKey: Symbol('dispatch key'),
				kDefaultHeaders: Symbol('default headers'),
				kDefaultTrailers: Symbol('default trailers'),
				kContentLength: Symbol('content length'),
				kMockAgent: Symbol('mock agent'),
				kMockAgentSet: Symbol('mock agent set'),
				kMockAgentGet: Symbol('mock agent get'),
				kMockDispatch: Symbol('mock dispatch'),
				kClose: Symbol('close'),
				kOriginalClose: Symbol('original agent close'),
				kOrigin: Symbol('origin'),
				kIsMockActive: Symbol('is mock active'),
				kNetConnect: Symbol('net connect'),
				kGetNetConnect: Symbol('get net connect'),
				kConnected: Symbol('connected'),
			}

			/***/
		},

		/***/ 53397: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { MockNotMatchedError } = __nccwpck_require__(52429)
			const {
				kDispatches,
				kMockAgent,
				kOriginalDispatch,
				kOrigin,
				kGetNetConnect,
			} = __nccwpck_require__(91117)
			const { buildURL, nop } = __nccwpck_require__(3440)
			const { STATUS_CODES } = __nccwpck_require__(58611)
			const {
				types: { isPromise },
			} = __nccwpck_require__(39023)

			function matchValue(match, value) {
				if (typeof match === 'string') {
					return match === value
				}
				if (match instanceof RegExp) {
					return match.test(value)
				}
				if (typeof match === 'function') {
					return match(value) === true
				}
				return false
			}

			function lowerCaseEntries(headers) {
				return Object.fromEntries(
					Object.entries(headers).map(([headerName, headerValue]) => {
						return [headerName.toLocaleLowerCase(), headerValue]
					}),
				)
			}

			/**
			 * @param {import('../../index').Headers|string[]|Record<string, string>} headers
			 * @param {string} key
			 */
			function getHeaderByName(headers, key) {
				if (Array.isArray(headers)) {
					for (let i = 0; i < headers.length; i += 2) {
						if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
							return headers[i + 1]
						}
					}

					return undefined
				} else if (typeof headers.get === 'function') {
					return headers.get(key)
				} else {
					return lowerCaseEntries(headers)[key.toLocaleLowerCase()]
				}
			}

			/** @param {string[]} headers */
			function buildHeadersFromArray(headers) {
				// fetch HeadersList
				const clone = headers.slice()
				const entries = []
				for (let index = 0; index < clone.length; index += 2) {
					entries.push([clone[index], clone[index + 1]])
				}
				return Object.fromEntries(entries)
			}

			function matchHeaders(mockDispatch, headers) {
				if (typeof mockDispatch.headers === 'function') {
					if (Array.isArray(headers)) {
						// fetch HeadersList
						headers = buildHeadersFromArray(headers)
					}
					return mockDispatch.headers(headers ? lowerCaseEntries(headers) : {})
				}
				if (typeof mockDispatch.headers === 'undefined') {
					return true
				}
				if (
					typeof headers !== 'object' ||
					typeof mockDispatch.headers !== 'object'
				) {
					return false
				}

				for (const [matchHeaderName, matchHeaderValue] of Object.entries(
					mockDispatch.headers,
				)) {
					const headerValue = getHeaderByName(headers, matchHeaderName)

					if (!matchValue(matchHeaderValue, headerValue)) {
						return false
					}
				}
				return true
			}

			function safeUrl(path) {
				if (typeof path !== 'string') {
					return path
				}

				const pathSegments = path.split('?')

				if (pathSegments.length !== 2) {
					return path
				}

				const qp = new URLSearchParams(pathSegments.pop())
				qp.sort()
				return [...pathSegments, qp.toString()].join('?')
			}

			function matchKey(mockDispatch, { path, method, body, headers }) {
				const pathMatch = matchValue(mockDispatch.path, path)
				const methodMatch = matchValue(mockDispatch.method, method)
				const bodyMatch =
					typeof mockDispatch.body !== 'undefined'
						? matchValue(mockDispatch.body, body)
						: true
				const headersMatch = matchHeaders(mockDispatch, headers)
				return pathMatch && methodMatch && bodyMatch && headersMatch
			}

			function getResponseData(data) {
				if (Buffer.isBuffer(data)) {
					return data
				} else if (typeof data === 'object') {
					return JSON.stringify(data)
				} else {
					return data.toString()
				}
			}

			function getMockDispatch(mockDispatches, key) {
				const basePath = key.query ? buildURL(key.path, key.query) : key.path
				const resolvedPath =
					typeof basePath === 'string' ? safeUrl(basePath) : basePath

				// Match path
				let matchedMockDispatches = mockDispatches
					.filter(({ consumed }) => !consumed)
					.filter(({ path }) => matchValue(safeUrl(path), resolvedPath))
				if (matchedMockDispatches.length === 0) {
					throw new MockNotMatchedError(
						`Mock dispatch not matched for path '${resolvedPath}'`,
					)
				}

				// Match method
				matchedMockDispatches = matchedMockDispatches.filter(({ method }) =>
					matchValue(method, key.method),
				)
				if (matchedMockDispatches.length === 0) {
					throw new MockNotMatchedError(
						`Mock dispatch not matched for method '${key.method}'`,
					)
				}

				// Match body
				matchedMockDispatches = matchedMockDispatches.filter(({ body }) =>
					typeof body !== 'undefined' ? matchValue(body, key.body) : true,
				)
				if (matchedMockDispatches.length === 0) {
					throw new MockNotMatchedError(
						`Mock dispatch not matched for body '${key.body}'`,
					)
				}

				// Match headers
				matchedMockDispatches = matchedMockDispatches.filter((mockDispatch) =>
					matchHeaders(mockDispatch, key.headers),
				)
				if (matchedMockDispatches.length === 0) {
					throw new MockNotMatchedError(
						`Mock dispatch not matched for headers '${typeof key.headers === 'object' ? JSON.stringify(key.headers) : key.headers}'`,
					)
				}

				return matchedMockDispatches[0]
			}

			function addMockDispatch(mockDispatches, key, data) {
				const baseData = {
					timesInvoked: 0,
					times: 1,
					persist: false,
					consumed: false,
				}
				const replyData =
					typeof data === 'function' ? { callback: data } : { ...data }
				const newMockDispatch = {
					...baseData,
					...key,
					pending: true,
					data: { error: null, ...replyData },
				}
				mockDispatches.push(newMockDispatch)
				return newMockDispatch
			}

			function deleteMockDispatch(mockDispatches, key) {
				const index = mockDispatches.findIndex((dispatch) => {
					if (!dispatch.consumed) {
						return false
					}
					return matchKey(dispatch, key)
				})
				if (index !== -1) {
					mockDispatches.splice(index, 1)
				}
			}

			function buildKey(opts) {
				const { path, method, body, headers, query } = opts
				return {
					path,
					method,
					body,
					headers,
					query,
				}
			}

			function generateKeyValues(data) {
				return Object.entries(data).reduce(
					(keyValuePairs, [key, value]) => [
						...keyValuePairs,
						Buffer.from(`${key}`),
						Array.isArray(value)
							? value.map((x) => Buffer.from(`${x}`))
							: Buffer.from(`${value}`),
					],
					[],
				)
			}

			/**
			 * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
			 * @param {number} statusCode
			 */
			function getStatusText(statusCode) {
				return STATUS_CODES[statusCode] || 'unknown'
			}

			async function getResponse(body) {
				const buffers = []
				for await (const data of body) {
					buffers.push(data)
				}
				return Buffer.concat(buffers).toString('utf8')
			}

			/**
			 * Mock dispatch function used to simulate undici dispatches
			 */
			function mockDispatch(opts, handler) {
				// Get mock dispatch from built key
				const key = buildKey(opts)
				const mockDispatch = getMockDispatch(this[kDispatches], key)

				mockDispatch.timesInvoked++

				// Here's where we resolve a callback if a callback is present for the dispatch data.
				if (mockDispatch.data.callback) {
					mockDispatch.data = {
						...mockDispatch.data,
						...mockDispatch.data.callback(opts),
					}
				}

				// Parse mockDispatch data
				const {
					data: { statusCode, data, headers, trailers, error },
					delay,
					persist,
				} = mockDispatch
				const { timesInvoked, times } = mockDispatch

				// If it's used up and not persistent, mark as consumed
				mockDispatch.consumed = !persist && timesInvoked >= times
				mockDispatch.pending = timesInvoked < times

				// If specified, trigger dispatch error
				if (error !== null) {
					deleteMockDispatch(this[kDispatches], key)
					handler.onError(error)
					return true
				}

				// Handle the request with a delay if necessary
				if (typeof delay === 'number' && delay > 0) {
					setTimeout(() => {
						handleReply(this[kDispatches])
					}, delay)
				} else {
					handleReply(this[kDispatches])
				}

				function handleReply(mockDispatches, _data = data) {
					// fetch's HeadersList is a 1D string array
					const optsHeaders = Array.isArray(opts.headers)
						? buildHeadersFromArray(opts.headers)
						: opts.headers
					const body =
						typeof _data === 'function'
							? _data({ ...opts, headers: optsHeaders })
							: _data

					// util.types.isPromise is likely needed for jest.
					if (isPromise(body)) {
						// If handleReply is asynchronous, throwing an error
						// in the callback will reject the promise, rather than
						// synchronously throw the error, which breaks some tests.
						// Rather, we wait for the callback to resolve if it is a
						// promise, and then re-run handleReply with the new body.
						body.then((newData) => handleReply(mockDispatches, newData))
						return
					}

					const responseData = getResponseData(body)
					const responseHeaders = generateKeyValues(headers)
					const responseTrailers = generateKeyValues(trailers)

					handler.abort = nop
					handler.onHeaders(
						statusCode,
						responseHeaders,
						resume,
						getStatusText(statusCode),
					)
					handler.onData(Buffer.from(responseData))
					handler.onComplete(responseTrailers)
					deleteMockDispatch(mockDispatches, key)
				}

				function resume() {}

				return true
			}

			function buildMockDispatch() {
				const agent = this[kMockAgent]
				const origin = this[kOrigin]
				const originalDispatch = this[kOriginalDispatch]

				return function dispatch(opts, handler) {
					if (agent.isMockActive) {
						try {
							mockDispatch.call(this, opts, handler)
						} catch (error) {
							if (error instanceof MockNotMatchedError) {
								const netConnect = agent[kGetNetConnect]()
								if (netConnect === false) {
									throw new MockNotMatchedError(
										`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`,
									)
								}
								if (checkNetConnect(netConnect, origin)) {
									originalDispatch.call(this, opts, handler)
								} else {
									throw new MockNotMatchedError(
										`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`,
									)
								}
							} else {
								throw error
							}
						}
					} else {
						originalDispatch.call(this, opts, handler)
					}
				}
			}

			function checkNetConnect(netConnect, origin) {
				const url = new URL(origin)
				if (netConnect === true) {
					return true
				} else if (
					Array.isArray(netConnect) &&
					netConnect.some((matcher) => matchValue(matcher, url.host))
				) {
					return true
				}
				return false
			}

			function buildMockOptions(opts) {
				if (opts) {
					const { agent, ...mockOptions } = opts
					return mockOptions
				}
			}

			module.exports = {
				getResponseData,
				getMockDispatch,
				addMockDispatch,
				deleteMockDispatch,
				buildKey,
				generateKeyValues,
				matchValue,
				getResponse,
				getStatusText,
				mockDispatch,
				buildMockDispatch,
				checkNetConnect,
				buildMockOptions,
				getHeaderByName,
			}

			/***/
		},

		/***/ 56142: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { Transform } = __nccwpck_require__(2203)
			const { Console } = __nccwpck_require__(64236)

			/**
			 * Gets the output of `console.table()` as a string.
			 */
			module.exports = class PendingInterceptorsFormatter {
				constructor({ disableColors } = {}) {
					this.transform = new Transform({
						transform(chunk, _enc, cb) {
							cb(null, chunk)
						},
					})

					this.logger = new Console({
						stdout: this.transform,
						inspectOptions: {
							colors: !disableColors && !process.env.CI,
						},
					})
				}

				format(pendingInterceptors) {
					const withPrettyHeaders = pendingInterceptors.map(
						({
							method,
							path,
							data: { statusCode },
							persist,
							times,
							timesInvoked,
							origin,
						}) => ({
							Method: method,
							Origin: origin,
							Path: path,
							'Status code': statusCode,
							Persistent: persist ? '' : '',
							Invocations: timesInvoked,
							Remaining: persist ? Infinity : times - timesInvoked,
						}),
					)

					this.logger.table(withPrettyHeaders)
					return this.transform.read().toString()
				}
			}

			/***/
		},

		/***/ 91529: /***/ (module) => {
			'use strict'

			const singulars = {
				pronoun: 'it',
				is: 'is',
				was: 'was',
				this: 'this',
			}

			const plurals = {
				pronoun: 'they',
				is: 'are',
				was: 'were',
				this: 'these',
			}

			module.exports = class Pluralizer {
				constructor(singular, plural) {
					this.singular = singular
					this.plural = plural
				}

				pluralize(count) {
					const one = count === 1
					const keys = one ? singulars : plurals
					const noun = one ? this.singular : this.plural
					return { ...keys, count, noun }
				}
			}

			/***/
		},

		/***/ 34869: /***/ (module) => {
			'use strict'
			/* eslint-disable */

			// Extracted from node/lib/internal/fixed_queue.js

			// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.
			const kSize = 2048
			const kMask = kSize - 1

			// The FixedQueue is implemented as a singly-linked list of fixed-size
			// circular buffers. It looks something like this:
			//
			//  head                                                       tail
			//    |                                                          |
			//    v                                                          v
			// +-----------+ <-----\       +-----------+ <------\         +-----------+
			// |  [null]   |        \----- |   next    |         \------- |   next    |
			// +-----------+               +-----------+                  +-----------+
			// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |
			// |   item    |               |   item    |                  |  [empty]  |
			// |   item    |               |   item    |                  |  [empty]  |
			// |   item    |               |   item    |                  |  [empty]  |
			// |   item    |               |   item    |       bottom --> |   item    |
			// |   item    |               |   item    |                  |   item    |
			// |    ...    |               |    ...    |                  |    ...    |
			// |   item    |               |   item    |                  |   item    |
			// |   item    |               |   item    |                  |   item    |
			// |  [empty]  | <-- top       |   item    |                  |   item    |
			// |  [empty]  |               |   item    |                  |   item    |
			// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |
			// +-----------+               +-----------+                  +-----------+
			//
			// Or, if there is only one circular buffer, it looks something
			// like either of these:
			//
			//  head   tail                                 head   tail
			//    |     |                                     |     |
			//    v     v                                     v     v
			// +-----------+                               +-----------+
			// |  [null]   |                               |  [null]   |
			// +-----------+                               +-----------+
			// |  [empty]  |                               |   item    |
			// |  [empty]  |                               |   item    |
			// |   item    | <-- bottom            top --> |  [empty]  |
			// |   item    |                               |  [empty]  |
			// |  [empty]  | <-- top            bottom --> |   item    |
			// |  [empty]  |                               |   item    |
			// +-----------+                               +-----------+
			//
			// Adding a value means moving `top` forward by one, removing means
			// moving `bottom` forward by one. After reaching the end, the queue
			// wraps around.
			//
			// When `top === bottom` the current queue is empty and when
			// `top + 1 === bottom` it's full. This wastes a single space of storage
			// but allows much quicker checks.

			class FixedCircularBuffer {
				constructor() {
					this.bottom = 0
					this.top = 0
					this.list = new Array(kSize)
					this.next = null
				}

				isEmpty() {
					return this.top === this.bottom
				}

				isFull() {
					return ((this.top + 1) & kMask) === this.bottom
				}

				push(data) {
					this.list[this.top] = data
					this.top = (this.top + 1) & kMask
				}

				shift() {
					const nextItem = this.list[this.bottom]
					if (nextItem === undefined) return null
					this.list[this.bottom] = undefined
					this.bottom = (this.bottom + 1) & kMask
					return nextItem
				}
			}

			module.exports = class FixedQueue {
				constructor() {
					this.head = this.tail = new FixedCircularBuffer()
				}

				isEmpty() {
					return this.head.isEmpty()
				}

				push(data) {
					if (this.head.isFull()) {
						// Head is full: Creates a new queue, sets the old queue's `.next` to it,
						// and sets it as the new main queue.
						this.head = this.head.next = new FixedCircularBuffer()
					}
					this.head.push(data)
				}

				shift() {
					const tail = this.tail
					const next = tail.shift()
					if (tail.isEmpty() && tail.next !== null) {
						// If there is another queue, it forms the new tail.
						this.tail = tail.next
					}
					return next
				}
			}

			/***/
		},

		/***/ 58640: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const DispatcherBase = __nccwpck_require__(50001)
			const FixedQueue = __nccwpck_require__(34869)
			const {
				kConnected,
				kSize,
				kRunning,
				kPending,
				kQueued,
				kBusy,
				kFree,
				kUrl,
				kClose,
				kDestroy,
				kDispatch,
			} = __nccwpck_require__(36443)
			const PoolStats = __nccwpck_require__(24622)

			const kClients = Symbol('clients')
			const kNeedDrain = Symbol('needDrain')
			const kQueue = Symbol('queue')
			const kClosedResolve = Symbol('closed resolve')
			const kOnDrain = Symbol('onDrain')
			const kOnConnect = Symbol('onConnect')
			const kOnDisconnect = Symbol('onDisconnect')
			const kOnConnectionError = Symbol('onConnectionError')
			const kGetDispatcher = Symbol('get dispatcher')
			const kAddClient = Symbol('add client')
			const kRemoveClient = Symbol('remove client')
			const kStats = Symbol('stats')

			class PoolBase extends DispatcherBase {
				constructor() {
					super()

					this[kQueue] = new FixedQueue()
					this[kClients] = []
					this[kQueued] = 0

					const pool = this

					this[kOnDrain] = function onDrain(origin, targets) {
						const queue = pool[kQueue]

						let needDrain = false

						while (!needDrain) {
							const item = queue.shift()
							if (!item) {
								break
							}
							pool[kQueued]--
							needDrain = !this.dispatch(item.opts, item.handler)
						}

						this[kNeedDrain] = needDrain

						if (!this[kNeedDrain] && pool[kNeedDrain]) {
							pool[kNeedDrain] = false
							pool.emit('drain', origin, [pool, ...targets])
						}

						if (pool[kClosedResolve] && queue.isEmpty()) {
							Promise.all(pool[kClients].map((c) => c.close())).then(
								pool[kClosedResolve],
							)
						}
					}

					this[kOnConnect] = (origin, targets) => {
						pool.emit('connect', origin, [pool, ...targets])
					}

					this[kOnDisconnect] = (origin, targets, err) => {
						pool.emit('disconnect', origin, [pool, ...targets], err)
					}

					this[kOnConnectionError] = (origin, targets, err) => {
						pool.emit('connectionError', origin, [pool, ...targets], err)
					}

					this[kStats] = new PoolStats(this)
				}

				get [kBusy]() {
					return this[kNeedDrain]
				}

				get [kConnected]() {
					return this[kClients].filter((client) => client[kConnected]).length
				}

				get [kFree]() {
					return this[kClients].filter(
						(client) => client[kConnected] && !client[kNeedDrain],
					).length
				}

				get [kPending]() {
					let ret = this[kQueued]
					for (const { [kPending]: pending } of this[kClients]) {
						ret += pending
					}
					return ret
				}

				get [kRunning]() {
					let ret = 0
					for (const { [kRunning]: running } of this[kClients]) {
						ret += running
					}
					return ret
				}

				get [kSize]() {
					let ret = this[kQueued]
					for (const { [kSize]: size } of this[kClients]) {
						ret += size
					}
					return ret
				}

				get stats() {
					return this[kStats]
				}

				async [kClose]() {
					if (this[kQueue].isEmpty()) {
						return Promise.all(this[kClients].map((c) => c.close()))
					} else {
						return new Promise((resolve) => {
							this[kClosedResolve] = resolve
						})
					}
				}

				async [kDestroy](err) {
					while (true) {
						const item = this[kQueue].shift()
						if (!item) {
							break
						}
						item.handler.onError(err)
					}

					return Promise.all(this[kClients].map((c) => c.destroy(err)))
				}

				[kDispatch](opts, handler) {
					const dispatcher = this[kGetDispatcher]()

					if (!dispatcher) {
						this[kNeedDrain] = true
						this[kQueue].push({ opts, handler })
						this[kQueued]++
					} else if (!dispatcher.dispatch(opts, handler)) {
						dispatcher[kNeedDrain] = true
						this[kNeedDrain] = !this[kGetDispatcher]()
					}

					return !this[kNeedDrain]
				}

				[kAddClient](client) {
					client
						.on('drain', this[kOnDrain])
						.on('connect', this[kOnConnect])
						.on('disconnect', this[kOnDisconnect])
						.on('connectionError', this[kOnConnectionError])

					this[kClients].push(client)

					if (this[kNeedDrain]) {
						process.nextTick(() => {
							if (this[kNeedDrain]) {
								this[kOnDrain](client[kUrl], [this, client])
							}
						})
					}

					return this
				}

				[kRemoveClient](client) {
					client.close(() => {
						const idx = this[kClients].indexOf(client)
						if (idx !== -1) {
							this[kClients].splice(idx, 1)
						}
					})

					this[kNeedDrain] = this[kClients].some(
						(dispatcher) =>
							!dispatcher[kNeedDrain] &&
							dispatcher.closed !== true &&
							dispatcher.destroyed !== true,
					)
				}
			}

			module.exports = {
				PoolBase,
				kClients,
				kNeedDrain,
				kAddClient,
				kRemoveClient,
				kGetDispatcher,
			}

			/***/
		},

		/***/ 24622: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			const { kFree, kConnected, kPending, kQueued, kRunning, kSize } =
				__nccwpck_require__(36443)
			const kPool = Symbol('pool')

			class PoolStats {
				constructor(pool) {
					this[kPool] = pool
				}

				get connected() {
					return this[kPool][kConnected]
				}

				get free() {
					return this[kPool][kFree]
				}

				get pending() {
					return this[kPool][kPending]
				}

				get queued() {
					return this[kPool][kQueued]
				}

				get running() {
					return this[kPool][kRunning]
				}

				get size() {
					return this[kPool][kSize]
				}
			}

			module.exports = PoolStats

			/***/
		},

		/***/ 35076: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { PoolBase, kClients, kNeedDrain, kAddClient, kGetDispatcher } =
				__nccwpck_require__(58640)
			const Client = __nccwpck_require__(86197)
			const { InvalidArgumentError } = __nccwpck_require__(68707)
			const util = __nccwpck_require__(3440)
			const { kUrl, kInterceptors } = __nccwpck_require__(36443)
			const buildConnector = __nccwpck_require__(59136)

			const kOptions = Symbol('options')
			const kConnections = Symbol('connections')
			const kFactory = Symbol('factory')

			function defaultFactory(origin, opts) {
				return new Client(origin, opts)
			}

			class Pool extends PoolBase {
				constructor(
					origin,
					{
						connections,
						factory = defaultFactory,
						connect,
						connectTimeout,
						tls,
						maxCachedSessions,
						socketPath,
						autoSelectFamily,
						autoSelectFamilyAttemptTimeout,
						allowH2,
						...options
					} = {},
				) {
					super()

					if (
						connections != null &&
						(!Number.isFinite(connections) || connections < 0)
					) {
						throw new InvalidArgumentError('invalid connections')
					}

					if (typeof factory !== 'function') {
						throw new InvalidArgumentError('factory must be a function.')
					}

					if (
						connect != null &&
						typeof connect !== 'function' &&
						typeof connect !== 'object'
					) {
						throw new InvalidArgumentError(
							'connect must be a function or an object',
						)
					}

					if (typeof connect !== 'function') {
						connect = buildConnector({
							...tls,
							maxCachedSessions,
							allowH2,
							socketPath,
							timeout: connectTimeout,
							...(util.nodeHasAutoSelectFamily && autoSelectFamily
								? { autoSelectFamily, autoSelectFamilyAttemptTimeout }
								: undefined),
							...connect,
						})
					}

					this[kInterceptors] =
						options.interceptors &&
						options.interceptors.Pool &&
						Array.isArray(options.interceptors.Pool)
							? options.interceptors.Pool
							: []
					this[kConnections] = connections || null
					this[kUrl] = util.parseOrigin(origin)
					this[kOptions] = { ...util.deepClone(options), connect, allowH2 }
					this[kOptions].interceptors = options.interceptors
						? { ...options.interceptors }
						: undefined
					this[kFactory] = factory

					this.on('connectionError', (origin, targets, error) => {
						// If a connection error occurs, we remove the client from the pool,
						// and emit a connectionError event. They will not be re-used.
						// Fixes https://github.com/nodejs/undici/issues/3895
						for (const target of targets) {
							// Do not use kRemoveClient here, as it will close the client,
							// but the client cannot be closed in this state.
							const idx = this[kClients].indexOf(target)
							if (idx !== -1) {
								this[kClients].splice(idx, 1)
							}
						}
					})
				}

				[kGetDispatcher]() {
					let dispatcher = this[kClients].find(
						(dispatcher) => !dispatcher[kNeedDrain],
					)

					if (dispatcher) {
						return dispatcher
					}

					if (
						!this[kConnections] ||
						this[kClients].length < this[kConnections]
					) {
						dispatcher = this[kFactory](this[kUrl], this[kOptions])
						this[kAddClient](dispatcher)
					}

					return dispatcher
				}
			}

			module.exports = Pool

			/***/
		},

		/***/ 22720: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { kProxy, kClose, kDestroy, kInterceptors } =
				__nccwpck_require__(36443)
			const { URL } = __nccwpck_require__(87016)
			const Agent = __nccwpck_require__(59965)
			const Pool = __nccwpck_require__(35076)
			const DispatcherBase = __nccwpck_require__(50001)
			const { InvalidArgumentError, RequestAbortedError } =
				__nccwpck_require__(68707)
			const buildConnector = __nccwpck_require__(59136)

			const kAgent = Symbol('proxy agent')
			const kClient = Symbol('proxy client')
			const kProxyHeaders = Symbol('proxy headers')
			const kRequestTls = Symbol('request tls settings')
			const kProxyTls = Symbol('proxy tls settings')
			const kConnectEndpoint = Symbol('connect endpoint function')

			function defaultProtocolPort(protocol) {
				return protocol === 'https:' ? 443 : 80
			}

			function buildProxyOptions(opts) {
				if (typeof opts === 'string') {
					opts = { uri: opts }
				}

				if (!opts || !opts.uri) {
					throw new InvalidArgumentError('Proxy opts.uri is mandatory')
				}

				return {
					uri: opts.uri,
					protocol: opts.protocol || 'https',
				}
			}

			function defaultFactory(origin, opts) {
				return new Pool(origin, opts)
			}

			class ProxyAgent extends DispatcherBase {
				constructor(opts) {
					super(opts)
					this[kProxy] = buildProxyOptions(opts)
					this[kAgent] = new Agent(opts)
					this[kInterceptors] =
						opts.interceptors &&
						opts.interceptors.ProxyAgent &&
						Array.isArray(opts.interceptors.ProxyAgent)
							? opts.interceptors.ProxyAgent
							: []

					if (typeof opts === 'string') {
						opts = { uri: opts }
					}

					if (!opts || !opts.uri) {
						throw new InvalidArgumentError('Proxy opts.uri is mandatory')
					}

					const { clientFactory = defaultFactory } = opts

					if (typeof clientFactory !== 'function') {
						throw new InvalidArgumentError(
							'Proxy opts.clientFactory must be a function.',
						)
					}

					this[kRequestTls] = opts.requestTls
					this[kProxyTls] = opts.proxyTls
					this[kProxyHeaders] = opts.headers || {}

					const resolvedUrl = new URL(opts.uri)
					const { origin, port, host, username, password } = resolvedUrl

					if (opts.auth && opts.token) {
						throw new InvalidArgumentError(
							'opts.auth cannot be used in combination with opts.token',
						)
					} else if (opts.auth) {
						/* @deprecated in favour of opts.token */
						this[kProxyHeaders]['proxy-authorization'] = `Basic ${opts.auth}`
					} else if (opts.token) {
						this[kProxyHeaders]['proxy-authorization'] = opts.token
					} else if (username && password) {
						this[kProxyHeaders]['proxy-authorization'] =
							`Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString('base64')}`
					}

					const connect = buildConnector({ ...opts.proxyTls })
					this[kConnectEndpoint] = buildConnector({ ...opts.requestTls })
					this[kClient] = clientFactory(resolvedUrl, { connect })
					this[kAgent] = new Agent({
						...opts,
						connect: async (opts, callback) => {
							let requestedHost = opts.host
							if (!opts.port) {
								requestedHost += `:${defaultProtocolPort(opts.protocol)}`
							}
							try {
								const { socket, statusCode } = await this[kClient].connect({
									origin,
									port,
									path: requestedHost,
									signal: opts.signal,
									headers: {
										...this[kProxyHeaders],
										host,
									},
								})
								if (statusCode !== 200) {
									socket.on('error', () => {}).destroy()
									callback(
										new RequestAbortedError(
											`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`,
										),
									)
								}
								if (opts.protocol !== 'https:') {
									callback(null, socket)
									return
								}
								let servername
								if (this[kRequestTls]) {
									servername = this[kRequestTls].servername
								} else {
									servername = opts.servername
								}
								this[kConnectEndpoint](
									{ ...opts, servername, httpSocket: socket },
									callback,
								)
							} catch (err) {
								callback(err)
							}
						},
					})
				}

				dispatch(opts, handler) {
					const { host } = new URL(opts.origin)
					const headers = buildHeaders(opts.headers)
					throwIfProxyAuthIsSent(headers)
					return this[kAgent].dispatch(
						{
							...opts,
							headers: {
								...headers,
								host,
							},
						},
						handler,
					)
				}

				async [kClose]() {
					await this[kAgent].close()
					await this[kClient].close()
				}

				async [kDestroy]() {
					await this[kAgent].destroy()
					await this[kClient].destroy()
				}
			}

			/**
			 * @param {string[] | Record<string, string>} headers
			 * @returns {Record<string, string>}
			 */
			function buildHeaders(headers) {
				// When using undici.fetch, the headers list is stored
				// as an array.
				if (Array.isArray(headers)) {
					/** @type {Record<string, string>} */
					const headersPair = {}

					for (let i = 0; i < headers.length; i += 2) {
						headersPair[headers[i]] = headers[i + 1]
					}

					return headersPair
				}

				return headers
			}

			/**
			 * @param {Record<string, string>} headers
			 *
			 * Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers
			 * Nevertheless, it was changed and to avoid a security vulnerability by end users
			 * this check was created.
			 * It should be removed in the next major version for performance reasons
			 */
			function throwIfProxyAuthIsSent(headers) {
				const existProxyAuth =
					headers &&
					Object.keys(headers).find(
						(key) => key.toLowerCase() === 'proxy-authorization',
					)
				if (existProxyAuth) {
					throw new InvalidArgumentError(
						'Proxy-Authorization should be sent in ProxyAgent constructor',
					)
				}
			}

			module.exports = ProxyAgent

			/***/
		},

		/***/ 28804: /***/ (module) => {
			'use strict'

			let fastNow = Date.now()
			let fastNowTimeout

			const fastTimers = []

			function onTimeout() {
				fastNow = Date.now()

				let len = fastTimers.length
				let idx = 0
				while (idx < len) {
					const timer = fastTimers[idx]

					if (timer.state === 0) {
						timer.state = fastNow + timer.delay
					} else if (timer.state > 0 && fastNow >= timer.state) {
						timer.state = -1
						timer.callback(timer.opaque)
					}

					if (timer.state === -1) {
						timer.state = -2
						if (idx !== len - 1) {
							fastTimers[idx] = fastTimers.pop()
						} else {
							fastTimers.pop()
						}
						len -= 1
					} else {
						idx += 1
					}
				}

				if (fastTimers.length > 0) {
					refreshTimeout()
				}
			}

			function refreshTimeout() {
				if (fastNowTimeout && fastNowTimeout.refresh) {
					fastNowTimeout.refresh()
				} else {
					clearTimeout(fastNowTimeout)
					fastNowTimeout = setTimeout(onTimeout, 1e3)
					if (fastNowTimeout.unref) {
						fastNowTimeout.unref()
					}
				}
			}

			class Timeout {
				constructor(callback, delay, opaque) {
					this.callback = callback
					this.delay = delay
					this.opaque = opaque

					//  -2 not in timer list
					//  -1 in timer list but inactive
					//   0 in timer list waiting for time
					// > 0 in timer list waiting for time to expire
					this.state = -2

					this.refresh()
				}

				refresh() {
					if (this.state === -2) {
						fastTimers.push(this)
						if (!fastNowTimeout || fastTimers.length === 1) {
							refreshTimeout()
						}
					}

					this.state = 0
				}

				clear() {
					this.state = -1
				}
			}

			module.exports = {
				setTimeout(callback, delay, opaque) {
					return delay < 1e3
						? setTimeout(callback, delay, opaque)
						: new Timeout(callback, delay, opaque)
				},
				clearTimeout(timeout) {
					if (timeout instanceof Timeout) {
						timeout.clear()
					} else {
						clearTimeout(timeout)
					}
				},
			}

			/***/
		},

		/***/ 68550: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const diagnosticsChannel = __nccwpck_require__(31637)
			const { uid, states } = __nccwpck_require__(45913)
			const { kReadyState, kSentClose, kByteParser, kReceivedClose } =
				__nccwpck_require__(62933)
			const { fireEvent, failWebsocketConnection } = __nccwpck_require__(3574)
			const { CloseEvent } = __nccwpck_require__(46255)
			const { makeRequest } = __nccwpck_require__(25194)
			const { fetching } = __nccwpck_require__(12315)
			const { Headers } = __nccwpck_require__(26349)
			const { getGlobalDispatcher } = __nccwpck_require__(32581)
			const { kHeadersList } = __nccwpck_require__(36443)

			const channels = {}
			channels.open = diagnosticsChannel.channel('undici:websocket:open')
			channels.close = diagnosticsChannel.channel('undici:websocket:close')
			channels.socketError = diagnosticsChannel.channel(
				'undici:websocket:socket_error',
			)

			/** @type {import('crypto')} */
			let crypto
			try {
				crypto = __nccwpck_require__(76982)
			} catch {}

			/**
			 * @see https://websockets.spec.whatwg.org/#concept-websocket-establish
			 * @param {URL} url
			 * @param {string|string[]} protocols
			 * @param {import('./websocket').WebSocket} ws
			 * @param {(response: any) => void} onEstablish
			 * @param {Partial<import('../../types/websocket').WebSocketInit>} options
			 */
			function establishWebSocketConnection(
				url,
				protocols,
				ws,
				onEstablish,
				options,
			) {
				// 1. Let requestURL be a copy of url, with its scheme set to "http", if urls
				//    scheme is "ws", and to "https" otherwise.
				const requestURL = url

				requestURL.protocol = url.protocol === 'ws:' ? 'http:' : 'https:'

				// 2. Let request be a new request, whose URL is requestURL, client is client,
				//    service-workers mode is "none", referrer is "no-referrer", mode is
				//    "websocket", credentials mode is "include", cache mode is "no-store" ,
				//    and redirect mode is "error".
				const request = makeRequest({
					urlList: [requestURL],
					serviceWorkers: 'none',
					referrer: 'no-referrer',
					mode: 'websocket',
					credentials: 'include',
					cache: 'no-store',
					redirect: 'error',
				})

				// Note: undici extension, allow setting custom headers.
				if (options.headers) {
					const headersList = new Headers(options.headers)[kHeadersList]

					request.headersList = headersList
				}

				// 3. Append (`Upgrade`, `websocket`) to requests header list.
				// 4. Append (`Connection`, `Upgrade`) to requests header list.
				// Note: both of these are handled by undici currently.
				// https://github.com/nodejs/undici/blob/68c269c4144c446f3f1220951338daef4a6b5ec4/lib/client.js#L1397

				// 5. Let keyValue be a nonce consisting of a randomly selected
				//    16-byte value that has been forgiving-base64-encoded and
				//    isomorphic encoded.
				const keyValue = crypto.randomBytes(16).toString('base64')

				// 6. Append (`Sec-WebSocket-Key`, keyValue) to requests
				//    header list.
				request.headersList.append('sec-websocket-key', keyValue)

				// 7. Append (`Sec-WebSocket-Version`, `13`) to requests
				//    header list.
				request.headersList.append('sec-websocket-version', '13')

				// 8. For each protocol in protocols, combine
				//    (`Sec-WebSocket-Protocol`, protocol) in requests header
				//    list.
				for (const protocol of protocols) {
					request.headersList.append('sec-websocket-protocol', protocol)
				}

				// 9. Let permessageDeflate be a user-agent defined
				//    "permessage-deflate" extension header value.
				// https://github.com/mozilla/gecko-dev/blob/ce78234f5e653a5d3916813ff990f053510227bc/netwerk/protocol/websocket/WebSocketChannel.cpp#L2673
				// TODO: enable once permessage-deflate is supported
				const permessageDeflate = '' // 'permessage-deflate; 15'

				// 10. Append (`Sec-WebSocket-Extensions`, permessageDeflate) to
				//     requests header list.
				// request.headersList.append('sec-websocket-extensions', permessageDeflate)

				// 11. Fetch request with useParallelQueue set to true, and
				//     processResponse given response being these steps:
				const controller = fetching({
					request,
					useParallelQueue: true,
					dispatcher: options.dispatcher ?? getGlobalDispatcher(),
					processResponse(response) {
						// 1. If response is a network error or its status is not 101,
						//    fail the WebSocket connection.
						if (response.type === 'error' || response.status !== 101) {
							failWebsocketConnection(
								ws,
								'Received network error or non-101 status code.',
							)
							return
						}

						// 2. If protocols is not the empty list and extracting header
						//    list values given `Sec-WebSocket-Protocol` and responses
						//    header list results in null, failure, or the empty byte
						//    sequence, then fail the WebSocket connection.
						if (
							protocols.length !== 0 &&
							!response.headersList.get('Sec-WebSocket-Protocol')
						) {
							failWebsocketConnection(
								ws,
								'Server did not respond with sent protocols.',
							)
							return
						}

						// 3. Follow the requirements stated step 2 to step 6, inclusive,
						//    of the last set of steps in section 4.1 of The WebSocket
						//    Protocol to validate response. This either results in fail
						//    the WebSocket connection or the WebSocket connection is
						//    established.

						// 2. If the response lacks an |Upgrade| header field or the |Upgrade|
						//    header field contains a value that is not an ASCII case-
						//    insensitive match for the value "websocket", the client MUST
						//    _Fail the WebSocket Connection_.
						if (
							response.headersList.get('Upgrade')?.toLowerCase() !== 'websocket'
						) {
							failWebsocketConnection(
								ws,
								'Server did not set Upgrade header to "websocket".',
							)
							return
						}

						// 3. If the response lacks a |Connection| header field or the
						//    |Connection| header field doesn't contain a token that is an
						//    ASCII case-insensitive match for the value "Upgrade", the client
						//    MUST _Fail the WebSocket Connection_.
						if (
							response.headersList.get('Connection')?.toLowerCase() !==
							'upgrade'
						) {
							failWebsocketConnection(
								ws,
								'Server did not set Connection header to "upgrade".',
							)
							return
						}

						// 4. If the response lacks a |Sec-WebSocket-Accept| header field or
						//    the |Sec-WebSocket-Accept| contains a value other than the
						//    base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-
						//    Key| (as a string, not base64-decoded) with the string "258EAFA5-
						//    E914-47DA-95CA-C5AB0DC85B11" but ignoring any leading and
						//    trailing whitespace, the client MUST _Fail the WebSocket
						//    Connection_.
						const secWSAccept = response.headersList.get('Sec-WebSocket-Accept')
						const digest = crypto
							.createHash('sha1')
							.update(keyValue + uid)
							.digest('base64')
						if (secWSAccept !== digest) {
							failWebsocketConnection(
								ws,
								'Incorrect hash received in Sec-WebSocket-Accept header.',
							)
							return
						}

						// 5. If the response includes a |Sec-WebSocket-Extensions| header
						//    field and this header field indicates the use of an extension
						//    that was not present in the client's handshake (the server has
						//    indicated an extension not requested by the client), the client
						//    MUST _Fail the WebSocket Connection_.  (The parsing of this
						//    header field to determine which extensions are requested is
						//    discussed in Section 9.1.)
						const secExtension = response.headersList.get(
							'Sec-WebSocket-Extensions',
						)

						if (secExtension !== null && secExtension !== permessageDeflate) {
							failWebsocketConnection(
								ws,
								'Received different permessage-deflate than the one set.',
							)
							return
						}

						// 6. If the response includes a |Sec-WebSocket-Protocol| header field
						//    and this header field indicates the use of a subprotocol that was
						//    not present in the client's handshake (the server has indicated a
						//    subprotocol not requested by the client), the client MUST _Fail
						//    the WebSocket Connection_.
						const secProtocol = response.headersList.get(
							'Sec-WebSocket-Protocol',
						)

						if (
							secProtocol !== null &&
							secProtocol !== request.headersList.get('Sec-WebSocket-Protocol')
						) {
							failWebsocketConnection(
								ws,
								'Protocol was not set in the opening handshake.',
							)
							return
						}

						response.socket.on('data', onSocketData)
						response.socket.on('close', onSocketClose)
						response.socket.on('error', onSocketError)

						if (channels.open.hasSubscribers) {
							channels.open.publish({
								address: response.socket.address(),
								protocol: secProtocol,
								extensions: secExtension,
							})
						}

						onEstablish(response)
					},
				})

				return controller
			}

			/**
			 * @param {Buffer} chunk
			 */
			function onSocketData(chunk) {
				if (!this.ws[kByteParser].write(chunk)) {
					this.pause()
				}
			}

			/**
			 * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
			 * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4
			 */
			function onSocketClose() {
				const { ws } = this

				// If the TCP connection was closed after the
				// WebSocket closing handshake was completed, the WebSocket connection
				// is said to have been closed _cleanly_.
				const wasClean = ws[kSentClose] && ws[kReceivedClose]

				let code = 1005
				let reason = ''

				const result = ws[kByteParser].closingInfo

				if (result) {
					code = result.code ?? 1005
					reason = result.reason
				} else if (!ws[kSentClose]) {
					// If _The WebSocket
					// Connection is Closed_ and no Close control frame was received by the
					// endpoint (such as could occur if the underlying transport connection
					// is lost), _The WebSocket Connection Close Code_ is considered to be
					// 1006.
					code = 1006
				}

				// 1. Change the ready state to CLOSED (3).
				ws[kReadyState] = states.CLOSED

				// 2. If the user agent was required to fail the WebSocket
				//    connection, or if the WebSocket connection was closed
				//    after being flagged as full, fire an event named error
				//    at the WebSocket object.
				// TODO

				// 3. Fire an event named close at the WebSocket object,
				//    using CloseEvent, with the wasClean attribute
				//    initialized to true if the connection closed cleanly
				//    and false otherwise, the code attribute initialized to
				//    the WebSocket connection close code, and the reason
				//    attribute initialized to the result of applying UTF-8
				//    decode without BOM to the WebSocket connection close
				//    reason.
				fireEvent('close', ws, CloseEvent, {
					wasClean,
					code,
					reason,
				})

				if (channels.close.hasSubscribers) {
					channels.close.publish({
						websocket: ws,
						code,
						reason,
					})
				}
			}

			function onSocketError(error) {
				const { ws } = this

				ws[kReadyState] = states.CLOSING

				if (channels.socketError.hasSubscribers) {
					channels.socketError.publish(error)
				}

				this.destroy()
			}

			module.exports = {
				establishWebSocketConnection,
			}

			/***/
		},

		/***/ 45913: /***/ (module) => {
			'use strict'

			// This is a Globally Unique Identifier unique used
			// to validate that the endpoint accepts websocket
			// connections.
			// See https://www.rfc-editor.org/rfc/rfc6455.html#section-1.3
			const uid = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'

			/** @type {PropertyDescriptor} */
			const staticPropertyDescriptors = {
				enumerable: true,
				writable: false,
				configurable: false,
			}

			const states = {
				CONNECTING: 0,
				OPEN: 1,
				CLOSING: 2,
				CLOSED: 3,
			}

			const opcodes = {
				CONTINUATION: 0x0,
				TEXT: 0x1,
				BINARY: 0x2,
				CLOSE: 0x8,
				PING: 0x9,
				PONG: 0xa,
			}

			const maxUnsigned16Bit = 2 ** 16 - 1 // 65535

			const parserStates = {
				INFO: 0,
				PAYLOADLENGTH_16: 2,
				PAYLOADLENGTH_64: 3,
				READ_DATA: 4,
			}

			const emptyBuffer = Buffer.allocUnsafe(0)

			module.exports = {
				uid,
				staticPropertyDescriptors,
				states,
				opcodes,
				maxUnsigned16Bit,
				parserStates,
				emptyBuffer,
			}

			/***/
		},

		/***/ 46255: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { webidl } = __nccwpck_require__(74222)
			const { kEnumerableProperty } = __nccwpck_require__(3440)
			const { MessagePort } = __nccwpck_require__(28167)

			/**
			 * @see https://html.spec.whatwg.org/multipage/comms.html#messageevent
			 */
			class MessageEvent extends Event {
				#eventInit

				constructor(type, eventInitDict = {}) {
					webidl.argumentLengthCheck(arguments, 1, {
						header: 'MessageEvent constructor',
					})

					type = webidl.converters.DOMString(type)
					eventInitDict = webidl.converters.MessageEventInit(eventInitDict)

					super(type, eventInitDict)

					this.#eventInit = eventInitDict
				}

				get data() {
					webidl.brandCheck(this, MessageEvent)

					return this.#eventInit.data
				}

				get origin() {
					webidl.brandCheck(this, MessageEvent)

					return this.#eventInit.origin
				}

				get lastEventId() {
					webidl.brandCheck(this, MessageEvent)

					return this.#eventInit.lastEventId
				}

				get source() {
					webidl.brandCheck(this, MessageEvent)

					return this.#eventInit.source
				}

				get ports() {
					webidl.brandCheck(this, MessageEvent)

					if (!Object.isFrozen(this.#eventInit.ports)) {
						Object.freeze(this.#eventInit.ports)
					}

					return this.#eventInit.ports
				}

				initMessageEvent(
					type,
					bubbles = false,
					cancelable = false,
					data = null,
					origin = '',
					lastEventId = '',
					source = null,
					ports = [],
				) {
					webidl.brandCheck(this, MessageEvent)

					webidl.argumentLengthCheck(arguments, 1, {
						header: 'MessageEvent.initMessageEvent',
					})

					return new MessageEvent(type, {
						bubbles,
						cancelable,
						data,
						origin,
						lastEventId,
						source,
						ports,
					})
				}
			}

			/**
			 * @see https://websockets.spec.whatwg.org/#the-closeevent-interface
			 */
			class CloseEvent extends Event {
				#eventInit

				constructor(type, eventInitDict = {}) {
					webidl.argumentLengthCheck(arguments, 1, {
						header: 'CloseEvent constructor',
					})

					type = webidl.converters.DOMString(type)
					eventInitDict = webidl.converters.CloseEventInit(eventInitDict)

					super(type, eventInitDict)

					this.#eventInit = eventInitDict
				}

				get wasClean() {
					webidl.brandCheck(this, CloseEvent)

					return this.#eventInit.wasClean
				}

				get code() {
					webidl.brandCheck(this, CloseEvent)

					return this.#eventInit.code
				}

				get reason() {
					webidl.brandCheck(this, CloseEvent)

					return this.#eventInit.reason
				}
			}

			// https://html.spec.whatwg.org/multipage/webappapis.html#the-errorevent-interface
			class ErrorEvent extends Event {
				#eventInit

				constructor(type, eventInitDict) {
					webidl.argumentLengthCheck(arguments, 1, {
						header: 'ErrorEvent constructor',
					})

					super(type, eventInitDict)

					type = webidl.converters.DOMString(type)
					eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {})

					this.#eventInit = eventInitDict
				}

				get message() {
					webidl.brandCheck(this, ErrorEvent)

					return this.#eventInit.message
				}

				get filename() {
					webidl.brandCheck(this, ErrorEvent)

					return this.#eventInit.filename
				}

				get lineno() {
					webidl.brandCheck(this, ErrorEvent)

					return this.#eventInit.lineno
				}

				get colno() {
					webidl.brandCheck(this, ErrorEvent)

					return this.#eventInit.colno
				}

				get error() {
					webidl.brandCheck(this, ErrorEvent)

					return this.#eventInit.error
				}
			}

			Object.defineProperties(MessageEvent.prototype, {
				[Symbol.toStringTag]: {
					value: 'MessageEvent',
					configurable: true,
				},
				data: kEnumerableProperty,
				origin: kEnumerableProperty,
				lastEventId: kEnumerableProperty,
				source: kEnumerableProperty,
				ports: kEnumerableProperty,
				initMessageEvent: kEnumerableProperty,
			})

			Object.defineProperties(CloseEvent.prototype, {
				[Symbol.toStringTag]: {
					value: 'CloseEvent',
					configurable: true,
				},
				reason: kEnumerableProperty,
				code: kEnumerableProperty,
				wasClean: kEnumerableProperty,
			})

			Object.defineProperties(ErrorEvent.prototype, {
				[Symbol.toStringTag]: {
					value: 'ErrorEvent',
					configurable: true,
				},
				message: kEnumerableProperty,
				filename: kEnumerableProperty,
				lineno: kEnumerableProperty,
				colno: kEnumerableProperty,
				error: kEnumerableProperty,
			})

			webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort)

			webidl.converters['sequence<MessagePort>'] = webidl.sequenceConverter(
				webidl.converters.MessagePort,
			)

			const eventInit = [
				{
					key: 'bubbles',
					converter: webidl.converters.boolean,
					defaultValue: false,
				},
				{
					key: 'cancelable',
					converter: webidl.converters.boolean,
					defaultValue: false,
				},
				{
					key: 'composed',
					converter: webidl.converters.boolean,
					defaultValue: false,
				},
			]

			webidl.converters.MessageEventInit = webidl.dictionaryConverter([
				...eventInit,
				{
					key: 'data',
					converter: webidl.converters.any,
					defaultValue: null,
				},
				{
					key: 'origin',
					converter: webidl.converters.USVString,
					defaultValue: '',
				},
				{
					key: 'lastEventId',
					converter: webidl.converters.DOMString,
					defaultValue: '',
				},
				{
					key: 'source',
					// Node doesn't implement WindowProxy or ServiceWorker, so the only
					// valid value for source is a MessagePort.
					converter: webidl.nullableConverter(webidl.converters.MessagePort),
					defaultValue: null,
				},
				{
					key: 'ports',
					converter: webidl.converters['sequence<MessagePort>'],
					get defaultValue() {
						return []
					},
				},
			])

			webidl.converters.CloseEventInit = webidl.dictionaryConverter([
				...eventInit,
				{
					key: 'wasClean',
					converter: webidl.converters.boolean,
					defaultValue: false,
				},
				{
					key: 'code',
					converter: webidl.converters['unsigned short'],
					defaultValue: 0,
				},
				{
					key: 'reason',
					converter: webidl.converters.USVString,
					defaultValue: '',
				},
			])

			webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
				...eventInit,
				{
					key: 'message',
					converter: webidl.converters.DOMString,
					defaultValue: '',
				},
				{
					key: 'filename',
					converter: webidl.converters.USVString,
					defaultValue: '',
				},
				{
					key: 'lineno',
					converter: webidl.converters['unsigned long'],
					defaultValue: 0,
				},
				{
					key: 'colno',
					converter: webidl.converters['unsigned long'],
					defaultValue: 0,
				},
				{
					key: 'error',
					converter: webidl.converters.any,
				},
			])

			module.exports = {
				MessageEvent,
				CloseEvent,
				ErrorEvent,
			}

			/***/
		},

		/***/ 31237: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { maxUnsigned16Bit } = __nccwpck_require__(45913)

			/** @type {import('crypto')} */
			let crypto
			try {
				crypto = __nccwpck_require__(76982)
			} catch {}

			class WebsocketFrameSend {
				/**
				 * @param {Buffer|undefined} data
				 */
				constructor(data) {
					this.frameData = data
					this.maskKey = crypto.randomBytes(4)
				}

				createFrame(opcode) {
					const bodyLength = this.frameData?.byteLength ?? 0

					/** @type {number} */
					let payloadLength = bodyLength // 0-125
					let offset = 6

					if (bodyLength > maxUnsigned16Bit) {
						offset += 8 // payload length is next 8 bytes
						payloadLength = 127
					} else if (bodyLength > 125) {
						offset += 2 // payload length is next 2 bytes
						payloadLength = 126
					}

					const buffer = Buffer.allocUnsafe(bodyLength + offset)

					// Clear first 2 bytes, everything else is overwritten
					buffer[0] = buffer[1] = 0
					buffer[0] |= 0x80 // FIN
					buffer[0] = (buffer[0] & 0xf0) + opcode // opcode

					/*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */
					buffer[offset - 4] = this.maskKey[0]
					buffer[offset - 3] = this.maskKey[1]
					buffer[offset - 2] = this.maskKey[2]
					buffer[offset - 1] = this.maskKey[3]

					buffer[1] = payloadLength

					if (payloadLength === 126) {
						buffer.writeUInt16BE(bodyLength, 2)
					} else if (payloadLength === 127) {
						// Clear extended payload length
						buffer[2] = buffer[3] = 0
						buffer.writeUIntBE(bodyLength, 4, 6)
					}

					buffer[1] |= 0x80 // MASK

					// mask body
					for (let i = 0; i < bodyLength; i++) {
						buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4]
					}

					return buffer
				}
			}

			module.exports = {
				WebsocketFrameSend,
			}

			/***/
		},

		/***/ 43171: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { Writable } = __nccwpck_require__(2203)
			const diagnosticsChannel = __nccwpck_require__(31637)
			const { parserStates, opcodes, states, emptyBuffer } =
				__nccwpck_require__(45913)
			const { kReadyState, kSentClose, kResponse, kReceivedClose } =
				__nccwpck_require__(62933)
			const {
				isValidStatusCode,
				failWebsocketConnection,
				websocketMessageReceived,
			} = __nccwpck_require__(3574)
			const { WebsocketFrameSend } = __nccwpck_require__(31237)

			// This code was influenced by ws released under the MIT license.
			// Copyright (c) 2011 Einar Otto Stangvik <einaros@gmail.com>
			// Copyright (c) 2013 Arnout Kazemier and contributors
			// Copyright (c) 2016 Luigi Pinca and contributors

			const channels = {}
			channels.ping = diagnosticsChannel.channel('undici:websocket:ping')
			channels.pong = diagnosticsChannel.channel('undici:websocket:pong')

			class ByteParser extends Writable {
				#buffers = []
				#byteOffset = 0

				#state = parserStates.INFO

				#info = {}
				#fragments = []

				constructor(ws) {
					super()

					this.ws = ws
				}

				/**
				 * @param {Buffer} chunk
				 * @param {() => void} callback
				 */
				_write(chunk, _, callback) {
					this.#buffers.push(chunk)
					this.#byteOffset += chunk.length

					this.run(callback)
				}

				/**
				 * Runs whenever a new chunk is received.
				 * Callback is called whenever there are no more chunks buffering,
				 * or not enough bytes are buffered to parse.
				 */
				run(callback) {
					while (true) {
						if (this.#state === parserStates.INFO) {
							// If there aren't enough bytes to parse the payload length, etc.
							if (this.#byteOffset < 2) {
								return callback()
							}

							const buffer = this.consume(2)

							this.#info.fin = (buffer[0] & 0x80) !== 0
							this.#info.opcode = buffer[0] & 0x0f

							// If we receive a fragmented message, we use the type of the first
							// frame to parse the full message as binary/text, when it's terminated
							this.#info.originalOpcode ??= this.#info.opcode

							this.#info.fragmented =
								!this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION

							if (
								this.#info.fragmented &&
								this.#info.opcode !== opcodes.BINARY &&
								this.#info.opcode !== opcodes.TEXT
							) {
								// Only text and binary frames can be fragmented
								failWebsocketConnection(
									this.ws,
									'Invalid frame type was fragmented.',
								)
								return
							}

							const payloadLength = buffer[1] & 0x7f

							if (payloadLength <= 125) {
								this.#info.payloadLength = payloadLength
								this.#state = parserStates.READ_DATA
							} else if (payloadLength === 126) {
								this.#state = parserStates.PAYLOADLENGTH_16
							} else if (payloadLength === 127) {
								this.#state = parserStates.PAYLOADLENGTH_64
							}

							if (this.#info.fragmented && payloadLength > 125) {
								// A fragmented frame can't be fragmented itself
								failWebsocketConnection(
									this.ws,
									'Fragmented frame exceeded 125 bytes.',
								)
								return
							} else if (
								(this.#info.opcode === opcodes.PING ||
									this.#info.opcode === opcodes.PONG ||
									this.#info.opcode === opcodes.CLOSE) &&
								payloadLength > 125
							) {
								// Control frames can have a payload length of 125 bytes MAX
								failWebsocketConnection(
									this.ws,
									'Payload length for control frame exceeded 125 bytes.',
								)
								return
							} else if (this.#info.opcode === opcodes.CLOSE) {
								if (payloadLength === 1) {
									failWebsocketConnection(
										this.ws,
										'Received close frame with a 1-byte body.',
									)
									return
								}

								const body = this.consume(payloadLength)

								this.#info.closeInfo = this.parseCloseBody(false, body)

								if (!this.ws[kSentClose]) {
									// If an endpoint receives a Close frame and did not previously send a
									// Close frame, the endpoint MUST send a Close frame in response.  (When
									// sending a Close frame in response, the endpoint typically echos the
									// status code it received.)
									const body = Buffer.allocUnsafe(2)
									body.writeUInt16BE(this.#info.closeInfo.code, 0)
									const closeFrame = new WebsocketFrameSend(body)

									this.ws[kResponse].socket.write(
										closeFrame.createFrame(opcodes.CLOSE),
										(err) => {
											if (!err) {
												this.ws[kSentClose] = true
											}
										},
									)
								}

								// Upon either sending or receiving a Close control frame, it is said
								// that _The WebSocket Closing Handshake is Started_ and that the
								// WebSocket connection is in the CLOSING state.
								this.ws[kReadyState] = states.CLOSING
								this.ws[kReceivedClose] = true

								this.end()

								return
							} else if (this.#info.opcode === opcodes.PING) {
								// Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in
								// response, unless it already received a Close frame.
								// A Pong frame sent in response to a Ping frame must have identical
								// "Application data"

								const body = this.consume(payloadLength)

								if (!this.ws[kReceivedClose]) {
									const frame = new WebsocketFrameSend(body)

									this.ws[kResponse].socket.write(
										frame.createFrame(opcodes.PONG),
									)

									if (channels.ping.hasSubscribers) {
										channels.ping.publish({
											payload: body,
										})
									}
								}

								this.#state = parserStates.INFO

								if (this.#byteOffset > 0) {
									continue
								} else {
									callback()
									return
								}
							} else if (this.#info.opcode === opcodes.PONG) {
								// A Pong frame MAY be sent unsolicited.  This serves as a
								// unidirectional heartbeat.  A response to an unsolicited Pong frame is
								// not expected.

								const body = this.consume(payloadLength)

								if (channels.pong.hasSubscribers) {
									channels.pong.publish({
										payload: body,
									})
								}

								if (this.#byteOffset > 0) {
									continue
								} else {
									callback()
									return
								}
							}
						} else if (this.#state === parserStates.PAYLOADLENGTH_16) {
							if (this.#byteOffset < 2) {
								return callback()
							}

							const buffer = this.consume(2)

							this.#info.payloadLength = buffer.readUInt16BE(0)
							this.#state = parserStates.READ_DATA
						} else if (this.#state === parserStates.PAYLOADLENGTH_64) {
							if (this.#byteOffset < 8) {
								return callback()
							}

							const buffer = this.consume(8)
							const upper = buffer.readUInt32BE(0)

							// 2^31 is the maxinimum bytes an arraybuffer can contain
							// on 32-bit systems. Although, on 64-bit systems, this is
							// 2^53-1 bytes.
							// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_array_length
							// https://source.chromium.org/chromium/chromium/src/+/main:v8/src/common/globals.h;drc=1946212ac0100668f14eb9e2843bdd846e510a1e;bpv=1;bpt=1;l=1275
							// https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/js-array-buffer.h;l=34;drc=1946212ac0100668f14eb9e2843bdd846e510a1e
							if (upper > 2 ** 31 - 1) {
								failWebsocketConnection(
									this.ws,
									'Received payload length > 2^31 bytes.',
								)
								return
							}

							const lower = buffer.readUInt32BE(4)

							this.#info.payloadLength = (upper << 8) + lower
							this.#state = parserStates.READ_DATA
						} else if (this.#state === parserStates.READ_DATA) {
							if (this.#byteOffset < this.#info.payloadLength) {
								// If there is still more data in this chunk that needs to be read
								return callback()
							} else if (this.#byteOffset >= this.#info.payloadLength) {
								// If the server sent multiple frames in a single chunk

								const body = this.consume(this.#info.payloadLength)

								this.#fragments.push(body)

								// If the frame is unfragmented, or a fragmented frame was terminated,
								// a message was received
								if (
									!this.#info.fragmented ||
									(this.#info.fin && this.#info.opcode === opcodes.CONTINUATION)
								) {
									const fullMessage = Buffer.concat(this.#fragments)

									websocketMessageReceived(
										this.ws,
										this.#info.originalOpcode,
										fullMessage,
									)

									this.#info = {}
									this.#fragments.length = 0
								}

								this.#state = parserStates.INFO
							}
						}

						if (this.#byteOffset > 0) {
							continue
						} else {
							callback()
							break
						}
					}
				}

				/**
				 * Take n bytes from the buffered Buffers
				 * @param {number} n
				 * @returns {Buffer|null}
				 */
				consume(n) {
					if (n > this.#byteOffset) {
						return null
					} else if (n === 0) {
						return emptyBuffer
					}

					if (this.#buffers[0].length === n) {
						this.#byteOffset -= this.#buffers[0].length
						return this.#buffers.shift()
					}

					const buffer = Buffer.allocUnsafe(n)
					let offset = 0

					while (offset !== n) {
						const next = this.#buffers[0]
						const { length } = next

						if (length + offset === n) {
							buffer.set(this.#buffers.shift(), offset)
							break
						} else if (length + offset > n) {
							buffer.set(next.subarray(0, n - offset), offset)
							this.#buffers[0] = next.subarray(n - offset)
							break
						} else {
							buffer.set(this.#buffers.shift(), offset)
							offset += next.length
						}
					}

					this.#byteOffset -= n

					return buffer
				}

				parseCloseBody(onlyCode, data) {
					// https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.5
					/** @type {number|undefined} */
					let code

					if (data.length >= 2) {
						// _The WebSocket Connection Close Code_ is
						// defined as the status code (Section 7.4) contained in the first Close
						// control frame received by the application
						code = data.readUInt16BE(0)
					}

					if (onlyCode) {
						if (!isValidStatusCode(code)) {
							return null
						}

						return { code }
					}

					// https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.6
					/** @type {Buffer} */
					let reason = data.subarray(2)

					// Remove BOM
					if (reason[0] === 0xef && reason[1] === 0xbb && reason[2] === 0xbf) {
						reason = reason.subarray(3)
					}

					if (code !== undefined && !isValidStatusCode(code)) {
						return null
					}

					try {
						// TODO: optimize this
						reason = new TextDecoder('utf-8', { fatal: true }).decode(reason)
					} catch {
						return null
					}

					return { code, reason }
				}

				get closingInfo() {
					return this.#info.closeInfo
				}
			}

			module.exports = {
				ByteParser,
			}

			/***/
		},

		/***/ 62933: /***/ (module) => {
			'use strict'

			module.exports = {
				kWebSocketURL: Symbol('url'),
				kReadyState: Symbol('ready state'),
				kController: Symbol('controller'),
				kResponse: Symbol('response'),
				kBinaryType: Symbol('binary type'),
				kSentClose: Symbol('sent close'),
				kReceivedClose: Symbol('received close'),
				kByteParser: Symbol('byte parser'),
			}

			/***/
		},

		/***/ 3574: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const {
				kReadyState,
				kController,
				kResponse,
				kBinaryType,
				kWebSocketURL,
			} = __nccwpck_require__(62933)
			const { states, opcodes } = __nccwpck_require__(45913)
			const { MessageEvent, ErrorEvent } = __nccwpck_require__(46255)

			/* globals Blob */

			/**
			 * @param {import('./websocket').WebSocket} ws
			 */
			function isEstablished(ws) {
				// If the server's response is validated as provided for above, it is
				// said that _The WebSocket Connection is Established_ and that the
				// WebSocket Connection is in the OPEN state.
				return ws[kReadyState] === states.OPEN
			}

			/**
			 * @param {import('./websocket').WebSocket} ws
			 */
			function isClosing(ws) {
				// Upon either sending or receiving a Close control frame, it is said
				// that _The WebSocket Closing Handshake is Started_ and that the
				// WebSocket connection is in the CLOSING state.
				return ws[kReadyState] === states.CLOSING
			}

			/**
			 * @param {import('./websocket').WebSocket} ws
			 */
			function isClosed(ws) {
				return ws[kReadyState] === states.CLOSED
			}

			/**
			 * @see https://dom.spec.whatwg.org/#concept-event-fire
			 * @param {string} e
			 * @param {EventTarget} target
			 * @param {EventInit | undefined} eventInitDict
			 */
			function fireEvent(e, target, eventConstructor = Event, eventInitDict) {
				// 1. If eventConstructor is not given, then let eventConstructor be Event.

				// 2. Let event be the result of creating an event given eventConstructor,
				//    in the relevant realm of target.
				// 3. Initialize events type attribute to e.
				const event = new eventConstructor(e, eventInitDict) // eslint-disable-line new-cap

				// 4. Initialize any other IDL attributes of event as described in the
				//    invocation of this algorithm.

				// 5. Return the result of dispatching event at target, with legacy target
				//    override flag set if set.
				target.dispatchEvent(event)
			}

			/**
			 * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
			 * @param {import('./websocket').WebSocket} ws
			 * @param {number} type Opcode
			 * @param {Buffer} data application data
			 */
			function websocketMessageReceived(ws, type, data) {
				// 1. If ready state is not OPEN (1), then return.
				if (ws[kReadyState] !== states.OPEN) {
					return
				}

				// 2. Let dataForEvent be determined by switching on type and binary type:
				let dataForEvent

				if (type === opcodes.TEXT) {
					// -> type indicates that the data is Text
					//      a new DOMString containing data
					try {
						dataForEvent = new TextDecoder('utf-8', { fatal: true }).decode(
							data,
						)
					} catch {
						failWebsocketConnection(ws, 'Received invalid UTF-8 in text frame.')
						return
					}
				} else if (type === opcodes.BINARY) {
					if (ws[kBinaryType] === 'blob') {
						// -> type indicates that the data is Binary and binary type is "blob"
						//      a new Blob object, created in the relevant Realm of the WebSocket
						//      object, that represents data as its raw data
						dataForEvent = new Blob([data])
					} else {
						// -> type indicates that the data is Binary and binary type is "arraybuffer"
						//      a new ArrayBuffer object, created in the relevant Realm of the
						//      WebSocket object, whose contents are data
						dataForEvent = new Uint8Array(data).buffer
					}
				}

				// 3. Fire an event named message at the WebSocket object, using MessageEvent,
				//    with the origin attribute initialized to the serialization of the WebSocket
				//    objects url's origin, and the data attribute initialized to dataForEvent.
				fireEvent('message', ws, MessageEvent, {
					origin: ws[kWebSocketURL].origin,
					data: dataForEvent,
				})
			}

			/**
			 * @see https://datatracker.ietf.org/doc/html/rfc6455
			 * @see https://datatracker.ietf.org/doc/html/rfc2616
			 * @see https://bugs.chromium.org/p/chromium/issues/detail?id=398407
			 * @param {string} protocol
			 */
			function isValidSubprotocol(protocol) {
				// If present, this value indicates one
				// or more comma-separated subprotocol the client wishes to speak,
				// ordered by preference.  The elements that comprise this value
				// MUST be non-empty strings with characters in the range U+0021 to
				// U+007E not including separator characters as defined in
				// [RFC2616] and MUST all be unique strings.
				if (protocol.length === 0) {
					return false
				}

				for (const char of protocol) {
					const code = char.charCodeAt(0)

					if (
						code < 0x21 ||
						code > 0x7e ||
						char === '(' ||
						char === ')' ||
						char === '<' ||
						char === '>' ||
						char === '@' ||
						char === ',' ||
						char === ';' ||
						char === ':' ||
						char === '\\' ||
						char === '"' ||
						char === '/' ||
						char === '[' ||
						char === ']' ||
						char === '?' ||
						char === '=' ||
						char === '{' ||
						char === '}' ||
						code === 32 || // SP
						code === 9 // HT
					) {
						return false
					}
				}

				return true
			}

			/**
			 * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7-4
			 * @param {number} code
			 */
			function isValidStatusCode(code) {
				if (code >= 1000 && code < 1015) {
					return (
						code !== 1004 && // reserved
						code !== 1005 && // "MUST NOT be set as a status code"
						code !== 1006 // "MUST NOT be set as a status code"
					)
				}

				return code >= 3000 && code <= 4999
			}

			/**
			 * @param {import('./websocket').WebSocket} ws
			 * @param {string|undefined} reason
			 */
			function failWebsocketConnection(ws, reason) {
				const { [kController]: controller, [kResponse]: response } = ws

				controller.abort()

				if (response?.socket && !response.socket.destroyed) {
					response.socket.destroy()
				}

				if (reason) {
					fireEvent('error', ws, ErrorEvent, {
						error: new Error(reason),
					})
				}
			}

			module.exports = {
				isEstablished,
				isClosing,
				isClosed,
				fireEvent,
				isValidSubprotocol,
				isValidStatusCode,
				failWebsocketConnection,
				websocketMessageReceived,
			}

			/***/
		},

		/***/ 55171: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const { webidl } = __nccwpck_require__(74222)
			const { DOMException } = __nccwpck_require__(87326)
			const { URLSerializer } = __nccwpck_require__(94322)
			const { getGlobalOrigin } = __nccwpck_require__(75628)
			const { staticPropertyDescriptors, states, opcodes, emptyBuffer } =
				__nccwpck_require__(45913)
			const {
				kWebSocketURL,
				kReadyState,
				kController,
				kBinaryType,
				kResponse,
				kSentClose,
				kByteParser,
			} = __nccwpck_require__(62933)
			const {
				isEstablished,
				isClosing,
				isValidSubprotocol,
				failWebsocketConnection,
				fireEvent,
			} = __nccwpck_require__(3574)
			const { establishWebSocketConnection } = __nccwpck_require__(68550)
			const { WebsocketFrameSend } = __nccwpck_require__(31237)
			const { ByteParser } = __nccwpck_require__(43171)
			const { kEnumerableProperty, isBlobLike } = __nccwpck_require__(3440)
			const { getGlobalDispatcher } = __nccwpck_require__(32581)
			const { types } = __nccwpck_require__(39023)

			let experimentalWarned = false

			// https://websockets.spec.whatwg.org/#interface-definition
			class WebSocket extends EventTarget {
				#events = {
					open: null,
					error: null,
					close: null,
					message: null,
				}

				#bufferedAmount = 0
				#protocol = ''
				#extensions = ''

				/**
				 * @param {string} url
				 * @param {string|string[]} protocols
				 */
				constructor(url, protocols = []) {
					super()

					webidl.argumentLengthCheck(arguments, 1, {
						header: 'WebSocket constructor',
					})

					if (!experimentalWarned) {
						experimentalWarned = true
						process.emitWarning(
							'WebSockets are experimental, expect them to change at any time.',
							{
								code: 'UNDICI-WS',
							},
						)
					}

					const options =
						webidl.converters[
							'DOMString or sequence<DOMString> or WebSocketInit'
						](protocols)

					url = webidl.converters.USVString(url)
					protocols = options.protocols

					// 1. Let baseURL be this's relevant settings object's API base URL.
					const baseURL = getGlobalOrigin()

					// 1. Let urlRecord be the result of applying the URL parser to url with baseURL.
					let urlRecord

					try {
						urlRecord = new URL(url, baseURL)
					} catch (e) {
						// 3. If urlRecord is failure, then throw a "SyntaxError" DOMException.
						throw new DOMException(e, 'SyntaxError')
					}

					// 4. If urlRecords scheme is "http", then set urlRecords scheme to "ws".
					if (urlRecord.protocol === 'http:') {
						urlRecord.protocol = 'ws:'
					} else if (urlRecord.protocol === 'https:') {
						// 5. Otherwise, if urlRecords scheme is "https", set urlRecords scheme to "wss".
						urlRecord.protocol = 'wss:'
					}

					// 6. If urlRecords scheme is not "ws" or "wss", then throw a "SyntaxError" DOMException.
					if (urlRecord.protocol !== 'ws:' && urlRecord.protocol !== 'wss:') {
						throw new DOMException(
							`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,
							'SyntaxError',
						)
					}

					// 7. If urlRecords fragment is non-null, then throw a "SyntaxError"
					//    DOMException.
					if (urlRecord.hash || urlRecord.href.endsWith('#')) {
						throw new DOMException('Got fragment', 'SyntaxError')
					}

					// 8. If protocols is a string, set protocols to a sequence consisting
					//    of just that string.
					if (typeof protocols === 'string') {
						protocols = [protocols]
					}

					// 9. If any of the values in protocols occur more than once or otherwise
					//    fail to match the requirements for elements that comprise the value
					//    of `Sec-WebSocket-Protocol` fields as defined by The WebSocket
					//    protocol, then throw a "SyntaxError" DOMException.
					if (
						protocols.length !==
						new Set(protocols.map((p) => p.toLowerCase())).size
					) {
						throw new DOMException(
							'Invalid Sec-WebSocket-Protocol value',
							'SyntaxError',
						)
					}

					if (
						protocols.length > 0 &&
						!protocols.every((p) => isValidSubprotocol(p))
					) {
						throw new DOMException(
							'Invalid Sec-WebSocket-Protocol value',
							'SyntaxError',
						)
					}

					// 10. Set this's url to urlRecord.
					this[kWebSocketURL] = new URL(urlRecord.href)

					// 11. Let client be this's relevant settings object.

					// 12. Run this step in parallel:

					//    1. Establish a WebSocket connection given urlRecord, protocols,
					//       and client.
					this[kController] = establishWebSocketConnection(
						urlRecord,
						protocols,
						this,
						(response) => this.#onConnectionEstablished(response),
						options,
					)

					// Each WebSocket object has an associated ready state, which is a
					// number representing the state of the connection. Initially it must
					// be CONNECTING (0).
					this[kReadyState] = WebSocket.CONNECTING

					// The extensions attribute must initially return the empty string.

					// The protocol attribute must initially return the empty string.

					// Each WebSocket object has an associated binary type, which is a
					// BinaryType. Initially it must be "blob".
					this[kBinaryType] = 'blob'
				}

				/**
				 * @see https://websockets.spec.whatwg.org/#dom-websocket-close
				 * @param {number|undefined} code
				 * @param {string|undefined} reason
				 */
				close(code = undefined, reason = undefined) {
					webidl.brandCheck(this, WebSocket)

					if (code !== undefined) {
						code = webidl.converters['unsigned short'](code, { clamp: true })
					}

					if (reason !== undefined) {
						reason = webidl.converters.USVString(reason)
					}

					// 1. If code is present, but is neither an integer equal to 1000 nor an
					//    integer in the range 3000 to 4999, inclusive, throw an
					//    "InvalidAccessError" DOMException.
					if (code !== undefined) {
						if (code !== 1000 && (code < 3000 || code > 4999)) {
							throw new DOMException('invalid code', 'InvalidAccessError')
						}
					}

					let reasonByteLength = 0

					// 2. If reason is present, then run these substeps:
					if (reason !== undefined) {
						// 1. Let reasonBytes be the result of encoding reason.
						// 2. If reasonBytes is longer than 123 bytes, then throw a
						//    "SyntaxError" DOMException.
						reasonByteLength = Buffer.byteLength(reason)

						if (reasonByteLength > 123) {
							throw new DOMException(
								`Reason must be less than 123 bytes; received ${reasonByteLength}`,
								'SyntaxError',
							)
						}
					}

					// 3. Run the first matching steps from the following list:
					if (
						this[kReadyState] === WebSocket.CLOSING ||
						this[kReadyState] === WebSocket.CLOSED
					) {
						// If this's ready state is CLOSING (2) or CLOSED (3)
						// Do nothing.
					} else if (!isEstablished(this)) {
						// If the WebSocket connection is not yet established
						// Fail the WebSocket connection and set this's ready state
						// to CLOSING (2).
						failWebsocketConnection(
							this,
							'Connection was closed before it was established.',
						)
						this[kReadyState] = WebSocket.CLOSING
					} else if (!isClosing(this)) {
						// If the WebSocket closing handshake has not yet been started
						// Start the WebSocket closing handshake and set this's ready
						// state to CLOSING (2).
						// - If neither code nor reason is present, the WebSocket Close
						//   message must not have a body.
						// - If code is present, then the status code to use in the
						//   WebSocket Close message must be the integer given by code.
						// - If reason is also present, then reasonBytes must be
						//   provided in the Close message after the status code.

						const frame = new WebsocketFrameSend()

						// If neither code nor reason is present, the WebSocket Close
						// message must not have a body.

						// If code is present, then the status code to use in the
						// WebSocket Close message must be the integer given by code.
						if (code !== undefined && reason === undefined) {
							frame.frameData = Buffer.allocUnsafe(2)
							frame.frameData.writeUInt16BE(code, 0)
						} else if (code !== undefined && reason !== undefined) {
							// If reason is also present, then reasonBytes must be
							// provided in the Close message after the status code.
							frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength)
							frame.frameData.writeUInt16BE(code, 0)
							// the body MAY contain UTF-8-encoded data with value /reason/
							frame.frameData.write(reason, 2, 'utf-8')
						} else {
							frame.frameData = emptyBuffer
						}

						/** @type {import('stream').Duplex} */
						const socket = this[kResponse].socket

						socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
							if (!err) {
								this[kSentClose] = true
							}
						})

						// Upon either sending or receiving a Close control frame, it is said
						// that _The WebSocket Closing Handshake is Started_ and that the
						// WebSocket connection is in the CLOSING state.
						this[kReadyState] = states.CLOSING
					} else {
						// Otherwise
						// Set this's ready state to CLOSING (2).
						this[kReadyState] = WebSocket.CLOSING
					}
				}

				/**
				 * @see https://websockets.spec.whatwg.org/#dom-websocket-send
				 * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
				 */
				send(data) {
					webidl.brandCheck(this, WebSocket)

					webidl.argumentLengthCheck(arguments, 1, { header: 'WebSocket.send' })

					data = webidl.converters.WebSocketSendData(data)

					// 1. If this's ready state is CONNECTING, then throw an
					//    "InvalidStateError" DOMException.
					if (this[kReadyState] === WebSocket.CONNECTING) {
						throw new DOMException(
							'Sent before connected.',
							'InvalidStateError',
						)
					}

					// 2. Run the appropriate set of steps from the following list:
					// https://datatracker.ietf.org/doc/html/rfc6455#section-6.1
					// https://datatracker.ietf.org/doc/html/rfc6455#section-5.2

					if (!isEstablished(this) || isClosing(this)) {
						return
					}

					/** @type {import('stream').Duplex} */
					const socket = this[kResponse].socket

					// If data is a string
					if (typeof data === 'string') {
						// If the WebSocket connection is established and the WebSocket
						// closing handshake has not yet started, then the user agent
						// must send a WebSocket Message comprised of the data argument
						// using a text frame opcode; if the data cannot be sent, e.g.
						// because it would need to be buffered but the buffer is full,
						// the user agent must flag the WebSocket as full and then close
						// the WebSocket connection. Any invocation of this method with a
						// string argument that does not throw an exception must increase
						// the bufferedAmount attribute by the number of bytes needed to
						// express the argument as UTF-8.

						const value = Buffer.from(data)
						const frame = new WebsocketFrameSend(value)
						const buffer = frame.createFrame(opcodes.TEXT)

						this.#bufferedAmount += value.byteLength
						socket.write(buffer, () => {
							this.#bufferedAmount -= value.byteLength
						})
					} else if (types.isArrayBuffer(data)) {
						// If the WebSocket connection is established, and the WebSocket
						// closing handshake has not yet started, then the user agent must
						// send a WebSocket Message comprised of data using a binary frame
						// opcode; if the data cannot be sent, e.g. because it would need
						// to be buffered but the buffer is full, the user agent must flag
						// the WebSocket as full and then close the WebSocket connection.
						// The data to be sent is the data stored in the buffer described
						// by the ArrayBuffer object. Any invocation of this method with an
						// ArrayBuffer argument that does not throw an exception must
						// increase the bufferedAmount attribute by the length of the
						// ArrayBuffer in bytes.

						const value = Buffer.from(data)
						const frame = new WebsocketFrameSend(value)
						const buffer = frame.createFrame(opcodes.BINARY)

						this.#bufferedAmount += value.byteLength
						socket.write(buffer, () => {
							this.#bufferedAmount -= value.byteLength
						})
					} else if (ArrayBuffer.isView(data)) {
						// If the WebSocket connection is established, and the WebSocket
						// closing handshake has not yet started, then the user agent must
						// send a WebSocket Message comprised of data using a binary frame
						// opcode; if the data cannot be sent, e.g. because it would need to
						// be buffered but the buffer is full, the user agent must flag the
						// WebSocket as full and then close the WebSocket connection. The
						// data to be sent is the data stored in the section of the buffer
						// described by the ArrayBuffer object that data references. Any
						// invocation of this method with this kind of argument that does
						// not throw an exception must increase the bufferedAmount attribute
						// by the length of datas buffer in bytes.

						const ab = Buffer.from(data, data.byteOffset, data.byteLength)

						const frame = new WebsocketFrameSend(ab)
						const buffer = frame.createFrame(opcodes.BINARY)

						this.#bufferedAmount += ab.byteLength
						socket.write(buffer, () => {
							this.#bufferedAmount -= ab.byteLength
						})
					} else if (isBlobLike(data)) {
						// If the WebSocket connection is established, and the WebSocket
						// closing handshake has not yet started, then the user agent must
						// send a WebSocket Message comprised of data using a binary frame
						// opcode; if the data cannot be sent, e.g. because it would need to
						// be buffered but the buffer is full, the user agent must flag the
						// WebSocket as full and then close the WebSocket connection. The data
						// to be sent is the raw data represented by the Blob object. Any
						// invocation of this method with a Blob argument that does not throw
						// an exception must increase the bufferedAmount attribute by the size
						// of the Blob objects raw data, in bytes.

						const frame = new WebsocketFrameSend()

						data.arrayBuffer().then((ab) => {
							const value = Buffer.from(ab)
							frame.frameData = value
							const buffer = frame.createFrame(opcodes.BINARY)

							this.#bufferedAmount += value.byteLength
							socket.write(buffer, () => {
								this.#bufferedAmount -= value.byteLength
							})
						})
					}
				}

				get readyState() {
					webidl.brandCheck(this, WebSocket)

					// The readyState getter steps are to return this's ready state.
					return this[kReadyState]
				}

				get bufferedAmount() {
					webidl.brandCheck(this, WebSocket)

					return this.#bufferedAmount
				}

				get url() {
					webidl.brandCheck(this, WebSocket)

					// The url getter steps are to return this's url, serialized.
					return URLSerializer(this[kWebSocketURL])
				}

				get extensions() {
					webidl.brandCheck(this, WebSocket)

					return this.#extensions
				}

				get protocol() {
					webidl.brandCheck(this, WebSocket)

					return this.#protocol
				}

				get onopen() {
					webidl.brandCheck(this, WebSocket)

					return this.#events.open
				}

				set onopen(fn) {
					webidl.brandCheck(this, WebSocket)

					if (this.#events.open) {
						this.removeEventListener('open', this.#events.open)
					}

					if (typeof fn === 'function') {
						this.#events.open = fn
						this.addEventListener('open', fn)
					} else {
						this.#events.open = null
					}
				}

				get onerror() {
					webidl.brandCheck(this, WebSocket)

					return this.#events.error
				}

				set onerror(fn) {
					webidl.brandCheck(this, WebSocket)

					if (this.#events.error) {
						this.removeEventListener('error', this.#events.error)
					}

					if (typeof fn === 'function') {
						this.#events.error = fn
						this.addEventListener('error', fn)
					} else {
						this.#events.error = null
					}
				}

				get onclose() {
					webidl.brandCheck(this, WebSocket)

					return this.#events.close
				}

				set onclose(fn) {
					webidl.brandCheck(this, WebSocket)

					if (this.#events.close) {
						this.removeEventListener('close', this.#events.close)
					}

					if (typeof fn === 'function') {
						this.#events.close = fn
						this.addEventListener('close', fn)
					} else {
						this.#events.close = null
					}
				}

				get onmessage() {
					webidl.brandCheck(this, WebSocket)

					return this.#events.message
				}

				set onmessage(fn) {
					webidl.brandCheck(this, WebSocket)

					if (this.#events.message) {
						this.removeEventListener('message', this.#events.message)
					}

					if (typeof fn === 'function') {
						this.#events.message = fn
						this.addEventListener('message', fn)
					} else {
						this.#events.message = null
					}
				}

				get binaryType() {
					webidl.brandCheck(this, WebSocket)

					return this[kBinaryType]
				}

				set binaryType(type) {
					webidl.brandCheck(this, WebSocket)

					if (type !== 'blob' && type !== 'arraybuffer') {
						this[kBinaryType] = 'blob'
					} else {
						this[kBinaryType] = type
					}
				}

				/**
				 * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
				 */
				#onConnectionEstablished(response) {
					// processResponse is called when the "responses header list has been received and initialized."
					// once this happens, the connection is open
					this[kResponse] = response

					const parser = new ByteParser(this)
					parser.on('drain', function onParserDrain() {
						this.ws[kResponse].socket.resume()
					})

					response.socket.ws = this
					this[kByteParser] = parser

					// 1. Change the ready state to OPEN (1).
					this[kReadyState] = states.OPEN

					// 2. Change the extensions attributes value to the extensions in use, if
					//    it is not the null value.
					// https://datatracker.ietf.org/doc/html/rfc6455#section-9.1
					const extensions = response.headersList.get(
						'sec-websocket-extensions',
					)

					if (extensions !== null) {
						this.#extensions = extensions
					}

					// 3. Change the protocol attributes value to the subprotocol in use, if
					//    it is not the null value.
					// https://datatracker.ietf.org/doc/html/rfc6455#section-1.9
					const protocol = response.headersList.get('sec-websocket-protocol')

					if (protocol !== null) {
						this.#protocol = protocol
					}

					// 4. Fire an event named open at the WebSocket object.
					fireEvent('open', this)
				}
			}

			// https://websockets.spec.whatwg.org/#dom-websocket-connecting
			WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING
			// https://websockets.spec.whatwg.org/#dom-websocket-open
			WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN
			// https://websockets.spec.whatwg.org/#dom-websocket-closing
			WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING
			// https://websockets.spec.whatwg.org/#dom-websocket-closed
			WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED

			Object.defineProperties(WebSocket.prototype, {
				CONNECTING: staticPropertyDescriptors,
				OPEN: staticPropertyDescriptors,
				CLOSING: staticPropertyDescriptors,
				CLOSED: staticPropertyDescriptors,
				url: kEnumerableProperty,
				readyState: kEnumerableProperty,
				bufferedAmount: kEnumerableProperty,
				onopen: kEnumerableProperty,
				onerror: kEnumerableProperty,
				onclose: kEnumerableProperty,
				close: kEnumerableProperty,
				onmessage: kEnumerableProperty,
				binaryType: kEnumerableProperty,
				send: kEnumerableProperty,
				extensions: kEnumerableProperty,
				protocol: kEnumerableProperty,
				[Symbol.toStringTag]: {
					value: 'WebSocket',
					writable: false,
					enumerable: false,
					configurable: true,
				},
			})

			Object.defineProperties(WebSocket, {
				CONNECTING: staticPropertyDescriptors,
				OPEN: staticPropertyDescriptors,
				CLOSING: staticPropertyDescriptors,
				CLOSED: staticPropertyDescriptors,
			})

			webidl.converters['sequence<DOMString>'] = webidl.sequenceConverter(
				webidl.converters.DOMString,
			)

			webidl.converters['DOMString or sequence<DOMString>'] = function (V) {
				if (webidl.util.Type(V) === 'Object' && Symbol.iterator in V) {
					return webidl.converters['sequence<DOMString>'](V)
				}

				return webidl.converters.DOMString(V)
			}

			// This implements the propsal made in https://github.com/whatwg/websockets/issues/42
			webidl.converters.WebSocketInit = webidl.dictionaryConverter([
				{
					key: 'protocols',
					converter: webidl.converters['DOMString or sequence<DOMString>'],
					get defaultValue() {
						return []
					},
				},
				{
					key: 'dispatcher',
					converter: (V) => V,
					get defaultValue() {
						return getGlobalDispatcher()
					},
				},
				{
					key: 'headers',
					converter: webidl.nullableConverter(webidl.converters.HeadersInit),
				},
			])

			webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'] =
				function (V) {
					if (webidl.util.Type(V) === 'Object' && !(Symbol.iterator in V)) {
						return webidl.converters.WebSocketInit(V)
					}

					return {
						protocols: webidl.converters['DOMString or sequence<DOMString>'](V),
					}
				}

			webidl.converters.WebSocketSendData = function (V) {
				if (webidl.util.Type(V) === 'Object') {
					if (isBlobLike(V)) {
						return webidl.converters.Blob(V, { strict: false })
					}

					if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
						return webidl.converters.BufferSource(V)
					}
				}

				return webidl.converters.USVString(V)
			}

			module.exports = {
				WebSocket,
			}

			/***/
		},

		/***/ 25351: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var xtend = __nccwpck_require__(80869)
			var inherits = __nccwpck_require__(39598)

			module.exports = unherit

			// Create a custom constructor which can be modified without affecting the
			// original class.
			function unherit(Super) {
				var result
				var key
				var value

				inherits(Of, Super)
				inherits(From, Of)

				// Clone values.
				result = Of.prototype

				for (key in result) {
					value = result[key]

					if (value && typeof value === 'object') {
						result[key] = 'concat' in value ? value.concat() : xtend(value)
					}
				}

				return Of

				// Constructor accepting a single argument, which itself is an `arguments`
				// object.
				function From(parameters) {
					return Super.apply(this, parameters)
				}

				// Constructor accepting variadic arguments.
				function Of() {
					if (!(this instanceof Of)) {
						return new From(arguments)
					}

					return Super.apply(this, arguments)
				}
			}

			/***/
		},

		/***/ 10617: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var visit = __nccwpck_require__(53267)

			module.exports = removePosition

			function removePosition(node, force) {
				visit(node, force ? hard : soft)
				return node
			}

			function hard(node) {
				delete node.position
			}

			function soft(node) {
				node.position = undefined
			}

			/***/
		},

		/***/ 65475: /***/ (module) => {
			'use strict'

			module.exports = convert

			function convert(test) {
				if (test == null) {
					return ok
				}

				if (typeof test === 'string') {
					return typeFactory(test)
				}

				if (typeof test === 'object') {
					return 'length' in test ? anyFactory(test) : allFactory(test)
				}

				if (typeof test === 'function') {
					return test
				}

				throw new Error('Expected function, string, or object as test')
			}

			// Utility assert each property in `test` is represented in `node`, and each
			// values are strictly equal.
			function allFactory(test) {
				return all

				function all(node) {
					var key

					for (key in test) {
						if (node[key] !== test[key]) return false
					}

					return true
				}
			}

			function anyFactory(tests) {
				var checks = []
				var index = -1

				while (++index < tests.length) {
					checks[index] = convert(tests[index])
				}

				return any

				function any() {
					var index = -1

					while (++index < checks.length) {
						if (checks[index].apply(this, arguments)) {
							return true
						}
					}

					return false
				}
			}

			// Utility to convert a string into a function which checks a given nodes type
			// for said string.
			function typeFactory(test) {
				return type

				function type(node) {
					return Boolean(node && node.type === test)
				}
			}

			// Utility to return true.
			function ok() {
				return true
			}

			/***/
		},

		/***/ 8692: /***/ (module) => {
			module.exports = color
			function color(d) {
				return '\u001B[33m' + d + '\u001B[39m'
			}

			/***/
		},

		/***/ 56035: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			module.exports = visitParents

			var convert = __nccwpck_require__(65475)
			var color = __nccwpck_require__(8692)

			var CONTINUE = true
			var SKIP = 'skip'
			var EXIT = false

			visitParents.CONTINUE = CONTINUE
			visitParents.SKIP = SKIP
			visitParents.EXIT = EXIT

			function visitParents(tree, test, visitor, reverse) {
				var step
				var is

				if (typeof test === 'function' && typeof visitor !== 'function') {
					reverse = visitor
					visitor = test
					test = null
				}

				is = convert(test)
				step = reverse ? -1 : 1

				factory(tree, null, [])()

				function factory(node, index, parents) {
					var value = typeof node === 'object' && node !== null ? node : {}
					var name

					if (typeof value.type === 'string') {
						name =
							typeof value.tagName === 'string'
								? value.tagName
								: typeof value.name === 'string'
									? value.name
									: undefined

						visit.displayName =
							'node (' +
							color(value.type + (name ? '<' + name + '>' : '')) +
							')'
					}

					return visit

					function visit() {
						var grandparents = parents.concat(node)
						var result = []
						var subresult
						var offset

						if (!test || is(node, index, parents[parents.length - 1] || null)) {
							result = toResult(visitor(node, parents))

							if (result[0] === EXIT) {
								return result
							}
						}

						if (node.children && result[0] !== SKIP) {
							offset = (reverse ? node.children.length : -1) + step

							while (offset > -1 && offset < node.children.length) {
								subresult = factory(
									node.children[offset],
									offset,
									grandparents,
								)()

								if (subresult[0] === EXIT) {
									return subresult
								}

								offset =
									typeof subresult[1] === 'number'
										? subresult[1]
										: offset + step
							}
						}

						return result
					}
				}
			}

			function toResult(value) {
				if (value !== null && typeof value === 'object' && 'length' in value) {
					return value
				}

				if (typeof value === 'number') {
					return [CONTINUE, value]
				}

				return [value]
			}

			/***/
		},

		/***/ 53267: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			module.exports = visit

			var visitParents = __nccwpck_require__(56035)

			var CONTINUE = visitParents.CONTINUE
			var SKIP = visitParents.SKIP
			var EXIT = visitParents.EXIT

			visit.CONTINUE = CONTINUE
			visit.SKIP = SKIP
			visit.EXIT = EXIT

			function visit(tree, test, visitor, reverse) {
				if (typeof test === 'function' && typeof visitor !== 'function') {
					reverse = visitor
					visitor = test
					test = null
				}

				visitParents(tree, test, overload, reverse)

				function overload(node, parents) {
					var parent = parents[parents.length - 1]
					var index = parent ? parent.children.indexOf(node) : null
					return visitor(node, index, parent)
				}
			}

			/***/
		},

		/***/ 34808: /***/ (module) => {
			'use strict'

			module.exports = factory

			function factory(file) {
				var value = String(file)
				var indices = []
				var search = /\r?\n|\r/g

				while (search.exec(value)) {
					indices.push(search.lastIndex)
				}

				indices.push(value.length + 1)

				return {
					toPoint: offsetToPoint,
					toPosition: offsetToPoint,
					toOffset: pointToOffset,
				}

				// Get the line and column-based `point` for `offset` in the bound indices.
				function offsetToPoint(offset) {
					var index = -1

					if (offset > -1 && offset < indices[indices.length - 1]) {
						while (++index < indices.length) {
							if (indices[index] > offset) {
								return {
									line: index + 1,
									column: offset - (indices[index - 1] || 0) + 1,
									offset: offset,
								}
							}
						}
					}

					return {}
				}

				// Get the `offset` for a line and column-based `point` in the bound
				// indices.
				function pointToOffset(point) {
					var line = point && point.line
					var column = point && point.column
					var offset

					if (!isNaN(line) && !isNaN(column) && line - 1 in indices) {
						offset = (indices[line - 2] || 0) + column - 1 || 0
					}

					return offset > -1 && offset < indices[indices.length - 1]
						? offset
						: -1
				}
			}

			/***/
		},

		/***/ 80869: /***/ (module) => {
			module.exports = extend

			var hasOwnProperty = Object.prototype.hasOwnProperty

			function extend() {
				var target = {}

				for (var i = 0; i < arguments.length; i++) {
					var source = arguments[i]

					for (var key in source) {
						if (hasOwnProperty.call(source, key)) {
							target[key] = source[key]
						}
					}
				}

				return target
			}

			/***/
		},

		/***/ 42613: /***/ (module) => {
			'use strict'
			module.exports = require('assert')

			/***/
		},

		/***/ 90290: /***/ (module) => {
			'use strict'
			module.exports = require('async_hooks')

			/***/
		},

		/***/ 20181: /***/ (module) => {
			'use strict'
			module.exports = require('buffer')

			/***/
		},

		/***/ 35317: /***/ (module) => {
			'use strict'
			module.exports = require('child_process')

			/***/
		},

		/***/ 64236: /***/ (module) => {
			'use strict'
			module.exports = require('console')

			/***/
		},

		/***/ 49140: /***/ (module) => {
			'use strict'
			module.exports = require('constants')

			/***/
		},

		/***/ 76982: /***/ (module) => {
			'use strict'
			module.exports = require('crypto')

			/***/
		},

		/***/ 31637: /***/ (module) => {
			'use strict'
			module.exports = require('diagnostics_channel')

			/***/
		},

		/***/ 24434: /***/ (module) => {
			'use strict'
			module.exports = require('events')

			/***/
		},

		/***/ 79896: /***/ (module) => {
			'use strict'
			module.exports = require('fs')

			/***/
		},

		/***/ 58611: /***/ (module) => {
			'use strict'
			module.exports = require('http')

			/***/
		},

		/***/ 85675: /***/ (module) => {
			'use strict'
			module.exports = require('http2')

			/***/
		},

		/***/ 65692: /***/ (module) => {
			'use strict'
			module.exports = require('https')

			/***/
		},

		/***/ 69278: /***/ (module) => {
			'use strict'
			module.exports = require('net')

			/***/
		},

		/***/ 77598: /***/ (module) => {
			'use strict'
			module.exports = require('node:crypto')

			/***/
		},

		/***/ 78474: /***/ (module) => {
			'use strict'
			module.exports = require('node:events')

			/***/
		},

		/***/ 57075: /***/ (module) => {
			'use strict'
			module.exports = require('node:stream')

			/***/
		},

		/***/ 57975: /***/ (module) => {
			'use strict'
			module.exports = require('node:util')

			/***/
		},

		/***/ 70857: /***/ (module) => {
			'use strict'
			module.exports = require('os')

			/***/
		},

		/***/ 16928: /***/ (module) => {
			'use strict'
			module.exports = require('path')

			/***/
		},

		/***/ 82987: /***/ (module) => {
			'use strict'
			module.exports = require('perf_hooks')

			/***/
		},

		/***/ 83480: /***/ (module) => {
			'use strict'
			module.exports = require('querystring')

			/***/
		},

		/***/ 2203: /***/ (module) => {
			'use strict'
			module.exports = require('stream')

			/***/
		},

		/***/ 63774: /***/ (module) => {
			'use strict'
			module.exports = require('stream/web')

			/***/
		},

		/***/ 13193: /***/ (module) => {
			'use strict'
			module.exports = require('string_decoder')

			/***/
		},

		/***/ 53557: /***/ (module) => {
			'use strict'
			module.exports = require('timers')

			/***/
		},

		/***/ 64756: /***/ (module) => {
			'use strict'
			module.exports = require('tls')

			/***/
		},

		/***/ 52018: /***/ (module) => {
			'use strict'
			module.exports = require('tty')

			/***/
		},

		/***/ 87016: /***/ (module) => {
			'use strict'
			module.exports = require('url')

			/***/
		},

		/***/ 39023: /***/ (module) => {
			'use strict'
			module.exports = require('util')

			/***/
		},

		/***/ 98253: /***/ (module) => {
			'use strict'
			module.exports = require('util/types')

			/***/
		},

		/***/ 28167: /***/ (module) => {
			'use strict'
			module.exports = require('worker_threads')

			/***/
		},

		/***/ 43106: /***/ (module) => {
			'use strict'
			module.exports = require('zlib')

			/***/
		},

		/***/ 90147: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', { value: true })

			var picocolors = __nccwpck_require__(57336)
			var jsTokens = __nccwpck_require__(85756)
			var helperValidatorIdentifier = __nccwpck_require__(76599)

			function isColorSupported() {
				return typeof process === 'object' &&
					(process.env.FORCE_COLOR === '0' ||
						process.env.FORCE_COLOR === 'false')
					? false
					: picocolors.isColorSupported
			}
			const compose = (f, g) => (v) => f(g(v))
			function buildDefs(colors) {
				return {
					keyword: colors.cyan,
					capitalized: colors.yellow,
					jsxIdentifier: colors.yellow,
					punctuator: colors.yellow,
					number: colors.magenta,
					string: colors.green,
					regex: colors.magenta,
					comment: colors.gray,
					invalid: compose(compose(colors.white, colors.bgRed), colors.bold),
					gutter: colors.gray,
					marker: compose(colors.red, colors.bold),
					message: compose(colors.red, colors.bold),
					reset: colors.reset,
				}
			}
			const defsOn = buildDefs(picocolors.createColors(true))
			const defsOff = buildDefs(picocolors.createColors(false))
			function getDefs(enabled) {
				return enabled ? defsOn : defsOff
			}

			const sometimesKeywords = new Set([
				'as',
				'async',
				'from',
				'get',
				'of',
				'set',
			])
			const NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/
			const BRACKET = /^[()[\]{}]$/
			let tokenize
			{
				const JSX_TAG = /^[a-z][\w-]*$/i
				const getTokenType = function (token, offset, text) {
					if (token.type === 'name') {
						if (
							helperValidatorIdentifier.isKeyword(token.value) ||
							helperValidatorIdentifier.isStrictReservedWord(
								token.value,
								true,
							) ||
							sometimesKeywords.has(token.value)
						) {
							return 'keyword'
						}
						if (
							JSX_TAG.test(token.value) &&
							(text[offset - 1] === '<' ||
								text.slice(offset - 2, offset) === '</')
						) {
							return 'jsxIdentifier'
						}
						if (token.value[0] !== token.value[0].toLowerCase()) {
							return 'capitalized'
						}
					}
					if (token.type === 'punctuator' && BRACKET.test(token.value)) {
						return 'bracket'
					}
					if (
						token.type === 'invalid' &&
						(token.value === '@' || token.value === '#')
					) {
						return 'punctuator'
					}
					return token.type
				}
				tokenize = function* (text) {
					let match
					while ((match = jsTokens.default.exec(text))) {
						const token = jsTokens.matchToToken(match)
						yield {
							type: getTokenType(token, match.index, text),
							value: token.value,
						}
					}
				}
			}
			function highlight(text) {
				if (text === '') return ''
				const defs = getDefs(true)
				let highlighted = ''
				for (const { type, value } of tokenize(text)) {
					if (type in defs) {
						highlighted += value
							.split(NEWLINE$1)
							.map((str) => defs[type](str))
							.join('\n')
					} else {
						highlighted += value
					}
				}
				return highlighted
			}

			let deprecationWarningShown = false
			const NEWLINE = /\r\n|[\n\r\u2028\u2029]/
			function getMarkerLines(loc, source, opts) {
				const startLoc = Object.assign(
					{
						column: 0,
						line: -1,
					},
					loc.start,
				)
				const endLoc = Object.assign({}, startLoc, loc.end)
				const { linesAbove = 2, linesBelow = 3 } = opts || {}
				const startLine = startLoc.line
				const startColumn = startLoc.column
				const endLine = endLoc.line
				const endColumn = endLoc.column
				let start = Math.max(startLine - (linesAbove + 1), 0)
				let end = Math.min(source.length, endLine + linesBelow)
				if (startLine === -1) {
					start = 0
				}
				if (endLine === -1) {
					end = source.length
				}
				const lineDiff = endLine - startLine
				const markerLines = {}
				if (lineDiff) {
					for (let i = 0; i <= lineDiff; i++) {
						const lineNumber = i + startLine
						if (!startColumn) {
							markerLines[lineNumber] = true
						} else if (i === 0) {
							const sourceLength = source[lineNumber - 1].length
							markerLines[lineNumber] = [
								startColumn,
								sourceLength - startColumn + 1,
							]
						} else if (i === lineDiff) {
							markerLines[lineNumber] = [0, endColumn]
						} else {
							const sourceLength = source[lineNumber - i].length
							markerLines[lineNumber] = [0, sourceLength]
						}
					}
				} else {
					if (startColumn === endColumn) {
						if (startColumn) {
							markerLines[startLine] = [startColumn, 0]
						} else {
							markerLines[startLine] = true
						}
					} else {
						markerLines[startLine] = [startColumn, endColumn - startColumn]
					}
				}
				return {
					start,
					end,
					markerLines,
				}
			}
			function codeFrameColumns(rawLines, loc, opts = {}) {
				const shouldHighlight =
					opts.forceColor || (isColorSupported() && opts.highlightCode)
				const defs = getDefs(shouldHighlight)
				const lines = rawLines.split(NEWLINE)
				const { start, end, markerLines } = getMarkerLines(loc, lines, opts)
				const hasColumns = loc.start && typeof loc.start.column === 'number'
				const numberMaxWidth = String(end).length
				const highlightedLines = shouldHighlight
					? highlight(rawLines)
					: rawLines
				let frame = highlightedLines
					.split(NEWLINE, end)
					.slice(start, end)
					.map((line, index) => {
						const number = start + 1 + index
						const paddedNumber = ` ${number}`.slice(-numberMaxWidth)
						const gutter = ` ${paddedNumber} |`
						const hasMarker = markerLines[number]
						const lastMarkerLine = !markerLines[number + 1]
						if (hasMarker) {
							let markerLine = ''
							if (Array.isArray(hasMarker)) {
								const markerSpacing = line
									.slice(0, Math.max(hasMarker[0] - 1, 0))
									.replace(/[^\t]/g, ' ')
								const numberOfMarkers = hasMarker[1] || 1
								markerLine = [
									'\n ',
									defs.gutter(gutter.replace(/\d/g, ' ')),
									' ',
									markerSpacing,
									defs.marker('^').repeat(numberOfMarkers),
								].join('')
								if (lastMarkerLine && opts.message) {
									markerLine += ' ' + defs.message(opts.message)
								}
							}
							return [
								defs.marker('>'),
								defs.gutter(gutter),
								line.length > 0 ? ` ${line}` : '',
								markerLine,
							].join('')
						} else {
							return ` ${defs.gutter(gutter)}${line.length > 0 ? ` ${line}` : ''}`
						}
					})
					.join('\n')
				if (opts.message && !hasColumns) {
					frame = `${' '.repeat(numberMaxWidth + 1)}${opts.message}\n${frame}`
				}
				if (shouldHighlight) {
					return defs.reset(frame)
				} else {
					return frame
				}
			}
			function index(rawLines, lineNumber, colNumber, opts = {}) {
				if (!deprecationWarningShown) {
					deprecationWarningShown = true
					const message =
						'Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.'
					if (process.emitWarning) {
						process.emitWarning(message, 'DeprecationWarning')
					} else {
						const deprecationError = new Error(message)
						deprecationError.name = 'DeprecationWarning'
						console.warn(new Error(message))
					}
				}
				colNumber = Math.max(colNumber, 0)
				const location = {
					start: {
						column: colNumber,
						line: lineNumber,
					},
				}
				return codeFrameColumns(rawLines, location, opts)
			}

			exports.codeFrameColumns = codeFrameColumns
			exports['default'] = index
			exports.highlight = highlight
			//# sourceMappingURL=index.js.map

			/***/
		},

		/***/ 11669: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = void 0
			class Buffer {
				constructor(map, indentChar) {
					this._map = null
					this._buf = ''
					this._str = ''
					this._appendCount = 0
					this._last = 0
					this._queue = []
					this._queueCursor = 0
					this._canMarkIdName = true
					this._indentChar = ''
					this._fastIndentations = []
					this._position = {
						line: 1,
						column: 0,
					}
					this._sourcePosition = {
						identifierName: undefined,
						identifierNamePos: undefined,
						line: undefined,
						column: undefined,
						filename: undefined,
					}
					this._map = map
					this._indentChar = indentChar
					for (let i = 0; i < 64; i++) {
						this._fastIndentations.push(indentChar.repeat(i))
					}
					this._allocQueue()
				}
				_allocQueue() {
					const queue = this._queue
					for (let i = 0; i < 16; i++) {
						queue.push({
							char: 0,
							repeat: 1,
							line: undefined,
							column: undefined,
							identifierName: undefined,
							identifierNamePos: undefined,
							filename: '',
						})
					}
				}
				_pushQueue(char, repeat, line, column, filename) {
					const cursor = this._queueCursor
					if (cursor === this._queue.length) {
						this._allocQueue()
					}
					const item = this._queue[cursor]
					item.char = char
					item.repeat = repeat
					item.line = line
					item.column = column
					item.filename = filename
					this._queueCursor++
				}
				_popQueue() {
					if (this._queueCursor === 0) {
						throw new Error('Cannot pop from empty queue')
					}
					return this._queue[--this._queueCursor]
				}
				get() {
					this._flush()
					const map = this._map
					const result = {
						code: (this._buf + this._str).trimRight(),
						decodedMap: map == null ? void 0 : map.getDecoded(),
						get __mergedMap() {
							return this.map
						},
						get map() {
							const resultMap = map ? map.get() : null
							result.map = resultMap
							return resultMap
						},
						set map(value) {
							Object.defineProperty(result, 'map', {
								value,
								writable: true,
							})
						},
						get rawMappings() {
							const mappings = map == null ? void 0 : map.getRawMappings()
							result.rawMappings = mappings
							return mappings
						},
						set rawMappings(value) {
							Object.defineProperty(result, 'rawMappings', {
								value,
								writable: true,
							})
						},
					}
					return result
				}
				append(str, maybeNewline) {
					this._flush()
					this._append(str, this._sourcePosition, maybeNewline)
				}
				appendChar(char) {
					this._flush()
					this._appendChar(char, 1, this._sourcePosition)
				}
				queue(char) {
					if (char === 10) {
						while (this._queueCursor !== 0) {
							const char = this._queue[this._queueCursor - 1].char
							if (char !== 32 && char !== 9) {
								break
							}
							this._queueCursor--
						}
					}
					const sourcePosition = this._sourcePosition
					this._pushQueue(
						char,
						1,
						sourcePosition.line,
						sourcePosition.column,
						sourcePosition.filename,
					)
				}
				queueIndentation(repeat) {
					if (repeat === 0) return
					this._pushQueue(-1, repeat, undefined, undefined, undefined)
				}
				_flush() {
					const queueCursor = this._queueCursor
					const queue = this._queue
					for (let i = 0; i < queueCursor; i++) {
						const item = queue[i]
						this._appendChar(item.char, item.repeat, item)
					}
					this._queueCursor = 0
				}
				_appendChar(char, repeat, sourcePos) {
					this._last = char
					if (char === -1) {
						const fastIndentation = this._fastIndentations[repeat]
						if (fastIndentation !== undefined) {
							this._str += fastIndentation
						} else {
							this._str +=
								repeat > 1 ? this._indentChar.repeat(repeat) : this._indentChar
						}
					} else {
						this._str +=
							repeat > 1
								? String.fromCharCode(char).repeat(repeat)
								: String.fromCharCode(char)
					}
					if (char !== 10) {
						this._mark(
							sourcePos.line,
							sourcePos.column,
							sourcePos.identifierName,
							sourcePos.identifierNamePos,
							sourcePos.filename,
						)
						this._position.column += repeat
					} else {
						this._position.line++
						this._position.column = 0
					}
					if (this._canMarkIdName) {
						sourcePos.identifierName = undefined
						sourcePos.identifierNamePos = undefined
					}
				}
				_append(str, sourcePos, maybeNewline) {
					const len = str.length
					const position = this._position
					this._last = str.charCodeAt(len - 1)
					if (++this._appendCount > 4096) {
						;+this._str
						this._buf += this._str
						this._str = str
						this._appendCount = 0
					} else {
						this._str += str
					}
					if (!maybeNewline && !this._map) {
						position.column += len
						return
					}
					const { column, identifierName, identifierNamePos, filename } =
						sourcePos
					let line = sourcePos.line
					if (
						(identifierName != null || identifierNamePos != null) &&
						this._canMarkIdName
					) {
						sourcePos.identifierName = undefined
						sourcePos.identifierNamePos = undefined
					}
					let i = str.indexOf('\n')
					let last = 0
					if (i !== 0) {
						this._mark(
							line,
							column,
							identifierName,
							identifierNamePos,
							filename,
						)
					}
					while (i !== -1) {
						position.line++
						position.column = 0
						last = i + 1
						if (last < len && line !== undefined) {
							this._mark(++line, 0, null, null, filename)
						}
						i = str.indexOf('\n', last)
					}
					position.column += len - last
				}
				_mark(line, column, identifierName, identifierNamePos, filename) {
					var _this$_map
					;(_this$_map = this._map) == null ||
						_this$_map.mark(
							this._position,
							line,
							column,
							identifierName,
							identifierNamePos,
							filename,
						)
				}
				removeTrailingNewline() {
					const queueCursor = this._queueCursor
					if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 10) {
						this._queueCursor--
					}
				}
				removeLastSemicolon() {
					const queueCursor = this._queueCursor
					if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 59) {
						this._queueCursor--
					}
				}
				getLastChar() {
					const queueCursor = this._queueCursor
					return queueCursor !== 0
						? this._queue[queueCursor - 1].char
						: this._last
				}
				getNewlineCount() {
					const queueCursor = this._queueCursor
					let count = 0
					if (queueCursor === 0) return this._last === 10 ? 1 : 0
					for (let i = queueCursor - 1; i >= 0; i--) {
						if (this._queue[i].char !== 10) {
							break
						}
						count++
					}
					return count === queueCursor && this._last === 10 ? count + 1 : count
				}
				endsWithCharAndNewline() {
					const queue = this._queue
					const queueCursor = this._queueCursor
					if (queueCursor !== 0) {
						const lastCp = queue[queueCursor - 1].char
						if (lastCp !== 10) return
						if (queueCursor > 1) {
							return queue[queueCursor - 2].char
						} else {
							return this._last
						}
					}
				}
				hasContent() {
					return this._queueCursor !== 0 || !!this._last
				}
				exactSource(loc, cb) {
					if (!this._map) {
						cb()
						return
					}
					this.source('start', loc)
					const identifierName = loc.identifierName
					const sourcePos = this._sourcePosition
					if (identifierName) {
						this._canMarkIdName = false
						sourcePos.identifierName = identifierName
					}
					cb()
					if (identifierName) {
						this._canMarkIdName = true
						sourcePos.identifierName = undefined
						sourcePos.identifierNamePos = undefined
					}
					this.source('end', loc)
				}
				source(prop, loc) {
					if (!this._map) return
					this._normalizePosition(prop, loc, 0)
				}
				sourceWithOffset(prop, loc, columnOffset) {
					if (!this._map) return
					this._normalizePosition(prop, loc, columnOffset)
				}
				_normalizePosition(prop, loc, columnOffset) {
					const pos = loc[prop]
					const target = this._sourcePosition
					if (pos) {
						target.line = pos.line
						target.column = Math.max(pos.column + columnOffset, 0)
						target.filename = loc.filename
					}
				}
				getCurrentColumn() {
					const queue = this._queue
					const queueCursor = this._queueCursor
					let lastIndex = -1
					let len = 0
					for (let i = 0; i < queueCursor; i++) {
						const item = queue[i]
						if (item.char === 10) {
							lastIndex = len
						}
						len += item.repeat
					}
					return lastIndex === -1
						? this._position.column + len
						: len - 1 - lastIndex
				}
				getCurrentLine() {
					let count = 0
					const queue = this._queue
					for (let i = 0; i < this._queueCursor; i++) {
						if (queue[i].char === 10) {
							count++
						}
					}
					return this._position.line + count
				}
			}
			exports['default'] = Buffer

			//# sourceMappingURL=buffer.js.map

			/***/
		},

		/***/ 82933: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.BlockStatement = BlockStatement
			exports.Directive = Directive
			exports.DirectiveLiteral = DirectiveLiteral
			exports.File = File
			exports.InterpreterDirective = InterpreterDirective
			exports.Placeholder = Placeholder
			exports.Program = Program
			function File(node) {
				if (node.program) {
					this.print(node.program.interpreter)
				}
				this.print(node.program)
			}
			function Program(node) {
				var _node$directives
				this.noIndentInnerCommentsHere()
				this.printInnerComments()
				const directivesLen =
					(_node$directives = node.directives) == null
						? void 0
						: _node$directives.length
				if (directivesLen) {
					var _node$directives$trai
					const newline = node.body.length ? 2 : 1
					this.printSequence(node.directives, undefined, newline)
					if (
						!(
							(_node$directives$trai =
								node.directives[directivesLen - 1].trailingComments) != null &&
							_node$directives$trai.length
						)
					) {
						this.newline(newline)
					}
				}
				this.printSequence(node.body)
			}
			function BlockStatement(node) {
				var _node$directives2
				this.tokenChar(123)
				const exit = this.enterDelimited()
				const directivesLen =
					(_node$directives2 = node.directives) == null
						? void 0
						: _node$directives2.length
				if (directivesLen) {
					var _node$directives$trai2
					const newline = node.body.length ? 2 : 1
					this.printSequence(node.directives, true, newline)
					if (
						!(
							(_node$directives$trai2 =
								node.directives[directivesLen - 1].trailingComments) != null &&
							_node$directives$trai2.length
						)
					) {
						this.newline(newline)
					}
				}
				this.printSequence(node.body, true)
				exit()
				this.rightBrace(node)
			}
			function Directive(node) {
				this.print(node.value)
				this.semicolon()
			}
			const unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/
			const unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/
			function DirectiveLiteral(node) {
				const raw = this.getPossibleRaw(node)
				if (!this.format.minified && raw !== undefined) {
					this.token(raw)
					return
				}
				const { value } = node
				if (!unescapedDoubleQuoteRE.test(value)) {
					this.token(`"${value}"`)
				} else if (!unescapedSingleQuoteRE.test(value)) {
					this.token(`'${value}'`)
				} else {
					throw new Error(
						'Malformed AST: it is not possible to print a directive containing' +
							' both unescaped single and double quotes.',
					)
				}
			}
			function InterpreterDirective(node) {
				this.token(`#!${node.value}`)
				this.newline(1, true)
			}
			function Placeholder(node) {
				this.token('%%')
				this.print(node.name)
				this.token('%%')
				if (node.expectedNode === 'Statement') {
					this.semicolon()
				}
			}

			//# sourceMappingURL=base.js.map

			/***/
		},

		/***/ 70926: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.ClassAccessorProperty = ClassAccessorProperty
			exports.ClassBody = ClassBody
			exports.ClassExpression = exports.ClassDeclaration = ClassDeclaration
			exports.ClassMethod = ClassMethod
			exports.ClassPrivateMethod = ClassPrivateMethod
			exports.ClassPrivateProperty = ClassPrivateProperty
			exports.ClassProperty = ClassProperty
			exports.StaticBlock = StaticBlock
			exports._classMethodHead = _classMethodHead
			var _t = __nccwpck_require__(16535)
			const { isExportDefaultDeclaration, isExportNamedDeclaration } = _t
			function ClassDeclaration(node, parent) {
				const inExport =
					isExportDefaultDeclaration(parent) || isExportNamedDeclaration(parent)
				if (!inExport || !this._shouldPrintDecoratorsBeforeExport(parent)) {
					this.printJoin(node.decorators)
				}
				if (node.declare) {
					this.word('declare')
					this.space()
				}
				if (node.abstract) {
					this.word('abstract')
					this.space()
				}
				this.word('class')
				if (node.id) {
					this.space()
					this.print(node.id)
				}
				this.print(node.typeParameters)
				if (node.superClass) {
					this.space()
					this.word('extends')
					this.space()
					this.print(node.superClass)
					this.print(node.superTypeParameters)
				}
				if (node.implements) {
					this.space()
					this.word('implements')
					this.space()
					this.printList(node.implements)
				}
				this.space()
				this.print(node.body)
			}
			function ClassBody(node) {
				this.tokenChar(123)
				if (node.body.length === 0) {
					this.tokenChar(125)
				} else {
					this.newline()
					const separator = classBodyEmptySemicolonsPrinter(this, node)
					separator == null || separator(-1)
					const exit = this.enterDelimited()
					this.printJoin(node.body, true, true, separator, true)
					exit()
					if (!this.endsWith(10)) this.newline()
					this.rightBrace(node)
				}
			}
			function classBodyEmptySemicolonsPrinter(printer, node) {
				if (!printer.tokenMap || node.start == null || node.end == null) {
					return null
				}
				const indexes = printer.tokenMap.getIndexes(node)
				if (!indexes) return null
				let k = 1
				let occurrenceCount = 0
				let nextLocIndex = 0
				const advanceNextLocIndex = () => {
					while (
						nextLocIndex < node.body.length &&
						node.body[nextLocIndex].start == null
					) {
						nextLocIndex++
					}
				}
				advanceNextLocIndex()
				return (i) => {
					if (nextLocIndex <= i) {
						nextLocIndex = i + 1
						advanceNextLocIndex()
					}
					const end =
						nextLocIndex === node.body.length
							? node.end
							: node.body[nextLocIndex].start
					let tok
					while (
						k < indexes.length &&
						printer.tokenMap.matchesOriginal(
							(tok = printer._tokens[indexes[k]]),
							';',
						) &&
						tok.start < end
					) {
						printer.token(';', undefined, occurrenceCount++)
						k++
					}
				}
			}
			function ClassProperty(node) {
				this.printJoin(node.decorators)
				if (!node.static && !this.format.preserveFormat) {
					var _node$key$loc
					const endLine =
						(_node$key$loc = node.key.loc) == null ||
						(_node$key$loc = _node$key$loc.end) == null
							? void 0
							: _node$key$loc.line
					if (endLine) this.catchUp(endLine)
				}
				this.tsPrintClassMemberModifiers(node)
				if (node.computed) {
					this.tokenChar(91)
					this.print(node.key)
					this.tokenChar(93)
				} else {
					this._variance(node)
					this.print(node.key)
				}
				if (node.optional) {
					this.tokenChar(63)
				}
				if (node.definite) {
					this.tokenChar(33)
				}
				this.print(node.typeAnnotation)
				if (node.value) {
					this.space()
					this.tokenChar(61)
					this.space()
					this.print(node.value)
				}
				this.semicolon()
			}
			function ClassAccessorProperty(node) {
				var _node$key$loc2
				this.printJoin(node.decorators)
				const endLine =
					(_node$key$loc2 = node.key.loc) == null ||
					(_node$key$loc2 = _node$key$loc2.end) == null
						? void 0
						: _node$key$loc2.line
				if (endLine) this.catchUp(endLine)
				this.tsPrintClassMemberModifiers(node)
				this.word('accessor', true)
				this.space()
				if (node.computed) {
					this.tokenChar(91)
					this.print(node.key)
					this.tokenChar(93)
				} else {
					this._variance(node)
					this.print(node.key)
				}
				if (node.optional) {
					this.tokenChar(63)
				}
				if (node.definite) {
					this.tokenChar(33)
				}
				this.print(node.typeAnnotation)
				if (node.value) {
					this.space()
					this.tokenChar(61)
					this.space()
					this.print(node.value)
				}
				this.semicolon()
			}
			function ClassPrivateProperty(node) {
				this.printJoin(node.decorators)
				this.tsPrintClassMemberModifiers(node)
				this.print(node.key)
				if (node.optional) {
					this.tokenChar(63)
				}
				if (node.definite) {
					this.tokenChar(33)
				}
				this.print(node.typeAnnotation)
				if (node.value) {
					this.space()
					this.tokenChar(61)
					this.space()
					this.print(node.value)
				}
				this.semicolon()
			}
			function ClassMethod(node) {
				this._classMethodHead(node)
				this.space()
				this.print(node.body)
			}
			function ClassPrivateMethod(node) {
				this._classMethodHead(node)
				this.space()
				this.print(node.body)
			}
			function _classMethodHead(node) {
				this.printJoin(node.decorators)
				if (!this.format.preserveFormat) {
					var _node$key$loc3
					const endLine =
						(_node$key$loc3 = node.key.loc) == null ||
						(_node$key$loc3 = _node$key$loc3.end) == null
							? void 0
							: _node$key$loc3.line
					if (endLine) this.catchUp(endLine)
				}
				this.tsPrintClassMemberModifiers(node)
				this._methodHead(node)
			}
			function StaticBlock(node) {
				this.word('static')
				this.space()
				this.tokenChar(123)
				if (node.body.length === 0) {
					this.tokenChar(125)
				} else {
					this.newline()
					this.printSequence(node.body, true)
					this.rightBrace(node)
				}
			}

			//# sourceMappingURL=classes.js.map

			/***/
		},

		/***/ 60617: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.addDeprecatedGenerators = addDeprecatedGenerators
			function addDeprecatedGenerators(PrinterClass) {
				{
					const deprecatedBabel7Generators = {
						Noop() {},
						TSExpressionWithTypeArguments(node) {
							this.print(node.expression)
							this.print(node.typeParameters)
						},
						DecimalLiteral(node) {
							const raw = this.getPossibleRaw(node)
							if (!this.format.minified && raw !== undefined) {
								this.word(raw)
								return
							}
							this.word(node.value + 'm')
						},
					}
					Object.assign(PrinterClass.prototype, deprecatedBabel7Generators)
				}
			}

			//# sourceMappingURL=deprecated.js.map

			/***/
		},

		/***/ 33361: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.LogicalExpression =
				exports.BinaryExpression =
				exports.AssignmentExpression =
					AssignmentExpression
			exports.AssignmentPattern = AssignmentPattern
			exports.AwaitExpression = AwaitExpression
			exports.BindExpression = BindExpression
			exports.CallExpression = CallExpression
			exports.ConditionalExpression = ConditionalExpression
			exports.Decorator = Decorator
			exports.DoExpression = DoExpression
			exports.EmptyStatement = EmptyStatement
			exports.ExpressionStatement = ExpressionStatement
			exports.Import = Import
			exports.MemberExpression = MemberExpression
			exports.MetaProperty = MetaProperty
			exports.ModuleExpression = ModuleExpression
			exports.NewExpression = NewExpression
			exports.OptionalCallExpression = OptionalCallExpression
			exports.OptionalMemberExpression = OptionalMemberExpression
			exports.ParenthesizedExpression = ParenthesizedExpression
			exports.PrivateName = PrivateName
			exports.SequenceExpression = SequenceExpression
			exports.Super = Super
			exports.ThisExpression = ThisExpression
			exports.UnaryExpression = UnaryExpression
			exports.UpdateExpression = UpdateExpression
			exports.V8IntrinsicIdentifier = V8IntrinsicIdentifier
			exports.YieldExpression = YieldExpression
			exports._shouldPrintDecoratorsBeforeExport =
				_shouldPrintDecoratorsBeforeExport
			var _t = __nccwpck_require__(16535)
			var _index = __nccwpck_require__(95460)
			const {
				isCallExpression,
				isLiteral,
				isMemberExpression,
				isNewExpression,
				isPattern,
			} = _t
			function UnaryExpression(node) {
				const { operator } = node
				if (
					operator === 'void' ||
					operator === 'delete' ||
					operator === 'typeof' ||
					operator === 'throw'
				) {
					this.word(operator)
					this.space()
				} else {
					this.token(operator)
				}
				this.print(node.argument)
			}
			function DoExpression(node) {
				if (node.async) {
					this.word('async', true)
					this.space()
				}
				this.word('do')
				this.space()
				this.print(node.body)
			}
			function ParenthesizedExpression(node) {
				this.tokenChar(40)
				const exit = this.enterDelimited()
				this.print(node.expression)
				exit()
				this.rightParens(node)
			}
			function UpdateExpression(node) {
				if (node.prefix) {
					this.token(node.operator)
					this.print(node.argument)
				} else {
					this.print(node.argument, true)
					this.token(node.operator)
				}
			}
			function ConditionalExpression(node) {
				this.print(node.test)
				this.space()
				this.tokenChar(63)
				this.space()
				this.print(node.consequent)
				this.space()
				this.tokenChar(58)
				this.space()
				this.print(node.alternate)
			}
			function NewExpression(node, parent) {
				this.word('new')
				this.space()
				this.print(node.callee)
				if (
					this.format.minified &&
					node.arguments.length === 0 &&
					!node.optional &&
					!isCallExpression(parent, {
						callee: node,
					}) &&
					!isMemberExpression(parent) &&
					!isNewExpression(parent)
				) {
					return
				}
				this.print(node.typeArguments)
				{
					this.print(node.typeParameters)
				}
				if (node.optional) {
					this.token('?.')
				}
				if (
					node.arguments.length === 0 &&
					this.tokenMap &&
					!this.tokenMap.endMatches(node, ')')
				) {
					return
				}
				this.tokenChar(40)
				const exit = this.enterDelimited()
				this.printList(node.arguments, this.shouldPrintTrailingComma(')'))
				exit()
				this.rightParens(node)
			}
			function SequenceExpression(node) {
				this.printList(node.expressions)
			}
			function ThisExpression() {
				this.word('this')
			}
			function Super() {
				this.word('super')
			}
			function _shouldPrintDecoratorsBeforeExport(node) {
				if (typeof this.format.decoratorsBeforeExport === 'boolean') {
					return this.format.decoratorsBeforeExport
				}
				return (
					typeof node.start === 'number' &&
					node.start === node.declaration.start
				)
			}
			function Decorator(node) {
				this.tokenChar(64)
				this.print(node.expression)
				this.newline()
			}
			function OptionalMemberExpression(node) {
				let { computed } = node
				const { optional, property } = node
				this.print(node.object)
				if (!computed && isMemberExpression(property)) {
					throw new TypeError(
						'Got a MemberExpression for MemberExpression property',
					)
				}
				if (isLiteral(property) && typeof property.value === 'number') {
					computed = true
				}
				if (optional) {
					this.token('?.')
				}
				if (computed) {
					this.tokenChar(91)
					this.print(property)
					this.tokenChar(93)
				} else {
					if (!optional) {
						this.tokenChar(46)
					}
					this.print(property)
				}
			}
			function OptionalCallExpression(node) {
				this.print(node.callee)
				{
					this.print(node.typeParameters)
				}
				if (node.optional) {
					this.token('?.')
				}
				this.print(node.typeArguments)
				this.tokenChar(40)
				const exit = this.enterDelimited()
				this.printList(node.arguments)
				exit()
				this.rightParens(node)
			}
			function CallExpression(node) {
				this.print(node.callee)
				this.print(node.typeArguments)
				{
					this.print(node.typeParameters)
				}
				this.tokenChar(40)
				const exit = this.enterDelimited()
				this.printList(node.arguments, this.shouldPrintTrailingComma(')'))
				exit()
				this.rightParens(node)
			}
			function Import() {
				this.word('import')
			}
			function AwaitExpression(node) {
				this.word('await')
				if (node.argument) {
					this.space()
					this.printTerminatorless(node.argument)
				}
			}
			function YieldExpression(node) {
				this.word('yield', true)
				if (node.delegate) {
					this.tokenChar(42)
					if (node.argument) {
						this.space()
						this.print(node.argument)
					}
				} else {
					if (node.argument) {
						this.space()
						this.printTerminatorless(node.argument)
					}
				}
			}
			function EmptyStatement() {
				this.semicolon(true)
			}
			function ExpressionStatement(node) {
				this.tokenContext |= _index.TokenContext.expressionStatement
				this.print(node.expression)
				this.semicolon()
			}
			function AssignmentPattern(node) {
				this.print(node.left)
				if (node.left.type === 'Identifier' || isPattern(node.left)) {
					if (node.left.optional) this.tokenChar(63)
					this.print(node.left.typeAnnotation)
				}
				this.space()
				this.tokenChar(61)
				this.space()
				this.print(node.right)
			}
			function AssignmentExpression(node) {
				this.print(node.left)
				this.space()
				if (node.operator === 'in' || node.operator === 'instanceof') {
					this.word(node.operator)
				} else {
					this.token(node.operator)
					this._endsWithDiv = node.operator === '/'
				}
				this.space()
				this.print(node.right)
			}
			function BindExpression(node) {
				this.print(node.object)
				this.token('::')
				this.print(node.callee)
			}
			function MemberExpression(node) {
				this.print(node.object)
				if (!node.computed && isMemberExpression(node.property)) {
					throw new TypeError(
						'Got a MemberExpression for MemberExpression property',
					)
				}
				let computed = node.computed
				if (
					isLiteral(node.property) &&
					typeof node.property.value === 'number'
				) {
					computed = true
				}
				if (computed) {
					const exit = this.enterDelimited()
					this.tokenChar(91)
					this.print(node.property)
					this.tokenChar(93)
					exit()
				} else {
					this.tokenChar(46)
					this.print(node.property)
				}
			}
			function MetaProperty(node) {
				this.print(node.meta)
				this.tokenChar(46)
				this.print(node.property)
			}
			function PrivateName(node) {
				this.tokenChar(35)
				this.print(node.id)
			}
			function V8IntrinsicIdentifier(node) {
				this.tokenChar(37)
				this.word(node.name)
			}
			function ModuleExpression(node) {
				this.word('module', true)
				this.space()
				this.tokenChar(123)
				this.indent()
				const { body } = node
				if (body.body.length || body.directives.length) {
					this.newline()
				}
				this.print(body)
				this.dedent()
				this.rightBrace(node)
			}

			//# sourceMappingURL=expressions.js.map

			/***/
		},

		/***/ 88408: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.AnyTypeAnnotation = AnyTypeAnnotation
			exports.ArrayTypeAnnotation = ArrayTypeAnnotation
			exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation
			exports.BooleanTypeAnnotation = BooleanTypeAnnotation
			exports.DeclareClass = DeclareClass
			exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration
			exports.DeclareExportDeclaration = DeclareExportDeclaration
			exports.DeclareFunction = DeclareFunction
			exports.DeclareInterface = DeclareInterface
			exports.DeclareModule = DeclareModule
			exports.DeclareModuleExports = DeclareModuleExports
			exports.DeclareOpaqueType = DeclareOpaqueType
			exports.DeclareTypeAlias = DeclareTypeAlias
			exports.DeclareVariable = DeclareVariable
			exports.DeclaredPredicate = DeclaredPredicate
			exports.EmptyTypeAnnotation = EmptyTypeAnnotation
			exports.EnumBooleanBody = EnumBooleanBody
			exports.EnumBooleanMember = EnumBooleanMember
			exports.EnumDeclaration = EnumDeclaration
			exports.EnumDefaultedMember = EnumDefaultedMember
			exports.EnumNumberBody = EnumNumberBody
			exports.EnumNumberMember = EnumNumberMember
			exports.EnumStringBody = EnumStringBody
			exports.EnumStringMember = EnumStringMember
			exports.EnumSymbolBody = EnumSymbolBody
			exports.ExistsTypeAnnotation = ExistsTypeAnnotation
			exports.FunctionTypeAnnotation = FunctionTypeAnnotation
			exports.FunctionTypeParam = FunctionTypeParam
			exports.IndexedAccessType = IndexedAccessType
			exports.InferredPredicate = InferredPredicate
			exports.InterfaceDeclaration = InterfaceDeclaration
			exports.GenericTypeAnnotation =
				exports.ClassImplements =
				exports.InterfaceExtends =
					InterfaceExtends
			exports.InterfaceTypeAnnotation = InterfaceTypeAnnotation
			exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation
			exports.MixedTypeAnnotation = MixedTypeAnnotation
			exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation
			exports.NullableTypeAnnotation = NullableTypeAnnotation
			Object.defineProperty(exports, 'NumberLiteralTypeAnnotation', {
				enumerable: true,
				get: function () {
					return _types2.NumericLiteral
				},
			})
			exports.NumberTypeAnnotation = NumberTypeAnnotation
			exports.ObjectTypeAnnotation = ObjectTypeAnnotation
			exports.ObjectTypeCallProperty = ObjectTypeCallProperty
			exports.ObjectTypeIndexer = ObjectTypeIndexer
			exports.ObjectTypeInternalSlot = ObjectTypeInternalSlot
			exports.ObjectTypeProperty = ObjectTypeProperty
			exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty
			exports.OpaqueType = OpaqueType
			exports.OptionalIndexedAccessType = OptionalIndexedAccessType
			exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier
			Object.defineProperty(exports, 'StringLiteralTypeAnnotation', {
				enumerable: true,
				get: function () {
					return _types2.StringLiteral
				},
			})
			exports.StringTypeAnnotation = StringTypeAnnotation
			exports.SymbolTypeAnnotation = SymbolTypeAnnotation
			exports.ThisTypeAnnotation = ThisTypeAnnotation
			exports.TupleTypeAnnotation = TupleTypeAnnotation
			exports.TypeAlias = TypeAlias
			exports.TypeAnnotation = TypeAnnotation
			exports.TypeCastExpression = TypeCastExpression
			exports.TypeParameter = TypeParameter
			exports.TypeParameterDeclaration = exports.TypeParameterInstantiation =
				TypeParameterInstantiation
			exports.TypeofTypeAnnotation = TypeofTypeAnnotation
			exports.UnionTypeAnnotation = UnionTypeAnnotation
			exports.Variance = Variance
			exports.VoidTypeAnnotation = VoidTypeAnnotation
			exports._interfaceish = _interfaceish
			exports._variance = _variance
			var _t = __nccwpck_require__(16535)
			var _modules = __nccwpck_require__(24119)
			var _index = __nccwpck_require__(95460)
			var _types2 = __nccwpck_require__(26659)
			const { isDeclareExportDeclaration, isStatement } = _t
			function AnyTypeAnnotation() {
				this.word('any')
			}
			function ArrayTypeAnnotation(node) {
				this.print(node.elementType, true)
				this.tokenChar(91)
				this.tokenChar(93)
			}
			function BooleanTypeAnnotation() {
				this.word('boolean')
			}
			function BooleanLiteralTypeAnnotation(node) {
				this.word(node.value ? 'true' : 'false')
			}
			function NullLiteralTypeAnnotation() {
				this.word('null')
			}
			function DeclareClass(node, parent) {
				if (!isDeclareExportDeclaration(parent)) {
					this.word('declare')
					this.space()
				}
				this.word('class')
				this.space()
				this._interfaceish(node)
			}
			function DeclareFunction(node, parent) {
				if (!isDeclareExportDeclaration(parent)) {
					this.word('declare')
					this.space()
				}
				this.word('function')
				this.space()
				this.print(node.id)
				this.print(node.id.typeAnnotation.typeAnnotation)
				if (node.predicate) {
					this.space()
					this.print(node.predicate)
				}
				this.semicolon()
			}
			function InferredPredicate() {
				this.tokenChar(37)
				this.word('checks')
			}
			function DeclaredPredicate(node) {
				this.tokenChar(37)
				this.word('checks')
				this.tokenChar(40)
				this.print(node.value)
				this.tokenChar(41)
			}
			function DeclareInterface(node) {
				this.word('declare')
				this.space()
				this.InterfaceDeclaration(node)
			}
			function DeclareModule(node) {
				this.word('declare')
				this.space()
				this.word('module')
				this.space()
				this.print(node.id)
				this.space()
				this.print(node.body)
			}
			function DeclareModuleExports(node) {
				this.word('declare')
				this.space()
				this.word('module')
				this.tokenChar(46)
				this.word('exports')
				this.print(node.typeAnnotation)
			}
			function DeclareTypeAlias(node) {
				this.word('declare')
				this.space()
				this.TypeAlias(node)
			}
			function DeclareOpaqueType(node, parent) {
				if (!isDeclareExportDeclaration(parent)) {
					this.word('declare')
					this.space()
				}
				this.OpaqueType(node)
			}
			function DeclareVariable(node, parent) {
				if (!isDeclareExportDeclaration(parent)) {
					this.word('declare')
					this.space()
				}
				this.word('var')
				this.space()
				this.print(node.id)
				this.print(node.id.typeAnnotation)
				this.semicolon()
			}
			function DeclareExportDeclaration(node) {
				this.word('declare')
				this.space()
				this.word('export')
				this.space()
				if (node.default) {
					this.word('default')
					this.space()
				}
				FlowExportDeclaration.call(this, node)
			}
			function DeclareExportAllDeclaration(node) {
				this.word('declare')
				this.space()
				_modules.ExportAllDeclaration.call(this, node)
			}
			function EnumDeclaration(node) {
				const { id, body } = node
				this.word('enum')
				this.space()
				this.print(id)
				this.print(body)
			}
			function enumExplicitType(context, name, hasExplicitType) {
				if (hasExplicitType) {
					context.space()
					context.word('of')
					context.space()
					context.word(name)
				}
				context.space()
			}
			function enumBody(context, node) {
				const { members } = node
				context.token('{')
				context.indent()
				context.newline()
				for (const member of members) {
					context.print(member)
					context.newline()
				}
				if (node.hasUnknownMembers) {
					context.token('...')
					context.newline()
				}
				context.dedent()
				context.token('}')
			}
			function EnumBooleanBody(node) {
				const { explicitType } = node
				enumExplicitType(this, 'boolean', explicitType)
				enumBody(this, node)
			}
			function EnumNumberBody(node) {
				const { explicitType } = node
				enumExplicitType(this, 'number', explicitType)
				enumBody(this, node)
			}
			function EnumStringBody(node) {
				const { explicitType } = node
				enumExplicitType(this, 'string', explicitType)
				enumBody(this, node)
			}
			function EnumSymbolBody(node) {
				enumExplicitType(this, 'symbol', true)
				enumBody(this, node)
			}
			function EnumDefaultedMember(node) {
				const { id } = node
				this.print(id)
				this.tokenChar(44)
			}
			function enumInitializedMember(context, node) {
				context.print(node.id)
				context.space()
				context.token('=')
				context.space()
				context.print(node.init)
				context.token(',')
			}
			function EnumBooleanMember(node) {
				enumInitializedMember(this, node)
			}
			function EnumNumberMember(node) {
				enumInitializedMember(this, node)
			}
			function EnumStringMember(node) {
				enumInitializedMember(this, node)
			}
			function FlowExportDeclaration(node) {
				if (node.declaration) {
					const declar = node.declaration
					this.print(declar)
					if (!isStatement(declar)) this.semicolon()
				} else {
					this.tokenChar(123)
					if (node.specifiers.length) {
						this.space()
						this.printList(node.specifiers)
						this.space()
					}
					this.tokenChar(125)
					if (node.source) {
						this.space()
						this.word('from')
						this.space()
						this.print(node.source)
					}
					this.semicolon()
				}
			}
			function ExistsTypeAnnotation() {
				this.tokenChar(42)
			}
			function FunctionTypeAnnotation(node, parent) {
				this.print(node.typeParameters)
				this.tokenChar(40)
				if (node.this) {
					this.word('this')
					this.tokenChar(58)
					this.space()
					this.print(node.this.typeAnnotation)
					if (node.params.length || node.rest) {
						this.tokenChar(44)
						this.space()
					}
				}
				this.printList(node.params)
				if (node.rest) {
					if (node.params.length) {
						this.tokenChar(44)
						this.space()
					}
					this.token('...')
					this.print(node.rest)
				}
				this.tokenChar(41)
				const type = parent == null ? void 0 : parent.type
				if (
					type != null &&
					(type === 'ObjectTypeCallProperty' ||
						type === 'ObjectTypeInternalSlot' ||
						type === 'DeclareFunction' ||
						(type === 'ObjectTypeProperty' && parent.method))
				) {
					this.tokenChar(58)
				} else {
					this.space()
					this.token('=>')
				}
				this.space()
				this.print(node.returnType)
			}
			function FunctionTypeParam(node) {
				this.print(node.name)
				if (node.optional) this.tokenChar(63)
				if (node.name) {
					this.tokenChar(58)
					this.space()
				}
				this.print(node.typeAnnotation)
			}
			function InterfaceExtends(node) {
				this.print(node.id)
				this.print(node.typeParameters, true)
			}
			function _interfaceish(node) {
				var _node$extends
				this.print(node.id)
				this.print(node.typeParameters)
				if ((_node$extends = node.extends) != null && _node$extends.length) {
					this.space()
					this.word('extends')
					this.space()
					this.printList(node.extends)
				}
				if (node.type === 'DeclareClass') {
					var _node$mixins, _node$implements
					if ((_node$mixins = node.mixins) != null && _node$mixins.length) {
						this.space()
						this.word('mixins')
						this.space()
						this.printList(node.mixins)
					}
					if (
						(_node$implements = node.implements) != null &&
						_node$implements.length
					) {
						this.space()
						this.word('implements')
						this.space()
						this.printList(node.implements)
					}
				}
				this.space()
				this.print(node.body)
			}
			function _variance(node) {
				var _node$variance
				const kind =
					(_node$variance = node.variance) == null
						? void 0
						: _node$variance.kind
				if (kind != null) {
					if (kind === 'plus') {
						this.tokenChar(43)
					} else if (kind === 'minus') {
						this.tokenChar(45)
					}
				}
			}
			function InterfaceDeclaration(node) {
				this.word('interface')
				this.space()
				this._interfaceish(node)
			}
			function andSeparator(occurrenceCount) {
				this.space()
				this.token('&', false, occurrenceCount)
				this.space()
			}
			function InterfaceTypeAnnotation(node) {
				var _node$extends2
				this.word('interface')
				if ((_node$extends2 = node.extends) != null && _node$extends2.length) {
					this.space()
					this.word('extends')
					this.space()
					this.printList(node.extends)
				}
				this.space()
				this.print(node.body)
			}
			function IntersectionTypeAnnotation(node) {
				this.printJoin(node.types, undefined, undefined, andSeparator)
			}
			function MixedTypeAnnotation() {
				this.word('mixed')
			}
			function EmptyTypeAnnotation() {
				this.word('empty')
			}
			function NullableTypeAnnotation(node) {
				this.tokenChar(63)
				this.print(node.typeAnnotation)
			}
			function NumberTypeAnnotation() {
				this.word('number')
			}
			function StringTypeAnnotation() {
				this.word('string')
			}
			function ThisTypeAnnotation() {
				this.word('this')
			}
			function TupleTypeAnnotation(node) {
				this.tokenChar(91)
				this.printList(node.types)
				this.tokenChar(93)
			}
			function TypeofTypeAnnotation(node) {
				this.word('typeof')
				this.space()
				this.print(node.argument)
			}
			function TypeAlias(node) {
				this.word('type')
				this.space()
				this.print(node.id)
				this.print(node.typeParameters)
				this.space()
				this.tokenChar(61)
				this.space()
				this.print(node.right)
				this.semicolon()
			}
			function TypeAnnotation(node, parent) {
				this.tokenChar(58)
				this.space()
				if (parent.type === 'ArrowFunctionExpression') {
					this.tokenContext |= _index.TokenContext.arrowFlowReturnType
				} else if (node.optional) {
					this.tokenChar(63)
				}
				this.print(node.typeAnnotation)
			}
			function TypeParameterInstantiation(node) {
				this.tokenChar(60)
				this.printList(node.params)
				this.tokenChar(62)
			}
			function TypeParameter(node) {
				this._variance(node)
				this.word(node.name)
				if (node.bound) {
					this.print(node.bound)
				}
				if (node.default) {
					this.space()
					this.tokenChar(61)
					this.space()
					this.print(node.default)
				}
			}
			function OpaqueType(node) {
				this.word('opaque')
				this.space()
				this.word('type')
				this.space()
				this.print(node.id)
				this.print(node.typeParameters)
				if (node.supertype) {
					this.tokenChar(58)
					this.space()
					this.print(node.supertype)
				}
				if (node.impltype) {
					this.space()
					this.tokenChar(61)
					this.space()
					this.print(node.impltype)
				}
				this.semicolon()
			}
			function ObjectTypeAnnotation(node) {
				if (node.exact) {
					this.token('{|')
				} else {
					this.tokenChar(123)
				}
				const props = [
					...node.properties,
					...(node.callProperties || []),
					...(node.indexers || []),
					...(node.internalSlots || []),
				]
				if (props.length) {
					this.newline()
					this.space()
					this.printJoin(
						props,
						true,
						true,
						undefined,
						undefined,
						function addNewlines(leading) {
							if (leading && !props[0]) return 1
						},
						() => {
							if (props.length !== 1 || node.inexact) {
								this.tokenChar(44)
								this.space()
							}
						},
					)
					this.space()
				}
				if (node.inexact) {
					this.indent()
					this.token('...')
					if (props.length) {
						this.newline()
					}
					this.dedent()
				}
				if (node.exact) {
					this.token('|}')
				} else {
					this.tokenChar(125)
				}
			}
			function ObjectTypeInternalSlot(node) {
				if (node.static) {
					this.word('static')
					this.space()
				}
				this.tokenChar(91)
				this.tokenChar(91)
				this.print(node.id)
				this.tokenChar(93)
				this.tokenChar(93)
				if (node.optional) this.tokenChar(63)
				if (!node.method) {
					this.tokenChar(58)
					this.space()
				}
				this.print(node.value)
			}
			function ObjectTypeCallProperty(node) {
				if (node.static) {
					this.word('static')
					this.space()
				}
				this.print(node.value)
			}
			function ObjectTypeIndexer(node) {
				if (node.static) {
					this.word('static')
					this.space()
				}
				this._variance(node)
				this.tokenChar(91)
				if (node.id) {
					this.print(node.id)
					this.tokenChar(58)
					this.space()
				}
				this.print(node.key)
				this.tokenChar(93)
				this.tokenChar(58)
				this.space()
				this.print(node.value)
			}
			function ObjectTypeProperty(node) {
				if (node.proto) {
					this.word('proto')
					this.space()
				}
				if (node.static) {
					this.word('static')
					this.space()
				}
				if (node.kind === 'get' || node.kind === 'set') {
					this.word(node.kind)
					this.space()
				}
				this._variance(node)
				this.print(node.key)
				if (node.optional) this.tokenChar(63)
				if (!node.method) {
					this.tokenChar(58)
					this.space()
				}
				this.print(node.value)
			}
			function ObjectTypeSpreadProperty(node) {
				this.token('...')
				this.print(node.argument)
			}
			function QualifiedTypeIdentifier(node) {
				this.print(node.qualification)
				this.tokenChar(46)
				this.print(node.id)
			}
			function SymbolTypeAnnotation() {
				this.word('symbol')
			}
			function orSeparator(occurrenceCount) {
				this.space()
				this.token('|', false, occurrenceCount)
				this.space()
			}
			function UnionTypeAnnotation(node) {
				this.printJoin(node.types, undefined, undefined, orSeparator)
			}
			function TypeCastExpression(node) {
				this.tokenChar(40)
				this.print(node.expression)
				this.print(node.typeAnnotation)
				this.tokenChar(41)
			}
			function Variance(node) {
				if (node.kind === 'plus') {
					this.tokenChar(43)
				} else {
					this.tokenChar(45)
				}
			}
			function VoidTypeAnnotation() {
				this.word('void')
			}
			function IndexedAccessType(node) {
				this.print(node.objectType, true)
				this.tokenChar(91)
				this.print(node.indexType)
				this.tokenChar(93)
			}
			function OptionalIndexedAccessType(node) {
				this.print(node.objectType)
				if (node.optional) {
					this.token('?.')
				}
				this.tokenChar(91)
				this.print(node.indexType)
				this.tokenChar(93)
			}

			//# sourceMappingURL=flow.js.map

			/***/
		},

		/***/ 39662: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			var _templateLiterals = __nccwpck_require__(97571)
			Object.keys(_templateLiterals).forEach(function (key) {
				if (key === 'default' || key === '__esModule') return
				if (key in exports && exports[key] === _templateLiterals[key]) return
				Object.defineProperty(exports, key, {
					enumerable: true,
					get: function () {
						return _templateLiterals[key]
					},
				})
			})
			var _expressions = __nccwpck_require__(33361)
			Object.keys(_expressions).forEach(function (key) {
				if (key === 'default' || key === '__esModule') return
				if (key in exports && exports[key] === _expressions[key]) return
				Object.defineProperty(exports, key, {
					enumerable: true,
					get: function () {
						return _expressions[key]
					},
				})
			})
			var _statements = __nccwpck_require__(40102)
			Object.keys(_statements).forEach(function (key) {
				if (key === 'default' || key === '__esModule') return
				if (key in exports && exports[key] === _statements[key]) return
				Object.defineProperty(exports, key, {
					enumerable: true,
					get: function () {
						return _statements[key]
					},
				})
			})
			var _classes = __nccwpck_require__(70926)
			Object.keys(_classes).forEach(function (key) {
				if (key === 'default' || key === '__esModule') return
				if (key in exports && exports[key] === _classes[key]) return
				Object.defineProperty(exports, key, {
					enumerable: true,
					get: function () {
						return _classes[key]
					},
				})
			})
			var _methods = __nccwpck_require__(31748)
			Object.keys(_methods).forEach(function (key) {
				if (key === 'default' || key === '__esModule') return
				if (key in exports && exports[key] === _methods[key]) return
				Object.defineProperty(exports, key, {
					enumerable: true,
					get: function () {
						return _methods[key]
					},
				})
			})
			var _modules = __nccwpck_require__(24119)
			Object.keys(_modules).forEach(function (key) {
				if (key === 'default' || key === '__esModule') return
				if (key in exports && exports[key] === _modules[key]) return
				Object.defineProperty(exports, key, {
					enumerable: true,
					get: function () {
						return _modules[key]
					},
				})
			})
			var _types = __nccwpck_require__(26659)
			Object.keys(_types).forEach(function (key) {
				if (key === 'default' || key === '__esModule') return
				if (key in exports && exports[key] === _types[key]) return
				Object.defineProperty(exports, key, {
					enumerable: true,
					get: function () {
						return _types[key]
					},
				})
			})
			var _flow = __nccwpck_require__(88408)
			Object.keys(_flow).forEach(function (key) {
				if (key === 'default' || key === '__esModule') return
				if (key in exports && exports[key] === _flow[key]) return
				Object.defineProperty(exports, key, {
					enumerable: true,
					get: function () {
						return _flow[key]
					},
				})
			})
			var _base = __nccwpck_require__(82933)
			Object.keys(_base).forEach(function (key) {
				if (key === 'default' || key === '__esModule') return
				if (key in exports && exports[key] === _base[key]) return
				Object.defineProperty(exports, key, {
					enumerable: true,
					get: function () {
						return _base[key]
					},
				})
			})
			var _jsx = __nccwpck_require__(27099)
			Object.keys(_jsx).forEach(function (key) {
				if (key === 'default' || key === '__esModule') return
				if (key in exports && exports[key] === _jsx[key]) return
				Object.defineProperty(exports, key, {
					enumerable: true,
					get: function () {
						return _jsx[key]
					},
				})
			})
			var _typescript = __nccwpck_require__(16975)
			Object.keys(_typescript).forEach(function (key) {
				if (key === 'default' || key === '__esModule') return
				if (key in exports && exports[key] === _typescript[key]) return
				Object.defineProperty(exports, key, {
					enumerable: true,
					get: function () {
						return _typescript[key]
					},
				})
			})

			//# sourceMappingURL=index.js.map

			/***/
		},

		/***/ 27099: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.JSXAttribute = JSXAttribute
			exports.JSXClosingElement = JSXClosingElement
			exports.JSXClosingFragment = JSXClosingFragment
			exports.JSXElement = JSXElement
			exports.JSXEmptyExpression = JSXEmptyExpression
			exports.JSXExpressionContainer = JSXExpressionContainer
			exports.JSXFragment = JSXFragment
			exports.JSXIdentifier = JSXIdentifier
			exports.JSXMemberExpression = JSXMemberExpression
			exports.JSXNamespacedName = JSXNamespacedName
			exports.JSXOpeningElement = JSXOpeningElement
			exports.JSXOpeningFragment = JSXOpeningFragment
			exports.JSXSpreadAttribute = JSXSpreadAttribute
			exports.JSXSpreadChild = JSXSpreadChild
			exports.JSXText = JSXText
			function JSXAttribute(node) {
				this.print(node.name)
				if (node.value) {
					this.tokenChar(61)
					this.print(node.value)
				}
			}
			function JSXIdentifier(node) {
				this.word(node.name)
			}
			function JSXNamespacedName(node) {
				this.print(node.namespace)
				this.tokenChar(58)
				this.print(node.name)
			}
			function JSXMemberExpression(node) {
				this.print(node.object)
				this.tokenChar(46)
				this.print(node.property)
			}
			function JSXSpreadAttribute(node) {
				this.tokenChar(123)
				this.token('...')
				this.print(node.argument)
				this.rightBrace(node)
			}
			function JSXExpressionContainer(node) {
				this.tokenChar(123)
				this.print(node.expression)
				this.rightBrace(node)
			}
			function JSXSpreadChild(node) {
				this.tokenChar(123)
				this.token('...')
				this.print(node.expression)
				this.rightBrace(node)
			}
			function JSXText(node) {
				const raw = this.getPossibleRaw(node)
				if (raw !== undefined) {
					this.token(raw, true)
				} else {
					this.token(node.value, true)
				}
			}
			function JSXElement(node) {
				const open = node.openingElement
				this.print(open)
				if (open.selfClosing) return
				this.indent()
				for (const child of node.children) {
					this.print(child)
				}
				this.dedent()
				this.print(node.closingElement)
			}
			function spaceSeparator() {
				this.space()
			}
			function JSXOpeningElement(node) {
				this.tokenChar(60)
				this.print(node.name)
				{
					if (node.typeArguments) {
						this.print(node.typeArguments)
					}
					this.print(node.typeParameters)
				}
				if (node.attributes.length > 0) {
					this.space()
					this.printJoin(node.attributes, undefined, undefined, spaceSeparator)
				}
				if (node.selfClosing) {
					this.space()
					this.tokenChar(47)
				}
				this.tokenChar(62)
			}
			function JSXClosingElement(node) {
				this.tokenChar(60)
				this.tokenChar(47)
				this.print(node.name)
				this.tokenChar(62)
			}
			function JSXEmptyExpression() {
				this.printInnerComments()
			}
			function JSXFragment(node) {
				this.print(node.openingFragment)
				this.indent()
				for (const child of node.children) {
					this.print(child)
				}
				this.dedent()
				this.print(node.closingFragment)
			}
			function JSXOpeningFragment() {
				this.tokenChar(60)
				this.tokenChar(62)
			}
			function JSXClosingFragment() {
				this.token('</')
				this.tokenChar(62)
			}

			//# sourceMappingURL=jsx.js.map

			/***/
		},

		/***/ 31748: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.ArrowFunctionExpression = ArrowFunctionExpression
			exports.FunctionDeclaration = exports.FunctionExpression =
				FunctionExpression
			exports._functionHead = _functionHead
			exports._methodHead = _methodHead
			exports._param = _param
			exports._parameters = _parameters
			exports._params = _params
			exports._predicate = _predicate
			exports._shouldPrintArrowParamsParens = _shouldPrintArrowParamsParens
			var _t = __nccwpck_require__(16535)
			var _index = __nccwpck_require__(95460)
			const { isIdentifier } = _t
			function _params(node, idNode, parentNode) {
				this.print(node.typeParameters)
				const nameInfo = _getFuncIdName.call(this, idNode, parentNode)
				if (nameInfo) {
					this.sourceIdentifierName(nameInfo.name, nameInfo.pos)
				}
				this.tokenChar(40)
				this._parameters(node.params, ')')
				const noLineTerminator = node.type === 'ArrowFunctionExpression'
				this.print(node.returnType, noLineTerminator)
				this._noLineTerminator = noLineTerminator
			}
			function _parameters(parameters, endToken) {
				const exit = this.enterDelimited()
				const trailingComma = this.shouldPrintTrailingComma(endToken)
				const paramLength = parameters.length
				for (let i = 0; i < paramLength; i++) {
					this._param(parameters[i])
					if (trailingComma || i < paramLength - 1) {
						this.token(',', null, i)
						this.space()
					}
				}
				this.token(endToken)
				exit()
			}
			function _param(parameter) {
				this.printJoin(parameter.decorators)
				this.print(parameter)
				if (parameter.optional) {
					this.tokenChar(63)
				}
				this.print(parameter.typeAnnotation)
			}
			function _methodHead(node) {
				const kind = node.kind
				const key = node.key
				if (kind === 'get' || kind === 'set') {
					this.word(kind)
					this.space()
				}
				if (node.async) {
					this.word('async', true)
					this.space()
				}
				if (kind === 'method' || kind === 'init') {
					if (node.generator) {
						this.tokenChar(42)
					}
				}
				if (node.computed) {
					this.tokenChar(91)
					this.print(key)
					this.tokenChar(93)
				} else {
					this.print(key)
				}
				if (node.optional) {
					this.tokenChar(63)
				}
				this._params(
					node,
					node.computed && node.key.type !== 'StringLiteral'
						? undefined
						: node.key,
					undefined,
				)
			}
			function _predicate(node, noLineTerminatorAfter) {
				if (node.predicate) {
					if (!node.returnType) {
						this.tokenChar(58)
					}
					this.space()
					this.print(node.predicate, noLineTerminatorAfter)
				}
			}
			function _functionHead(node, parent) {
				if (node.async) {
					this.word('async')
					if (!this.format.preserveFormat) {
						this._endsWithInnerRaw = false
					}
					this.space()
				}
				this.word('function')
				if (node.generator) {
					if (!this.format.preserveFormat) {
						this._endsWithInnerRaw = false
					}
					this.tokenChar(42)
				}
				this.space()
				if (node.id) {
					this.print(node.id)
				}
				this._params(node, node.id, parent)
				if (node.type !== 'TSDeclareFunction') {
					this._predicate(node)
				}
			}
			function FunctionExpression(node, parent) {
				this._functionHead(node, parent)
				this.space()
				this.print(node.body)
			}
			function ArrowFunctionExpression(node, parent) {
				if (node.async) {
					this.word('async', true)
					this.space()
				}
				if (this._shouldPrintArrowParamsParens(node)) {
					this._params(node, undefined, parent)
				} else {
					this.print(node.params[0], true)
				}
				this._predicate(node, true)
				this.space()
				this.printInnerComments()
				this.token('=>')
				this.space()
				this.tokenContext |= _index.TokenContext.arrowBody
				this.print(node.body)
			}
			function _shouldPrintArrowParamsParens(node) {
				var _firstParam$leadingCo, _firstParam$trailingC
				if (node.params.length !== 1) return true
				if (node.typeParameters || node.returnType || node.predicate) {
					return true
				}
				const firstParam = node.params[0]
				if (
					!isIdentifier(firstParam) ||
					firstParam.typeAnnotation ||
					firstParam.optional ||
					((_firstParam$leadingCo = firstParam.leadingComments) != null &&
						_firstParam$leadingCo.length) ||
					((_firstParam$trailingC = firstParam.trailingComments) != null &&
						_firstParam$trailingC.length)
				) {
					return true
				}
				if (this.tokenMap) {
					if (node.loc == null) return true
					if (this.tokenMap.findMatching(node, '(') !== null) return true
					const arrowToken = this.tokenMap.findMatching(node, '=>')
					if ((arrowToken == null ? void 0 : arrowToken.loc) == null)
						return true
					return arrowToken.loc.start.line !== node.loc.start.line
				}
				if (this.format.retainLines) return true
				return false
			}
			function _getFuncIdName(idNode, parent) {
				let id = idNode
				if (!id && parent) {
					const parentType = parent.type
					if (parentType === 'VariableDeclarator') {
						id = parent.id
					} else if (
						parentType === 'AssignmentExpression' ||
						parentType === 'AssignmentPattern'
					) {
						id = parent.left
					} else if (
						parentType === 'ObjectProperty' ||
						parentType === 'ClassProperty'
					) {
						if (!parent.computed || parent.key.type === 'StringLiteral') {
							id = parent.key
						}
					} else if (
						parentType === 'ClassPrivateProperty' ||
						parentType === 'ClassAccessorProperty'
					) {
						id = parent.key
					}
				}
				if (!id) return
				let nameInfo
				if (id.type === 'Identifier') {
					var _id$loc, _id$loc2
					nameInfo = {
						pos: (_id$loc = id.loc) == null ? void 0 : _id$loc.start,
						name:
							((_id$loc2 = id.loc) == null
								? void 0
								: _id$loc2.identifierName) || id.name,
					}
				} else if (id.type === 'PrivateName') {
					var _id$loc3
					nameInfo = {
						pos: (_id$loc3 = id.loc) == null ? void 0 : _id$loc3.start,
						name: '#' + id.id.name,
					}
				} else if (id.type === 'StringLiteral') {
					var _id$loc4
					nameInfo = {
						pos: (_id$loc4 = id.loc) == null ? void 0 : _id$loc4.start,
						name: id.value,
					}
				}
				return nameInfo
			}

			//# sourceMappingURL=methods.js.map

			/***/
		},

		/***/ 24119: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.ExportAllDeclaration = ExportAllDeclaration
			exports.ExportDefaultDeclaration = ExportDefaultDeclaration
			exports.ExportDefaultSpecifier = ExportDefaultSpecifier
			exports.ExportNamedDeclaration = ExportNamedDeclaration
			exports.ExportNamespaceSpecifier = ExportNamespaceSpecifier
			exports.ExportSpecifier = ExportSpecifier
			exports.ImportAttribute = ImportAttribute
			exports.ImportDeclaration = ImportDeclaration
			exports.ImportDefaultSpecifier = ImportDefaultSpecifier
			exports.ImportExpression = ImportExpression
			exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier
			exports.ImportSpecifier = ImportSpecifier
			exports._printAttributes = _printAttributes
			var _t = __nccwpck_require__(16535)
			var _index = __nccwpck_require__(95460)
			const {
				isClassDeclaration,
				isExportDefaultSpecifier,
				isExportNamespaceSpecifier,
				isImportDefaultSpecifier,
				isImportNamespaceSpecifier,
				isStatement,
			} = _t
			function ImportSpecifier(node) {
				if (node.importKind === 'type' || node.importKind === 'typeof') {
					this.word(node.importKind)
					this.space()
				}
				this.print(node.imported)
				if (node.local && node.local.name !== node.imported.name) {
					this.space()
					this.word('as')
					this.space()
					this.print(node.local)
				}
			}
			function ImportDefaultSpecifier(node) {
				this.print(node.local)
			}
			function ExportDefaultSpecifier(node) {
				this.print(node.exported)
			}
			function ExportSpecifier(node) {
				if (node.exportKind === 'type') {
					this.word('type')
					this.space()
				}
				this.print(node.local)
				if (node.exported && node.local.name !== node.exported.name) {
					this.space()
					this.word('as')
					this.space()
					this.print(node.exported)
				}
			}
			function ExportNamespaceSpecifier(node) {
				this.tokenChar(42)
				this.space()
				this.word('as')
				this.space()
				this.print(node.exported)
			}
			let warningShown = false
			function _printAttributes(node, hasPreviousBrace) {
				var _node$extra
				const { importAttributesKeyword } = this.format
				const { attributes, assertions } = node
				if (
					attributes &&
					!importAttributesKeyword &&
					node.extra &&
					(node.extra.deprecatedAssertSyntax ||
						node.extra.deprecatedWithLegacySyntax) &&
					!warningShown
				) {
					warningShown = true
					console.warn(`\
You are using import attributes, without specifying the desired output syntax.
Please specify the "importAttributesKeyword" generator option, whose value can be one of:
 - "with"        : \`import { a } from "b" with { type: "json" };\`
 - "assert"      : \`import { a } from "b" assert { type: "json" };\`
 - "with-legacy" : \`import { a } from "b" with type: "json";\`
`)
				}
				const useAssertKeyword =
					importAttributesKeyword === 'assert' ||
					(!importAttributesKeyword && assertions)
				this.word(useAssertKeyword ? 'assert' : 'with')
				this.space()
				if (
					!useAssertKeyword &&
					(importAttributesKeyword === 'with-legacy' ||
						(!importAttributesKeyword &&
							(_node$extra = node.extra) != null &&
							_node$extra.deprecatedWithLegacySyntax))
				) {
					this.printList(attributes || assertions)
					return
				}
				const occurrenceCount = hasPreviousBrace ? 1 : 0
				this.token('{', null, occurrenceCount)
				this.space()
				this.printList(
					attributes || assertions,
					this.shouldPrintTrailingComma('}'),
				)
				this.space()
				this.token('}', null, occurrenceCount)
			}
			function ExportAllDeclaration(node) {
				var _node$attributes, _node$assertions
				this.word('export')
				this.space()
				if (node.exportKind === 'type') {
					this.word('type')
					this.space()
				}
				this.tokenChar(42)
				this.space()
				this.word('from')
				this.space()
				if (
					((_node$attributes = node.attributes) != null &&
						_node$attributes.length) ||
					((_node$assertions = node.assertions) != null &&
						_node$assertions.length)
				) {
					this.print(node.source, true)
					this.space()
					this._printAttributes(node, false)
				} else {
					this.print(node.source)
				}
				this.semicolon()
			}
			function maybePrintDecoratorsBeforeExport(printer, node) {
				if (
					isClassDeclaration(node.declaration) &&
					printer._shouldPrintDecoratorsBeforeExport(node)
				) {
					printer.printJoin(node.declaration.decorators)
				}
			}
			function ExportNamedDeclaration(node) {
				maybePrintDecoratorsBeforeExport(this, node)
				this.word('export')
				this.space()
				if (node.declaration) {
					const declar = node.declaration
					this.print(declar)
					if (!isStatement(declar)) this.semicolon()
				} else {
					if (node.exportKind === 'type') {
						this.word('type')
						this.space()
					}
					const specifiers = node.specifiers.slice(0)
					let hasSpecial = false
					for (;;) {
						const first = specifiers[0]
						if (
							isExportDefaultSpecifier(first) ||
							isExportNamespaceSpecifier(first)
						) {
							hasSpecial = true
							this.print(specifiers.shift())
							if (specifiers.length) {
								this.tokenChar(44)
								this.space()
							}
						} else {
							break
						}
					}
					let hasBrace = false
					if (specifiers.length || (!specifiers.length && !hasSpecial)) {
						hasBrace = true
						this.tokenChar(123)
						if (specifiers.length) {
							this.space()
							this.printList(specifiers, this.shouldPrintTrailingComma('}'))
							this.space()
						}
						this.tokenChar(125)
					}
					if (node.source) {
						var _node$attributes2, _node$assertions2
						this.space()
						this.word('from')
						this.space()
						if (
							((_node$attributes2 = node.attributes) != null &&
								_node$attributes2.length) ||
							((_node$assertions2 = node.assertions) != null &&
								_node$assertions2.length)
						) {
							this.print(node.source, true)
							this.space()
							this._printAttributes(node, hasBrace)
						} else {
							this.print(node.source)
						}
					}
					this.semicolon()
				}
			}
			function ExportDefaultDeclaration(node) {
				maybePrintDecoratorsBeforeExport(this, node)
				this.word('export')
				this.noIndentInnerCommentsHere()
				this.space()
				this.word('default')
				this.space()
				this.tokenContext |= _index.TokenContext.exportDefault
				const declar = node.declaration
				this.print(declar)
				if (!isStatement(declar)) this.semicolon()
			}
			function ImportDeclaration(node) {
				var _node$attributes3, _node$assertions3
				this.word('import')
				this.space()
				const isTypeKind =
					node.importKind === 'type' || node.importKind === 'typeof'
				if (isTypeKind) {
					this.noIndentInnerCommentsHere()
					this.word(node.importKind)
					this.space()
				} else if (node.module) {
					this.noIndentInnerCommentsHere()
					this.word('module')
					this.space()
				} else if (node.phase) {
					this.noIndentInnerCommentsHere()
					this.word(node.phase)
					this.space()
				}
				const specifiers = node.specifiers.slice(0)
				const hasSpecifiers = !!specifiers.length
				while (hasSpecifiers) {
					const first = specifiers[0]
					if (
						isImportDefaultSpecifier(first) ||
						isImportNamespaceSpecifier(first)
					) {
						this.print(specifiers.shift())
						if (specifiers.length) {
							this.tokenChar(44)
							this.space()
						}
					} else {
						break
					}
				}
				let hasBrace = false
				if (specifiers.length) {
					hasBrace = true
					this.tokenChar(123)
					this.space()
					this.printList(specifiers, this.shouldPrintTrailingComma('}'))
					this.space()
					this.tokenChar(125)
				} else if (isTypeKind && !hasSpecifiers) {
					hasBrace = true
					this.tokenChar(123)
					this.tokenChar(125)
				}
				if (hasSpecifiers || isTypeKind) {
					this.space()
					this.word('from')
					this.space()
				}
				if (
					((_node$attributes3 = node.attributes) != null &&
						_node$attributes3.length) ||
					((_node$assertions3 = node.assertions) != null &&
						_node$assertions3.length)
				) {
					this.print(node.source, true)
					this.space()
					this._printAttributes(node, hasBrace)
				} else {
					this.print(node.source)
				}
				this.semicolon()
			}
			function ImportAttribute(node) {
				this.print(node.key)
				this.tokenChar(58)
				this.space()
				this.print(node.value)
			}
			function ImportNamespaceSpecifier(node) {
				this.tokenChar(42)
				this.space()
				this.word('as')
				this.space()
				this.print(node.local)
			}
			function ImportExpression(node) {
				this.word('import')
				if (node.phase) {
					this.tokenChar(46)
					this.word(node.phase)
				}
				this.tokenChar(40)
				this.print(node.source)
				if (node.options != null) {
					this.tokenChar(44)
					this.space()
					this.print(node.options)
				}
				this.tokenChar(41)
			}

			//# sourceMappingURL=modules.js.map

			/***/
		},

		/***/ 40102: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.BreakStatement = BreakStatement
			exports.CatchClause = CatchClause
			exports.ContinueStatement = ContinueStatement
			exports.DebuggerStatement = DebuggerStatement
			exports.DoWhileStatement = DoWhileStatement
			exports.ForOfStatement = exports.ForInStatement = void 0
			exports.ForStatement = ForStatement
			exports.IfStatement = IfStatement
			exports.LabeledStatement = LabeledStatement
			exports.ReturnStatement = ReturnStatement
			exports.SwitchCase = SwitchCase
			exports.SwitchStatement = SwitchStatement
			exports.ThrowStatement = ThrowStatement
			exports.TryStatement = TryStatement
			exports.VariableDeclaration = VariableDeclaration
			exports.VariableDeclarator = VariableDeclarator
			exports.WhileStatement = WhileStatement
			exports.WithStatement = WithStatement
			var _t = __nccwpck_require__(16535)
			var _index = __nccwpck_require__(95460)
			const { isFor, isForStatement, isIfStatement, isStatement } = _t
			function WithStatement(node) {
				this.word('with')
				this.space()
				this.tokenChar(40)
				this.print(node.object)
				this.tokenChar(41)
				this.printBlock(node)
			}
			function IfStatement(node) {
				this.word('if')
				this.space()
				this.tokenChar(40)
				this.print(node.test)
				this.tokenChar(41)
				this.space()
				const needsBlock =
					node.alternate && isIfStatement(getLastStatement(node.consequent))
				if (needsBlock) {
					this.tokenChar(123)
					this.newline()
					this.indent()
				}
				this.printAndIndentOnComments(node.consequent)
				if (needsBlock) {
					this.dedent()
					this.newline()
					this.tokenChar(125)
				}
				if (node.alternate) {
					if (this.endsWith(125)) this.space()
					this.word('else')
					this.space()
					this.printAndIndentOnComments(node.alternate)
				}
			}
			function getLastStatement(statement) {
				const { body } = statement
				if (isStatement(body) === false) {
					return statement
				}
				return getLastStatement(body)
			}
			function ForStatement(node) {
				this.word('for')
				this.space()
				this.tokenChar(40)
				{
					const exit = this.enterForStatementInit()
					this.tokenContext |= _index.TokenContext.forHead
					this.print(node.init)
					exit()
				}
				this.tokenChar(59)
				if (node.test) {
					this.space()
					this.print(node.test)
				}
				this.token(';', false, 1)
				if (node.update) {
					this.space()
					this.print(node.update)
				}
				this.tokenChar(41)
				this.printBlock(node)
			}
			function WhileStatement(node) {
				this.word('while')
				this.space()
				this.tokenChar(40)
				this.print(node.test)
				this.tokenChar(41)
				this.printBlock(node)
			}
			function ForXStatement(node) {
				this.word('for')
				this.space()
				const isForOf = node.type === 'ForOfStatement'
				if (isForOf && node.await) {
					this.word('await')
					this.space()
				}
				this.noIndentInnerCommentsHere()
				this.tokenChar(40)
				{
					const exit = isForOf ? null : this.enterForStatementInit()
					this.tokenContext |= isForOf
						? _index.TokenContext.forOfHead
						: _index.TokenContext.forInHead
					this.print(node.left)
					exit == null || exit()
				}
				this.space()
				this.word(isForOf ? 'of' : 'in')
				this.space()
				this.print(node.right)
				this.tokenChar(41)
				this.printBlock(node)
			}
			const ForInStatement = (exports.ForInStatement = ForXStatement)
			const ForOfStatement = (exports.ForOfStatement = ForXStatement)
			function DoWhileStatement(node) {
				this.word('do')
				this.space()
				this.print(node.body)
				this.space()
				this.word('while')
				this.space()
				this.tokenChar(40)
				this.print(node.test)
				this.tokenChar(41)
				this.semicolon()
			}
			function printStatementAfterKeyword(printer, node) {
				if (node) {
					printer.space()
					printer.printTerminatorless(node)
				}
				printer.semicolon()
			}
			function BreakStatement(node) {
				this.word('break')
				printStatementAfterKeyword(this, node.label)
			}
			function ContinueStatement(node) {
				this.word('continue')
				printStatementAfterKeyword(this, node.label)
			}
			function ReturnStatement(node) {
				this.word('return')
				printStatementAfterKeyword(this, node.argument)
			}
			function ThrowStatement(node) {
				this.word('throw')
				printStatementAfterKeyword(this, node.argument)
			}
			function LabeledStatement(node) {
				this.print(node.label)
				this.tokenChar(58)
				this.space()
				this.print(node.body)
			}
			function TryStatement(node) {
				this.word('try')
				this.space()
				this.print(node.block)
				this.space()
				if (node.handlers) {
					this.print(node.handlers[0])
				} else {
					this.print(node.handler)
				}
				if (node.finalizer) {
					this.space()
					this.word('finally')
					this.space()
					this.print(node.finalizer)
				}
			}
			function CatchClause(node) {
				this.word('catch')
				this.space()
				if (node.param) {
					this.tokenChar(40)
					this.print(node.param)
					this.print(node.param.typeAnnotation)
					this.tokenChar(41)
					this.space()
				}
				this.print(node.body)
			}
			function SwitchStatement(node) {
				this.word('switch')
				this.space()
				this.tokenChar(40)
				this.print(node.discriminant)
				this.tokenChar(41)
				this.space()
				this.tokenChar(123)
				this.printSequence(
					node.cases,
					true,
					undefined,
					function addNewlines(leading, cas) {
						if (!leading && node.cases[node.cases.length - 1] === cas) return -1
					},
				)
				this.rightBrace(node)
			}
			function SwitchCase(node) {
				if (node.test) {
					this.word('case')
					this.space()
					this.print(node.test)
					this.tokenChar(58)
				} else {
					this.word('default')
					this.tokenChar(58)
				}
				if (node.consequent.length) {
					this.newline()
					this.printSequence(node.consequent, true)
				}
			}
			function DebuggerStatement() {
				this.word('debugger')
				this.semicolon()
			}
			function VariableDeclaration(node, parent) {
				if (node.declare) {
					this.word('declare')
					this.space()
				}
				const { kind } = node
				if (kind === 'await using') {
					this.word('await')
					this.space()
					this.word('using', true)
				} else {
					this.word(kind, kind === 'using')
				}
				this.space()
				let hasInits = false
				if (!isFor(parent)) {
					for (const declar of node.declarations) {
						if (declar.init) {
							hasInits = true
						}
					}
				}
				this.printList(
					node.declarations,
					undefined,
					undefined,
					node.declarations.length > 1,
					hasInits
						? function (occurrenceCount) {
								this.token(',', false, occurrenceCount)
								this.newline()
							}
						: undefined,
				)
				if (isFor(parent)) {
					if (isForStatement(parent)) {
						if (parent.init === node) return
					} else {
						if (parent.left === node) return
					}
				}
				this.semicolon()
			}
			function VariableDeclarator(node) {
				this.print(node.id)
				if (node.definite) this.tokenChar(33)
				this.print(node.id.typeAnnotation)
				if (node.init) {
					this.space()
					this.tokenChar(61)
					this.space()
					this.print(node.init)
				}
			}

			//# sourceMappingURL=statements.js.map

			/***/
		},

		/***/ 97571: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.TaggedTemplateExpression = TaggedTemplateExpression
			exports.TemplateElement = TemplateElement
			exports.TemplateLiteral = TemplateLiteral
			exports._printTemplate = _printTemplate
			function TaggedTemplateExpression(node) {
				this.print(node.tag)
				{
					this.print(node.typeParameters)
				}
				this.print(node.quasi)
			}
			function TemplateElement() {
				throw new Error(
					'TemplateElement printing is handled in TemplateLiteral',
				)
			}
			function _printTemplate(node, substitutions) {
				const quasis = node.quasis
				let partRaw = '`'
				for (let i = 0; i < quasis.length - 1; i++) {
					partRaw += quasis[i].value.raw
					this.token(partRaw + '${', true)
					this.print(substitutions[i])
					partRaw = '}'
					if (this.tokenMap) {
						const token = this.tokenMap.findMatching(node, '}', i)
						if (token) this._catchUpTo(token.loc.start)
					}
				}
				partRaw += quasis[quasis.length - 1].value.raw
				this.token(partRaw + '`', true)
			}
			function TemplateLiteral(node) {
				this._printTemplate(node, node.expressions)
			}

			//# sourceMappingURL=template-literals.js.map

			/***/
		},

		/***/ 26659: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.ArgumentPlaceholder = ArgumentPlaceholder
			exports.ArrayPattern = exports.ArrayExpression = ArrayExpression
			exports.BigIntLiteral = BigIntLiteral
			exports.BooleanLiteral = BooleanLiteral
			exports.Identifier = Identifier
			exports.NullLiteral = NullLiteral
			exports.NumericLiteral = NumericLiteral
			exports.ObjectPattern = exports.ObjectExpression = ObjectExpression
			exports.ObjectMethod = ObjectMethod
			exports.ObjectProperty = ObjectProperty
			exports.PipelineBareFunction = PipelineBareFunction
			exports.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference
			exports.PipelineTopicExpression = PipelineTopicExpression
			exports.RecordExpression = RecordExpression
			exports.RegExpLiteral = RegExpLiteral
			exports.SpreadElement = exports.RestElement = RestElement
			exports.StringLiteral = StringLiteral
			exports.TopicReference = TopicReference
			exports.TupleExpression = TupleExpression
			exports._getRawIdentifier = _getRawIdentifier
			var _t = __nccwpck_require__(16535)
			var _jsesc = __nccwpck_require__(59376)
			const { isAssignmentPattern, isIdentifier } = _t
			let lastRawIdentNode = null
			let lastRawIdentResult = ''
			function _getRawIdentifier(node) {
				if (node === lastRawIdentNode) return lastRawIdentResult
				lastRawIdentNode = node
				const { name } = node
				const token = this.tokenMap.find(node, (tok) => tok.value === name)
				if (token) {
					lastRawIdentResult = this._originalCode.slice(token.start, token.end)
					return lastRawIdentResult
				}
				return (lastRawIdentResult = node.name)
			}
			function Identifier(node) {
				var _node$loc
				this.sourceIdentifierName(
					((_node$loc = node.loc) == null
						? void 0
						: _node$loc.identifierName) || node.name,
				)
				this.word(this.tokenMap ? this._getRawIdentifier(node) : node.name)
			}
			function ArgumentPlaceholder() {
				this.tokenChar(63)
			}
			function RestElement(node) {
				this.token('...')
				this.print(node.argument)
			}
			function ObjectExpression(node) {
				const props = node.properties
				this.tokenChar(123)
				if (props.length) {
					const exit = this.enterDelimited()
					this.space()
					this.printList(props, this.shouldPrintTrailingComma('}'), true, true)
					this.space()
					exit()
				}
				this.sourceWithOffset('end', node.loc, -1)
				this.tokenChar(125)
			}
			function ObjectMethod(node) {
				this.printJoin(node.decorators)
				this._methodHead(node)
				this.space()
				this.print(node.body)
			}
			function ObjectProperty(node) {
				this.printJoin(node.decorators)
				if (node.computed) {
					this.tokenChar(91)
					this.print(node.key)
					this.tokenChar(93)
				} else {
					if (
						isAssignmentPattern(node.value) &&
						isIdentifier(node.key) &&
						node.key.name === node.value.left.name
					) {
						this.print(node.value)
						return
					}
					this.print(node.key)
					if (
						node.shorthand &&
						isIdentifier(node.key) &&
						isIdentifier(node.value) &&
						node.key.name === node.value.name
					) {
						return
					}
				}
				this.tokenChar(58)
				this.space()
				this.print(node.value)
			}
			function ArrayExpression(node) {
				const elems = node.elements
				const len = elems.length
				this.tokenChar(91)
				const exit = this.enterDelimited()
				for (let i = 0; i < elems.length; i++) {
					const elem = elems[i]
					if (elem) {
						if (i > 0) this.space()
						this.print(elem)
						if (i < len - 1 || this.shouldPrintTrailingComma(']')) {
							this.token(',', false, i)
						}
					} else {
						this.token(',', false, i)
					}
				}
				exit()
				this.tokenChar(93)
			}
			function RecordExpression(node) {
				const props = node.properties
				let startToken
				let endToken
				{
					if (this.format.recordAndTupleSyntaxType === 'bar') {
						startToken = '{|'
						endToken = '|}'
					} else if (
						this.format.recordAndTupleSyntaxType !== 'hash' &&
						this.format.recordAndTupleSyntaxType != null
					) {
						throw new Error(
							`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`,
						)
					} else {
						startToken = '#{'
						endToken = '}'
					}
				}
				this.token(startToken)
				if (props.length) {
					this.space()
					this.printList(
						props,
						this.shouldPrintTrailingComma(endToken),
						true,
						true,
					)
					this.space()
				}
				this.token(endToken)
			}
			function TupleExpression(node) {
				const elems = node.elements
				const len = elems.length
				let startToken
				let endToken
				{
					if (this.format.recordAndTupleSyntaxType === 'bar') {
						startToken = '[|'
						endToken = '|]'
					} else if (this.format.recordAndTupleSyntaxType === 'hash') {
						startToken = '#['
						endToken = ']'
					} else {
						throw new Error(
							`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`,
						)
					}
				}
				this.token(startToken)
				for (let i = 0; i < elems.length; i++) {
					const elem = elems[i]
					if (elem) {
						if (i > 0) this.space()
						this.print(elem)
						if (i < len - 1 || this.shouldPrintTrailingComma(endToken)) {
							this.token(',', false, i)
						}
					}
				}
				this.token(endToken)
			}
			function RegExpLiteral(node) {
				this.word(`/${node.pattern}/${node.flags}`)
			}
			function BooleanLiteral(node) {
				this.word(node.value ? 'true' : 'false')
			}
			function NullLiteral() {
				this.word('null')
			}
			function NumericLiteral(node) {
				const raw = this.getPossibleRaw(node)
				const opts = this.format.jsescOption
				const value = node.value
				const str = value + ''
				if (opts.numbers) {
					this.number(_jsesc(value, opts), value)
				} else if (raw == null) {
					this.number(str, value)
				} else if (this.format.minified) {
					this.number(raw.length < str.length ? raw : str, value)
				} else {
					this.number(raw, value)
				}
			}
			function StringLiteral(node) {
				const raw = this.getPossibleRaw(node)
				if (!this.format.minified && raw !== undefined) {
					this.token(raw)
					return
				}
				const val = _jsesc(node.value, this.format.jsescOption)
				this.token(val)
			}
			function BigIntLiteral(node) {
				const raw = this.getPossibleRaw(node)
				if (!this.format.minified && raw !== undefined) {
					this.word(raw)
					return
				}
				this.word(node.value + 'n')
			}
			const validTopicTokenSet = new Set(['^^', '@@', '^', '%', '#'])
			function TopicReference() {
				const { topicToken } = this.format
				if (validTopicTokenSet.has(topicToken)) {
					this.token(topicToken)
				} else {
					const givenTopicTokenJSON = JSON.stringify(topicToken)
					const validTopics = Array.from(validTopicTokenSet, (v) =>
						JSON.stringify(v),
					)
					throw new Error(
						`The "topicToken" generator option must be one of ` +
							`${validTopics.join(', ')} (${givenTopicTokenJSON} received instead).`,
					)
				}
			}
			function PipelineTopicExpression(node) {
				this.print(node.expression)
			}
			function PipelineBareFunction(node) {
				this.print(node.callee)
			}
			function PipelinePrimaryTopicReference() {
				this.tokenChar(35)
			}

			//# sourceMappingURL=types.js.map

			/***/
		},

		/***/ 16975: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.TSAnyKeyword = TSAnyKeyword
			exports.TSArrayType = TSArrayType
			exports.TSSatisfiesExpression = exports.TSAsExpression = TSTypeExpression
			exports.TSBigIntKeyword = TSBigIntKeyword
			exports.TSBooleanKeyword = TSBooleanKeyword
			exports.TSCallSignatureDeclaration = TSCallSignatureDeclaration
			exports.TSInterfaceHeritage = exports.TSClassImplements =
				TSClassImplements
			exports.TSConditionalType = TSConditionalType
			exports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration
			exports.TSConstructorType = TSConstructorType
			exports.TSDeclareFunction = TSDeclareFunction
			exports.TSDeclareMethod = TSDeclareMethod
			exports.TSEnumBody = TSEnumBody
			exports.TSEnumDeclaration = TSEnumDeclaration
			exports.TSEnumMember = TSEnumMember
			exports.TSExportAssignment = TSExportAssignment
			exports.TSExternalModuleReference = TSExternalModuleReference
			exports.TSFunctionType = TSFunctionType
			exports.TSImportEqualsDeclaration = TSImportEqualsDeclaration
			exports.TSImportType = TSImportType
			exports.TSIndexSignature = TSIndexSignature
			exports.TSIndexedAccessType = TSIndexedAccessType
			exports.TSInferType = TSInferType
			exports.TSInstantiationExpression = TSInstantiationExpression
			exports.TSInterfaceBody = TSInterfaceBody
			exports.TSInterfaceDeclaration = TSInterfaceDeclaration
			exports.TSIntersectionType = TSIntersectionType
			exports.TSIntrinsicKeyword = TSIntrinsicKeyword
			exports.TSLiteralType = TSLiteralType
			exports.TSMappedType = TSMappedType
			exports.TSMethodSignature = TSMethodSignature
			exports.TSModuleBlock = TSModuleBlock
			exports.TSModuleDeclaration = TSModuleDeclaration
			exports.TSNamedTupleMember = TSNamedTupleMember
			exports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration
			exports.TSNeverKeyword = TSNeverKeyword
			exports.TSNonNullExpression = TSNonNullExpression
			exports.TSNullKeyword = TSNullKeyword
			exports.TSNumberKeyword = TSNumberKeyword
			exports.TSObjectKeyword = TSObjectKeyword
			exports.TSOptionalType = TSOptionalType
			exports.TSParameterProperty = TSParameterProperty
			exports.TSParenthesizedType = TSParenthesizedType
			exports.TSPropertySignature = TSPropertySignature
			exports.TSQualifiedName = TSQualifiedName
			exports.TSRestType = TSRestType
			exports.TSStringKeyword = TSStringKeyword
			exports.TSSymbolKeyword = TSSymbolKeyword
			exports.TSTemplateLiteralType = TSTemplateLiteralType
			exports.TSThisType = TSThisType
			exports.TSTupleType = TSTupleType
			exports.TSTypeAliasDeclaration = TSTypeAliasDeclaration
			exports.TSTypeAnnotation = TSTypeAnnotation
			exports.TSTypeAssertion = TSTypeAssertion
			exports.TSTypeLiteral = TSTypeLiteral
			exports.TSTypeOperator = TSTypeOperator
			exports.TSTypeParameter = TSTypeParameter
			exports.TSTypeParameterDeclaration =
				exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation
			exports.TSTypePredicate = TSTypePredicate
			exports.TSTypeQuery = TSTypeQuery
			exports.TSTypeReference = TSTypeReference
			exports.TSUndefinedKeyword = TSUndefinedKeyword
			exports.TSUnionType = TSUnionType
			exports.TSUnknownKeyword = TSUnknownKeyword
			exports.TSVoidKeyword = TSVoidKeyword
			exports.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers
			exports.tsPrintFunctionOrConstructorType =
				tsPrintFunctionOrConstructorType
			exports.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName
			exports.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase
			function TSTypeAnnotation(node, parent) {
				this.token(
					(parent.type === 'TSFunctionType' ||
						parent.type === 'TSConstructorType') &&
						parent.typeAnnotation === node
						? '=>'
						: ':',
				)
				this.space()
				if (node.optional) this.tokenChar(63)
				this.print(node.typeAnnotation)
			}
			function TSTypeParameterInstantiation(node, parent) {
				this.tokenChar(60)
				let printTrailingSeparator =
					parent.type === 'ArrowFunctionExpression' && node.params.length === 1
				if (this.tokenMap && node.start != null && node.end != null) {
					printTrailingSeparator &&
						(printTrailingSeparator = !!this.tokenMap.find(node, (t) =>
							this.tokenMap.matchesOriginal(t, ','),
						))
					printTrailingSeparator ||
						(printTrailingSeparator = this.shouldPrintTrailingComma('>'))
				}
				this.printList(node.params, printTrailingSeparator)
				this.tokenChar(62)
			}
			function TSTypeParameter(node) {
				if (node.const) {
					this.word('const')
					this.space()
				}
				if (node.in) {
					this.word('in')
					this.space()
				}
				if (node.out) {
					this.word('out')
					this.space()
				}
				this.word(node.name)
				if (node.constraint) {
					this.space()
					this.word('extends')
					this.space()
					this.print(node.constraint)
				}
				if (node.default) {
					this.space()
					this.tokenChar(61)
					this.space()
					this.print(node.default)
				}
			}
			function TSParameterProperty(node) {
				if (node.accessibility) {
					this.word(node.accessibility)
					this.space()
				}
				if (node.readonly) {
					this.word('readonly')
					this.space()
				}
				this._param(node.parameter)
			}
			function TSDeclareFunction(node, parent) {
				if (node.declare) {
					this.word('declare')
					this.space()
				}
				this._functionHead(node, parent)
				this.semicolon()
			}
			function TSDeclareMethod(node) {
				this._classMethodHead(node)
				this.semicolon()
			}
			function TSQualifiedName(node) {
				this.print(node.left)
				this.tokenChar(46)
				this.print(node.right)
			}
			function TSCallSignatureDeclaration(node) {
				this.tsPrintSignatureDeclarationBase(node)
				maybePrintTrailingCommaOrSemicolon(this, node)
			}
			function maybePrintTrailingCommaOrSemicolon(printer, node) {
				if (!printer.tokenMap || !node.start || !node.end) {
					printer.semicolon()
					return
				}
				if (printer.tokenMap.endMatches(node, ',')) {
					printer.token(',')
				} else if (printer.tokenMap.endMatches(node, ';')) {
					printer.semicolon()
				}
			}
			function TSConstructSignatureDeclaration(node) {
				this.word('new')
				this.space()
				this.tsPrintSignatureDeclarationBase(node)
				maybePrintTrailingCommaOrSemicolon(this, node)
			}
			function TSPropertySignature(node) {
				const { readonly } = node
				if (readonly) {
					this.word('readonly')
					this.space()
				}
				this.tsPrintPropertyOrMethodName(node)
				this.print(node.typeAnnotation)
				maybePrintTrailingCommaOrSemicolon(this, node)
			}
			function tsPrintPropertyOrMethodName(node) {
				if (node.computed) {
					this.tokenChar(91)
				}
				this.print(node.key)
				if (node.computed) {
					this.tokenChar(93)
				}
				if (node.optional) {
					this.tokenChar(63)
				}
			}
			function TSMethodSignature(node) {
				const { kind } = node
				if (kind === 'set' || kind === 'get') {
					this.word(kind)
					this.space()
				}
				this.tsPrintPropertyOrMethodName(node)
				this.tsPrintSignatureDeclarationBase(node)
				maybePrintTrailingCommaOrSemicolon(this, node)
			}
			function TSIndexSignature(node) {
				const { readonly, static: isStatic } = node
				if (isStatic) {
					this.word('static')
					this.space()
				}
				if (readonly) {
					this.word('readonly')
					this.space()
				}
				this.tokenChar(91)
				this._parameters(node.parameters, ']')
				this.print(node.typeAnnotation)
				maybePrintTrailingCommaOrSemicolon(this, node)
			}
			function TSAnyKeyword() {
				this.word('any')
			}
			function TSBigIntKeyword() {
				this.word('bigint')
			}
			function TSUnknownKeyword() {
				this.word('unknown')
			}
			function TSNumberKeyword() {
				this.word('number')
			}
			function TSObjectKeyword() {
				this.word('object')
			}
			function TSBooleanKeyword() {
				this.word('boolean')
			}
			function TSStringKeyword() {
				this.word('string')
			}
			function TSSymbolKeyword() {
				this.word('symbol')
			}
			function TSVoidKeyword() {
				this.word('void')
			}
			function TSUndefinedKeyword() {
				this.word('undefined')
			}
			function TSNullKeyword() {
				this.word('null')
			}
			function TSNeverKeyword() {
				this.word('never')
			}
			function TSIntrinsicKeyword() {
				this.word('intrinsic')
			}
			function TSThisType() {
				this.word('this')
			}
			function TSFunctionType(node) {
				this.tsPrintFunctionOrConstructorType(node)
			}
			function TSConstructorType(node) {
				if (node.abstract) {
					this.word('abstract')
					this.space()
				}
				this.word('new')
				this.space()
				this.tsPrintFunctionOrConstructorType(node)
			}
			function tsPrintFunctionOrConstructorType(node) {
				const { typeParameters } = node
				const parameters = node.parameters
				this.print(typeParameters)
				this.tokenChar(40)
				this._parameters(parameters, ')')
				this.space()
				const returnType = node.typeAnnotation
				this.print(returnType)
			}
			function TSTypeReference(node) {
				const typeArguments = node.typeParameters
				this.print(node.typeName, !!typeArguments)
				this.print(typeArguments)
			}
			function TSTypePredicate(node) {
				if (node.asserts) {
					this.word('asserts')
					this.space()
				}
				this.print(node.parameterName)
				if (node.typeAnnotation) {
					this.space()
					this.word('is')
					this.space()
					this.print(node.typeAnnotation.typeAnnotation)
				}
			}
			function TSTypeQuery(node) {
				this.word('typeof')
				this.space()
				this.print(node.exprName)
				const typeArguments = node.typeParameters
				if (typeArguments) {
					this.print(typeArguments)
				}
			}
			function TSTypeLiteral(node) {
				printBraced(this, node, () => this.printJoin(node.members, true, true))
			}
			function TSArrayType(node) {
				this.print(node.elementType, true)
				this.tokenChar(91)
				this.tokenChar(93)
			}
			function TSTupleType(node) {
				this.tokenChar(91)
				this.printList(node.elementTypes, this.shouldPrintTrailingComma(']'))
				this.tokenChar(93)
			}
			function TSOptionalType(node) {
				this.print(node.typeAnnotation)
				this.tokenChar(63)
			}
			function TSRestType(node) {
				this.token('...')
				this.print(node.typeAnnotation)
			}
			function TSNamedTupleMember(node) {
				this.print(node.label)
				if (node.optional) this.tokenChar(63)
				this.tokenChar(58)
				this.space()
				this.print(node.elementType)
			}
			function TSUnionType(node) {
				tsPrintUnionOrIntersectionType(this, node, '|')
			}
			function TSIntersectionType(node) {
				tsPrintUnionOrIntersectionType(this, node, '&')
			}
			function tsPrintUnionOrIntersectionType(printer, node, sep) {
				var _printer$tokenMap
				let hasLeadingToken = 0
				if (
					(_printer$tokenMap = printer.tokenMap) != null &&
					_printer$tokenMap.startMatches(node, sep)
				) {
					hasLeadingToken = 1
					printer.token(sep)
				}
				printer.printJoin(node.types, undefined, undefined, function (i) {
					this.space()
					this.token(sep, null, i + hasLeadingToken)
					this.space()
				})
			}
			function TSConditionalType(node) {
				this.print(node.checkType)
				this.space()
				this.word('extends')
				this.space()
				this.print(node.extendsType)
				this.space()
				this.tokenChar(63)
				this.space()
				this.print(node.trueType)
				this.space()
				this.tokenChar(58)
				this.space()
				this.print(node.falseType)
			}
			function TSInferType(node) {
				this.word('infer')
				this.print(node.typeParameter)
			}
			function TSParenthesizedType(node) {
				this.tokenChar(40)
				this.print(node.typeAnnotation)
				this.tokenChar(41)
			}
			function TSTypeOperator(node) {
				this.word(node.operator)
				this.space()
				this.print(node.typeAnnotation)
			}
			function TSIndexedAccessType(node) {
				this.print(node.objectType, true)
				this.tokenChar(91)
				this.print(node.indexType)
				this.tokenChar(93)
			}
			function TSMappedType(node) {
				const { nameType, optional, readonly, typeAnnotation } = node
				this.tokenChar(123)
				const exit = this.enterDelimited()
				this.space()
				if (readonly) {
					tokenIfPlusMinus(this, readonly)
					this.word('readonly')
					this.space()
				}
				this.tokenChar(91)
				{
					this.word(node.typeParameter.name)
				}
				this.space()
				this.word('in')
				this.space()
				{
					this.print(node.typeParameter.constraint)
				}
				if (nameType) {
					this.space()
					this.word('as')
					this.space()
					this.print(nameType)
				}
				this.tokenChar(93)
				if (optional) {
					tokenIfPlusMinus(this, optional)
					this.tokenChar(63)
				}
				if (typeAnnotation) {
					this.tokenChar(58)
					this.space()
					this.print(typeAnnotation)
				}
				this.space()
				exit()
				this.tokenChar(125)
			}
			function tokenIfPlusMinus(self, tok) {
				if (tok !== true) {
					self.token(tok)
				}
			}
			function TSTemplateLiteralType(node) {
				this._printTemplate(node, node.types)
			}
			function TSLiteralType(node) {
				this.print(node.literal)
			}
			function TSClassImplements(node) {
				this.print(node.expression)
				this.print(node.typeArguments)
			}
			function TSInterfaceDeclaration(node) {
				const { declare, id, typeParameters, extends: extendz, body } = node
				if (declare) {
					this.word('declare')
					this.space()
				}
				this.word('interface')
				this.space()
				this.print(id)
				this.print(typeParameters)
				if (extendz != null && extendz.length) {
					this.space()
					this.word('extends')
					this.space()
					this.printList(extendz)
				}
				this.space()
				this.print(body)
			}
			function TSInterfaceBody(node) {
				printBraced(this, node, () => this.printJoin(node.body, true, true))
			}
			function TSTypeAliasDeclaration(node) {
				const { declare, id, typeParameters, typeAnnotation } = node
				if (declare) {
					this.word('declare')
					this.space()
				}
				this.word('type')
				this.space()
				this.print(id)
				this.print(typeParameters)
				this.space()
				this.tokenChar(61)
				this.space()
				this.print(typeAnnotation)
				this.semicolon()
			}
			function TSTypeExpression(node) {
				const { type, expression, typeAnnotation } = node
				this.print(expression, true)
				this.space()
				this.word(type === 'TSAsExpression' ? 'as' : 'satisfies')
				this.space()
				this.print(typeAnnotation)
			}
			function TSTypeAssertion(node) {
				const { typeAnnotation, expression } = node
				this.tokenChar(60)
				this.print(typeAnnotation)
				this.tokenChar(62)
				this.space()
				this.print(expression)
			}
			function TSInstantiationExpression(node) {
				this.print(node.expression)
				{
					this.print(node.typeParameters)
				}
			}
			function TSEnumDeclaration(node) {
				const { declare, const: isConst, id } = node
				if (declare) {
					this.word('declare')
					this.space()
				}
				if (isConst) {
					this.word('const')
					this.space()
				}
				this.word('enum')
				this.space()
				this.print(id)
				this.space()
				{
					TSEnumBody.call(this, node)
				}
			}
			function TSEnumBody(node) {
				printBraced(this, node, () => {
					var _this$shouldPrintTrai
					return this.printList(
						node.members,
						(_this$shouldPrintTrai = this.shouldPrintTrailingComma('}')) != null
							? _this$shouldPrintTrai
							: true,
						true,
						true,
					)
				})
			}
			function TSEnumMember(node) {
				const { id, initializer } = node
				this.print(id)
				if (initializer) {
					this.space()
					this.tokenChar(61)
					this.space()
					this.print(initializer)
				}
			}
			function TSModuleDeclaration(node) {
				const { declare, id, kind } = node
				if (declare) {
					this.word('declare')
					this.space()
				}
				{
					if (!node.global) {
						this.word(
							kind != null
								? kind
								: id.type === 'Identifier'
									? 'namespace'
									: 'module',
						)
						this.space()
					}
					this.print(id)
					if (!node.body) {
						this.semicolon()
						return
					}
					let body = node.body
					while (body.type === 'TSModuleDeclaration') {
						this.tokenChar(46)
						this.print(body.id)
						body = body.body
					}
					this.space()
					this.print(body)
				}
			}
			function TSModuleBlock(node) {
				printBraced(this, node, () => this.printSequence(node.body, true))
			}
			function TSImportType(node) {
				const { argument, qualifier, options } = node
				this.word('import')
				this.tokenChar(40)
				this.print(argument)
				if (options) {
					this.tokenChar(44)
					this.print(options)
				}
				this.tokenChar(41)
				if (qualifier) {
					this.tokenChar(46)
					this.print(qualifier)
				}
				const typeArguments = node.typeParameters
				if (typeArguments) {
					this.print(typeArguments)
				}
			}
			function TSImportEqualsDeclaration(node) {
				const { id, moduleReference } = node
				if (node.isExport) {
					this.word('export')
					this.space()
				}
				this.word('import')
				this.space()
				this.print(id)
				this.space()
				this.tokenChar(61)
				this.space()
				this.print(moduleReference)
				this.semicolon()
			}
			function TSExternalModuleReference(node) {
				this.token('require(')
				this.print(node.expression)
				this.tokenChar(41)
			}
			function TSNonNullExpression(node) {
				this.print(node.expression)
				this.tokenChar(33)
			}
			function TSExportAssignment(node) {
				this.word('export')
				this.space()
				this.tokenChar(61)
				this.space()
				this.print(node.expression)
				this.semicolon()
			}
			function TSNamespaceExportDeclaration(node) {
				this.word('export')
				this.space()
				this.word('as')
				this.space()
				this.word('namespace')
				this.space()
				this.print(node.id)
				this.semicolon()
			}
			function tsPrintSignatureDeclarationBase(node) {
				const { typeParameters } = node
				const parameters = node.parameters
				this.print(typeParameters)
				this.tokenChar(40)
				this._parameters(parameters, ')')
				const returnType = node.typeAnnotation
				this.print(returnType)
			}
			function tsPrintClassMemberModifiers(node) {
				const isPrivateField = node.type === 'ClassPrivateProperty'
				const isPublicField =
					node.type === 'ClassAccessorProperty' || node.type === 'ClassProperty'
				printModifiersList(this, node, [
					isPublicField && node.declare && 'declare',
					!isPrivateField && node.accessibility,
				])
				if (node.static) {
					this.word('static')
					this.space()
				}
				printModifiersList(this, node, [
					!isPrivateField && node.abstract && 'abstract',
					!isPrivateField && node.override && 'override',
					(isPublicField || isPrivateField) && node.readonly && 'readonly',
				])
			}
			function printBraced(printer, node, cb) {
				printer.token('{')
				const exit = printer.enterDelimited()
				cb()
				exit()
				printer.rightBrace(node)
			}
			function printModifiersList(printer, node, modifiers) {
				var _printer$tokenMap2
				const modifiersSet = new Set()
				for (const modifier of modifiers) {
					if (modifier) modifiersSet.add(modifier)
				}
				;(_printer$tokenMap2 = printer.tokenMap) == null ||
					_printer$tokenMap2.find(node, (tok) => {
						if (modifiersSet.has(tok.value)) {
							printer.token(tok.value)
							printer.space()
							modifiersSet.delete(tok.value)
							return modifiersSet.size === 0
						}
					})
				for (const modifier of modifiersSet) {
					printer.word(modifier)
					printer.space()
				}
			}

			//# sourceMappingURL=typescript.js.map

			/***/
		},

		/***/ 12123: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = void 0
			exports.generate = generate
			var _sourceMap = __nccwpck_require__(18201)
			var _printer = __nccwpck_require__(81163)
			function normalizeOptions(code, opts, ast) {
				if (opts.experimental_preserveFormat) {
					if (typeof code !== 'string') {
						throw new Error(
							'`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string',
						)
					}
					if (!opts.retainLines) {
						throw new Error(
							'`experimental_preserveFormat` requires `retainLines` to be set to `true`',
						)
					}
					if (opts.compact && opts.compact !== 'auto') {
						throw new Error(
							'`experimental_preserveFormat` is not compatible with the `compact` option',
						)
					}
					if (opts.minified) {
						throw new Error(
							'`experimental_preserveFormat` is not compatible with the `minified` option',
						)
					}
					if (opts.jsescOption) {
						throw new Error(
							'`experimental_preserveFormat` is not compatible with the `jsescOption` option',
						)
					}
					if (!Array.isArray(ast.tokens)) {
						throw new Error(
							'`experimental_preserveFormat` requires the AST to have attatched the token of the input code. Make sure to enable the `tokens: true` parser option.',
						)
					}
				}
				const format = {
					auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
					auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
					shouldPrintComment: opts.shouldPrintComment,
					preserveFormat: opts.experimental_preserveFormat,
					retainLines: opts.retainLines,
					retainFunctionParens: opts.retainFunctionParens,
					comments: opts.comments == null || opts.comments,
					compact: opts.compact,
					minified: opts.minified,
					concise: opts.concise,
					indent: {
						adjustMultilineComment: true,
						style: '  ',
					},
					jsescOption: Object.assign(
						{
							quotes: 'double',
							wrap: true,
							minimal: false,
						},
						opts.jsescOption,
					),
					topicToken: opts.topicToken,
					importAttributesKeyword: opts.importAttributesKeyword,
				}
				{
					var _opts$recordAndTupleS
					format.decoratorsBeforeExport = opts.decoratorsBeforeExport
					format.jsescOption.json = opts.jsonCompatibleStrings
					format.recordAndTupleSyntaxType =
						(_opts$recordAndTupleS = opts.recordAndTupleSyntaxType) != null
							? _opts$recordAndTupleS
							: 'hash'
				}
				if (format.minified) {
					format.compact = true
					format.shouldPrintComment =
						format.shouldPrintComment || (() => format.comments)
				} else {
					format.shouldPrintComment =
						format.shouldPrintComment ||
						((value) =>
							format.comments ||
							value.includes('@license') ||
							value.includes('@preserve'))
				}
				if (format.compact === 'auto') {
					format.compact = typeof code === 'string' && code.length > 500000
					if (format.compact) {
						console.error(
							'[BABEL] Note: The code generator has deoptimised the styling of ' +
								`${opts.filename} as it exceeds the max of ${'500KB'}.`,
						)
					}
				}
				if (format.compact || format.preserveFormat) {
					format.indent.adjustMultilineComment = false
				}
				const {
					auxiliaryCommentBefore,
					auxiliaryCommentAfter,
					shouldPrintComment,
				} = format
				if (
					auxiliaryCommentBefore &&
					!shouldPrintComment(auxiliaryCommentBefore)
				) {
					format.auxiliaryCommentBefore = undefined
				}
				if (
					auxiliaryCommentAfter &&
					!shouldPrintComment(auxiliaryCommentAfter)
				) {
					format.auxiliaryCommentAfter = undefined
				}
				return format
			}
			{
				exports.CodeGenerator = class CodeGenerator {
					constructor(ast, opts = {}, code) {
						this._ast = void 0
						this._format = void 0
						this._map = void 0
						this._ast = ast
						this._format = normalizeOptions(code, opts, ast)
						this._map = opts.sourceMaps
							? new _sourceMap.default(opts, code)
							: null
					}
					generate() {
						const printer = new _printer.default(this._format, this._map)
						return printer.generate(this._ast)
					}
				}
			}
			function generate(ast, opts = {}, code) {
				const format = normalizeOptions(code, opts, ast)
				const map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null
				const printer = new _printer.default(
					format,
					map,
					ast.tokens,
					typeof code === 'string' ? code : null,
				)
				return printer.generate(ast)
			}
			var _default = (exports['default'] = generate)

			//# sourceMappingURL=index.js.map

			/***/
		},

		/***/ 95460: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.TokenContext = void 0
			exports.isLastChild = isLastChild
			exports.needsParens = needsParens
			exports.needsWhitespace = needsWhitespace
			exports.needsWhitespaceAfter = needsWhitespaceAfter
			exports.needsWhitespaceBefore = needsWhitespaceBefore
			var whitespace = __nccwpck_require__(77971)
			var parens = __nccwpck_require__(19504)
			var _t = __nccwpck_require__(16535)
			const {
				FLIPPED_ALIAS_KEYS,
				VISITOR_KEYS,
				isCallExpression,
				isDecorator,
				isExpressionStatement,
				isMemberExpression,
				isNewExpression,
				isParenthesizedExpression,
			} = _t
			const TokenContext = (exports.TokenContext = {
				expressionStatement: 1,
				arrowBody: 2,
				exportDefault: 4,
				forHead: 8,
				forInHead: 16,
				forOfHead: 32,
				arrowFlowReturnType: 64,
			})
			function expandAliases(obj) {
				const map = new Map()
				function add(type, func) {
					const fn = map.get(type)
					map.set(
						type,
						fn
							? function (node, parent, stack, inForInit, getRawIdentifier) {
									var _fn
									return (_fn = fn(
										node,
										parent,
										stack,
										inForInit,
										getRawIdentifier,
									)) != null
										? _fn
										: func(node, parent, stack, inForInit, getRawIdentifier)
								}
							: func,
					)
				}
				for (const type of Object.keys(obj)) {
					const aliases = FLIPPED_ALIAS_KEYS[type]
					if (aliases) {
						for (const alias of aliases) {
							add(alias, obj[type])
						}
					} else {
						add(type, obj[type])
					}
				}
				return map
			}
			const expandedParens = expandAliases(parens)
			const expandedWhitespaceNodes = expandAliases(whitespace.nodes)
			function isOrHasCallExpression(node) {
				if (isCallExpression(node)) {
					return true
				}
				return isMemberExpression(node) && isOrHasCallExpression(node.object)
			}
			function needsWhitespace(node, parent, type) {
				var _expandedWhitespaceNo
				if (!node) return false
				if (isExpressionStatement(node)) {
					node = node.expression
				}
				const flag =
					(_expandedWhitespaceNo = expandedWhitespaceNodes.get(node.type)) ==
					null
						? void 0
						: _expandedWhitespaceNo(node, parent)
				if (typeof flag === 'number') {
					return (flag & type) !== 0
				}
				return false
			}
			function needsWhitespaceBefore(node, parent) {
				return needsWhitespace(node, parent, 1)
			}
			function needsWhitespaceAfter(node, parent) {
				return needsWhitespace(node, parent, 2)
			}
			function needsParens(
				node,
				parent,
				tokenContext,
				inForInit,
				getRawIdentifier,
			) {
				var _expandedParens$get
				if (!parent) return false
				if (isNewExpression(parent) && parent.callee === node) {
					if (isOrHasCallExpression(node)) return true
				}
				if (isDecorator(parent)) {
					return (
						!isDecoratorMemberExpression(node) &&
						!(
							isCallExpression(node) && isDecoratorMemberExpression(node.callee)
						) &&
						!isParenthesizedExpression(node)
					)
				}
				return (_expandedParens$get = expandedParens.get(node.type)) == null
					? void 0
					: _expandedParens$get(
							node,
							parent,
							tokenContext,
							inForInit,
							getRawIdentifier,
						)
			}
			function isDecoratorMemberExpression(node) {
				switch (node.type) {
					case 'Identifier':
						return true
					case 'MemberExpression':
						return (
							!node.computed &&
							node.property.type === 'Identifier' &&
							isDecoratorMemberExpression(node.object)
						)
					default:
						return false
				}
			}
			function isLastChild(parent, child) {
				const visitorKeys = VISITOR_KEYS[parent.type]
				for (let i = visitorKeys.length - 1; i >= 0; i--) {
					const val = parent[visitorKeys[i]]
					if (val === child) {
						return true
					} else if (Array.isArray(val)) {
						let j = val.length - 1
						while (j >= 0 && val[j] === null) j--
						return j >= 0 && val[j] === child
					} else if (val) {
						return false
					}
				}
				return false
			}

			//# sourceMappingURL=index.js.map

			/***/
		},

		/***/ 19504: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.AssignmentExpression = AssignmentExpression
			exports.Binary = Binary
			exports.BinaryExpression = BinaryExpression
			exports.ClassExpression = ClassExpression
			exports.ArrowFunctionExpression = exports.ConditionalExpression =
				ConditionalExpression
			exports.DoExpression = DoExpression
			exports.FunctionExpression = FunctionExpression
			exports.FunctionTypeAnnotation = FunctionTypeAnnotation
			exports.Identifier = Identifier
			exports.LogicalExpression = LogicalExpression
			exports.NullableTypeAnnotation = NullableTypeAnnotation
			exports.ObjectExpression = ObjectExpression
			exports.OptionalIndexedAccessType = OptionalIndexedAccessType
			exports.OptionalCallExpression = exports.OptionalMemberExpression =
				OptionalMemberExpression
			exports.SequenceExpression = SequenceExpression
			exports.TSSatisfiesExpression = exports.TSAsExpression = TSAsExpression
			exports.TSConditionalType = TSConditionalType
			exports.TSConstructorType = exports.TSFunctionType = TSFunctionType
			exports.TSInferType = TSInferType
			exports.TSInstantiationExpression = TSInstantiationExpression
			exports.TSIntersectionType = TSIntersectionType
			exports.UnaryLike = exports.TSTypeAssertion = UnaryLike
			exports.TSTypeOperator = TSTypeOperator
			exports.TSUnionType = TSUnionType
			exports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation =
				UnionTypeAnnotation
			exports.UpdateExpression = UpdateExpression
			exports.AwaitExpression = exports.YieldExpression = YieldExpression
			var _t = __nccwpck_require__(16535)
			var _index = __nccwpck_require__(95460)
			const {
				isArrayTypeAnnotation,
				isBinaryExpression,
				isCallExpression,
				isForOfStatement,
				isIndexedAccessType,
				isMemberExpression,
				isObjectPattern,
				isOptionalMemberExpression,
				isYieldExpression,
				isStatement,
			} = _t
			const PRECEDENCE = new Map([
				['||', 0],
				['??', 0],
				['|>', 0],
				['&&', 1],
				['|', 2],
				['^', 3],
				['&', 4],
				['==', 5],
				['===', 5],
				['!=', 5],
				['!==', 5],
				['<', 6],
				['>', 6],
				['<=', 6],
				['>=', 6],
				['in', 6],
				['instanceof', 6],
				['>>', 7],
				['<<', 7],
				['>>>', 7],
				['+', 8],
				['-', 8],
				['*', 9],
				['/', 9],
				['%', 9],
				['**', 10],
			])
			function getBinaryPrecedence(node, nodeType) {
				if (
					nodeType === 'BinaryExpression' ||
					nodeType === 'LogicalExpression'
				) {
					return PRECEDENCE.get(node.operator)
				}
				if (
					nodeType === 'TSAsExpression' ||
					nodeType === 'TSSatisfiesExpression'
				) {
					return PRECEDENCE.get('in')
				}
			}
			function isTSTypeExpression(nodeType) {
				return (
					nodeType === 'TSAsExpression' ||
					nodeType === 'TSSatisfiesExpression' ||
					nodeType === 'TSTypeAssertion'
				)
			}
			const isClassExtendsClause = (node, parent) => {
				const parentType = parent.type
				return (
					(parentType === 'ClassDeclaration' ||
						parentType === 'ClassExpression') &&
					parent.superClass === node
				)
			}
			const hasPostfixPart = (node, parent) => {
				const parentType = parent.type
				return (
					((parentType === 'MemberExpression' ||
						parentType === 'OptionalMemberExpression') &&
						parent.object === node) ||
					((parentType === 'CallExpression' ||
						parentType === 'OptionalCallExpression' ||
						parentType === 'NewExpression') &&
						parent.callee === node) ||
					(parentType === 'TaggedTemplateExpression' && parent.tag === node) ||
					parentType === 'TSNonNullExpression'
				)
			}
			function NullableTypeAnnotation(node, parent) {
				return isArrayTypeAnnotation(parent)
			}
			function FunctionTypeAnnotation(node, parent, tokenContext) {
				const parentType = parent.type
				return (
					parentType === 'UnionTypeAnnotation' ||
					parentType === 'IntersectionTypeAnnotation' ||
					parentType === 'ArrayTypeAnnotation' ||
					Boolean(tokenContext & _index.TokenContext.arrowFlowReturnType)
				)
			}
			function UpdateExpression(node, parent) {
				return (
					hasPostfixPart(node, parent) || isClassExtendsClause(node, parent)
				)
			}
			function needsParenBeforeExpressionBrace(tokenContext) {
				return Boolean(
					tokenContext &
						(_index.TokenContext.expressionStatement |
							_index.TokenContext.arrowBody),
				)
			}
			function ObjectExpression(node, parent, tokenContext) {
				return needsParenBeforeExpressionBrace(tokenContext)
			}
			function DoExpression(node, parent, tokenContext) {
				return (
					!node.async &&
					Boolean(tokenContext & _index.TokenContext.expressionStatement)
				)
			}
			function Binary(node, parent) {
				const parentType = parent.type
				if (
					node.type === 'BinaryExpression' &&
					node.operator === '**' &&
					parentType === 'BinaryExpression' &&
					parent.operator === '**'
				) {
					return parent.left === node
				}
				if (isClassExtendsClause(node, parent)) {
					return true
				}
				if (
					hasPostfixPart(node, parent) ||
					parentType === 'UnaryExpression' ||
					parentType === 'SpreadElement' ||
					parentType === 'AwaitExpression'
				) {
					return true
				}
				const parentPos = getBinaryPrecedence(parent, parentType)
				if (parentPos != null) {
					const nodePos = getBinaryPrecedence(node, node.type)
					if (
						(parentPos === nodePos &&
							parentType === 'BinaryExpression' &&
							parent.right === node) ||
						parentPos > nodePos
					) {
						return true
					}
				}
				return undefined
			}
			function UnionTypeAnnotation(node, parent) {
				const parentType = parent.type
				return (
					parentType === 'ArrayTypeAnnotation' ||
					parentType === 'NullableTypeAnnotation' ||
					parentType === 'IntersectionTypeAnnotation' ||
					parentType === 'UnionTypeAnnotation'
				)
			}
			function OptionalIndexedAccessType(node, parent) {
				return isIndexedAccessType(parent) && parent.objectType === node
			}
			function TSAsExpression(node, parent) {
				if (
					(parent.type === 'AssignmentExpression' ||
						parent.type === 'AssignmentPattern') &&
					parent.left === node
				) {
					return true
				}
				if (
					parent.type === 'BinaryExpression' &&
					(parent.operator === '|' || parent.operator === '&') &&
					node === parent.left
				) {
					return true
				}
				return Binary(node, parent)
			}
			function TSConditionalType(node, parent) {
				const parentType = parent.type
				if (
					parentType === 'TSArrayType' ||
					(parentType === 'TSIndexedAccessType' &&
						parent.objectType === node) ||
					parentType === 'TSOptionalType' ||
					parentType === 'TSTypeOperator' ||
					parentType === 'TSTypeParameter'
				) {
					return true
				}
				if (
					(parentType === 'TSIntersectionType' ||
						parentType === 'TSUnionType') &&
					parent.types[0] === node
				) {
					return true
				}
				if (
					parentType === 'TSConditionalType' &&
					(parent.checkType === node || parent.extendsType === node)
				) {
					return true
				}
				return false
			}
			function TSUnionType(node, parent) {
				const parentType = parent.type
				return (
					parentType === 'TSIntersectionType' ||
					parentType === 'TSTypeOperator' ||
					parentType === 'TSArrayType' ||
					(parentType === 'TSIndexedAccessType' &&
						parent.objectType === node) ||
					parentType === 'TSOptionalType'
				)
			}
			function TSIntersectionType(node, parent) {
				const parentType = parent.type
				return (
					parentType === 'TSTypeOperator' ||
					parentType === 'TSArrayType' ||
					(parentType === 'TSIndexedAccessType' &&
						parent.objectType === node) ||
					parentType === 'TSOptionalType'
				)
			}
			function TSInferType(node, parent) {
				const parentType = parent.type
				if (
					parentType === 'TSArrayType' ||
					(parentType === 'TSIndexedAccessType' &&
						parent.objectType === node) ||
					parentType === 'TSOptionalType'
				) {
					return true
				}
				if (node.typeParameter.constraint) {
					if (
						(parentType === 'TSIntersectionType' ||
							parentType === 'TSUnionType') &&
						parent.types[0] === node
					) {
						return true
					}
				}
				return false
			}
			function TSTypeOperator(node, parent) {
				const parentType = parent.type
				return (
					parentType === 'TSArrayType' ||
					(parentType === 'TSIndexedAccessType' &&
						parent.objectType === node) ||
					parentType === 'TSOptionalType'
				)
			}
			function TSInstantiationExpression(node, parent) {
				const parentType = parent.type
				return (
					(parentType === 'CallExpression' ||
						parentType === 'OptionalCallExpression' ||
						parentType === 'NewExpression' ||
						parentType === 'TSInstantiationExpression') &&
					!!parent.typeParameters
				)
			}
			function TSFunctionType(node, parent) {
				const parentType = parent.type
				return (
					parentType === 'TSIntersectionType' ||
					parentType === 'TSUnionType' ||
					parentType === 'TSTypeOperator' ||
					parentType === 'TSOptionalType' ||
					parentType === 'TSArrayType' ||
					(parentType === 'TSIndexedAccessType' &&
						parent.objectType === node) ||
					(parentType === 'TSConditionalType' &&
						(parent.checkType === node || parent.extendsType === node))
				)
			}
			function BinaryExpression(
				node,
				parent,
				tokenContext,
				inForStatementInit,
			) {
				return node.operator === 'in' && inForStatementInit
			}
			function SequenceExpression(node, parent) {
				const parentType = parent.type
				if (
					parentType === 'SequenceExpression' ||
					parentType === 'ParenthesizedExpression' ||
					(parentType === 'MemberExpression' && parent.property === node) ||
					(parentType === 'OptionalMemberExpression' &&
						parent.property === node) ||
					parentType === 'TemplateLiteral'
				) {
					return false
				}
				if (parentType === 'ClassDeclaration') {
					return true
				}
				if (parentType === 'ForOfStatement') {
					return parent.right === node
				}
				if (parentType === 'ExportDefaultDeclaration') {
					return true
				}
				return !isStatement(parent)
			}
			function YieldExpression(node, parent) {
				const parentType = parent.type
				return (
					parentType === 'BinaryExpression' ||
					parentType === 'LogicalExpression' ||
					parentType === 'UnaryExpression' ||
					parentType === 'SpreadElement' ||
					hasPostfixPart(node, parent) ||
					(parentType === 'AwaitExpression' && isYieldExpression(node)) ||
					(parentType === 'ConditionalExpression' && node === parent.test) ||
					isClassExtendsClause(node, parent) ||
					isTSTypeExpression(parentType)
				)
			}
			function ClassExpression(node, parent, tokenContext) {
				return Boolean(
					tokenContext &
						(_index.TokenContext.expressionStatement |
							_index.TokenContext.exportDefault),
				)
			}
			function UnaryLike(node, parent) {
				return (
					hasPostfixPart(node, parent) ||
					(isBinaryExpression(parent) &&
						parent.operator === '**' &&
						parent.left === node) ||
					isClassExtendsClause(node, parent)
				)
			}
			function FunctionExpression(node, parent, tokenContext) {
				return Boolean(
					tokenContext &
						(_index.TokenContext.expressionStatement |
							_index.TokenContext.exportDefault),
				)
			}
			function ConditionalExpression(node, parent) {
				const parentType = parent.type
				if (
					parentType === 'UnaryExpression' ||
					parentType === 'SpreadElement' ||
					parentType === 'BinaryExpression' ||
					parentType === 'LogicalExpression' ||
					(parentType === 'ConditionalExpression' && parent.test === node) ||
					parentType === 'AwaitExpression' ||
					isTSTypeExpression(parentType)
				) {
					return true
				}
				return UnaryLike(node, parent)
			}
			function OptionalMemberExpression(node, parent) {
				return (
					(isCallExpression(parent) && parent.callee === node) ||
					(isMemberExpression(parent) && parent.object === node)
				)
			}
			function AssignmentExpression(node, parent, tokenContext) {
				if (
					needsParenBeforeExpressionBrace(tokenContext) &&
					isObjectPattern(node.left)
				) {
					return true
				} else {
					return ConditionalExpression(node, parent)
				}
			}
			function LogicalExpression(node, parent) {
				const parentType = parent.type
				if (isTSTypeExpression(parentType)) return true
				if (parentType !== 'LogicalExpression') return false
				switch (node.operator) {
					case '||':
						return parent.operator === '??' || parent.operator === '&&'
					case '&&':
						return parent.operator === '??'
					case '??':
						return parent.operator !== '??'
				}
			}
			function Identifier(
				node,
				parent,
				tokenContext,
				_inForInit,
				getRawIdentifier,
			) {
				var _node$extra
				const parentType = parent.type
				if (
					(_node$extra = node.extra) != null &&
					_node$extra.parenthesized &&
					parentType === 'AssignmentExpression' &&
					parent.left === node
				) {
					const rightType = parent.right.type
					if (
						(rightType === 'FunctionExpression' ||
							rightType === 'ClassExpression') &&
						parent.right.id == null
					) {
						return true
					}
				}
				if (getRawIdentifier && getRawIdentifier(node) !== node.name) {
					return false
				}
				if (node.name === 'let') {
					const isFollowedByBracket =
						isMemberExpression(parent, {
							object: node,
							computed: true,
						}) ||
						isOptionalMemberExpression(parent, {
							object: node,
							computed: true,
							optional: false,
						})
					if (
						isFollowedByBracket &&
						tokenContext &
							(_index.TokenContext.expressionStatement |
								_index.TokenContext.forHead |
								_index.TokenContext.forInHead)
					) {
						return true
					}
					return Boolean(tokenContext & _index.TokenContext.forOfHead)
				}
				return (
					node.name === 'async' &&
					isForOfStatement(parent, {
						left: node,
						await: false,
					})
				)
			}

			//# sourceMappingURL=parentheses.js.map

			/***/
		},

		/***/ 77971: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.nodes = void 0
			var _t = __nccwpck_require__(16535)
			const {
				FLIPPED_ALIAS_KEYS,
				isArrayExpression,
				isAssignmentExpression,
				isBinary,
				isBlockStatement,
				isCallExpression,
				isFunction,
				isIdentifier,
				isLiteral,
				isMemberExpression,
				isObjectExpression,
				isOptionalCallExpression,
				isOptionalMemberExpression,
				isStringLiteral,
			} = _t
			function crawlInternal(node, state) {
				if (!node) return state
				if (isMemberExpression(node) || isOptionalMemberExpression(node)) {
					crawlInternal(node.object, state)
					if (node.computed) crawlInternal(node.property, state)
				} else if (isBinary(node) || isAssignmentExpression(node)) {
					crawlInternal(node.left, state)
					crawlInternal(node.right, state)
				} else if (isCallExpression(node) || isOptionalCallExpression(node)) {
					state.hasCall = true
					crawlInternal(node.callee, state)
				} else if (isFunction(node)) {
					state.hasFunction = true
				} else if (isIdentifier(node)) {
					state.hasHelper =
						state.hasHelper || (node.callee && isHelper(node.callee))
				}
				return state
			}
			function crawl(node) {
				return crawlInternal(node, {
					hasCall: false,
					hasFunction: false,
					hasHelper: false,
				})
			}
			function isHelper(node) {
				if (!node) return false
				if (isMemberExpression(node)) {
					return isHelper(node.object) || isHelper(node.property)
				} else if (isIdentifier(node)) {
					return node.name === 'require' || node.name.charCodeAt(0) === 95
				} else if (isCallExpression(node)) {
					return isHelper(node.callee)
				} else if (isBinary(node) || isAssignmentExpression(node)) {
					return (
						(isIdentifier(node.left) && isHelper(node.left)) ||
						isHelper(node.right)
					)
				} else {
					return false
				}
			}
			function isType(node) {
				return (
					isLiteral(node) ||
					isObjectExpression(node) ||
					isArrayExpression(node) ||
					isIdentifier(node) ||
					isMemberExpression(node)
				)
			}
			const nodes = (exports.nodes = {
				AssignmentExpression(node) {
					const state = crawl(node.right)
					if ((state.hasCall && state.hasHelper) || state.hasFunction) {
						return state.hasFunction ? 1 | 2 : 2
					}
				},
				SwitchCase(node, parent) {
					return (
						(!!node.consequent.length || parent.cases[0] === node ? 1 : 0) |
						(!node.consequent.length &&
						parent.cases[parent.cases.length - 1] === node
							? 2
							: 0)
					)
				},
				LogicalExpression(node) {
					if (isFunction(node.left) || isFunction(node.right)) {
						return 2
					}
				},
				Literal(node) {
					if (isStringLiteral(node) && node.value === 'use strict') {
						return 2
					}
				},
				CallExpression(node) {
					if (isFunction(node.callee) || isHelper(node)) {
						return 1 | 2
					}
				},
				OptionalCallExpression(node) {
					if (isFunction(node.callee)) {
						return 1 | 2
					}
				},
				VariableDeclaration(node) {
					for (let i = 0; i < node.declarations.length; i++) {
						const declar = node.declarations[i]
						let enabled = isHelper(declar.id) && !isType(declar.init)
						if (!enabled && declar.init) {
							const state = crawl(declar.init)
							enabled =
								(isHelper(declar.init) && state.hasCall) || state.hasFunction
						}
						if (enabled) {
							return 1 | 2
						}
					}
				},
				IfStatement(node) {
					if (isBlockStatement(node.consequent)) {
						return 1 | 2
					}
				},
			})
			nodes.ObjectProperty =
				nodes.ObjectTypeProperty =
				nodes.ObjectMethod =
					function (node, parent) {
						if (parent.properties[0] === node) {
							return 1
						}
					}
			nodes.ObjectTypeCallProperty = function (node, parent) {
				var _parent$properties
				if (
					parent.callProperties[0] === node &&
					!(
						(_parent$properties = parent.properties) != null &&
						_parent$properties.length
					)
				) {
					return 1
				}
			}
			nodes.ObjectTypeIndexer = function (node, parent) {
				var _parent$properties2, _parent$callPropertie
				if (
					parent.indexers[0] === node &&
					!(
						(_parent$properties2 = parent.properties) != null &&
						_parent$properties2.length
					) &&
					!(
						(_parent$callPropertie = parent.callProperties) != null &&
						_parent$callPropertie.length
					)
				) {
					return 1
				}
			}
			nodes.ObjectTypeInternalSlot = function (node, parent) {
				var _parent$properties3, _parent$callPropertie2, _parent$indexers
				if (
					parent.internalSlots[0] === node &&
					!(
						(_parent$properties3 = parent.properties) != null &&
						_parent$properties3.length
					) &&
					!(
						(_parent$callPropertie2 = parent.callProperties) != null &&
						_parent$callPropertie2.length
					) &&
					!(
						(_parent$indexers = parent.indexers) != null &&
						_parent$indexers.length
					)
				) {
					return 1
				}
			}
			;[
				['Function', true],
				['Class', true],
				['Loop', true],
				['LabeledStatement', true],
				['SwitchStatement', true],
				['TryStatement', true],
			].forEach(function ([type, amounts]) {
				;[type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {
					const ret = amounts ? 1 | 2 : 0
					nodes[type] = () => ret
				})
			})

			//# sourceMappingURL=whitespace.js.map

			/***/
		},

		/***/ 81163: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = void 0
			var _buffer = __nccwpck_require__(11669)
			var n = __nccwpck_require__(95460)
			var _t = __nccwpck_require__(16535)
			var _tokenMap = __nccwpck_require__(93849)
			var generatorFunctions = __nccwpck_require__(39662)
			var _deprecated = __nccwpck_require__(60617)
			const {
				isExpression,
				isFunction,
				isStatement,
				isClassBody,
				isTSInterfaceBody,
				isTSEnumMember,
			} = _t
			const SCIENTIFIC_NOTATION = /e/i
			const ZERO_DECIMAL_INTEGER = /\.0+$/
			const HAS_NEWLINE = /[\n\r\u2028\u2029]/
			const HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[\n\r\u2028\u2029]|\*\//
			function commentIsNewline(c) {
				return c.type === 'CommentLine' || HAS_NEWLINE.test(c.value)
			}
			const { needsParens } = n
			class Printer {
				constructor(format, map, tokens, originalCode) {
					this.inForStatementInit = false
					this.tokenContext = 0
					this._tokens = null
					this._originalCode = null
					this._currentNode = null
					this._indent = 0
					this._indentRepeat = 0
					this._insideAux = false
					this._noLineTerminator = false
					this._noLineTerminatorAfterNode = null
					this._printAuxAfterOnNextUserNode = false
					this._printedComments = new Set()
					this._endsWithInteger = false
					this._endsWithWord = false
					this._endsWithDiv = false
					this._lastCommentLine = 0
					this._endsWithInnerRaw = false
					this._indentInnerComments = true
					this.tokenMap = null
					this._boundGetRawIdentifier = this._getRawIdentifier.bind(this)
					this._printSemicolonBeforeNextNode = -1
					this._printSemicolonBeforeNextToken = -1
					this.format = format
					this._tokens = tokens
					this._originalCode = originalCode
					this._indentRepeat = format.indent.style.length
					this._inputMap = map == null ? void 0 : map._inputMap
					this._buf = new _buffer.default(map, format.indent.style[0])
				}
				enterForStatementInit() {
					if (this.inForStatementInit) return () => {}
					this.inForStatementInit = true
					return () => {
						this.inForStatementInit = false
					}
				}
				enterDelimited() {
					const oldInForStatementInit = this.inForStatementInit
					const oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode
					if (
						oldInForStatementInit === false &&
						oldNoLineTerminatorAfterNode === null
					) {
						return () => {}
					}
					this.inForStatementInit = false
					this._noLineTerminatorAfterNode = null
					return () => {
						this.inForStatementInit = oldInForStatementInit
						this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode
					}
				}
				generate(ast) {
					if (this.format.preserveFormat) {
						this.tokenMap = new _tokenMap.TokenMap(
							ast,
							this._tokens,
							this._originalCode,
						)
					}
					this.print(ast)
					this._maybeAddAuxComment()
					return this._buf.get()
				}
				indent() {
					const { format } = this
					if (format.preserveFormat || format.compact || format.concise) {
						return
					}
					this._indent++
				}
				dedent() {
					const { format } = this
					if (format.preserveFormat || format.compact || format.concise) {
						return
					}
					this._indent--
				}
				semicolon(force = false) {
					this._maybeAddAuxComment()
					if (force) {
						this._appendChar(59)
						this._noLineTerminator = false
						return
					}
					if (this.tokenMap) {
						const node = this._currentNode
						if (node.start != null && node.end != null) {
							if (!this.tokenMap.endMatches(node, ';')) {
								this._printSemicolonBeforeNextNode = this._buf.getCurrentLine()
								return
							}
							const indexes = this.tokenMap.getIndexes(this._currentNode)
							this._catchUpTo(
								this._tokens[indexes[indexes.length - 1]].loc.start,
							)
						}
					}
					this._queue(59)
					this._noLineTerminator = false
				}
				rightBrace(node) {
					if (this.format.minified) {
						this._buf.removeLastSemicolon()
					}
					this.sourceWithOffset('end', node.loc, -1)
					this.tokenChar(125)
				}
				rightParens(node) {
					this.sourceWithOffset('end', node.loc, -1)
					this.tokenChar(41)
				}
				space(force = false) {
					const { format } = this
					if (format.compact || format.preserveFormat) return
					if (force) {
						this._space()
					} else if (this._buf.hasContent()) {
						const lastCp = this.getLastChar()
						if (lastCp !== 32 && lastCp !== 10) {
							this._space()
						}
					}
				}
				word(str, noLineTerminatorAfter = false) {
					this.tokenContext = 0
					this._maybePrintInnerComments(str)
					this._maybeAddAuxComment()
					if (this.tokenMap) this._catchUpToCurrentToken(str)
					if (
						this._endsWithWord ||
						(this._endsWithDiv && str.charCodeAt(0) === 47)
					) {
						this._space()
					}
					this._append(str, false)
					this._endsWithWord = true
					this._noLineTerminator = noLineTerminatorAfter
				}
				number(str, number) {
					function isNonDecimalLiteral(str) {
						if (str.length > 2 && str.charCodeAt(0) === 48) {
							const secondChar = str.charCodeAt(1)
							return (
								secondChar === 98 || secondChar === 111 || secondChar === 120
							)
						}
						return false
					}
					this.word(str)
					this._endsWithInteger =
						Number.isInteger(number) &&
						!isNonDecimalLiteral(str) &&
						!SCIENTIFIC_NOTATION.test(str) &&
						!ZERO_DECIMAL_INTEGER.test(str) &&
						str.charCodeAt(str.length - 1) !== 46
				}
				token(str, maybeNewline = false, occurrenceCount = 0) {
					this.tokenContext = 0
					this._maybePrintInnerComments(str, occurrenceCount)
					this._maybeAddAuxComment()
					if (this.tokenMap) this._catchUpToCurrentToken(str, occurrenceCount)
					const lastChar = this.getLastChar()
					const strFirst = str.charCodeAt(0)
					if (
						(lastChar === 33 && (str === '--' || strFirst === 61)) ||
						(strFirst === 43 && lastChar === 43) ||
						(strFirst === 45 && lastChar === 45) ||
						(strFirst === 46 && this._endsWithInteger)
					) {
						this._space()
					}
					this._append(str, maybeNewline)
					this._noLineTerminator = false
				}
				tokenChar(char) {
					this.tokenContext = 0
					const str = String.fromCharCode(char)
					this._maybePrintInnerComments(str)
					this._maybeAddAuxComment()
					if (this.tokenMap) this._catchUpToCurrentToken(str)
					const lastChar = this.getLastChar()
					if (
						(char === 43 && lastChar === 43) ||
						(char === 45 && lastChar === 45) ||
						(char === 46 && this._endsWithInteger)
					) {
						this._space()
					}
					this._appendChar(char)
					this._noLineTerminator = false
				}
				newline(i = 1, force) {
					if (i <= 0) return
					if (!force) {
						if (this.format.retainLines || this.format.compact) return
						if (this.format.concise) {
							this.space()
							return
						}
					}
					if (i > 2) i = 2
					i -= this._buf.getNewlineCount()
					for (let j = 0; j < i; j++) {
						this._newline()
					}
					return
				}
				endsWith(char) {
					return this.getLastChar() === char
				}
				getLastChar() {
					return this._buf.getLastChar()
				}
				endsWithCharAndNewline() {
					return this._buf.endsWithCharAndNewline()
				}
				removeTrailingNewline() {
					this._buf.removeTrailingNewline()
				}
				exactSource(loc, cb) {
					if (!loc) {
						cb()
						return
					}
					this._catchUp('start', loc)
					this._buf.exactSource(loc, cb)
				}
				source(prop, loc) {
					if (!loc) return
					this._catchUp(prop, loc)
					this._buf.source(prop, loc)
				}
				sourceWithOffset(prop, loc, columnOffset) {
					if (!loc || this.format.preserveFormat) return
					this._catchUp(prop, loc)
					this._buf.sourceWithOffset(prop, loc, columnOffset)
				}
				sourceIdentifierName(identifierName, pos) {
					if (!this._buf._canMarkIdName) return
					const sourcePosition = this._buf._sourcePosition
					sourcePosition.identifierNamePos = pos
					sourcePosition.identifierName = identifierName
				}
				_space() {
					this._queue(32)
				}
				_newline() {
					this._queue(10)
				}
				_catchUpToCurrentToken(str, occurrenceCount = 0) {
					const token = this.tokenMap.findMatching(
						this._currentNode,
						str,
						occurrenceCount,
					)
					if (token) this._catchUpTo(token.loc.start)
					if (
						this._printSemicolonBeforeNextToken !== -1 &&
						this._printSemicolonBeforeNextToken === this._buf.getCurrentLine()
					) {
						this._buf.appendChar(59)
						this._endsWithWord = false
						this._endsWithInteger = false
						this._endsWithDiv = false
					}
					this._printSemicolonBeforeNextToken = -1
					this._printSemicolonBeforeNextNode = -1
				}
				_append(str, maybeNewline) {
					this._maybeIndent(str.charCodeAt(0))
					this._buf.append(str, maybeNewline)
					this._endsWithWord = false
					this._endsWithInteger = false
					this._endsWithDiv = false
				}
				_appendChar(char) {
					this._maybeIndent(char)
					this._buf.appendChar(char)
					this._endsWithWord = false
					this._endsWithInteger = false
					this._endsWithDiv = false
				}
				_queue(char) {
					this._maybeIndent(char)
					this._buf.queue(char)
					this._endsWithWord = false
					this._endsWithInteger = false
				}
				_maybeIndent(firstChar) {
					if (this._indent && firstChar !== 10 && this.endsWith(10)) {
						this._buf.queueIndentation(this._getIndent())
					}
				}
				_shouldIndent(firstChar) {
					if (this._indent && firstChar !== 10 && this.endsWith(10)) {
						return true
					}
				}
				catchUp(line) {
					if (!this.format.retainLines) return
					const count = line - this._buf.getCurrentLine()
					for (let i = 0; i < count; i++) {
						this._newline()
					}
				}
				_catchUp(prop, loc) {
					const { format } = this
					if (!format.preserveFormat) {
						if (format.retainLines && loc != null && loc[prop]) {
							this.catchUp(loc[prop].line)
						}
						return
					}
					const pos = loc == null ? void 0 : loc[prop]
					if (pos != null) this._catchUpTo(pos)
				}
				_catchUpTo({ line, column, index }) {
					const count = line - this._buf.getCurrentLine()
					if (count > 0 && this._noLineTerminator) {
						return
					}
					for (let i = 0; i < count; i++) {
						this._newline()
					}
					const spacesCount =
						count > 0 ? column : column - this._buf.getCurrentColumn()
					if (spacesCount > 0) {
						const spaces = this._originalCode
							? this._originalCode
									.slice(index - spacesCount, index)
									.replace(
										/[^\t\x0B\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]/gu,
										' ',
									)
							: ' '.repeat(spacesCount)
						this._append(spaces, false)
					}
				}
				_getIndent() {
					return this._indentRepeat * this._indent
				}
				printTerminatorless(node) {
					this._noLineTerminator = true
					this.print(node)
				}
				print(node, noLineTerminatorAfter, trailingCommentsLineOffset) {
					var _node$extra, _node$leadingComments, _node$leadingComments2
					if (!node) return
					this._endsWithInnerRaw = false
					const nodeType = node.type
					const format = this.format
					const oldConcise = format.concise
					if (node._compact) {
						format.concise = true
					}
					const printMethod = this[nodeType]
					if (printMethod === undefined) {
						throw new ReferenceError(
							`unknown node of type ${JSON.stringify(nodeType)} with constructor ${JSON.stringify(node.constructor.name)}`,
						)
					}
					const parent = this._currentNode
					this._currentNode = node
					if (this.tokenMap) {
						this._printSemicolonBeforeNextToken =
							this._printSemicolonBeforeNextNode
					}
					const oldInAux = this._insideAux
					this._insideAux = node.loc == null
					this._maybeAddAuxComment(this._insideAux && !oldInAux)
					const parenthesized =
						(_node$extra = node.extra) == null
							? void 0
							: _node$extra.parenthesized
					let shouldPrintParens =
						(parenthesized && format.preserveFormat) ||
						(parenthesized &&
							format.retainFunctionParens &&
							nodeType === 'FunctionExpression') ||
						needsParens(
							node,
							parent,
							this.tokenContext,
							this.inForStatementInit,
							format.preserveFormat ? this._boundGetRawIdentifier : undefined,
						)
					if (
						!shouldPrintParens &&
						parenthesized &&
						(_node$leadingComments = node.leadingComments) != null &&
						_node$leadingComments.length &&
						node.leadingComments[0].type === 'CommentBlock'
					) {
						const parentType = parent == null ? void 0 : parent.type
						switch (parentType) {
							case 'ExpressionStatement':
							case 'VariableDeclarator':
							case 'AssignmentExpression':
							case 'ReturnStatement':
								break
							case 'CallExpression':
							case 'OptionalCallExpression':
							case 'NewExpression':
								if (parent.callee !== node) break
							default:
								shouldPrintParens = true
						}
					}
					let indentParenthesized = false
					if (
						!shouldPrintParens &&
						this._noLineTerminator &&
						(((_node$leadingComments2 = node.leadingComments) != null &&
							_node$leadingComments2.some(commentIsNewline)) ||
							(this.format.retainLines &&
								node.loc &&
								node.loc.start.line > this._buf.getCurrentLine()))
					) {
						shouldPrintParens = true
						indentParenthesized = true
					}
					let oldNoLineTerminatorAfterNode
					let oldInForStatementInitWasTrue
					if (!shouldPrintParens) {
						noLineTerminatorAfter ||
							(noLineTerminatorAfter =
								parent &&
								this._noLineTerminatorAfterNode === parent &&
								n.isLastChild(parent, node))
						if (noLineTerminatorAfter) {
							var _node$trailingComment
							if (
								(_node$trailingComment = node.trailingComments) != null &&
								_node$trailingComment.some(commentIsNewline)
							) {
								if (isExpression(node)) shouldPrintParens = true
							} else {
								oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode
								this._noLineTerminatorAfterNode = node
							}
						}
					}
					if (shouldPrintParens) {
						this.tokenChar(40)
						if (indentParenthesized) this.indent()
						this._endsWithInnerRaw = false
						if (this.inForStatementInit) {
							oldInForStatementInitWasTrue = true
							this.inForStatementInit = false
						}
						oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode
						this._noLineTerminatorAfterNode = null
					}
					this._lastCommentLine = 0
					this._printLeadingComments(node, parent)
					const loc =
						nodeType === 'Program' || nodeType === 'File' ? null : node.loc
					this.exactSource(loc, printMethod.bind(this, node, parent))
					if (shouldPrintParens) {
						this._printTrailingComments(node, parent)
						if (indentParenthesized) {
							this.dedent()
							this.newline()
						}
						this.tokenChar(41)
						this._noLineTerminator = noLineTerminatorAfter
						if (oldInForStatementInitWasTrue) this.inForStatementInit = true
					} else if (noLineTerminatorAfter && !this._noLineTerminator) {
						this._noLineTerminator = true
						this._printTrailingComments(node, parent)
					} else {
						this._printTrailingComments(
							node,
							parent,
							trailingCommentsLineOffset,
						)
					}
					this._currentNode = parent
					format.concise = oldConcise
					this._insideAux = oldInAux
					if (oldNoLineTerminatorAfterNode !== undefined) {
						this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode
					}
					this._endsWithInnerRaw = false
				}
				_maybeAddAuxComment(enteredPositionlessNode) {
					if (enteredPositionlessNode) this._printAuxBeforeComment()
					if (!this._insideAux) this._printAuxAfterComment()
				}
				_printAuxBeforeComment() {
					if (this._printAuxAfterOnNextUserNode) return
					this._printAuxAfterOnNextUserNode = true
					const comment = this.format.auxiliaryCommentBefore
					if (comment) {
						this._printComment(
							{
								type: 'CommentBlock',
								value: comment,
							},
							0,
						)
					}
				}
				_printAuxAfterComment() {
					if (!this._printAuxAfterOnNextUserNode) return
					this._printAuxAfterOnNextUserNode = false
					const comment = this.format.auxiliaryCommentAfter
					if (comment) {
						this._printComment(
							{
								type: 'CommentBlock',
								value: comment,
							},
							0,
						)
					}
				}
				getPossibleRaw(node) {
					const extra = node.extra
					if (
						(extra == null ? void 0 : extra.raw) != null &&
						extra.rawValue != null &&
						node.value === extra.rawValue
					) {
						return extra.raw
					}
				}
				printJoin(
					nodes,
					statement,
					indent,
					separator,
					printTrailingSeparator,
					addNewlines,
					iterator,
					trailingCommentsLineOffset,
				) {
					if (!(nodes != null && nodes.length)) return
					if (indent == null && this.format.retainLines) {
						var _nodes$0$loc
						const startLine =
							(_nodes$0$loc = nodes[0].loc) == null
								? void 0
								: _nodes$0$loc.start.line
						if (startLine != null && startLine !== this._buf.getCurrentLine()) {
							indent = true
						}
					}
					if (indent) this.indent()
					const newlineOpts = {
						addNewlines: addNewlines,
						nextNodeStartLine: 0,
					}
					const boundSeparator =
						separator == null ? void 0 : separator.bind(this)
					const len = nodes.length
					for (let i = 0; i < len; i++) {
						const node = nodes[i]
						if (!node) continue
						if (statement) this._printNewline(i === 0, newlineOpts)
						this.print(node, undefined, trailingCommentsLineOffset || 0)
						iterator == null || iterator(node, i)
						if (boundSeparator != null) {
							if (i < len - 1) boundSeparator(i, false)
							else if (printTrailingSeparator) boundSeparator(i, true)
						}
						if (statement) {
							var _node$trailingComment2
							if (
								!(
									(_node$trailingComment2 = node.trailingComments) != null &&
									_node$trailingComment2.length
								)
							) {
								this._lastCommentLine = 0
							}
							if (i + 1 === len) {
								this.newline(1)
							} else {
								var _nextNode$loc
								const nextNode = nodes[i + 1]
								newlineOpts.nextNodeStartLine =
									((_nextNode$loc = nextNode.loc) == null
										? void 0
										: _nextNode$loc.start.line) || 0
								this._printNewline(true, newlineOpts)
							}
						}
					}
					if (indent) this.dedent()
				}
				printAndIndentOnComments(node) {
					const indent = node.leadingComments && node.leadingComments.length > 0
					if (indent) this.indent()
					this.print(node)
					if (indent) this.dedent()
				}
				printBlock(parent) {
					const node = parent.body
					if (node.type !== 'EmptyStatement') {
						this.space()
					}
					this.print(node)
				}
				_printTrailingComments(node, parent, lineOffset) {
					const { innerComments, trailingComments } = node
					if (innerComments != null && innerComments.length) {
						this._printComments(2, innerComments, node, parent, lineOffset)
					}
					if (trailingComments != null && trailingComments.length) {
						this._printComments(2, trailingComments, node, parent, lineOffset)
					}
				}
				_printLeadingComments(node, parent) {
					const comments = node.leadingComments
					if (!(comments != null && comments.length)) return
					this._printComments(0, comments, node, parent)
				}
				_maybePrintInnerComments(nextTokenStr, nextTokenOccurrenceCount) {
					if (this._endsWithInnerRaw) {
						var _this$tokenMap
						this.printInnerComments(
							(_this$tokenMap = this.tokenMap) == null
								? void 0
								: _this$tokenMap.findMatching(
										this._currentNode,
										nextTokenStr,
										nextTokenOccurrenceCount,
									),
						)
					}
					this._endsWithInnerRaw = true
					this._indentInnerComments = true
				}
				printInnerComments(nextToken) {
					const node = this._currentNode
					const comments = node.innerComments
					if (!(comments != null && comments.length)) return
					const hasSpace = this.endsWith(32)
					const indent = this._indentInnerComments
					const printedCommentsCount = this._printedComments.size
					if (indent) this.indent()
					this._printComments(
						1,
						comments,
						node,
						undefined,
						undefined,
						nextToken,
					)
					if (hasSpace && printedCommentsCount !== this._printedComments.size) {
						this.space()
					}
					if (indent) this.dedent()
				}
				noIndentInnerCommentsHere() {
					this._indentInnerComments = false
				}
				printSequence(nodes, indent, trailingCommentsLineOffset, addNewlines) {
					this.printJoin(
						nodes,
						true,
						indent != null ? indent : false,
						undefined,
						undefined,
						addNewlines,
						undefined,
						trailingCommentsLineOffset,
					)
				}
				printList(
					items,
					printTrailingSeparator,
					statement,
					indent,
					separator,
					iterator,
				) {
					this.printJoin(
						items,
						statement,
						indent,
						separator != null ? separator : commaSeparator,
						printTrailingSeparator,
						undefined,
						iterator,
					)
				}
				shouldPrintTrailingComma(listEnd) {
					if (!this.tokenMap) return null
					const listEndIndex = this.tokenMap.findLastIndex(
						this._currentNode,
						(token) => this.tokenMap.matchesOriginal(token, listEnd),
					)
					if (listEndIndex <= 0) return null
					return this.tokenMap.matchesOriginal(
						this._tokens[listEndIndex - 1],
						',',
					)
				}
				_printNewline(newLine, opts) {
					const format = this.format
					if (format.retainLines || format.compact) return
					if (format.concise) {
						this.space()
						return
					}
					if (!newLine) {
						return
					}
					const startLine = opts.nextNodeStartLine
					const lastCommentLine = this._lastCommentLine
					if (startLine > 0 && lastCommentLine > 0) {
						const offset = startLine - lastCommentLine
						if (offset >= 0) {
							this.newline(offset || 1)
							return
						}
					}
					if (this._buf.hasContent()) {
						this.newline(1)
					}
				}
				_shouldPrintComment(comment, nextToken) {
					if (comment.ignore) return 0
					if (this._printedComments.has(comment)) return 0
					if (
						this._noLineTerminator &&
						HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(comment.value)
					) {
						return 2
					}
					if (nextToken && this.tokenMap) {
						const commentTok = this.tokenMap.find(
							this._currentNode,
							(token) => token.value === comment.value,
						)
						if (commentTok && commentTok.start > nextToken.start) {
							return 2
						}
					}
					this._printedComments.add(comment)
					if (!this.format.shouldPrintComment(comment.value)) {
						return 0
					}
					return 1
				}
				_printComment(comment, skipNewLines) {
					const noLineTerminator = this._noLineTerminator
					const isBlockComment = comment.type === 'CommentBlock'
					const printNewLines =
						isBlockComment && skipNewLines !== 1 && !this._noLineTerminator
					if (printNewLines && this._buf.hasContent() && skipNewLines !== 2) {
						this.newline(1)
					}
					const lastCharCode = this.getLastChar()
					if (
						lastCharCode !== 91 &&
						lastCharCode !== 123 &&
						lastCharCode !== 40
					) {
						this.space()
					}
					let val
					if (isBlockComment) {
						val = `/*${comment.value}*/`
						if (this.format.indent.adjustMultilineComment) {
							var _comment$loc
							const offset =
								(_comment$loc = comment.loc) == null
									? void 0
									: _comment$loc.start.column
							if (offset) {
								const newlineRegex = new RegExp('\\n\\s{1,' + offset + '}', 'g')
								val = val.replace(newlineRegex, '\n')
							}
							if (this.format.concise) {
								val = val.replace(/\n(?!$)/g, `\n`)
							} else {
								let indentSize = this.format.retainLines
									? 0
									: this._buf.getCurrentColumn()
								if (this._shouldIndent(47) || this.format.retainLines) {
									indentSize += this._getIndent()
								}
								val = val.replace(/\n(?!$)/g, `\n${' '.repeat(indentSize)}`)
							}
						}
					} else if (!noLineTerminator) {
						val = `//${comment.value}`
					} else {
						val = `/*${comment.value}*/`
					}
					if (this._endsWithDiv) this._space()
					if (this.tokenMap) {
						const {
							_printSemicolonBeforeNextToken,
							_printSemicolonBeforeNextNode,
						} = this
						this._printSemicolonBeforeNextToken = -1
						this._printSemicolonBeforeNextNode = -1
						this.source('start', comment.loc)
						this._append(val, isBlockComment)
						this._printSemicolonBeforeNextNode = _printSemicolonBeforeNextNode
						this._printSemicolonBeforeNextToken = _printSemicolonBeforeNextToken
					} else {
						this.source('start', comment.loc)
						this._append(val, isBlockComment)
					}
					if (!isBlockComment && !noLineTerminator) {
						this.newline(1, true)
					}
					if (printNewLines && skipNewLines !== 3) {
						this.newline(1)
					}
				}
				_printComments(
					type,
					comments,
					node,
					parent,
					lineOffset = 0,
					nextToken,
				) {
					const nodeLoc = node.loc
					const len = comments.length
					let hasLoc = !!nodeLoc
					const nodeStartLine = hasLoc ? nodeLoc.start.line : 0
					const nodeEndLine = hasLoc ? nodeLoc.end.line : 0
					let lastLine = 0
					let leadingCommentNewline = 0
					const maybeNewline = this._noLineTerminator
						? function () {}
						: this.newline.bind(this)
					for (let i = 0; i < len; i++) {
						const comment = comments[i]
						const shouldPrint = this._shouldPrintComment(comment, nextToken)
						if (shouldPrint === 2) {
							hasLoc = false
							break
						}
						if (hasLoc && comment.loc && shouldPrint === 1) {
							const commentStartLine = comment.loc.start.line
							const commentEndLine = comment.loc.end.line
							if (type === 0) {
								let offset = 0
								if (i === 0) {
									if (
										this._buf.hasContent() &&
										(comment.type === 'CommentLine' ||
											commentStartLine !== commentEndLine)
									) {
										offset = leadingCommentNewline = 1
									}
								} else {
									offset = commentStartLine - lastLine
								}
								lastLine = commentEndLine
								maybeNewline(offset)
								this._printComment(comment, 1)
								if (i + 1 === len) {
									maybeNewline(
										Math.max(nodeStartLine - lastLine, leadingCommentNewline),
									)
									lastLine = nodeStartLine
								}
							} else if (type === 1) {
								const offset =
									commentStartLine - (i === 0 ? nodeStartLine : lastLine)
								lastLine = commentEndLine
								maybeNewline(offset)
								this._printComment(comment, 1)
								if (i + 1 === len) {
									maybeNewline(Math.min(1, nodeEndLine - lastLine))
									lastLine = nodeEndLine
								}
							} else {
								const offset =
									commentStartLine -
									(i === 0 ? nodeEndLine - lineOffset : lastLine)
								lastLine = commentEndLine
								maybeNewline(offset)
								this._printComment(comment, 1)
							}
						} else {
							hasLoc = false
							if (shouldPrint !== 1) {
								continue
							}
							if (len === 1) {
								const singleLine = comment.loc
									? comment.loc.start.line === comment.loc.end.line
									: !HAS_NEWLINE.test(comment.value)
								const shouldSkipNewline =
									singleLine &&
									!isStatement(node) &&
									!isClassBody(parent) &&
									!isTSInterfaceBody(parent) &&
									!isTSEnumMember(node)
								if (type === 0) {
									this._printComment(
										comment,
										(shouldSkipNewline && node.type !== 'ObjectExpression') ||
											(singleLine &&
												isFunction(parent, {
													body: node,
												}))
											? 1
											: 0,
									)
								} else if (shouldSkipNewline && type === 2) {
									this._printComment(comment, 1)
								} else {
									this._printComment(comment, 0)
								}
							} else if (
								type === 1 &&
								!(
									node.type === 'ObjectExpression' && node.properties.length > 1
								) &&
								node.type !== 'ClassBody' &&
								node.type !== 'TSInterfaceBody'
							) {
								this._printComment(comment, i === 0 ? 2 : i === len - 1 ? 3 : 0)
							} else {
								this._printComment(comment, 0)
							}
						}
					}
					if (type === 2 && hasLoc && lastLine) {
						this._lastCommentLine = lastLine
					}
				}
			}
			Object.assign(Printer.prototype, generatorFunctions)
			{
				;(0, _deprecated.addDeprecatedGenerators)(Printer)
			}
			var _default = (exports['default'] = Printer)
			function commaSeparator(occurrenceCount, last) {
				this.token(',', false, occurrenceCount)
				if (!last) this.space()
			}

			//# sourceMappingURL=printer.js.map

			/***/
		},

		/***/ 18201: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = void 0
			var _genMapping = __nccwpck_require__(36153)
			var _traceMapping = __nccwpck_require__(99535)
			class SourceMap {
				constructor(opts, code) {
					var _opts$sourceFileName
					this._map = void 0
					this._rawMappings = void 0
					this._sourceFileName = void 0
					this._lastGenLine = 0
					this._lastSourceLine = 0
					this._lastSourceColumn = 0
					this._inputMap = void 0
					const map = (this._map = new _genMapping.GenMapping({
						sourceRoot: opts.sourceRoot,
					}))
					this._sourceFileName =
						(_opts$sourceFileName = opts.sourceFileName) == null
							? void 0
							: _opts$sourceFileName.replace(/\\/g, '/')
					this._rawMappings = undefined
					if (opts.inputSourceMap) {
						this._inputMap = new _traceMapping.TraceMap(opts.inputSourceMap)
						const resolvedSources = this._inputMap.resolvedSources
						if (resolvedSources.length) {
							for (let i = 0; i < resolvedSources.length; i++) {
								var _this$_inputMap$sourc
								;(0, _genMapping.setSourceContent)(
									map,
									resolvedSources[i],
									(_this$_inputMap$sourc = this._inputMap.sourcesContent) ==
										null
										? void 0
										: _this$_inputMap$sourc[i],
								)
							}
						}
					}
					if (typeof code === 'string' && !opts.inputSourceMap) {
						;(0, _genMapping.setSourceContent)(map, this._sourceFileName, code)
					} else if (typeof code === 'object') {
						for (const sourceFileName of Object.keys(code)) {
							;(0, _genMapping.setSourceContent)(
								map,
								sourceFileName.replace(/\\/g, '/'),
								code[sourceFileName],
							)
						}
					}
				}
				get() {
					return (0, _genMapping.toEncodedMap)(this._map)
				}
				getDecoded() {
					return (0, _genMapping.toDecodedMap)(this._map)
				}
				getRawMappings() {
					return (
						this._rawMappings ||
						(this._rawMappings = (0, _genMapping.allMappings)(this._map))
					)
				}
				mark(
					generated,
					line,
					column,
					identifierName,
					identifierNamePos,
					filename,
				) {
					var _originalMapping
					this._rawMappings = undefined
					let originalMapping
					if (line != null) {
						if (this._inputMap) {
							originalMapping = (0, _traceMapping.originalPositionFor)(
								this._inputMap,
								{
									line,
									column,
								},
							)
							if (!originalMapping.name && identifierNamePos) {
								const originalIdentifierMapping = (0,
								_traceMapping.originalPositionFor)(
									this._inputMap,
									identifierNamePos,
								)
								if (originalIdentifierMapping.name) {
									identifierName = originalIdentifierMapping.name
								}
							}
						} else {
							originalMapping = {
								source:
									(filename == null ? void 0 : filename.replace(/\\/g, '/')) ||
									this._sourceFileName,
								line: line,
								column: column,
							}
						}
					}
					;(0, _genMapping.maybeAddMapping)(this._map, {
						name: identifierName,
						generated,
						source:
							(_originalMapping = originalMapping) == null
								? void 0
								: _originalMapping.source,
						original: originalMapping,
					})
				}
			}
			exports['default'] = SourceMap

			//# sourceMappingURL=source-map.js.map

			/***/
		},

		/***/ 93849: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.TokenMap = void 0
			var _t = __nccwpck_require__(16535)
			const { traverseFast, VISITOR_KEYS } = _t
			class TokenMap {
				constructor(ast, tokens, source) {
					this._tokens = void 0
					this._source = void 0
					this._nodesToTokenIndexes = new Map()
					this._nodesOccurrencesCountCache = new Map()
					this._tokensCache = new Map()
					this._tokens = tokens
					this._source = source
					traverseFast(ast, (node) => {
						const indexes = this._getTokensIndexesOfNode(node)
						if (indexes.length > 0) this._nodesToTokenIndexes.set(node, indexes)
					})
					this._tokensCache = null
				}
				has(node) {
					return this._nodesToTokenIndexes.has(node)
				}
				getIndexes(node) {
					return this._nodesToTokenIndexes.get(node)
				}
				find(node, condition) {
					const indexes = this._nodesToTokenIndexes.get(node)
					if (indexes) {
						for (let k = 0; k < indexes.length; k++) {
							const index = indexes[k]
							const tok = this._tokens[index]
							if (condition(tok, index)) return tok
						}
					}
					return null
				}
				findLastIndex(node, condition) {
					const indexes = this._nodesToTokenIndexes.get(node)
					if (indexes) {
						for (let k = indexes.length - 1; k >= 0; k--) {
							const index = indexes[k]
							const tok = this._tokens[index]
							if (condition(tok, index)) return index
						}
					}
					return -1
				}
				findMatching(node, test, occurrenceCount = 0) {
					const indexes = this._nodesToTokenIndexes.get(node)
					if (indexes) {
						let i = 0
						const count = occurrenceCount
						if (count > 1) {
							const cache = this._nodesOccurrencesCountCache.get(node)
							if (cache && cache.test === test && cache.count < count) {
								i = cache.i + 1
								occurrenceCount -= cache.count + 1
							}
						}
						for (; i < indexes.length; i++) {
							const tok = this._tokens[indexes[i]]
							if (this.matchesOriginal(tok, test)) {
								if (occurrenceCount === 0) {
									if (count > 0) {
										this._nodesOccurrencesCountCache.set(node, {
											test,
											count,
											i,
										})
									}
									return tok
								}
								occurrenceCount--
							}
						}
					}
					return null
				}
				matchesOriginal(token, test) {
					if (token.end - token.start !== test.length) return false
					if (token.value != null) return token.value === test
					return this._source.startsWith(test, token.start)
				}
				startMatches(node, test) {
					const indexes = this._nodesToTokenIndexes.get(node)
					if (!indexes) return false
					const tok = this._tokens[indexes[0]]
					if (tok.start !== node.start) return false
					return this.matchesOriginal(tok, test)
				}
				endMatches(node, test) {
					const indexes = this._nodesToTokenIndexes.get(node)
					if (!indexes) return false
					const tok = this._tokens[indexes[indexes.length - 1]]
					if (tok.end !== node.end) return false
					return this.matchesOriginal(tok, test)
				}
				_getTokensIndexesOfNode(node) {
					if (node.start == null || node.end == null) return []
					const { first, last } = this._findTokensOfNode(
						node,
						0,
						this._tokens.length - 1,
					)
					let low = first
					const children = childrenIterator(node)
					if (
						(node.type === 'ExportNamedDeclaration' ||
							node.type === 'ExportDefaultDeclaration') &&
						node.declaration &&
						node.declaration.type === 'ClassDeclaration'
					) {
						children.next()
					}
					const indexes = []
					for (const child of children) {
						if (child == null) continue
						if (child.start == null || child.end == null) continue
						const childTok = this._findTokensOfNode(child, low, last)
						const high = childTok.first
						for (let k = low; k < high; k++) indexes.push(k)
						low = childTok.last + 1
					}
					for (let k = low; k <= last; k++) indexes.push(k)
					return indexes
				}
				_findTokensOfNode(node, low, high) {
					const cached = this._tokensCache.get(node)
					if (cached) return cached
					const first = this._findFirstTokenOfNode(node.start, low, high)
					const last = this._findLastTokenOfNode(node.end, first, high)
					this._tokensCache.set(node, {
						first,
						last,
					})
					return {
						first,
						last,
					}
				}
				_findFirstTokenOfNode(start, low, high) {
					while (low <= high) {
						const mid = (high + low) >> 1
						if (start < this._tokens[mid].start) {
							high = mid - 1
						} else if (start > this._tokens[mid].start) {
							low = mid + 1
						} else {
							return mid
						}
					}
					return low
				}
				_findLastTokenOfNode(end, low, high) {
					while (low <= high) {
						const mid = (high + low) >> 1
						if (end < this._tokens[mid].end) {
							high = mid - 1
						} else if (end > this._tokens[mid].end) {
							low = mid + 1
						} else {
							return mid
						}
					}
					return high
				}
			}
			exports.TokenMap = TokenMap
			function* childrenIterator(node) {
				if (node.type === 'TemplateLiteral') {
					yield node.quasis[0]
					for (let i = 1; i < node.quasis.length; i++) {
						yield node.expressions[i - 1]
						yield node.quasis[i]
					}
					return
				}
				const keys = VISITOR_KEYS[node.type]
				for (const key of keys) {
					const child = node[key]
					if (!child) continue
					if (Array.isArray(child)) {
						yield* child
					} else {
						yield child
					}
				}
			}

			//# sourceMappingURL=token-map.js.map

			/***/
		},

		/***/ 91235: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = void 0
			var _assert = __nccwpck_require__(42613)
			var _t = __nccwpck_require__(16535)
			const {
				callExpression,
				cloneNode,
				expressionStatement,
				identifier,
				importDeclaration,
				importDefaultSpecifier,
				importNamespaceSpecifier,
				importSpecifier,
				memberExpression,
				stringLiteral,
				variableDeclaration,
				variableDeclarator,
			} = _t
			class ImportBuilder {
				constructor(importedSource, scope, hub) {
					this._statements = []
					this._resultName = null
					this._importedSource = void 0
					this._scope = scope
					this._hub = hub
					this._importedSource = importedSource
				}
				done() {
					return {
						statements: this._statements,
						resultName: this._resultName,
					}
				}
				import() {
					this._statements.push(
						importDeclaration([], stringLiteral(this._importedSource)),
					)
					return this
				}
				require() {
					this._statements.push(
						expressionStatement(
							callExpression(identifier('require'), [
								stringLiteral(this._importedSource),
							]),
						),
					)
					return this
				}
				namespace(name = 'namespace') {
					const local = this._scope.generateUidIdentifier(name)
					const statement = this._statements[this._statements.length - 1]
					_assert(statement.type === 'ImportDeclaration')
					_assert(statement.specifiers.length === 0)
					statement.specifiers = [importNamespaceSpecifier(local)]
					this._resultName = cloneNode(local)
					return this
				}
				default(name) {
					const id = this._scope.generateUidIdentifier(name)
					const statement = this._statements[this._statements.length - 1]
					_assert(statement.type === 'ImportDeclaration')
					_assert(statement.specifiers.length === 0)
					statement.specifiers = [importDefaultSpecifier(id)]
					this._resultName = cloneNode(id)
					return this
				}
				named(name, importName) {
					if (importName === 'default') return this.default(name)
					const id = this._scope.generateUidIdentifier(name)
					const statement = this._statements[this._statements.length - 1]
					_assert(statement.type === 'ImportDeclaration')
					_assert(statement.specifiers.length === 0)
					statement.specifiers = [importSpecifier(id, identifier(importName))]
					this._resultName = cloneNode(id)
					return this
				}
				var(name) {
					const id = this._scope.generateUidIdentifier(name)
					let statement = this._statements[this._statements.length - 1]
					if (statement.type !== 'ExpressionStatement') {
						_assert(this._resultName)
						statement = expressionStatement(this._resultName)
						this._statements.push(statement)
					}
					this._statements[this._statements.length - 1] = variableDeclaration(
						'var',
						[variableDeclarator(id, statement.expression)],
					)
					this._resultName = cloneNode(id)
					return this
				}
				defaultInterop() {
					return this._interop(this._hub.addHelper('interopRequireDefault'))
				}
				wildcardInterop() {
					return this._interop(this._hub.addHelper('interopRequireWildcard'))
				}
				_interop(callee) {
					const statement = this._statements[this._statements.length - 1]
					if (statement.type === 'ExpressionStatement') {
						statement.expression = callExpression(callee, [
							statement.expression,
						])
					} else if (statement.type === 'VariableDeclaration') {
						_assert(statement.declarations.length === 1)
						statement.declarations[0].init = callExpression(callee, [
							statement.declarations[0].init,
						])
					} else {
						_assert.fail('Unexpected type.')
					}
					return this
				}
				prop(name) {
					const statement = this._statements[this._statements.length - 1]
					if (statement.type === 'ExpressionStatement') {
						statement.expression = memberExpression(
							statement.expression,
							identifier(name),
						)
					} else if (statement.type === 'VariableDeclaration') {
						_assert(statement.declarations.length === 1)
						statement.declarations[0].init = memberExpression(
							statement.declarations[0].init,
							identifier(name),
						)
					} else {
						_assert.fail('Unexpected type:' + statement.type)
					}
					return this
				}
				read(name) {
					this._resultName = memberExpression(
						this._resultName,
						identifier(name),
					)
				}
			}
			exports['default'] = ImportBuilder

			//# sourceMappingURL=import-builder.js.map

			/***/
		},

		/***/ 56358: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = void 0
			var _assert = __nccwpck_require__(42613)
			var _t = __nccwpck_require__(16535)
			var _importBuilder = __nccwpck_require__(91235)
			var _isModule = __nccwpck_require__(97585)
			const {
				identifier,
				importSpecifier,
				numericLiteral,
				sequenceExpression,
				isImportDeclaration,
			} = _t
			class ImportInjector {
				constructor(path, importedSource, opts) {
					this._defaultOpts = {
						importedSource: null,
						importedType: 'commonjs',
						importedInterop: 'babel',
						importingInterop: 'babel',
						ensureLiveReference: false,
						ensureNoContext: false,
						importPosition: 'before',
					}
					const programPath = path.find((p) => p.isProgram())
					this._programPath = programPath
					this._programScope = programPath.scope
					this._hub = programPath.hub
					this._defaultOpts = this._applyDefaults(importedSource, opts, true)
				}
				addDefault(importedSourceIn, opts) {
					return this.addNamed('default', importedSourceIn, opts)
				}
				addNamed(importName, importedSourceIn, opts) {
					_assert(typeof importName === 'string')
					return this._generateImport(
						this._applyDefaults(importedSourceIn, opts),
						importName,
					)
				}
				addNamespace(importedSourceIn, opts) {
					return this._generateImport(
						this._applyDefaults(importedSourceIn, opts),
						null,
					)
				}
				addSideEffect(importedSourceIn, opts) {
					return this._generateImport(
						this._applyDefaults(importedSourceIn, opts),
						void 0,
					)
				}
				_applyDefaults(importedSource, opts, isInit = false) {
					let newOpts
					if (typeof importedSource === 'string') {
						newOpts = Object.assign(
							{},
							this._defaultOpts,
							{
								importedSource,
							},
							opts,
						)
					} else {
						_assert(!opts, 'Unexpected secondary arguments.')
						newOpts = Object.assign({}, this._defaultOpts, importedSource)
					}
					if (!isInit && opts) {
						if (opts.nameHint !== undefined) newOpts.nameHint = opts.nameHint
						if (opts.blockHoist !== undefined)
							newOpts.blockHoist = opts.blockHoist
					}
					return newOpts
				}
				_generateImport(opts, importName) {
					const isDefault = importName === 'default'
					const isNamed = !!importName && !isDefault
					const isNamespace = importName === null
					const {
						importedSource,
						importedType,
						importedInterop,
						importingInterop,
						ensureLiveReference,
						ensureNoContext,
						nameHint,
						importPosition,
						blockHoist,
					} = opts
					let name = nameHint || importName
					const isMod = (0, _isModule.default)(this._programPath)
					const isModuleForNode = isMod && importingInterop === 'node'
					const isModuleForBabel = isMod && importingInterop === 'babel'
					if (importPosition === 'after' && !isMod) {
						throw new Error(
							`"importPosition": "after" is only supported in modules`,
						)
					}
					const builder = new _importBuilder.default(
						importedSource,
						this._programScope,
						this._hub,
					)
					if (importedType === 'es6') {
						if (!isModuleForNode && !isModuleForBabel) {
							throw new Error('Cannot import an ES6 module from CommonJS')
						}
						builder.import()
						if (isNamespace) {
							builder.namespace(nameHint || importedSource)
						} else if (isDefault || isNamed) {
							builder.named(name, importName)
						}
					} else if (importedType !== 'commonjs') {
						throw new Error(`Unexpected interopType "${importedType}"`)
					} else if (importedInterop === 'babel') {
						if (isModuleForNode) {
							name = name !== 'default' ? name : importedSource
							const es6Default = `${importedSource}$es6Default`
							builder.import()
							if (isNamespace) {
								builder
									.default(es6Default)
									.var(name || importedSource)
									.wildcardInterop()
							} else if (isDefault) {
								if (ensureLiveReference) {
									builder
										.default(es6Default)
										.var(name || importedSource)
										.defaultInterop()
										.read('default')
								} else {
									builder
										.default(es6Default)
										.var(name)
										.defaultInterop()
										.prop(importName)
								}
							} else if (isNamed) {
								builder.default(es6Default).read(importName)
							}
						} else if (isModuleForBabel) {
							builder.import()
							if (isNamespace) {
								builder.namespace(name || importedSource)
							} else if (isDefault || isNamed) {
								builder.named(name, importName)
							}
						} else {
							builder.require()
							if (isNamespace) {
								builder.var(name || importedSource).wildcardInterop()
							} else if ((isDefault || isNamed) && ensureLiveReference) {
								if (isDefault) {
									name = name !== 'default' ? name : importedSource
									builder.var(name).read(importName)
									builder.defaultInterop()
								} else {
									builder.var(importedSource).read(importName)
								}
							} else if (isDefault) {
								builder.var(name).defaultInterop().prop(importName)
							} else if (isNamed) {
								builder.var(name).prop(importName)
							}
						}
					} else if (importedInterop === 'compiled') {
						if (isModuleForNode) {
							builder.import()
							if (isNamespace) {
								builder.default(name || importedSource)
							} else if (isDefault || isNamed) {
								builder.default(importedSource).read(name)
							}
						} else if (isModuleForBabel) {
							builder.import()
							if (isNamespace) {
								builder.namespace(name || importedSource)
							} else if (isDefault || isNamed) {
								builder.named(name, importName)
							}
						} else {
							builder.require()
							if (isNamespace) {
								builder.var(name || importedSource)
							} else if (isDefault || isNamed) {
								if (ensureLiveReference) {
									builder.var(importedSource).read(name)
								} else {
									builder.prop(importName).var(name)
								}
							}
						}
					} else if (importedInterop === 'uncompiled') {
						if (isDefault && ensureLiveReference) {
							throw new Error('No live reference for commonjs default')
						}
						if (isModuleForNode) {
							builder.import()
							if (isNamespace) {
								builder.default(name || importedSource)
							} else if (isDefault) {
								builder.default(name)
							} else if (isNamed) {
								builder.default(importedSource).read(name)
							}
						} else if (isModuleForBabel) {
							builder.import()
							if (isNamespace) {
								builder.default(name || importedSource)
							} else if (isDefault) {
								builder.default(name)
							} else if (isNamed) {
								builder.named(name, importName)
							}
						} else {
							builder.require()
							if (isNamespace) {
								builder.var(name || importedSource)
							} else if (isDefault) {
								builder.var(name)
							} else if (isNamed) {
								if (ensureLiveReference) {
									builder.var(importedSource).read(name)
								} else {
									builder.var(name).prop(importName)
								}
							}
						}
					} else {
						throw new Error(`Unknown importedInterop "${importedInterop}".`)
					}
					const { statements, resultName } = builder.done()
					this._insertStatements(statements, importPosition, blockHoist)
					if (
						(isDefault || isNamed) &&
						ensureNoContext &&
						resultName.type !== 'Identifier'
					) {
						return sequenceExpression([numericLiteral(0), resultName])
					}
					return resultName
				}
				_insertStatements(
					statements,
					importPosition = 'before',
					blockHoist = 3,
				) {
					if (importPosition === 'after') {
						if (this._insertStatementsAfter(statements)) return
					} else {
						if (this._insertStatementsBefore(statements, blockHoist)) return
					}
					this._programPath.unshiftContainer('body', statements)
				}
				_insertStatementsBefore(statements, blockHoist) {
					if (
						statements.length === 1 &&
						isImportDeclaration(statements[0]) &&
						isValueImport(statements[0])
					) {
						const firstImportDecl = this._programPath.get('body').find((p) => {
							return p.isImportDeclaration() && isValueImport(p.node)
						})
						if (
							(firstImportDecl == null
								? void 0
								: firstImportDecl.node.source.value) ===
								statements[0].source.value &&
							maybeAppendImportSpecifiers(firstImportDecl.node, statements[0])
						) {
							return true
						}
					}
					statements.forEach((node) => {
						node._blockHoist = blockHoist
					})
					const targetPath = this._programPath.get('body').find((p) => {
						const val = p.node._blockHoist
						return Number.isFinite(val) && val < 4
					})
					if (targetPath) {
						targetPath.insertBefore(statements)
						return true
					}
					return false
				}
				_insertStatementsAfter(statements) {
					const statementsSet = new Set(statements)
					const importDeclarations = new Map()
					for (const statement of statements) {
						if (isImportDeclaration(statement) && isValueImport(statement)) {
							const source = statement.source.value
							if (!importDeclarations.has(source))
								importDeclarations.set(source, [])
							importDeclarations.get(source).push(statement)
						}
					}
					let lastImportPath = null
					for (const bodyStmt of this._programPath.get('body')) {
						if (
							bodyStmt.isImportDeclaration() &&
							isValueImport(bodyStmt.node)
						) {
							lastImportPath = bodyStmt
							const source = bodyStmt.node.source.value
							const newImports = importDeclarations.get(source)
							if (!newImports) continue
							for (const decl of newImports) {
								if (!statementsSet.has(decl)) continue
								if (maybeAppendImportSpecifiers(bodyStmt.node, decl)) {
									statementsSet.delete(decl)
								}
							}
						}
					}
					if (statementsSet.size === 0) return true
					if (lastImportPath)
						lastImportPath.insertAfter(Array.from(statementsSet))
					return !!lastImportPath
				}
			}
			exports['default'] = ImportInjector
			function isValueImport(node) {
				return node.importKind !== 'type' && node.importKind !== 'typeof'
			}
			function hasNamespaceImport(node) {
				return (
					(node.specifiers.length === 1 &&
						node.specifiers[0].type === 'ImportNamespaceSpecifier') ||
					(node.specifiers.length === 2 &&
						node.specifiers[1].type === 'ImportNamespaceSpecifier')
				)
			}
			function hasDefaultImport(node) {
				return (
					node.specifiers.length > 0 &&
					node.specifiers[0].type === 'ImportDefaultSpecifier'
				)
			}
			function maybeAppendImportSpecifiers(target, source) {
				if (!target.specifiers.length) {
					target.specifiers = source.specifiers
					return true
				}
				if (!source.specifiers.length) return true
				if (hasNamespaceImport(target) || hasNamespaceImport(source))
					return false
				if (hasDefaultImport(source)) {
					if (hasDefaultImport(target)) {
						source.specifiers[0] = importSpecifier(
							source.specifiers[0].local,
							identifier('default'),
						)
					} else {
						target.specifiers.unshift(source.specifiers.shift())
					}
				}
				target.specifiers.push(...source.specifiers)
				return true
			}

			//# sourceMappingURL=import-injector.js.map

			/***/
		},

		/***/ 10678: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			Object.defineProperty(exports, 'ImportInjector', {
				enumerable: true,
				get: function () {
					return _importInjector.default
				},
			})
			exports.addDefault = addDefault
			exports.addNamed = addNamed
			exports.addNamespace = addNamespace
			exports.addSideEffect = addSideEffect
			Object.defineProperty(exports, 'isModule', {
				enumerable: true,
				get: function () {
					return _isModule.default
				},
			})
			var _importInjector = __nccwpck_require__(56358)
			var _isModule = __nccwpck_require__(97585)
			function addDefault(path, importedSource, opts) {
				return new _importInjector.default(path).addDefault(
					importedSource,
					opts,
				)
			}
			function addNamed(path, name, importedSource, opts) {
				return new _importInjector.default(path).addNamed(
					name,
					importedSource,
					opts,
				)
			}
			function addNamespace(path, importedSource, opts) {
				return new _importInjector.default(path).addNamespace(
					importedSource,
					opts,
				)
			}
			function addSideEffect(path, importedSource, opts) {
				return new _importInjector.default(path).addSideEffect(
					importedSource,
					opts,
				)
			}

			//# sourceMappingURL=index.js.map

			/***/
		},

		/***/ 97585: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = isModule
			function isModule(path) {
				return path.node.sourceType === 'module'
			}

			//# sourceMappingURL=is-module.js.map

			/***/
		},

		/***/ 92840: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.buildDynamicImport = buildDynamicImport
			var _core = __nccwpck_require__(85414)
			{
				exports.getDynamicImportSource = function getDynamicImportSource(node) {
					const [source] = node.arguments
					return _core.types.isStringLiteral(source) ||
						_core.types.isTemplateLiteral(source)
						? source
						: _core.template.expression.ast`\`\${${source}}\``
				}
			}
			function buildDynamicImport(node, deferToThen, wrapWithPromise, builder) {
				const specifier = _core.types.isCallExpression(node)
					? node.arguments[0]
					: node.source
				if (
					_core.types.isStringLiteral(specifier) ||
					(_core.types.isTemplateLiteral(specifier) &&
						specifier.quasis.length === 0)
				) {
					if (deferToThen) {
						return _core.template.expression.ast`
        Promise.resolve().then(() => ${builder(specifier)})
      `
					} else return builder(specifier)
				}
				const specifierToString = _core.types.isTemplateLiteral(specifier)
					? _core.types.identifier('specifier')
					: _core.types.templateLiteral(
							[
								_core.types.templateElement({
									raw: '',
								}),
								_core.types.templateElement({
									raw: '',
								}),
							],
							[_core.types.identifier('specifier')],
						)
				if (deferToThen) {
					return _core.template.expression.ast`
      (specifier =>
        new Promise(r => r(${specifierToString}))
          .then(s => ${builder(_core.types.identifier('s'))})
      )(${specifier})
    `
				} else if (wrapWithPromise) {
					return _core.template.expression.ast`
      (specifier =>
        new Promise(r => r(${builder(specifierToString)}))
      )(${specifier})
    `
				} else {
					return _core.template.expression.ast`
      (specifier => ${builder(specifierToString)})(${specifier})
    `
				}
			}

			//# sourceMappingURL=dynamic-import.js.map

			/***/
		},

		/***/ 94036: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = getModuleName
			{
				const originalGetModuleName = getModuleName
				exports['default'] = getModuleName = function getModuleName(
					rootOpts,
					pluginOpts,
				) {
					var _pluginOpts$moduleId,
						_pluginOpts$moduleIds,
						_pluginOpts$getModule,
						_pluginOpts$moduleRoo
					return originalGetModuleName(rootOpts, {
						moduleId:
							(_pluginOpts$moduleId = pluginOpts.moduleId) != null
								? _pluginOpts$moduleId
								: rootOpts.moduleId,
						moduleIds:
							(_pluginOpts$moduleIds = pluginOpts.moduleIds) != null
								? _pluginOpts$moduleIds
								: rootOpts.moduleIds,
						getModuleId:
							(_pluginOpts$getModule = pluginOpts.getModuleId) != null
								? _pluginOpts$getModule
								: rootOpts.getModuleId,
						moduleRoot:
							(_pluginOpts$moduleRoo = pluginOpts.moduleRoot) != null
								? _pluginOpts$moduleRoo
								: rootOpts.moduleRoot,
					})
				}
			}
			function getModuleName(rootOpts, pluginOpts) {
				const {
					filename,
					filenameRelative = filename,
					sourceRoot = pluginOpts.moduleRoot,
				} = rootOpts
				const {
					moduleId,
					moduleIds = !!moduleId,
					getModuleId,
					moduleRoot = sourceRoot,
				} = pluginOpts
				if (!moduleIds) return null
				if (moduleId != null && !getModuleId) {
					return moduleId
				}
				let moduleName = moduleRoot != null ? moduleRoot + '/' : ''
				if (filenameRelative) {
					const sourceRootReplacer =
						sourceRoot != null ? new RegExp('^' + sourceRoot + '/?') : ''
					moduleName += filenameRelative
						.replace(sourceRootReplacer, '')
						.replace(/\.\w*$/, '')
				}
				moduleName = moduleName.replace(/\\/g, '/')
				if (getModuleId) {
					return getModuleId(moduleName) || moduleName
				} else {
					return moduleName
				}
			}

			//# sourceMappingURL=get-module-name.js.map

			/***/
		},

		/***/ 3665: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			Object.defineProperty(exports, 'buildDynamicImport', {
				enumerable: true,
				get: function () {
					return _dynamicImport.buildDynamicImport
				},
			})
			exports.buildNamespaceInitStatements = buildNamespaceInitStatements
			exports.ensureStatementsHoisted = ensureStatementsHoisted
			Object.defineProperty(exports, 'getModuleName', {
				enumerable: true,
				get: function () {
					return _getModuleName.default
				},
			})
			Object.defineProperty(exports, 'hasExports', {
				enumerable: true,
				get: function () {
					return _normalizeAndLoadMetadata.hasExports
				},
			})
			Object.defineProperty(exports, 'isModule', {
				enumerable: true,
				get: function () {
					return _helperModuleImports.isModule
				},
			})
			Object.defineProperty(exports, 'isSideEffectImport', {
				enumerable: true,
				get: function () {
					return _normalizeAndLoadMetadata.isSideEffectImport
				},
			})
			exports.rewriteModuleStatementsAndPrepareHeader =
				rewriteModuleStatementsAndPrepareHeader
			Object.defineProperty(exports, 'rewriteThis', {
				enumerable: true,
				get: function () {
					return _rewriteThis.default
				},
			})
			exports.wrapInterop = wrapInterop
			var _assert = __nccwpck_require__(42613)
			var _core = __nccwpck_require__(85414)
			var _helperModuleImports = __nccwpck_require__(10678)
			var _rewriteThis = __nccwpck_require__(92338)
			var _rewriteLiveReferences = __nccwpck_require__(78775)
			var _normalizeAndLoadMetadata = __nccwpck_require__(64193)
			var Lazy = __nccwpck_require__(80247)
			var _dynamicImport = __nccwpck_require__(92840)
			var _getModuleName = __nccwpck_require__(94036)
			{
				exports.getDynamicImportSource =
					__nccwpck_require__(92840).getDynamicImportSource
			}
			function rewriteModuleStatementsAndPrepareHeader(
				path,
				{
					exportName,
					strict,
					allowTopLevelThis,
					strictMode,
					noInterop,
					importInterop = noInterop ? 'none' : 'babel',
					lazy,
					getWrapperPayload = Lazy.toGetWrapperPayload(
						lazy != null ? lazy : false,
					),
					wrapReference = Lazy.wrapReference,
					esNamespaceOnly,
					filename,
					constantReexports = arguments[1].loose,
					enumerableModuleMeta = arguments[1].loose,
					noIncompleteNsImportDetection,
				},
			) {
				;(0, _normalizeAndLoadMetadata.validateImportInteropOption)(
					importInterop,
				)
				_assert(
					(0, _helperModuleImports.isModule)(path),
					'Cannot process module statements in a script',
				)
				path.node.sourceType = 'script'
				const meta = (0, _normalizeAndLoadMetadata.default)(path, exportName, {
					importInterop,
					initializeReexports: constantReexports,
					getWrapperPayload,
					esNamespaceOnly,
					filename,
				})
				if (!allowTopLevelThis) {
					;(0, _rewriteThis.default)(path)
				}
				;(0, _rewriteLiveReferences.default)(path, meta, wrapReference)
				if (strictMode !== false) {
					const hasStrict = path.node.directives.some((directive) => {
						return directive.value.value === 'use strict'
					})
					if (!hasStrict) {
						path.unshiftContainer(
							'directives',
							_core.types.directive(_core.types.directiveLiteral('use strict')),
						)
					}
				}
				const headers = []
				if ((0, _normalizeAndLoadMetadata.hasExports)(meta) && !strict) {
					headers.push(buildESModuleHeader(meta, enumerableModuleMeta))
				}
				const nameList = buildExportNameListDeclaration(path, meta)
				if (nameList) {
					meta.exportNameListName = nameList.name
					headers.push(nameList.statement)
				}
				headers.push(
					...buildExportInitializationStatements(
						path,
						meta,
						wrapReference,
						constantReexports,
						noIncompleteNsImportDetection,
					),
				)
				return {
					meta,
					headers,
				}
			}
			function ensureStatementsHoisted(statements) {
				statements.forEach((header) => {
					header._blockHoist = 3
				})
			}
			function wrapInterop(programPath, expr, type) {
				if (type === 'none') {
					return null
				}
				if (type === 'node-namespace') {
					return _core.types.callExpression(
						programPath.hub.addHelper('interopRequireWildcard'),
						[expr, _core.types.booleanLiteral(true)],
					)
				} else if (type === 'node-default') {
					return null
				}
				let helper
				if (type === 'default') {
					helper = 'interopRequireDefault'
				} else if (type === 'namespace') {
					helper = 'interopRequireWildcard'
				} else {
					throw new Error(`Unknown interop: ${type}`)
				}
				return _core.types.callExpression(programPath.hub.addHelper(helper), [
					expr,
				])
			}
			function buildNamespaceInitStatements(
				metadata,
				sourceMetadata,
				constantReexports = false,
				wrapReference = Lazy.wrapReference,
			) {
				var _wrapReference
				const statements = []
				const srcNamespaceId = _core.types.identifier(sourceMetadata.name)
				for (const localName of sourceMetadata.importsNamespace) {
					if (localName === sourceMetadata.name) continue
					statements.push(
						_core.template.statement`var NAME = SOURCE;`({
							NAME: localName,
							SOURCE: _core.types.cloneNode(srcNamespaceId),
						}),
					)
				}
				const srcNamespace =
					(_wrapReference = wrapReference(
						srcNamespaceId,
						sourceMetadata.wrap,
					)) != null
						? _wrapReference
						: srcNamespaceId
				if (constantReexports) {
					statements.push(
						...buildReexportsFromMeta(
							metadata,
							sourceMetadata,
							true,
							wrapReference,
						),
					)
				}
				for (const exportName of sourceMetadata.reexportNamespace) {
					statements.push(
						(!_core.types.isIdentifier(srcNamespace)
							? _core.template.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() {
                return NAMESPACE;
              }
            });
          `
							: _core.template.statement`EXPORTS.NAME = NAMESPACE;`)({
							EXPORTS: metadata.exportName,
							NAME: exportName,
							NAMESPACE: _core.types.cloneNode(srcNamespace),
						}),
					)
				}
				if (sourceMetadata.reexportAll) {
					const statement = buildNamespaceReexport(
						metadata,
						_core.types.cloneNode(srcNamespace),
						constantReexports,
					)
					statement.loc = sourceMetadata.reexportAll.loc
					statements.push(statement)
				}
				return statements
			}
			const ReexportTemplate = {
				constant: ({ exports, exportName, namespaceImport }) => _core.template
					.statement.ast`
      ${exports}.${exportName} = ${namespaceImport};
    `,
				constantComputed: ({ exports, exportName, namespaceImport }) => _core
					.template.statement.ast`
      ${exports}["${exportName}"] = ${namespaceImport};
    `,
				spec: ({ exports, exportName, namespaceImport }) => _core.template
					.statement.ast`
      Object.defineProperty(${exports}, "${exportName}", {
        enumerable: true,
        get: function() {
          return ${namespaceImport};
        },
      });
    `,
			}
			function buildReexportsFromMeta(
				meta,
				metadata,
				constantReexports,
				wrapReference,
			) {
				var _wrapReference2
				let namespace = _core.types.identifier(metadata.name)
				namespace =
					(_wrapReference2 = wrapReference(namespace, metadata.wrap)) != null
						? _wrapReference2
						: namespace
				const { stringSpecifiers } = meta
				return Array.from(metadata.reexports, ([exportName, importName]) => {
					let namespaceImport = _core.types.cloneNode(namespace)
					if (importName === 'default' && metadata.interop === 'node-default') {
					} else if (stringSpecifiers.has(importName)) {
						namespaceImport = _core.types.memberExpression(
							namespaceImport,
							_core.types.stringLiteral(importName),
							true,
						)
					} else {
						namespaceImport = _core.types.memberExpression(
							namespaceImport,
							_core.types.identifier(importName),
						)
					}
					const astNodes = {
						exports: meta.exportName,
						exportName,
						namespaceImport,
					}
					if (constantReexports || _core.types.isIdentifier(namespaceImport)) {
						if (stringSpecifiers.has(exportName)) {
							return ReexportTemplate.constantComputed(astNodes)
						} else {
							return ReexportTemplate.constant(astNodes)
						}
					} else {
						return ReexportTemplate.spec(astNodes)
					}
				})
			}
			function buildESModuleHeader(metadata, enumerableModuleMeta = false) {
				return (
					enumerableModuleMeta
						? _core.template.statement`
        EXPORTS.__esModule = true;
      `
						: _core.template.statement`
        Object.defineProperty(EXPORTS, "__esModule", {
          value: true,
        });
      `
				)({
					EXPORTS: metadata.exportName,
				})
			}
			function buildNamespaceReexport(metadata, namespace, constantReexports) {
				return (
					constantReexports
						? _core.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          EXPORTS[key] = NAMESPACE[key];
        });
      `
						: _core.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() {
              return NAMESPACE[key];
            },
          });
        });
    `
				)({
					NAMESPACE: namespace,
					EXPORTS: metadata.exportName,
					VERIFY_NAME_LIST: metadata.exportNameListName
						? (0, _core.template)`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({
								EXPORTS_LIST: metadata.exportNameListName,
							})
						: null,
				})
			}
			function buildExportNameListDeclaration(programPath, metadata) {
				const exportedVars = Object.create(null)
				for (const data of metadata.local.values()) {
					for (const name of data.names) {
						exportedVars[name] = true
					}
				}
				let hasReexport = false
				for (const data of metadata.source.values()) {
					for (const exportName of data.reexports.keys()) {
						exportedVars[exportName] = true
					}
					for (const exportName of data.reexportNamespace) {
						exportedVars[exportName] = true
					}
					hasReexport = hasReexport || !!data.reexportAll
				}
				if (!hasReexport || Object.keys(exportedVars).length === 0) return null
				const name = programPath.scope.generateUidIdentifier('exportNames')
				delete exportedVars.default
				return {
					name: name.name,
					statement: _core.types.variableDeclaration('var', [
						_core.types.variableDeclarator(
							name,
							_core.types.valueToNode(exportedVars),
						),
					]),
				}
			}
			function buildExportInitializationStatements(
				programPath,
				metadata,
				wrapReference,
				constantReexports = false,
				noIncompleteNsImportDetection = false,
			) {
				const initStatements = []
				for (const [localName, data] of metadata.local) {
					if (data.kind === 'import') {
					} else if (data.kind === 'hoisted') {
						initStatements.push([
							data.names[0],
							buildInitStatement(
								metadata,
								data.names,
								_core.types.identifier(localName),
							),
						])
					} else if (!noIncompleteNsImportDetection) {
						for (const exportName of data.names) {
							initStatements.push([exportName, null])
						}
					}
				}
				for (const data of metadata.source.values()) {
					if (!constantReexports) {
						const reexportsStatements = buildReexportsFromMeta(
							metadata,
							data,
							false,
							wrapReference,
						)
						const reexports = [...data.reexports.keys()]
						for (let i = 0; i < reexportsStatements.length; i++) {
							initStatements.push([reexports[i], reexportsStatements[i]])
						}
					}
					if (!noIncompleteNsImportDetection) {
						for (const exportName of data.reexportNamespace) {
							initStatements.push([exportName, null])
						}
					}
				}
				initStatements.sort(([a], [b]) => {
					if (a < b) return -1
					if (b < a) return 1
					return 0
				})
				const results = []
				if (noIncompleteNsImportDetection) {
					for (const [, initStatement] of initStatements) {
						results.push(initStatement)
					}
				} else {
					const chunkSize = 100
					for (let i = 0; i < initStatements.length; i += chunkSize) {
						let uninitializedExportNames = []
						for (
							let j = 0;
							j < chunkSize && i + j < initStatements.length;
							j++
						) {
							const [exportName, initStatement] = initStatements[i + j]
							if (initStatement !== null) {
								if (uninitializedExportNames.length > 0) {
									results.push(
										buildInitStatement(
											metadata,
											uninitializedExportNames,
											programPath.scope.buildUndefinedNode(),
										),
									)
									uninitializedExportNames = []
								}
								results.push(initStatement)
							} else {
								uninitializedExportNames.push(exportName)
							}
						}
						if (uninitializedExportNames.length > 0) {
							results.push(
								buildInitStatement(
									metadata,
									uninitializedExportNames,
									programPath.scope.buildUndefinedNode(),
								),
							)
						}
					}
				}
				return results
			}
			const InitTemplate = {
				computed: ({ exports, name, value }) =>
					_core.template.expression.ast`${exports}["${name}"] = ${value}`,
				default: ({ exports, name, value }) =>
					_core.template.expression.ast`${exports}.${name} = ${value}`,
				define: ({ exports, name, value }) => _core.template.expression.ast`
      Object.defineProperty(${exports}, "${name}", {
        enumerable: true,
        value: void 0,
        writable: true
      })["${name}"] = ${value}`,
			}
			function buildInitStatement(metadata, exportNames, initExpr) {
				const { stringSpecifiers, exportName: exports } = metadata
				return _core.types.expressionStatement(
					exportNames.reduce((value, name) => {
						const params = {
							exports,
							name,
							value,
						}
						if (name === '__proto__') {
							return InitTemplate.define(params)
						}
						if (stringSpecifiers.has(name)) {
							return InitTemplate.computed(params)
						}
						return InitTemplate.default(params)
					}, initExpr),
				)
			}

			//# sourceMappingURL=index.js.map

			/***/
		},

		/***/ 80247: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.toGetWrapperPayload = toGetWrapperPayload
			exports.wrapReference = wrapReference
			var _core = __nccwpck_require__(85414)
			var _normalizeAndLoadMetadata = __nccwpck_require__(64193)
			function toGetWrapperPayload(lazy) {
				return (source, metadata) => {
					if (lazy === false) return null
					if (
						(0, _normalizeAndLoadMetadata.isSideEffectImport)(metadata) ||
						metadata.reexportAll
					)
						return null
					if (lazy === true) {
						return source.includes('.') ? null : 'lazy'
					}
					if (Array.isArray(lazy)) {
						return !lazy.includes(source) ? null : 'lazy'
					}
					if (typeof lazy === 'function') {
						return lazy(source) ? 'lazy' : null
					}
					throw new Error(`.lazy must be a boolean, string array, or function`)
				}
			}
			function wrapReference(ref, payload) {
				if (payload === 'lazy') return _core.types.callExpression(ref, [])
				return null
			}

			//# sourceMappingURL=lazy-modules.js.map

			/***/
		},

		/***/ 64193: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = normalizeModuleAndLoadMetadata
			exports.hasExports = hasExports
			exports.isSideEffectImport = isSideEffectImport
			exports.validateImportInteropOption = validateImportInteropOption
			var _path = __nccwpck_require__(16928)
			var _helperValidatorIdentifier = __nccwpck_require__(76599)
			function hasExports(metadata) {
				return metadata.hasExports
			}
			function isSideEffectImport(source) {
				return (
					source.imports.size === 0 &&
					source.importsNamespace.size === 0 &&
					source.reexports.size === 0 &&
					source.reexportNamespace.size === 0 &&
					!source.reexportAll
				)
			}
			function validateImportInteropOption(importInterop) {
				if (
					typeof importInterop !== 'function' &&
					importInterop !== 'none' &&
					importInterop !== 'babel' &&
					importInterop !== 'node'
				) {
					throw new Error(
						`.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${importInterop}).`,
					)
				}
				return importInterop
			}
			function resolveImportInterop(importInterop, source, filename) {
				if (typeof importInterop === 'function') {
					return validateImportInteropOption(importInterop(source, filename))
				}
				return importInterop
			}
			function normalizeModuleAndLoadMetadata(
				programPath,
				exportName,
				{
					importInterop,
					initializeReexports = false,
					getWrapperPayload,
					esNamespaceOnly = false,
					filename,
				},
			) {
				if (!exportName) {
					exportName = programPath.scope.generateUidIdentifier('exports').name
				}
				const stringSpecifiers = new Set()
				nameAnonymousExports(programPath)
				const { local, sources, hasExports } = getModuleMetadata(
					programPath,
					{
						initializeReexports,
						getWrapperPayload,
					},
					stringSpecifiers,
				)
				removeImportExportDeclarations(programPath)
				for (const [source, metadata] of sources) {
					const { importsNamespace, imports } = metadata
					if (importsNamespace.size > 0 && imports.size === 0) {
						const [nameOfnamespace] = importsNamespace
						metadata.name = nameOfnamespace
					}
					const resolvedInterop = resolveImportInterop(
						importInterop,
						source,
						filename,
					)
					if (resolvedInterop === 'none') {
						metadata.interop = 'none'
					} else if (
						resolvedInterop === 'node' &&
						metadata.interop === 'namespace'
					) {
						metadata.interop = 'node-namespace'
					} else if (
						resolvedInterop === 'node' &&
						metadata.interop === 'default'
					) {
						metadata.interop = 'node-default'
					} else if (esNamespaceOnly && metadata.interop === 'namespace') {
						metadata.interop = 'default'
					}
				}
				return {
					exportName,
					exportNameListName: null,
					hasExports,
					local,
					source: sources,
					stringSpecifiers,
				}
			}
			function getExportSpecifierName(path, stringSpecifiers) {
				if (path.isIdentifier()) {
					return path.node.name
				} else if (path.isStringLiteral()) {
					const stringValue = path.node.value
					if (!(0, _helperValidatorIdentifier.isIdentifierName)(stringValue)) {
						stringSpecifiers.add(stringValue)
					}
					return stringValue
				} else {
					throw new Error(
						`Expected export specifier to be either Identifier or StringLiteral, got ${path.node.type}`,
					)
				}
			}
			function assertExportSpecifier(path) {
				if (path.isExportSpecifier()) {
					return
				} else if (path.isExportNamespaceSpecifier()) {
					throw path.buildCodeFrameError(
						'Export namespace should be first transformed by `@babel/plugin-transform-export-namespace-from`.',
					)
				} else {
					throw path.buildCodeFrameError('Unexpected export specifier type')
				}
			}
			function getModuleMetadata(
				programPath,
				{ getWrapperPayload, initializeReexports },
				stringSpecifiers,
			) {
				const localData = getLocalExportMetadata(
					programPath,
					initializeReexports,
					stringSpecifiers,
				)
				const importNodes = new Map()
				const sourceData = new Map()
				const getData = (sourceNode, node) => {
					const source = sourceNode.value
					let data = sourceData.get(source)
					if (!data) {
						data = {
							name: programPath.scope.generateUidIdentifier(
								(0, _path.basename)(source, (0, _path.extname)(source)),
							).name,
							interop: 'none',
							loc: null,
							imports: new Map(),
							importsNamespace: new Set(),
							reexports: new Map(),
							reexportNamespace: new Set(),
							reexportAll: null,
							wrap: null,
							get lazy() {
								return this.wrap === 'lazy'
							},
							referenced: false,
						}
						sourceData.set(source, data)
						importNodes.set(source, [node])
					} else {
						importNodes.get(source).push(node)
					}
					return data
				}
				let hasExports = false
				programPath.get('body').forEach((child) => {
					if (child.isImportDeclaration()) {
						const data = getData(child.node.source, child.node)
						if (!data.loc) data.loc = child.node.loc
						child.get('specifiers').forEach((spec) => {
							if (spec.isImportDefaultSpecifier()) {
								const localName = spec.get('local').node.name
								data.imports.set(localName, 'default')
								const reexport = localData.get(localName)
								if (reexport) {
									localData.delete(localName)
									reexport.names.forEach((name) => {
										data.reexports.set(name, 'default')
									})
									data.referenced = true
								}
							} else if (spec.isImportNamespaceSpecifier()) {
								const localName = spec.get('local').node.name
								data.importsNamespace.add(localName)
								const reexport = localData.get(localName)
								if (reexport) {
									localData.delete(localName)
									reexport.names.forEach((name) => {
										data.reexportNamespace.add(name)
									})
									data.referenced = true
								}
							} else if (spec.isImportSpecifier()) {
								const importName = getExportSpecifierName(
									spec.get('imported'),
									stringSpecifiers,
								)
								const localName = spec.get('local').node.name
								data.imports.set(localName, importName)
								const reexport = localData.get(localName)
								if (reexport) {
									localData.delete(localName)
									reexport.names.forEach((name) => {
										data.reexports.set(name, importName)
									})
									data.referenced = true
								}
							}
						})
					} else if (child.isExportAllDeclaration()) {
						hasExports = true
						const data = getData(child.node.source, child.node)
						if (!data.loc) data.loc = child.node.loc
						data.reexportAll = {
							loc: child.node.loc,
						}
						data.referenced = true
					} else if (child.isExportNamedDeclaration() && child.node.source) {
						hasExports = true
						const data = getData(child.node.source, child.node)
						if (!data.loc) data.loc = child.node.loc
						child.get('specifiers').forEach((spec) => {
							assertExportSpecifier(spec)
							const importName = getExportSpecifierName(
								spec.get('local'),
								stringSpecifiers,
							)
							const exportName = getExportSpecifierName(
								spec.get('exported'),
								stringSpecifiers,
							)
							data.reexports.set(exportName, importName)
							data.referenced = true
							if (exportName === '__esModule') {
								throw spec
									.get('exported')
									.buildCodeFrameError('Illegal export "__esModule".')
							}
						})
					} else if (
						child.isExportNamedDeclaration() ||
						child.isExportDefaultDeclaration()
					) {
						hasExports = true
					}
				})
				for (const metadata of sourceData.values()) {
					let needsDefault = false
					let needsNamed = false
					if (metadata.importsNamespace.size > 0) {
						needsDefault = true
						needsNamed = true
					}
					if (metadata.reexportAll) {
						needsNamed = true
					}
					for (const importName of metadata.imports.values()) {
						if (importName === 'default') needsDefault = true
						else needsNamed = true
					}
					for (const importName of metadata.reexports.values()) {
						if (importName === 'default') needsDefault = true
						else needsNamed = true
					}
					if (needsDefault && needsNamed) {
						metadata.interop = 'namespace'
					} else if (needsDefault) {
						metadata.interop = 'default'
					}
				}
				if (getWrapperPayload) {
					for (const [source, metadata] of sourceData) {
						metadata.wrap = getWrapperPayload(
							source,
							metadata,
							importNodes.get(source),
						)
					}
				}
				return {
					hasExports,
					local: localData,
					sources: sourceData,
				}
			}
			function getLocalExportMetadata(
				programPath,
				initializeReexports,
				stringSpecifiers,
			) {
				const bindingKindLookup = new Map()
				programPath.get('body').forEach((child) => {
					let kind
					if (child.isImportDeclaration()) {
						kind = 'import'
					} else {
						if (child.isExportDefaultDeclaration()) {
							child = child.get('declaration')
						}
						if (child.isExportNamedDeclaration()) {
							if (child.node.declaration) {
								child = child.get('declaration')
							} else if (
								initializeReexports &&
								child.node.source &&
								child.get('source').isStringLiteral()
							) {
								child.get('specifiers').forEach((spec) => {
									assertExportSpecifier(spec)
									bindingKindLookup.set(spec.get('local').node.name, 'block')
								})
								return
							}
						}
						if (child.isFunctionDeclaration()) {
							kind = 'hoisted'
						} else if (child.isClassDeclaration()) {
							kind = 'block'
						} else if (
							child.isVariableDeclaration({
								kind: 'var',
							})
						) {
							kind = 'var'
						} else if (child.isVariableDeclaration()) {
							kind = 'block'
						} else {
							return
						}
					}
					Object.keys(child.getOuterBindingIdentifiers()).forEach((name) => {
						bindingKindLookup.set(name, kind)
					})
				})
				const localMetadata = new Map()
				const getLocalMetadata = (idPath) => {
					const localName = idPath.node.name
					let metadata = localMetadata.get(localName)
					if (!metadata) {
						const kind = bindingKindLookup.get(localName)
						if (kind === undefined) {
							throw idPath.buildCodeFrameError(
								`Exporting local "${localName}", which is not declared.`,
							)
						}
						metadata = {
							names: [],
							kind,
						}
						localMetadata.set(localName, metadata)
					}
					return metadata
				}
				programPath.get('body').forEach((child) => {
					if (
						child.isExportNamedDeclaration() &&
						(initializeReexports || !child.node.source)
					) {
						if (child.node.declaration) {
							const declaration = child.get('declaration')
							const ids = declaration.getOuterBindingIdentifierPaths()
							Object.keys(ids).forEach((name) => {
								if (name === '__esModule') {
									throw declaration.buildCodeFrameError(
										'Illegal export "__esModule".',
									)
								}
								getLocalMetadata(ids[name]).names.push(name)
							})
						} else {
							child.get('specifiers').forEach((spec) => {
								const local = spec.get('local')
								const exported = spec.get('exported')
								const localMetadata = getLocalMetadata(local)
								const exportName = getExportSpecifierName(
									exported,
									stringSpecifiers,
								)
								if (exportName === '__esModule') {
									throw exported.buildCodeFrameError(
										'Illegal export "__esModule".',
									)
								}
								localMetadata.names.push(exportName)
							})
						}
					} else if (child.isExportDefaultDeclaration()) {
						const declaration = child.get('declaration')
						if (
							declaration.isFunctionDeclaration() ||
							declaration.isClassDeclaration()
						) {
							getLocalMetadata(declaration.get('id')).names.push('default')
						} else {
							throw declaration.buildCodeFrameError(
								'Unexpected default expression export.',
							)
						}
					}
				})
				return localMetadata
			}
			function nameAnonymousExports(programPath) {
				programPath.get('body').forEach((child) => {
					if (!child.isExportDefaultDeclaration()) return
					{
						var _child$splitExportDec
						;(_child$splitExportDec = child.splitExportDeclaration) != null
							? _child$splitExportDec
							: (child.splitExportDeclaration =
									__nccwpck_require__(
										50148,
									).NodePath.prototype.splitExportDeclaration)
					}
					child.splitExportDeclaration()
				})
			}
			function removeImportExportDeclarations(programPath) {
				programPath.get('body').forEach((child) => {
					if (child.isImportDeclaration()) {
						child.remove()
					} else if (child.isExportNamedDeclaration()) {
						if (child.node.declaration) {
							child.node.declaration._blockHoist = child.node._blockHoist
							child.replaceWith(child.node.declaration)
						} else {
							child.remove()
						}
					} else if (child.isExportDefaultDeclaration()) {
						const declaration = child.get('declaration')
						if (
							declaration.isFunctionDeclaration() ||
							declaration.isClassDeclaration()
						) {
							declaration._blockHoist = child.node._blockHoist
							child.replaceWith(declaration)
						} else {
							throw declaration.buildCodeFrameError(
								'Unexpected default expression export.',
							)
						}
					} else if (child.isExportAllDeclaration()) {
						child.remove()
					}
				})
			}

			//# sourceMappingURL=normalize-and-load-metadata.js.map

			/***/
		},

		/***/ 78775: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = rewriteLiveReferences
			var _core = __nccwpck_require__(85414)
			function isInType(path) {
				do {
					switch (path.parent.type) {
						case 'TSTypeAnnotation':
						case 'TSTypeAliasDeclaration':
						case 'TSTypeReference':
						case 'TypeAnnotation':
						case 'TypeAlias':
							return true
						case 'ExportSpecifier':
							return path.parentPath.parent.exportKind === 'type'
						default:
							if (
								path.parentPath.isStatement() ||
								path.parentPath.isExpression()
							) {
								return false
							}
					}
				} while ((path = path.parentPath))
			}
			function rewriteLiveReferences(programPath, metadata, wrapReference) {
				const imported = new Map()
				const exported = new Map()
				const requeueInParent = (path) => {
					programPath.requeue(path)
				}
				for (const [source, data] of metadata.source) {
					for (const [localName, importName] of data.imports) {
						imported.set(localName, [source, importName, null])
					}
					for (const localName of data.importsNamespace) {
						imported.set(localName, [source, null, localName])
					}
				}
				for (const [local, data] of metadata.local) {
					let exportMeta = exported.get(local)
					if (!exportMeta) {
						exportMeta = []
						exported.set(local, exportMeta)
					}
					exportMeta.push(...data.names)
				}
				const rewriteBindingInitVisitorState = {
					metadata,
					requeueInParent,
					scope: programPath.scope,
					exported,
				}
				programPath.traverse(
					rewriteBindingInitVisitor,
					rewriteBindingInitVisitorState,
				)
				const rewriteReferencesVisitorState = {
					seen: new WeakSet(),
					metadata,
					requeueInParent,
					scope: programPath.scope,
					imported,
					exported,
					buildImportReference([source, importName, localName], identNode) {
						const meta = metadata.source.get(source)
						meta.referenced = true
						if (localName) {
							if (meta.wrap) {
								var _wrapReference
								identNode =
									(_wrapReference = wrapReference(identNode, meta.wrap)) != null
										? _wrapReference
										: identNode
							}
							return identNode
						}
						let namespace = _core.types.identifier(meta.name)
						if (meta.wrap) {
							var _wrapReference2
							namespace =
								(_wrapReference2 = wrapReference(namespace, meta.wrap)) != null
									? _wrapReference2
									: namespace
						}
						if (importName === 'default' && meta.interop === 'node-default') {
							return namespace
						}
						const computed = metadata.stringSpecifiers.has(importName)
						return _core.types.memberExpression(
							namespace,
							computed
								? _core.types.stringLiteral(importName)
								: _core.types.identifier(importName),
							computed,
						)
					},
				}
				programPath.traverse(
					rewriteReferencesVisitor,
					rewriteReferencesVisitorState,
				)
			}
			const rewriteBindingInitVisitor = {
				Scope(path) {
					path.skip()
				},
				ClassDeclaration(path) {
					const { requeueInParent, exported, metadata } = this
					const { id } = path.node
					if (!id) throw new Error('Expected class to have a name')
					const localName = id.name
					const exportNames = exported.get(localName) || []
					if (exportNames.length > 0) {
						const statement = _core.types.expressionStatement(
							buildBindingExportAssignmentExpression(
								metadata,
								exportNames,
								_core.types.identifier(localName),
								path.scope,
							),
						)
						statement._blockHoist = path.node._blockHoist
						requeueInParent(path.insertAfter(statement)[0])
					}
				},
				VariableDeclaration(path) {
					const { requeueInParent, exported, metadata } = this
					const isVar = path.node.kind === 'var'
					for (const decl of path.get('declarations')) {
						const { id } = decl.node
						let { init } = decl.node
						if (
							_core.types.isIdentifier(id) &&
							exported.has(id.name) &&
							!_core.types.isArrowFunctionExpression(init) &&
							(!_core.types.isFunctionExpression(init) || init.id) &&
							(!_core.types.isClassExpression(init) || init.id)
						) {
							if (!init) {
								if (isVar) {
									continue
								} else {
									init = path.scope.buildUndefinedNode()
								}
							}
							decl.node.init = buildBindingExportAssignmentExpression(
								metadata,
								exported.get(id.name),
								init,
								path.scope,
							)
							requeueInParent(decl.get('init'))
						} else {
							for (const localName of Object.keys(
								decl.getOuterBindingIdentifiers(),
							)) {
								if (exported.has(localName)) {
									const statement = _core.types.expressionStatement(
										buildBindingExportAssignmentExpression(
											metadata,
											exported.get(localName),
											_core.types.identifier(localName),
											path.scope,
										),
									)
									statement._blockHoist = path.node._blockHoist
									requeueInParent(path.insertAfter(statement)[0])
								}
							}
						}
					}
				},
			}
			const buildBindingExportAssignmentExpression = (
				metadata,
				exportNames,
				localExpr,
				scope,
			) => {
				const exportsObjectName = metadata.exportName
				for (
					let currentScope = scope;
					currentScope != null;
					currentScope = currentScope.parent
				) {
					if (currentScope.hasOwnBinding(exportsObjectName)) {
						currentScope.rename(exportsObjectName)
					}
				}
				return (exportNames || []).reduce((expr, exportName) => {
					const { stringSpecifiers } = metadata
					const computed = stringSpecifiers.has(exportName)
					return _core.types.assignmentExpression(
						'=',
						_core.types.memberExpression(
							_core.types.identifier(exportsObjectName),
							computed
								? _core.types.stringLiteral(exportName)
								: _core.types.identifier(exportName),
							computed,
						),
						expr,
					)
				}, localExpr)
			}
			const buildImportThrow = (localName) => {
				return _core.template.expression.ast`
    (function() {
      throw new Error('"' + '${localName}' + '" is read-only.');
    })()
  `
			}
			const rewriteReferencesVisitor = {
				ReferencedIdentifier(path) {
					const {
						seen,
						buildImportReference,
						scope,
						imported,
						requeueInParent,
					} = this
					if (seen.has(path.node)) return
					seen.add(path.node)
					const localName = path.node.name
					const importData = imported.get(localName)
					if (importData) {
						if (isInType(path)) {
							throw path.buildCodeFrameError(
								`Cannot transform the imported binding "${localName}" since it's also used in a type annotation. ` +
									`Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`,
							)
						}
						const localBinding = path.scope.getBinding(localName)
						const rootBinding = scope.getBinding(localName)
						if (rootBinding !== localBinding) return
						const ref = buildImportReference(importData, path.node)
						ref.loc = path.node.loc
						if (
							(path.parentPath.isCallExpression({
								callee: path.node,
							}) ||
								path.parentPath.isOptionalCallExpression({
									callee: path.node,
								}) ||
								path.parentPath.isTaggedTemplateExpression({
									tag: path.node,
								})) &&
							_core.types.isMemberExpression(ref)
						) {
							path.replaceWith(
								_core.types.sequenceExpression([
									_core.types.numericLiteral(0),
									ref,
								]),
							)
						} else if (
							path.isJSXIdentifier() &&
							_core.types.isMemberExpression(ref)
						) {
							const { object, property } = ref
							path.replaceWith(
								_core.types.jsxMemberExpression(
									_core.types.jsxIdentifier(object.name),
									_core.types.jsxIdentifier(property.name),
								),
							)
						} else {
							path.replaceWith(ref)
						}
						requeueInParent(path)
						path.skip()
					}
				},
				UpdateExpression(path) {
					const {
						scope,
						seen,
						imported,
						exported,
						requeueInParent,
						buildImportReference,
					} = this
					if (seen.has(path.node)) return
					seen.add(path.node)
					const arg = path.get('argument')
					if (arg.isMemberExpression()) return
					const update = path.node
					if (arg.isIdentifier()) {
						const localName = arg.node.name
						if (
							scope.getBinding(localName) !== path.scope.getBinding(localName)
						) {
							return
						}
						const exportedNames = exported.get(localName)
						const importData = imported.get(localName)
						if (
							(exportedNames == null ? void 0 : exportedNames.length) > 0 ||
							importData
						) {
							if (importData) {
								path.replaceWith(
									_core.types.assignmentExpression(
										update.operator[0] + '=',
										buildImportReference(importData, arg.node),
										buildImportThrow(localName),
									),
								)
							} else if (update.prefix) {
								path.replaceWith(
									buildBindingExportAssignmentExpression(
										this.metadata,
										exportedNames,
										_core.types.cloneNode(update),
										path.scope,
									),
								)
							} else {
								const ref = scope.generateDeclaredUidIdentifier(localName)
								path.replaceWith(
									_core.types.sequenceExpression([
										_core.types.assignmentExpression(
											'=',
											_core.types.cloneNode(ref),
											_core.types.cloneNode(update),
										),
										buildBindingExportAssignmentExpression(
											this.metadata,
											exportedNames,
											_core.types.identifier(localName),
											path.scope,
										),
										_core.types.cloneNode(ref),
									]),
								)
							}
						}
					}
					requeueInParent(path)
					path.skip()
				},
				AssignmentExpression: {
					exit(path) {
						const {
							scope,
							seen,
							imported,
							exported,
							requeueInParent,
							buildImportReference,
						} = this
						if (seen.has(path.node)) return
						seen.add(path.node)
						const left = path.get('left')
						if (left.isMemberExpression()) return
						if (left.isIdentifier()) {
							const localName = left.node.name
							if (
								scope.getBinding(localName) !== path.scope.getBinding(localName)
							) {
								return
							}
							const exportedNames = exported.get(localName)
							const importData = imported.get(localName)
							if (
								(exportedNames == null ? void 0 : exportedNames.length) > 0 ||
								importData
							) {
								const assignment = path.node
								if (importData) {
									assignment.left = buildImportReference(importData, left.node)
									assignment.right = _core.types.sequenceExpression([
										assignment.right,
										buildImportThrow(localName),
									])
								}
								const { operator } = assignment
								let newExpr
								if (operator === '=') {
									newExpr = assignment
								} else if (
									operator === '&&=' ||
									operator === '||=' ||
									operator === '??='
								) {
									newExpr = _core.types.assignmentExpression(
										'=',
										assignment.left,
										_core.types.logicalExpression(
											operator.slice(0, -1),
											_core.types.cloneNode(assignment.left),
											assignment.right,
										),
									)
								} else {
									newExpr = _core.types.assignmentExpression(
										'=',
										assignment.left,
										_core.types.binaryExpression(
											operator.slice(0, -1),
											_core.types.cloneNode(assignment.left),
											assignment.right,
										),
									)
								}
								path.replaceWith(
									buildBindingExportAssignmentExpression(
										this.metadata,
										exportedNames,
										newExpr,
										path.scope,
									),
								)
								requeueInParent(path)
								path.skip()
							}
						} else {
							const ids = left.getOuterBindingIdentifiers()
							const programScopeIds = Object.keys(ids).filter(
								(localName) =>
									scope.getBinding(localName) ===
									path.scope.getBinding(localName),
							)
							const id = programScopeIds.find((localName) =>
								imported.has(localName),
							)
							if (id) {
								path.node.right = _core.types.sequenceExpression([
									path.node.right,
									buildImportThrow(id),
								])
							}
							const items = []
							programScopeIds.forEach((localName) => {
								const exportedNames = exported.get(localName) || []
								if (exportedNames.length > 0) {
									items.push(
										buildBindingExportAssignmentExpression(
											this.metadata,
											exportedNames,
											_core.types.identifier(localName),
											path.scope,
										),
									)
								}
							})
							if (items.length > 0) {
								let node = _core.types.sequenceExpression(items)
								if (path.parentPath.isExpressionStatement()) {
									node = _core.types.expressionStatement(node)
									node._blockHoist = path.parentPath.node._blockHoist
								}
								const statement = path.insertAfter(node)[0]
								requeueInParent(statement)
							}
						}
					},
				},
				ForXStatement(path) {
					const { scope, node } = path
					const { left } = node
					const { exported, imported, scope: programScope } = this
					if (!_core.types.isVariableDeclaration(left)) {
						let didTransformExport = false,
							importConstViolationName
						const loopBodyScope = path.get('body').scope
						for (const name of Object.keys(
							_core.types.getOuterBindingIdentifiers(left),
						)) {
							if (programScope.getBinding(name) === scope.getBinding(name)) {
								if (exported.has(name)) {
									didTransformExport = true
									if (loopBodyScope.hasOwnBinding(name)) {
										loopBodyScope.rename(name)
									}
								}
								if (imported.has(name) && !importConstViolationName) {
									importConstViolationName = name
								}
							}
						}
						if (!didTransformExport && !importConstViolationName) {
							return
						}
						path.ensureBlock()
						const bodyPath = path.get('body')
						const newLoopId = scope.generateUidIdentifierBasedOnNode(left)
						path
							.get('left')
							.replaceWith(
								_core.types.variableDeclaration('let', [
									_core.types.variableDeclarator(
										_core.types.cloneNode(newLoopId),
									),
								]),
							)
						scope.registerDeclaration(path.get('left'))
						if (didTransformExport) {
							bodyPath.unshiftContainer(
								'body',
								_core.types.expressionStatement(
									_core.types.assignmentExpression('=', left, newLoopId),
								),
							)
						}
						if (importConstViolationName) {
							bodyPath.unshiftContainer(
								'body',
								_core.types.expressionStatement(
									buildImportThrow(importConstViolationName),
								),
							)
						}
					}
				},
			}

			//# sourceMappingURL=rewrite-live-references.js.map

			/***/
		},

		/***/ 92338: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = rewriteThis
			var _core = __nccwpck_require__(85414)
			var _traverse = __nccwpck_require__(50148)
			let rewriteThisVisitor
			function rewriteThis(programPath) {
				if (!rewriteThisVisitor) {
					rewriteThisVisitor = _traverse.visitors.environmentVisitor({
						ThisExpression(path) {
							path.replaceWith(
								_core.types.unaryExpression(
									'void',
									_core.types.numericLiteral(0),
									true,
								),
							)
						},
					})
					rewriteThisVisitor.noScope = true
				}
				;(0, _traverse.default)(programPath.node, rewriteThisVisitor)
			}

			//# sourceMappingURL=rewrite-this.js.map

			/***/
		},

		/***/ 73728: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.readCodePoint = readCodePoint
			exports.readInt = readInt
			exports.readStringContents = readStringContents
			var _isDigit = function isDigit(code) {
				return code >= 48 && code <= 57
			}
			const forbiddenNumericSeparatorSiblings = {
				decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),
				hex: new Set([46, 88, 95, 120]),
			}
			const isAllowedNumericSeparatorSibling = {
				bin: (ch) => ch === 48 || ch === 49,
				oct: (ch) => ch >= 48 && ch <= 55,
				dec: (ch) => ch >= 48 && ch <= 57,
				hex: (ch) =>
					(ch >= 48 && ch <= 57) ||
					(ch >= 65 && ch <= 70) ||
					(ch >= 97 && ch <= 102),
			}
			function readStringContents(
				type,
				input,
				pos,
				lineStart,
				curLine,
				errors,
			) {
				const initialPos = pos
				const initialLineStart = lineStart
				const initialCurLine = curLine
				let out = ''
				let firstInvalidLoc = null
				let chunkStart = pos
				const { length } = input
				for (;;) {
					if (pos >= length) {
						errors.unterminated(initialPos, initialLineStart, initialCurLine)
						out += input.slice(chunkStart, pos)
						break
					}
					const ch = input.charCodeAt(pos)
					if (isStringEnd(type, ch, input, pos)) {
						out += input.slice(chunkStart, pos)
						break
					}
					if (ch === 92) {
						out += input.slice(chunkStart, pos)
						const res = readEscapedChar(
							input,
							pos,
							lineStart,
							curLine,
							type === 'template',
							errors,
						)
						if (res.ch === null && !firstInvalidLoc) {
							firstInvalidLoc = {
								pos,
								lineStart,
								curLine,
							}
						} else {
							out += res.ch
						}
						;({ pos, lineStart, curLine } = res)
						chunkStart = pos
					} else if (ch === 8232 || ch === 8233) {
						++pos
						++curLine
						lineStart = pos
					} else if (ch === 10 || ch === 13) {
						if (type === 'template') {
							out += input.slice(chunkStart, pos) + '\n'
							++pos
							if (ch === 13 && input.charCodeAt(pos) === 10) {
								++pos
							}
							++curLine
							chunkStart = lineStart = pos
						} else {
							errors.unterminated(initialPos, initialLineStart, initialCurLine)
						}
					} else {
						++pos
					}
				}
				return {
					pos,
					str: out,
					firstInvalidLoc,
					lineStart,
					curLine,
					containsInvalid: !!firstInvalidLoc,
				}
			}
			function isStringEnd(type, ch, input, pos) {
				if (type === 'template') {
					return ch === 96 || (ch === 36 && input.charCodeAt(pos + 1) === 123)
				}
				return ch === (type === 'double' ? 34 : 39)
			}
			function readEscapedChar(
				input,
				pos,
				lineStart,
				curLine,
				inTemplate,
				errors,
			) {
				const throwOnInvalid = !inTemplate
				pos++
				const res = (ch) => ({
					pos,
					ch,
					lineStart,
					curLine,
				})
				const ch = input.charCodeAt(pos++)
				switch (ch) {
					case 110:
						return res('\n')
					case 114:
						return res('\r')
					case 120: {
						let code
						;({ code, pos } = readHexChar(
							input,
							pos,
							lineStart,
							curLine,
							2,
							false,
							throwOnInvalid,
							errors,
						))
						return res(code === null ? null : String.fromCharCode(code))
					}
					case 117: {
						let code
						;({ code, pos } = readCodePoint(
							input,
							pos,
							lineStart,
							curLine,
							throwOnInvalid,
							errors,
						))
						return res(code === null ? null : String.fromCodePoint(code))
					}
					case 116:
						return res('\t')
					case 98:
						return res('\b')
					case 118:
						return res('\u000b')
					case 102:
						return res('\f')
					case 13:
						if (input.charCodeAt(pos) === 10) {
							++pos
						}
					case 10:
						lineStart = pos
						++curLine
					case 8232:
					case 8233:
						return res('')
					case 56:
					case 57:
						if (inTemplate) {
							return res(null)
						} else {
							errors.strictNumericEscape(pos - 1, lineStart, curLine)
						}
					default:
						if (ch >= 48 && ch <= 55) {
							const startPos = pos - 1
							const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2))
							let octalStr = match[0]
							let octal = parseInt(octalStr, 8)
							if (octal > 255) {
								octalStr = octalStr.slice(0, -1)
								octal = parseInt(octalStr, 8)
							}
							pos += octalStr.length - 1
							const next = input.charCodeAt(pos)
							if (octalStr !== '0' || next === 56 || next === 57) {
								if (inTemplate) {
									return res(null)
								} else {
									errors.strictNumericEscape(startPos, lineStart, curLine)
								}
							}
							return res(String.fromCharCode(octal))
						}
						return res(String.fromCharCode(ch))
				}
			}
			function readHexChar(
				input,
				pos,
				lineStart,
				curLine,
				len,
				forceLen,
				throwOnInvalid,
				errors,
			) {
				const initialPos = pos
				let n
				;({ n, pos } = readInt(
					input,
					pos,
					lineStart,
					curLine,
					16,
					len,
					forceLen,
					false,
					errors,
					!throwOnInvalid,
				))
				if (n === null) {
					if (throwOnInvalid) {
						errors.invalidEscapeSequence(initialPos, lineStart, curLine)
					} else {
						pos = initialPos - 1
					}
				}
				return {
					code: n,
					pos,
				}
			}
			function readInt(
				input,
				pos,
				lineStart,
				curLine,
				radix,
				len,
				forceLen,
				allowNumSeparator,
				errors,
				bailOnError,
			) {
				const start = pos
				const forbiddenSiblings =
					radix === 16
						? forbiddenNumericSeparatorSiblings.hex
						: forbiddenNumericSeparatorSiblings.decBinOct
				const isAllowedSibling =
					radix === 16
						? isAllowedNumericSeparatorSibling.hex
						: radix === 10
							? isAllowedNumericSeparatorSibling.dec
							: radix === 8
								? isAllowedNumericSeparatorSibling.oct
								: isAllowedNumericSeparatorSibling.bin
				let invalid = false
				let total = 0
				for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
					const code = input.charCodeAt(pos)
					let val
					if (code === 95 && allowNumSeparator !== 'bail') {
						const prev = input.charCodeAt(pos - 1)
						const next = input.charCodeAt(pos + 1)
						if (!allowNumSeparator) {
							if (bailOnError)
								return {
									n: null,
									pos,
								}
							errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine)
						} else if (
							Number.isNaN(next) ||
							!isAllowedSibling(next) ||
							forbiddenSiblings.has(prev) ||
							forbiddenSiblings.has(next)
						) {
							if (bailOnError)
								return {
									n: null,
									pos,
								}
							errors.unexpectedNumericSeparator(pos, lineStart, curLine)
						}
						++pos
						continue
					}
					if (code >= 97) {
						val = code - 97 + 10
					} else if (code >= 65) {
						val = code - 65 + 10
					} else if (_isDigit(code)) {
						val = code - 48
					} else {
						val = Infinity
					}
					if (val >= radix) {
						if (val <= 9 && bailOnError) {
							return {
								n: null,
								pos,
							}
						} else if (
							val <= 9 &&
							errors.invalidDigit(pos, lineStart, curLine, radix)
						) {
							val = 0
						} else if (forceLen) {
							val = 0
							invalid = true
						} else {
							break
						}
					}
					++pos
					total = total * radix + val
				}
				if (pos === start || (len != null && pos - start !== len) || invalid) {
					return {
						n: null,
						pos,
					}
				}
				return {
					n: total,
					pos,
				}
			}
			function readCodePoint(
				input,
				pos,
				lineStart,
				curLine,
				throwOnInvalid,
				errors,
			) {
				const ch = input.charCodeAt(pos)
				let code
				if (ch === 123) {
					++pos
					;({ code, pos } = readHexChar(
						input,
						pos,
						lineStart,
						curLine,
						input.indexOf('}', pos) - pos,
						true,
						throwOnInvalid,
						errors,
					))
					++pos
					if (code !== null && code > 0x10ffff) {
						if (throwOnInvalid) {
							errors.invalidCodePoint(pos, lineStart, curLine)
						} else {
							return {
								code: null,
								pos,
							}
						}
					}
				} else {
					;({ code, pos } = readHexChar(
						input,
						pos,
						lineStart,
						curLine,
						4,
						false,
						throwOnInvalid,
						errors,
					))
				}
				return {
					code,
					pos,
				}
			}

			//# sourceMappingURL=index.js.map

			/***/
		},

		/***/ 92924: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.isIdentifierChar = isIdentifierChar
			exports.isIdentifierName = isIdentifierName
			exports.isIdentifierStart = isIdentifierStart
			let nonASCIIidentifierStartChars =
				'\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c8a\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7cd\ua7d0\ua7d1\ua7d3\ua7d5-\ua7dc\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc'
			let nonASCIIidentifierChars =
				'\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0897-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0cf3\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ece\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\u30fb\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f\uff65'
			const nonASCIIidentifierStart = new RegExp(
				'[' + nonASCIIidentifierStartChars + ']',
			)
			const nonASCIIidentifier = new RegExp(
				'[' + nonASCIIidentifierStartChars + nonASCIIidentifierChars + ']',
			)
			nonASCIIidentifierStartChars = nonASCIIidentifierChars = null
			const astralIdentifierStartCodes = [
				0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4,
				48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35,
				5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2,
				1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2,
				43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71,
				55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28,
				53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10,
				22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22,
				13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0,
				13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2,
				14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13,
				4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2,
				31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72,
				26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2,
				0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0,
				19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22,
				0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80,
				921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582,
				6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6,
				18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9,
				1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9,
				395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3,
				3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0,
				4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2,
				30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322,
				29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196,
				60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0,
				7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0,
				2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2,
				16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467,
				541, 1507, 4938, 6, 4191,
			]
			const astralIdentifierCodes = [
				509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166,
				1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54,
				14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1,
				45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7,
				3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0,
				2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3,
				8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14,
				166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9,
				41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21,
				2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9,
				330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27,
				2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0,
				12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31,
				3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6,
				2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13,
				245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239,
			]
			function isInAstralSet(code, set) {
				let pos = 0x10000
				for (let i = 0, length = set.length; i < length; i += 2) {
					pos += set[i]
					if (pos > code) return false
					pos += set[i + 1]
					if (pos >= code) return true
				}
				return false
			}
			function isIdentifierStart(code) {
				if (code < 65) return code === 36
				if (code <= 90) return true
				if (code < 97) return code === 95
				if (code <= 122) return true
				if (code <= 0xffff) {
					return (
						code >= 0xaa &&
						nonASCIIidentifierStart.test(String.fromCharCode(code))
					)
				}
				return isInAstralSet(code, astralIdentifierStartCodes)
			}
			function isIdentifierChar(code) {
				if (code < 48) return code === 36
				if (code < 58) return true
				if (code < 65) return false
				if (code <= 90) return true
				if (code < 97) return code === 95
				if (code <= 122) return true
				if (code <= 0xffff) {
					return (
						code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code))
					)
				}
				return (
					isInAstralSet(code, astralIdentifierStartCodes) ||
					isInAstralSet(code, astralIdentifierCodes)
				)
			}
			function isIdentifierName(name) {
				let isFirst = true
				for (let i = 0; i < name.length; i++) {
					let cp = name.charCodeAt(i)
					if ((cp & 0xfc00) === 0xd800 && i + 1 < name.length) {
						const trail = name.charCodeAt(++i)
						if ((trail & 0xfc00) === 0xdc00) {
							cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff)
						}
					}
					if (isFirst) {
						isFirst = false
						if (!isIdentifierStart(cp)) {
							return false
						}
					} else if (!isIdentifierChar(cp)) {
						return false
					}
				}
				return !isFirst
			}

			//# sourceMappingURL=identifier.js.map

			/***/
		},

		/***/ 76599: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			Object.defineProperty(exports, 'isIdentifierChar', {
				enumerable: true,
				get: function () {
					return _identifier.isIdentifierChar
				},
			})
			Object.defineProperty(exports, 'isIdentifierName', {
				enumerable: true,
				get: function () {
					return _identifier.isIdentifierName
				},
			})
			Object.defineProperty(exports, 'isIdentifierStart', {
				enumerable: true,
				get: function () {
					return _identifier.isIdentifierStart
				},
			})
			Object.defineProperty(exports, 'isKeyword', {
				enumerable: true,
				get: function () {
					return _keyword.isKeyword
				},
			})
			Object.defineProperty(exports, 'isReservedWord', {
				enumerable: true,
				get: function () {
					return _keyword.isReservedWord
				},
			})
			Object.defineProperty(exports, 'isStrictBindOnlyReservedWord', {
				enumerable: true,
				get: function () {
					return _keyword.isStrictBindOnlyReservedWord
				},
			})
			Object.defineProperty(exports, 'isStrictBindReservedWord', {
				enumerable: true,
				get: function () {
					return _keyword.isStrictBindReservedWord
				},
			})
			Object.defineProperty(exports, 'isStrictReservedWord', {
				enumerable: true,
				get: function () {
					return _keyword.isStrictReservedWord
				},
			})
			var _identifier = __nccwpck_require__(92924)
			var _keyword = __nccwpck_require__(49884)

			//# sourceMappingURL=index.js.map

			/***/
		},

		/***/ 49884: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.isKeyword = isKeyword
			exports.isReservedWord = isReservedWord
			exports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord
			exports.isStrictBindReservedWord = isStrictBindReservedWord
			exports.isStrictReservedWord = isStrictReservedWord
			const reservedWords = {
				keyword: [
					'break',
					'case',
					'catch',
					'continue',
					'debugger',
					'default',
					'do',
					'else',
					'finally',
					'for',
					'function',
					'if',
					'return',
					'switch',
					'throw',
					'try',
					'var',
					'const',
					'while',
					'with',
					'new',
					'this',
					'super',
					'class',
					'extends',
					'export',
					'import',
					'null',
					'true',
					'false',
					'in',
					'instanceof',
					'typeof',
					'void',
					'delete',
				],
				strict: [
					'implements',
					'interface',
					'let',
					'package',
					'private',
					'protected',
					'public',
					'static',
					'yield',
				],
				strictBind: ['eval', 'arguments'],
			}
			const keywords = new Set(reservedWords.keyword)
			const reservedWordsStrictSet = new Set(reservedWords.strict)
			const reservedWordsStrictBindSet = new Set(reservedWords.strictBind)
			function isReservedWord(word, inModule) {
				return (inModule && word === 'await') || word === 'enum'
			}
			function isStrictReservedWord(word, inModule) {
				return (
					isReservedWord(word, inModule) || reservedWordsStrictSet.has(word)
				)
			}
			function isStrictBindOnlyReservedWord(word) {
				return reservedWordsStrictBindSet.has(word)
			}
			function isStrictBindReservedWord(word, inModule) {
				return (
					isStrictReservedWord(word, inModule) ||
					isStrictBindOnlyReservedWord(word)
				)
			}
			function isKeyword(word) {
				return keywords.has(word)
			}

			//# sourceMappingURL=keyword.js.map

			/***/
		},

		/***/ 21214: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = void 0
			var _template = __nccwpck_require__(19648)
			function helper(minVersion, source, metadata) {
				return Object.freeze({
					minVersion,
					ast: () =>
						_template.default.program.ast(source, {
							preserveComments: true,
						}),
					metadata,
				})
			}
			const helpers = (exports['default'] = {
				__proto__: null,
				OverloadYield: helper(
					'7.18.14',
					'function _OverloadYield(e,d){this.v=e,this.k=d}',
					{
						globals: [],
						locals: {
							_OverloadYield: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_OverloadYield',
						dependencies: {},
					},
				),
				applyDecoratedDescriptor: helper(
					'7.0.0-beta.0',
					'function _applyDecoratedDescriptor(i,e,r,n,l){var a={};return Object.keys(n).forEach((function(i){a[i]=n[i]})),a.enumerable=!!a.enumerable,a.configurable=!!a.configurable,("value"in a||a.initializer)&&(a.writable=!0),a=r.slice().reverse().reduce((function(r,n){return n(i,e,r)||r}),a),l&&void 0!==a.initializer&&(a.value=a.initializer?a.initializer.call(l):void 0,a.initializer=void 0),void 0===a.initializer?(Object.defineProperty(i,e,a),null):a}',
					{
						globals: ['Object'],
						locals: {
							_applyDecoratedDescriptor: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_applyDecoratedDescriptor',
						dependencies: {},
					},
				),
				applyDecs2311: helper(
					'7.24.0',
					'function applyDecs2311(e,t,n,r,o,i){var a,c,u,s,f,l,p,d=Symbol.metadata||Symbol.for("Symbol.metadata"),m=Object.defineProperty,h=Object.create,y=[h(null),h(null)],v=t.length;function g(t,n,r){return function(o,i){n&&(i=o,o=e);for(var a=0;a<t.length;a++)i=t[a].apply(o,r?[i]:[]);return r?i:o}}function b(e,t,n,r){if("function"!=typeof e&&(r||void 0!==e))throw new TypeError(t+" must "+(n||"be")+" a function"+(r?"":" or undefined"));return e}function applyDec(e,t,n,r,o,i,u,s,f,l,p){function d(e){if(!p(e))throw new TypeError("Attempted to access private element on non-instance")}var h=[].concat(t[0]),v=t[3],w=!u,D=1===o,S=3===o,j=4===o,E=2===o;function I(t,n,r){return function(o,i){return n&&(i=o,o=e),r&&r(o),P[t].call(o,i)}}if(!w){var P={},k=[],F=S?"get":j||D?"set":"value";if(f?(l||D?P={get:setFunctionName((function(){return v(this)}),r,"get"),set:function(e){t[4](this,e)}}:P[F]=v,l||setFunctionName(P[F],r,E?"":F)):l||(P=Object.getOwnPropertyDescriptor(e,r)),!l&&!f){if((c=y[+s][r])&&7!=(c^o))throw Error("Decorating two elements with the same name ("+P[F].name+") is not supported yet");y[+s][r]=o<3?1:o}}for(var N=e,O=h.length-1;O>=0;O-=n?2:1){var T=b(h[O],"A decorator","be",!0),z=n?h[O-1]:void 0,A={},H={kind:["field","accessor","method","getter","setter","class"][o],name:r,metadata:a,addInitializer:function(e,t){if(e.v)throw new TypeError("attempted to call addInitializer after decoration was finished");b(t,"An initializer","be",!0),i.push(t)}.bind(null,A)};if(w)c=T.call(z,N,H),A.v=1,b(c,"class decorators","return")&&(N=c);else if(H.static=s,H.private=f,c=H.access={has:f?p.bind():function(e){return r in e}},j||(c.get=f?E?function(e){return d(e),P.value}:I("get",0,d):function(e){return e[r]}),E||S||(c.set=f?I("set",0,d):function(e,t){e[r]=t}),N=T.call(z,D?{get:P.get,set:P.set}:P[F],H),A.v=1,D){if("object"==typeof N&&N)(c=b(N.get,"accessor.get"))&&(P.get=c),(c=b(N.set,"accessor.set"))&&(P.set=c),(c=b(N.init,"accessor.init"))&&k.unshift(c);else if(void 0!==N)throw new TypeError("accessor decorators must return an object with get, set, or init properties or undefined")}else b(N,(l?"field":"method")+" decorators","return")&&(l?k.unshift(N):P[F]=N)}return o<2&&u.push(g(k,s,1),g(i,s,0)),l||w||(f?D?u.splice(-1,0,I("get",s),I("set",s)):u.push(E?P[F]:b.call.bind(P[F])):m(e,r,P)),N}function w(e){return m(e,d,{configurable:!0,enumerable:!0,value:a})}return void 0!==i&&(a=i[d]),a=h(null==a?null:a),f=[],l=function(e){e&&f.push(g(e))},p=function(t,r){for(var i=0;i<n.length;i++){var a=n[i],c=a[1],l=7&c;if((8&c)==t&&!l==r){var p=a[2],d=!!a[3],m=16&c;applyDec(t?e:e.prototype,a,m,d?"#"+p:toPropertyKey(p),l,l<2?[]:t?s=s||[]:u=u||[],f,!!t,d,r,t&&d?function(t){return checkInRHS(t)===e}:o)}}},p(8,0),p(0,0),p(8,1),p(0,1),l(u),l(s),c=f,v||w(e),{e:c,get c(){var n=[];return v&&[w(e=applyDec(e,[t],r,e.name,5,n)),g(n,1)]}}}',
					{
						globals: ['Symbol', 'Object', 'TypeError', 'Error'],
						locals: {
							applyDecs2311: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: 'applyDecs2311',
						dependencies: {
							checkInRHS: [
								'body.0.body.body.5.argument.expressions.4.right.body.body.0.body.body.1.consequent.body.1.expression.arguments.10.consequent.body.body.0.argument.left.callee',
							],
							setFunctionName: [
								'body.0.body.body.3.body.body.3.consequent.body.1.test.expressions.0.consequent.expressions.0.consequent.right.properties.0.value.callee',
								'body.0.body.body.3.body.body.3.consequent.body.1.test.expressions.0.consequent.expressions.1.right.callee',
							],
							toPropertyKey: [
								'body.0.body.body.5.argument.expressions.4.right.body.body.0.body.body.1.consequent.body.1.expression.arguments.3.alternate.callee',
							],
						},
					},
				),
				arrayLikeToArray: helper(
					'7.9.0',
					'function _arrayLikeToArray(r,a){(null==a||a>r.length)&&(a=r.length);for(var e=0,n=Array(a);e<a;e++)n[e]=r[e];return n}',
					{
						globals: ['Array'],
						locals: {
							_arrayLikeToArray: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_arrayLikeToArray',
						dependencies: {},
					},
				),
				arrayWithHoles: helper(
					'7.0.0-beta.0',
					'function _arrayWithHoles(r){if(Array.isArray(r))return r}',
					{
						globals: ['Array'],
						locals: {
							_arrayWithHoles: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_arrayWithHoles',
						dependencies: {},
					},
				),
				arrayWithoutHoles: helper(
					'7.0.0-beta.0',
					'function _arrayWithoutHoles(r){if(Array.isArray(r))return arrayLikeToArray(r)}',
					{
						globals: ['Array'],
						locals: {
							_arrayWithoutHoles: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_arrayWithoutHoles',
						dependencies: {
							arrayLikeToArray: [
								'body.0.body.body.0.consequent.argument.callee',
							],
						},
					},
				),
				assertClassBrand: helper(
					'7.24.0',
					'function _assertClassBrand(e,t,n){if("function"==typeof e?e===t:e.has(t))return arguments.length<3?t:n;throw new TypeError("Private element is not present on this object")}',
					{
						globals: ['TypeError'],
						locals: {
							_assertClassBrand: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_assertClassBrand',
						dependencies: {},
					},
				),
				assertThisInitialized: helper(
					'7.0.0-beta.0',
					'function _assertThisInitialized(e){if(void 0===e)throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");return e}',
					{
						globals: ['ReferenceError'],
						locals: {
							_assertThisInitialized: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_assertThisInitialized',
						dependencies: {},
					},
				),
				asyncGeneratorDelegate: helper(
					'7.0.0-beta.0',
					'function _asyncGeneratorDelegate(t){var e={},n=!1;function pump(e,r){return n=!0,r=new Promise((function(n){n(t[e](r))})),{done:!1,value:new OverloadYield(r,1)}}return e["undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator"]=function(){return this},e.next=function(t){return n?(n=!1,t):pump("next",t)},"function"==typeof t.throw&&(e.throw=function(t){if(n)throw n=!1,t;return pump("throw",t)}),"function"==typeof t.return&&(e.return=function(t){return n?(n=!1,t):pump("return",t)}),e}',
					{
						globals: ['Promise', 'Symbol'],
						locals: {
							_asyncGeneratorDelegate: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_asyncGeneratorDelegate',
						dependencies: {
							OverloadYield: [
								'body.0.body.body.1.body.body.0.argument.expressions.2.properties.1.value.callee',
							],
						},
					},
				),
				asyncIterator: helper(
					'7.15.9',
					'function _asyncIterator(r){var n,t,o,e=2;for("undefined"!=typeof Symbol&&(t=Symbol.asyncIterator,o=Symbol.iterator);e--;){if(t&&null!=(n=r[t]))return n.call(r);if(o&&null!=(n=r[o]))return new AsyncFromSyncIterator(n.call(r));t="@@asyncIterator",o="@@iterator"}throw new TypeError("Object is not async iterable")}function AsyncFromSyncIterator(r){function AsyncFromSyncIteratorContinuation(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+" is not an object."));var n=r.done;return Promise.resolve(r.value).then((function(r){return{value:r,done:n}}))}return AsyncFromSyncIterator=function(r){this.s=r,this.n=r.next},AsyncFromSyncIterator.prototype={s:null,n:null,next:function(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments))},return:function(r){var n=this.s.return;return void 0===n?Promise.resolve({value:r,done:!0}):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))},throw:function(r){var n=this.s.return;return void 0===n?Promise.reject(r):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))}},new AsyncFromSyncIterator(r)}',
					{
						globals: ['Symbol', 'TypeError', 'Object', 'Promise'],
						locals: {
							_asyncIterator: ['body.0.id'],
							AsyncFromSyncIterator: [
								'body.1.id',
								'body.0.body.body.1.body.body.1.consequent.argument.callee',
								'body.1.body.body.1.argument.expressions.1.left.object',
								'body.1.body.body.1.argument.expressions.2.callee',
								'body.1.body.body.1.argument.expressions.0.left',
							],
						},
						exportBindingAssignments: [],
						exportName: '_asyncIterator',
						dependencies: {},
					},
				),
				asyncToGenerator: helper(
					'7.0.0-beta.0',
					'function asyncGeneratorStep(n,t,e,r,o,a,c){try{var i=n[a](c),u=i.value}catch(n){return void e(n)}i.done?t(u):Promise.resolve(u).then(r,o)}function _asyncToGenerator(n){return function(){var t=this,e=arguments;return new Promise((function(r,o){var a=n.apply(t,e);function _next(n){asyncGeneratorStep(a,r,o,_next,_throw,"next",n)}function _throw(n){asyncGeneratorStep(a,r,o,_next,_throw,"throw",n)}_next(void 0)}))}}',
					{
						globals: ['Promise'],
						locals: {
							asyncGeneratorStep: [
								'body.0.id',
								'body.1.body.body.0.argument.body.body.1.argument.arguments.0.body.body.1.body.body.0.expression.callee',
								'body.1.body.body.0.argument.body.body.1.argument.arguments.0.body.body.2.body.body.0.expression.callee',
							],
							_asyncToGenerator: ['body.1.id'],
						},
						exportBindingAssignments: [],
						exportName: '_asyncToGenerator',
						dependencies: {},
					},
				),
				awaitAsyncGenerator: helper(
					'7.0.0-beta.0',
					'function _awaitAsyncGenerator(e){return new OverloadYield(e,0)}',
					{
						globals: [],
						locals: {
							_awaitAsyncGenerator: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_awaitAsyncGenerator',
						dependencies: {
							OverloadYield: ['body.0.body.body.0.argument.callee'],
						},
					},
				),
				callSuper: helper(
					'7.23.8',
					'function _callSuper(t,o,e){return o=getPrototypeOf(o),possibleConstructorReturn(t,isNativeReflectConstruct()?Reflect.construct(o,e||[],getPrototypeOf(t).constructor):o.apply(t,e))}',
					{
						globals: ['Reflect'],
						locals: {
							_callSuper: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_callSuper',
						dependencies: {
							getPrototypeOf: [
								'body.0.body.body.0.argument.expressions.0.right.callee',
								'body.0.body.body.0.argument.expressions.1.arguments.1.consequent.arguments.2.object.callee',
							],
							isNativeReflectConstruct: [
								'body.0.body.body.0.argument.expressions.1.arguments.1.test.callee',
							],
							possibleConstructorReturn: [
								'body.0.body.body.0.argument.expressions.1.callee',
							],
						},
					},
				),
				checkInRHS: helper(
					'7.20.5',
					'function _checkInRHS(e){if(Object(e)!==e)throw TypeError("right-hand side of \'in\' should be an object, got "+(null!==e?typeof e:"null"));return e}',
					{
						globals: ['Object', 'TypeError'],
						locals: {
							_checkInRHS: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_checkInRHS',
						dependencies: {},
					},
				),
				checkPrivateRedeclaration: helper(
					'7.14.1',
					'function _checkPrivateRedeclaration(e,t){if(t.has(e))throw new TypeError("Cannot initialize the same private elements twice on an object")}',
					{
						globals: ['TypeError'],
						locals: {
							_checkPrivateRedeclaration: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_checkPrivateRedeclaration',
						dependencies: {},
					},
				),
				classCallCheck: helper(
					'7.0.0-beta.0',
					'function _classCallCheck(a,n){if(!(a instanceof n))throw new TypeError("Cannot call a class as a function")}',
					{
						globals: ['TypeError'],
						locals: {
							_classCallCheck: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_classCallCheck',
						dependencies: {},
					},
				),
				classNameTDZError: helper(
					'7.0.0-beta.0',
					"function _classNameTDZError(e){throw new ReferenceError('Class \"'+e+'\" cannot be referenced in computed property keys.')}",
					{
						globals: ['ReferenceError'],
						locals: {
							_classNameTDZError: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_classNameTDZError',
						dependencies: {},
					},
				),
				classPrivateFieldGet2: helper(
					'7.24.0',
					'function _classPrivateFieldGet2(s,a){return s.get(assertClassBrand(s,a))}',
					{
						globals: [],
						locals: {
							_classPrivateFieldGet2: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_classPrivateFieldGet2',
						dependencies: {
							assertClassBrand: [
								'body.0.body.body.0.argument.arguments.0.callee',
							],
						},
					},
				),
				classPrivateFieldInitSpec: helper(
					'7.14.1',
					'function _classPrivateFieldInitSpec(e,t,a){checkPrivateRedeclaration(e,t),t.set(e,a)}',
					{
						globals: [],
						locals: {
							_classPrivateFieldInitSpec: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_classPrivateFieldInitSpec',
						dependencies: {
							checkPrivateRedeclaration: [
								'body.0.body.body.0.expression.expressions.0.callee',
							],
						},
					},
				),
				classPrivateFieldLooseBase: helper(
					'7.0.0-beta.0',
					'function _classPrivateFieldBase(e,t){if(!{}.hasOwnProperty.call(e,t))throw new TypeError("attempted to use private field on non-instance");return e}',
					{
						globals: ['TypeError'],
						locals: {
							_classPrivateFieldBase: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_classPrivateFieldBase',
						dependencies: {},
					},
				),
				classPrivateFieldLooseKey: helper(
					'7.0.0-beta.0',
					'var id=0;function _classPrivateFieldKey(e){return"__private_"+id+++"_"+e}',
					{
						globals: [],
						locals: {
							id: [
								'body.0.declarations.0.id',
								'body.1.body.body.0.argument.left.left.right.argument',
								'body.1.body.body.0.argument.left.left.right.argument',
							],
							_classPrivateFieldKey: ['body.1.id'],
						},
						exportBindingAssignments: [],
						exportName: '_classPrivateFieldKey',
						dependencies: {},
					},
				),
				classPrivateFieldSet2: helper(
					'7.24.0',
					'function _classPrivateFieldSet2(s,a,r){return s.set(assertClassBrand(s,a),r),r}',
					{
						globals: [],
						locals: {
							_classPrivateFieldSet2: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_classPrivateFieldSet2',
						dependencies: {
							assertClassBrand: [
								'body.0.body.body.0.argument.expressions.0.arguments.0.callee',
							],
						},
					},
				),
				classPrivateGetter: helper(
					'7.24.0',
					'function _classPrivateGetter(s,r,a){return a(assertClassBrand(s,r))}',
					{
						globals: [],
						locals: {
							_classPrivateGetter: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_classPrivateGetter',
						dependencies: {
							assertClassBrand: [
								'body.0.body.body.0.argument.arguments.0.callee',
							],
						},
					},
				),
				classPrivateMethodInitSpec: helper(
					'7.14.1',
					'function _classPrivateMethodInitSpec(e,a){checkPrivateRedeclaration(e,a),a.add(e)}',
					{
						globals: [],
						locals: {
							_classPrivateMethodInitSpec: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_classPrivateMethodInitSpec',
						dependencies: {
							checkPrivateRedeclaration: [
								'body.0.body.body.0.expression.expressions.0.callee',
							],
						},
					},
				),
				classPrivateSetter: helper(
					'7.24.0',
					'function _classPrivateSetter(s,r,a,t){return r(assertClassBrand(s,a),t),t}',
					{
						globals: [],
						locals: {
							_classPrivateSetter: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_classPrivateSetter',
						dependencies: {
							assertClassBrand: [
								'body.0.body.body.0.argument.expressions.0.arguments.0.callee',
							],
						},
					},
				),
				classStaticPrivateMethodGet: helper(
					'7.3.2',
					'function _classStaticPrivateMethodGet(s,a,t){return assertClassBrand(a,s),t}',
					{
						globals: [],
						locals: {
							_classStaticPrivateMethodGet: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_classStaticPrivateMethodGet',
						dependencies: {
							assertClassBrand: [
								'body.0.body.body.0.argument.expressions.0.callee',
							],
						},
					},
				),
				construct: helper(
					'7.0.0-beta.0',
					'function _construct(t,e,r){if(isNativeReflectConstruct())return Reflect.construct.apply(null,arguments);var o=[null];o.push.apply(o,e);var p=new(t.bind.apply(t,o));return r&&setPrototypeOf(p,r.prototype),p}',
					{
						globals: ['Reflect'],
						locals: {
							_construct: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_construct',
						dependencies: {
							isNativeReflectConstruct: ['body.0.body.body.0.test.callee'],
							setPrototypeOf: [
								'body.0.body.body.4.argument.expressions.0.right.callee',
							],
						},
					},
				),
				createClass: helper(
					'7.0.0-beta.0',
					'function _defineProperties(e,r){for(var t=0;t<r.length;t++){var o=r[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,toPropertyKey(o.key),o)}}function _createClass(e,r,t){return r&&_defineProperties(e.prototype,r),t&&_defineProperties(e,t),Object.defineProperty(e,"prototype",{writable:!1}),e}',
					{
						globals: ['Object'],
						locals: {
							_defineProperties: [
								'body.0.id',
								'body.1.body.body.0.argument.expressions.0.right.callee',
								'body.1.body.body.0.argument.expressions.1.right.callee',
							],
							_createClass: ['body.1.id'],
						},
						exportBindingAssignments: [],
						exportName: '_createClass',
						dependencies: {
							toPropertyKey: [
								'body.0.body.body.0.body.body.1.expression.expressions.3.arguments.1.callee',
							],
						},
					},
				),
				createForOfIteratorHelper: helper(
					'7.9.0',
					'function _createForOfIteratorHelper(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(!t){if(Array.isArray(r)||(t=unsupportedIterableToArray(r))||e&&r&&"number"==typeof r.length){t&&(r=t);var n=0,F=function(){};return{s:F,n:function(){return n>=r.length?{done:!0}:{done:!1,value:r[n++]}},e:function(r){throw r},f:F}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,a=!0,u=!1;return{s:function(){t=t.call(r)},n:function(){var r=t.next();return a=r.done,r},e:function(r){u=!0,o=r},f:function(){try{a||null==t.return||t.return()}finally{if(u)throw o}}}}',
					{
						globals: ['Symbol', 'Array', 'TypeError'],
						locals: {
							_createForOfIteratorHelper: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_createForOfIteratorHelper',
						dependencies: {
							unsupportedIterableToArray: [
								'body.0.body.body.1.consequent.body.0.test.left.right.right.callee',
							],
						},
					},
				),
				createForOfIteratorHelperLoose: helper(
					'7.9.0',
					'function _createForOfIteratorHelperLoose(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(t)return(t=t.call(r)).next.bind(t);if(Array.isArray(r)||(t=unsupportedIterableToArray(r))||e&&r&&"number"==typeof r.length){t&&(r=t);var o=0;return function(){return o>=r.length?{done:!0}:{done:!1,value:r[o++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}',
					{
						globals: ['Symbol', 'Array', 'TypeError'],
						locals: {
							_createForOfIteratorHelperLoose: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_createForOfIteratorHelperLoose',
						dependencies: {
							unsupportedIterableToArray: [
								'body.0.body.body.2.test.left.right.right.callee',
							],
						},
					},
				),
				createSuper: helper(
					'7.9.0',
					'function _createSuper(t){var r=isNativeReflectConstruct();return function(){var e,o=getPrototypeOf(t);if(r){var s=getPrototypeOf(this).constructor;e=Reflect.construct(o,arguments,s)}else e=o.apply(this,arguments);return possibleConstructorReturn(this,e)}}',
					{
						globals: ['Reflect'],
						locals: {
							_createSuper: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_createSuper',
						dependencies: {
							getPrototypeOf: [
								'body.0.body.body.1.argument.body.body.0.declarations.1.init.callee',
								'body.0.body.body.1.argument.body.body.1.consequent.body.0.declarations.0.init.object.callee',
							],
							isNativeReflectConstruct: [
								'body.0.body.body.0.declarations.0.init.callee',
							],
							possibleConstructorReturn: [
								'body.0.body.body.1.argument.body.body.2.argument.callee',
							],
						},
					},
				),
				decorate: helper(
					'7.1.5',
					'function _decorate(e,r,t,i){var o=_getDecoratorsApi();if(i)for(var n=0;n<i.length;n++)o=i[n](o);var s=r((function(e){o.initializeInstanceElements(e,a.elements)}),t),a=o.decorateClass(_coalesceClassElements(s.d.map(_createElementDescriptor)),e);return o.initializeClassElements(s.F,a.elements),o.runClassFinishers(s.F,a.finishers)}function _getDecoratorsApi(){_getDecoratorsApi=function(){return e};var e={elementsDefinitionOrder:[["method"],["field"]],initializeInstanceElements:function(e,r){["method","field"].forEach((function(t){r.forEach((function(r){r.kind===t&&"own"===r.placement&&this.defineClassElement(e,r)}),this)}),this)},initializeClassElements:function(e,r){var t=e.prototype;["method","field"].forEach((function(i){r.forEach((function(r){var o=r.placement;if(r.kind===i&&("static"===o||"prototype"===o)){var n="static"===o?e:t;this.defineClassElement(n,r)}}),this)}),this)},defineClassElement:function(e,r){var t=r.descriptor;if("field"===r.kind){var i=r.initializer;t={enumerable:t.enumerable,writable:t.writable,configurable:t.configurable,value:void 0===i?void 0:i.call(e)}}Object.defineProperty(e,r.key,t)},decorateClass:function(e,r){var t=[],i=[],o={static:[],prototype:[],own:[]};if(e.forEach((function(e){this.addElementPlacement(e,o)}),this),e.forEach((function(e){if(!_hasDecorators(e))return t.push(e);var r=this.decorateElement(e,o);t.push(r.element),t.push.apply(t,r.extras),i.push.apply(i,r.finishers)}),this),!r)return{elements:t,finishers:i};var n=this.decorateConstructor(t,r);return i.push.apply(i,n.finishers),n.finishers=i,n},addElementPlacement:function(e,r,t){var i=r[e.placement];if(!t&&-1!==i.indexOf(e.key))throw new TypeError("Duplicated element ("+e.key+")");i.push(e.key)},decorateElement:function(e,r){for(var t=[],i=[],o=e.decorators,n=o.length-1;n>=0;n--){var s=r[e.placement];s.splice(s.indexOf(e.key),1);var a=this.fromElementDescriptor(e),l=this.toElementFinisherExtras((0,o[n])(a)||a);e=l.element,this.addElementPlacement(e,r),l.finisher&&i.push(l.finisher);var c=l.extras;if(c){for(var p=0;p<c.length;p++)this.addElementPlacement(c[p],r);t.push.apply(t,c)}}return{element:e,finishers:i,extras:t}},decorateConstructor:function(e,r){for(var t=[],i=r.length-1;i>=0;i--){var o=this.fromClassDescriptor(e),n=this.toClassDescriptor((0,r[i])(o)||o);if(void 0!==n.finisher&&t.push(n.finisher),void 0!==n.elements){e=n.elements;for(var s=0;s<e.length-1;s++)for(var a=s+1;a<e.length;a++)if(e[s].key===e[a].key&&e[s].placement===e[a].placement)throw new TypeError("Duplicated element ("+e[s].key+")")}}return{elements:e,finishers:t}},fromElementDescriptor:function(e){var r={kind:e.kind,key:e.key,placement:e.placement,descriptor:e.descriptor};return Object.defineProperty(r,Symbol.toStringTag,{value:"Descriptor",configurable:!0}),"field"===e.kind&&(r.initializer=e.initializer),r},toElementDescriptors:function(e){if(void 0!==e)return toArray(e).map((function(e){var r=this.toElementDescriptor(e);return this.disallowProperty(e,"finisher","An element descriptor"),this.disallowProperty(e,"extras","An element descriptor"),r}),this)},toElementDescriptor:function(e){var r=e.kind+"";if("method"!==r&&"field"!==r)throw new TypeError(\'An element descriptor\\\'s .kind property must be either "method" or "field", but a decorator created an element descriptor with .kind "\'+r+\'"\');var t=toPropertyKey(e.key),i=e.placement+"";if("static"!==i&&"prototype"!==i&&"own"!==i)throw new TypeError(\'An element descriptor\\\'s .placement property must be one of "static", "prototype" or "own", but a decorator created an element descriptor with .placement "\'+i+\'"\');var o=e.descriptor;this.disallowProperty(e,"elements","An element descriptor");var n={kind:r,key:t,placement:i,descriptor:Object.assign({},o)};return"field"!==r?this.disallowProperty(e,"initializer","A method descriptor"):(this.disallowProperty(o,"get","The property descriptor of a field descriptor"),this.disallowProperty(o,"set","The property descriptor of a field descriptor"),this.disallowProperty(o,"value","The property descriptor of a field descriptor"),n.initializer=e.initializer),n},toElementFinisherExtras:function(e){return{element:this.toElementDescriptor(e),finisher:_optionalCallableProperty(e,"finisher"),extras:this.toElementDescriptors(e.extras)}},fromClassDescriptor:function(e){var r={kind:"class",elements:e.map(this.fromElementDescriptor,this)};return Object.defineProperty(r,Symbol.toStringTag,{value:"Descriptor",configurable:!0}),r},toClassDescriptor:function(e){var r=e.kind+"";if("class"!==r)throw new TypeError(\'A class descriptor\\\'s .kind property must be "class", but a decorator created a class descriptor with .kind "\'+r+\'"\');this.disallowProperty(e,"key","A class descriptor"),this.disallowProperty(e,"placement","A class descriptor"),this.disallowProperty(e,"descriptor","A class descriptor"),this.disallowProperty(e,"initializer","A class descriptor"),this.disallowProperty(e,"extras","A class descriptor");var t=_optionalCallableProperty(e,"finisher");return{elements:this.toElementDescriptors(e.elements),finisher:t}},runClassFinishers:function(e,r){for(var t=0;t<r.length;t++){var i=(0,r[t])(e);if(void 0!==i){if("function"!=typeof i)throw new TypeError("Finishers must return a constructor.");e=i}}return e},disallowProperty:function(e,r,t){if(void 0!==e[r])throw new TypeError(t+" can\'t have a ."+r+" property.")}};return e}function _createElementDescriptor(e){var r,t=toPropertyKey(e.key);"method"===e.kind?r={value:e.value,writable:!0,configurable:!0,enumerable:!1}:"get"===e.kind?r={get:e.value,configurable:!0,enumerable:!1}:"set"===e.kind?r={set:e.value,configurable:!0,enumerable:!1}:"field"===e.kind&&(r={configurable:!0,writable:!0,enumerable:!0});var i={kind:"field"===e.kind?"field":"method",key:t,placement:e.static?"static":"field"===e.kind?"own":"prototype",descriptor:r};return e.decorators&&(i.decorators=e.decorators),"field"===e.kind&&(i.initializer=e.value),i}function _coalesceGetterSetter(e,r){void 0!==e.descriptor.get?r.descriptor.get=e.descriptor.get:r.descriptor.set=e.descriptor.set}function _coalesceClassElements(e){for(var r=[],isSameElement=function(e){return"method"===e.kind&&e.key===o.key&&e.placement===o.placement},t=0;t<e.length;t++){var i,o=e[t];if("method"===o.kind&&(i=r.find(isSameElement)))if(_isDataDescriptor(o.descriptor)||_isDataDescriptor(i.descriptor)){if(_hasDecorators(o)||_hasDecorators(i))throw new ReferenceError("Duplicated methods ("+o.key+") can\'t be decorated.");i.descriptor=o.descriptor}else{if(_hasDecorators(o)){if(_hasDecorators(i))throw new ReferenceError("Decorators can\'t be placed on different accessors with for the same property ("+o.key+").");i.decorators=o.decorators}_coalesceGetterSetter(o,i)}else r.push(o)}return r}function _hasDecorators(e){return e.decorators&&e.decorators.length}function _isDataDescriptor(e){return void 0!==e&&!(void 0===e.value&&void 0===e.writable)}function _optionalCallableProperty(e,r){var t=e[r];if(void 0!==t&&"function"!=typeof t)throw new TypeError("Expected \'"+r+"\' to be a function");return t}',
					{
						globals: ['Object', 'TypeError', 'Symbol', 'ReferenceError'],
						locals: {
							_decorate: ['body.0.id'],
							_getDecoratorsApi: [
								'body.1.id',
								'body.0.body.body.0.declarations.0.init.callee',
								'body.1.body.body.0.expression.left',
							],
							_createElementDescriptor: [
								'body.2.id',
								'body.0.body.body.2.declarations.1.init.arguments.0.arguments.0.arguments.0',
							],
							_coalesceGetterSetter: [
								'body.3.id',
								'body.4.body.body.0.body.body.1.consequent.alternate.body.1.expression.callee',
							],
							_coalesceClassElements: [
								'body.4.id',
								'body.0.body.body.2.declarations.1.init.arguments.0.callee',
							],
							_hasDecorators: [
								'body.5.id',
								'body.1.body.body.1.declarations.0.init.properties.4.value.body.body.1.test.expressions.1.arguments.0.body.body.0.test.argument.callee',
								'body.4.body.body.0.body.body.1.consequent.consequent.body.0.test.left.callee',
								'body.4.body.body.0.body.body.1.consequent.consequent.body.0.test.right.callee',
								'body.4.body.body.0.body.body.1.consequent.alternate.body.0.test.callee',
								'body.4.body.body.0.body.body.1.consequent.alternate.body.0.consequent.body.0.test.callee',
							],
							_isDataDescriptor: [
								'body.6.id',
								'body.4.body.body.0.body.body.1.consequent.test.left.callee',
								'body.4.body.body.0.body.body.1.consequent.test.right.callee',
							],
							_optionalCallableProperty: [
								'body.7.id',
								'body.1.body.body.1.declarations.0.init.properties.11.value.body.body.0.argument.properties.1.value.callee',
								'body.1.body.body.1.declarations.0.init.properties.13.value.body.body.3.declarations.0.init.callee',
							],
						},
						exportBindingAssignments: [],
						exportName: '_decorate',
						dependencies: {
							toArray: [
								'body.1.body.body.1.declarations.0.init.properties.9.value.body.body.0.consequent.argument.callee.object.callee',
							],
							toPropertyKey: [
								'body.1.body.body.1.declarations.0.init.properties.10.value.body.body.2.declarations.0.init.callee',
								'body.2.body.body.0.declarations.1.init.callee',
							],
						},
					},
				),
				defaults: helper(
					'7.0.0-beta.0',
					'function _defaults(e,r){for(var t=Object.getOwnPropertyNames(r),o=0;o<t.length;o++){var n=t[o],a=Object.getOwnPropertyDescriptor(r,n);a&&a.configurable&&void 0===e[n]&&Object.defineProperty(e,n,a)}return e}',
					{
						globals: ['Object'],
						locals: {
							_defaults: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_defaults',
						dependencies: {},
					},
				),
				defineAccessor: helper(
					'7.20.7',
					'function _defineAccessor(e,r,n,t){var c={configurable:!0,enumerable:!0};return c[e]=t,Object.defineProperty(r,n,c)}',
					{
						globals: ['Object'],
						locals: {
							_defineAccessor: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_defineAccessor',
						dependencies: {},
					},
				),
				defineProperty: helper(
					'7.0.0-beta.0',
					'function _defineProperty(e,r,t){return(r=toPropertyKey(r))in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}',
					{
						globals: ['Object'],
						locals: {
							_defineProperty: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_defineProperty',
						dependencies: {
							toPropertyKey: [
								'body.0.body.body.0.argument.expressions.0.test.left.right.callee',
							],
						},
					},
				),
				extends: helper(
					'7.0.0-beta.0',
					'function _extends(){return _extends=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)({}).hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},_extends.apply(null,arguments)}',
					{
						globals: ['Object'],
						locals: {
							_extends: [
								'body.0.id',
								'body.0.body.body.0.argument.expressions.1.callee.object',
								'body.0.body.body.0.argument.expressions.0.left',
							],
						},
						exportBindingAssignments: [
							'body.0.body.body.0.argument.expressions.0',
						],
						exportName: '_extends',
						dependencies: {},
					},
				),
				get: helper(
					'7.0.0-beta.0',
					'function _get(){return _get="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(e,t,r){var p=superPropBase(e,t);if(p){var n=Object.getOwnPropertyDescriptor(p,t);return n.get?n.get.call(arguments.length<3?e:r):n.value}},_get.apply(null,arguments)}',
					{
						globals: ['Reflect', 'Object'],
						locals: {
							_get: [
								'body.0.id',
								'body.0.body.body.0.argument.expressions.1.callee.object',
								'body.0.body.body.0.argument.expressions.0.left',
							],
						},
						exportBindingAssignments: [
							'body.0.body.body.0.argument.expressions.0',
						],
						exportName: '_get',
						dependencies: {
							superPropBase: [
								'body.0.body.body.0.argument.expressions.0.right.alternate.body.body.0.declarations.0.init.callee',
							],
						},
					},
				),
				getPrototypeOf: helper(
					'7.0.0-beta.0',
					'function _getPrototypeOf(t){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},_getPrototypeOf(t)}',
					{
						globals: ['Object'],
						locals: {
							_getPrototypeOf: [
								'body.0.id',
								'body.0.body.body.0.argument.expressions.1.callee',
								'body.0.body.body.0.argument.expressions.0.left',
							],
						},
						exportBindingAssignments: [
							'body.0.body.body.0.argument.expressions.0',
						],
						exportName: '_getPrototypeOf',
						dependencies: {},
					},
				),
				identity: helper('7.17.0', 'function _identity(t){return t}', {
					globals: [],
					locals: {
						_identity: ['body.0.id'],
					},
					exportBindingAssignments: [],
					exportName: '_identity',
					dependencies: {},
				}),
				importDeferProxy: helper(
					'7.23.0',
					'function _importDeferProxy(e){var t=null,constValue=function(e){return function(){return e}},proxy=function(r){return function(n,o,f){return null===t&&(t=e()),r(t,o,f)}};return new Proxy({},{defineProperty:constValue(!1),deleteProperty:constValue(!1),get:proxy(Reflect.get),getOwnPropertyDescriptor:proxy(Reflect.getOwnPropertyDescriptor),getPrototypeOf:constValue(null),isExtensible:constValue(!1),has:proxy(Reflect.has),ownKeys:proxy(Reflect.ownKeys),preventExtensions:constValue(!0),set:constValue(!1),setPrototypeOf:constValue(!1)})}',
					{
						globals: ['Proxy', 'Reflect'],
						locals: {
							_importDeferProxy: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_importDeferProxy',
						dependencies: {},
					},
				),
				inherits: helper(
					'7.0.0-beta.0',
					'function _inherits(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&setPrototypeOf(t,e)}',
					{
						globals: ['TypeError', 'Object'],
						locals: {
							_inherits: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_inherits',
						dependencies: {
							setPrototypeOf: [
								'body.0.body.body.1.expression.expressions.2.right.callee',
							],
						},
					},
				),
				inheritsLoose: helper(
					'7.0.0-beta.0',
					'function _inheritsLoose(t,o){t.prototype=Object.create(o.prototype),t.prototype.constructor=t,setPrototypeOf(t,o)}',
					{
						globals: ['Object'],
						locals: {
							_inheritsLoose: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_inheritsLoose',
						dependencies: {
							setPrototypeOf: [
								'body.0.body.body.0.expression.expressions.2.callee',
							],
						},
					},
				),
				initializerDefineProperty: helper(
					'7.0.0-beta.0',
					'function _initializerDefineProperty(e,i,r,l){r&&Object.defineProperty(e,i,{enumerable:r.enumerable,configurable:r.configurable,writable:r.writable,value:r.initializer?r.initializer.call(l):void 0})}',
					{
						globals: ['Object'],
						locals: {
							_initializerDefineProperty: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_initializerDefineProperty',
						dependencies: {},
					},
				),
				initializerWarningHelper: helper(
					'7.0.0-beta.0',
					'function _initializerWarningHelper(r,e){throw Error("Decorating class property failed. Please ensure that transform-class-properties is enabled and runs after the decorators transform.")}',
					{
						globals: ['Error'],
						locals: {
							_initializerWarningHelper: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_initializerWarningHelper',
						dependencies: {},
					},
				),
				instanceof: helper(
					'7.0.0-beta.0',
					'function _instanceof(n,e){return null!=e&&"undefined"!=typeof Symbol&&e[Symbol.hasInstance]?!!e[Symbol.hasInstance](n):n instanceof e}',
					{
						globals: ['Symbol'],
						locals: {
							_instanceof: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_instanceof',
						dependencies: {},
					},
				),
				interopRequireDefault: helper(
					'7.0.0-beta.0',
					'function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}',
					{
						globals: [],
						locals: {
							_interopRequireDefault: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_interopRequireDefault',
						dependencies: {},
					},
				),
				interopRequireWildcard: helper(
					'7.14.0',
					'function _interopRequireWildcard(e,t){if("function"==typeof WeakMap)var r=new WeakMap,n=new WeakMap;return(_interopRequireWildcard=function(e,t){if(!t&&e&&e.__esModule)return e;var o,i,f={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return f;if(o=t?n:r){if(o.has(e))return o.get(e);o.set(e,f)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((i=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(i.get||i.set)?o(f,t,i):f[t]=e[t]);return f})(e,t)}',
					{
						globals: ['WeakMap', 'Object'],
						locals: {
							_interopRequireWildcard: [
								'body.0.id',
								'body.0.body.body.1.argument.callee.left',
							],
						},
						exportBindingAssignments: ['body.0.body.body.1.argument.callee'],
						exportName: '_interopRequireWildcard',
						dependencies: {},
					},
				),
				isNativeFunction: helper(
					'7.0.0-beta.0',
					'function _isNativeFunction(t){try{return-1!==Function.toString.call(t).indexOf("[native code]")}catch(n){return"function"==typeof t}}',
					{
						globals: ['Function'],
						locals: {
							_isNativeFunction: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_isNativeFunction',
						dependencies: {},
					},
				),
				isNativeReflectConstruct: helper(
					'7.9.0',
					'function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(_isNativeReflectConstruct=function(){return!!t})()}',
					{
						globals: ['Boolean', 'Reflect'],
						locals: {
							_isNativeReflectConstruct: [
								'body.0.id',
								'body.0.body.body.1.argument.callee.left',
							],
						},
						exportBindingAssignments: ['body.0.body.body.1.argument.callee'],
						exportName: '_isNativeReflectConstruct',
						dependencies: {},
					},
				),
				iterableToArray: helper(
					'7.0.0-beta.0',
					'function _iterableToArray(r){if("undefined"!=typeof Symbol&&null!=r[Symbol.iterator]||null!=r["@@iterator"])return Array.from(r)}',
					{
						globals: ['Symbol', 'Array'],
						locals: {
							_iterableToArray: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_iterableToArray',
						dependencies: {},
					},
				),
				iterableToArrayLimit: helper(
					'7.0.0-beta.0',
					'function _iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1}else for(;!(f=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r}finally{try{if(!f&&null!=t.return&&(u=t.return(),Object(u)!==u))return}finally{if(o)throw n}}return a}}',
					{
						globals: ['Symbol', 'Object'],
						locals: {
							_iterableToArrayLimit: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_iterableToArrayLimit',
						dependencies: {},
					},
				),
				jsx: helper(
					'7.0.0-beta.0',
					'var REACT_ELEMENT_TYPE;function _createRawReactElement(e,r,E,l){REACT_ELEMENT_TYPE||(REACT_ELEMENT_TYPE="function"==typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103);var o=e&&e.defaultProps,n=arguments.length-3;if(r||0===n||(r={children:void 0}),1===n)r.children=l;else if(n>1){for(var t=Array(n),f=0;f<n;f++)t[f]=arguments[f+3];r.children=t}if(r&&o)for(var i in o)void 0===r[i]&&(r[i]=o[i]);else r||(r=o||{});return{$$typeof:REACT_ELEMENT_TYPE,type:e,key:void 0===E?null:""+E,ref:null,props:r,_owner:null}}',
					{
						globals: ['Symbol', 'Array'],
						locals: {
							REACT_ELEMENT_TYPE: [
								'body.0.declarations.0.id',
								'body.1.body.body.0.expression.left',
								'body.1.body.body.4.argument.properties.0.value',
								'body.1.body.body.0.expression.right.left',
							],
							_createRawReactElement: ['body.1.id'],
						},
						exportBindingAssignments: [],
						exportName: '_createRawReactElement',
						dependencies: {},
					},
				),
				maybeArrayLike: helper(
					'7.9.0',
					'function _maybeArrayLike(r,a,e){if(a&&!Array.isArray(a)&&"number"==typeof a.length){var y=a.length;return arrayLikeToArray(a,void 0!==e&&e<y?e:y)}return r(a,e)}',
					{
						globals: ['Array'],
						locals: {
							_maybeArrayLike: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_maybeArrayLike',
						dependencies: {
							arrayLikeToArray: [
								'body.0.body.body.0.consequent.body.1.argument.callee',
							],
						},
					},
				),
				newArrowCheck: helper(
					'7.0.0-beta.0',
					'function _newArrowCheck(n,r){if(n!==r)throw new TypeError("Cannot instantiate an arrow function")}',
					{
						globals: ['TypeError'],
						locals: {
							_newArrowCheck: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_newArrowCheck',
						dependencies: {},
					},
				),
				nonIterableRest: helper(
					'7.0.0-beta.0',
					'function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}',
					{
						globals: ['TypeError'],
						locals: {
							_nonIterableRest: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_nonIterableRest',
						dependencies: {},
					},
				),
				nonIterableSpread: helper(
					'7.0.0-beta.0',
					'function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}',
					{
						globals: ['TypeError'],
						locals: {
							_nonIterableSpread: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_nonIterableSpread',
						dependencies: {},
					},
				),
				nullishReceiverError: helper(
					'7.22.6',
					'function _nullishReceiverError(r){throw new TypeError("Cannot set property of null or undefined.")}',
					{
						globals: ['TypeError'],
						locals: {
							_nullishReceiverError: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_nullishReceiverError',
						dependencies: {},
					},
				),
				objectDestructuringEmpty: helper(
					'7.0.0-beta.0',
					'function _objectDestructuringEmpty(t){if(null==t)throw new TypeError("Cannot destructure "+t)}',
					{
						globals: ['TypeError'],
						locals: {
							_objectDestructuringEmpty: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_objectDestructuringEmpty',
						dependencies: {},
					},
				),
				objectSpread2: helper(
					'7.5.0',
					'function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,o)}return t}function _objectSpread2(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach((function(r){defineProperty(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}',
					{
						globals: ['Object'],
						locals: {
							ownKeys: [
								'body.0.id',
								'body.1.body.body.0.body.body.1.expression.consequent.callee.object.callee',
								'body.1.body.body.0.body.body.1.expression.alternate.alternate.callee.object.callee',
							],
							_objectSpread2: ['body.1.id'],
						},
						exportBindingAssignments: [],
						exportName: '_objectSpread2',
						dependencies: {
							defineProperty: [
								'body.1.body.body.0.body.body.1.expression.consequent.arguments.0.body.body.0.expression.callee',
							],
						},
					},
				),
				objectWithoutProperties: helper(
					'7.0.0-beta.0',
					'function _objectWithoutProperties(e,t){if(null==e)return{};var o,r,i=objectWithoutPropertiesLoose(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(r=0;r<n.length;r++)o=n[r],-1===t.indexOf(o)&&{}.propertyIsEnumerable.call(e,o)&&(i[o]=e[o])}return i}',
					{
						globals: ['Object'],
						locals: {
							_objectWithoutProperties: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_objectWithoutProperties',
						dependencies: {
							objectWithoutPropertiesLoose: [
								'body.0.body.body.1.declarations.2.init.callee',
							],
						},
					},
				),
				objectWithoutPropertiesLoose: helper(
					'7.0.0-beta.0',
					'function _objectWithoutPropertiesLoose(r,e){if(null==r)return{};var t={};for(var n in r)if({}.hasOwnProperty.call(r,n)){if(-1!==e.indexOf(n))continue;t[n]=r[n]}return t}',
					{
						globals: [],
						locals: {
							_objectWithoutPropertiesLoose: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_objectWithoutPropertiesLoose',
						dependencies: {},
					},
				),
				possibleConstructorReturn: helper(
					'7.0.0-beta.0',
					'function _possibleConstructorReturn(t,e){if(e&&("object"==typeof e||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return assertThisInitialized(t)}',
					{
						globals: ['TypeError'],
						locals: {
							_possibleConstructorReturn: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_possibleConstructorReturn',
						dependencies: {
							assertThisInitialized: ['body.0.body.body.2.argument.callee'],
						},
					},
				),
				readOnlyError: helper(
					'7.0.0-beta.0',
					"function _readOnlyError(r){throw new TypeError('\"'+r+'\" is read-only')}",
					{
						globals: ['TypeError'],
						locals: {
							_readOnlyError: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_readOnlyError',
						dependencies: {},
					},
				),
				regeneratorRuntime: helper(
					'7.18.0',
					'function _regeneratorRuntime(){"use strict";\n/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */_regeneratorRuntime=function(){return r};var t,r={},e=Object.prototype,n=e.hasOwnProperty,o="function"==typeof Symbol?Symbol:{},i=o.iterator||"@@iterator",a=o.asyncIterator||"@@asyncIterator",u=o.toStringTag||"@@toStringTag";function c(t,r,e,n){return Object.defineProperty(t,r,{value:e,enumerable:!n,configurable:!n,writable:!n})}try{c({},"")}catch(t){c=function(t,r,e){return t[r]=e}}function h(r,e,n,o){var i=e&&e.prototype instanceof Generator?e:Generator,a=Object.create(i.prototype);return c(a,"_invoke",function(r,e,n){var o=1;return function(i,a){if(3===o)throw Error("Generator is already running");if(4===o){if("throw"===i)throw a;return{value:t,done:!0}}for(n.method=i,n.arg=a;;){var u=n.delegate;if(u){var c=d(u,n);if(c){if(c===f)continue;return c}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if(1===o)throw o=4,n.arg;n.dispatchException(n.arg)}else"return"===n.method&&n.abrupt("return",n.arg);o=3;var h=s(r,e,n);if("normal"===h.type){if(o=n.done?4:2,h.arg===f)continue;return{value:h.arg,done:n.done}}"throw"===h.type&&(o=4,n.method="throw",n.arg=h.arg)}}}(r,n,new Context(o||[])),!0),a}function s(t,r,e){try{return{type:"normal",arg:t.call(r,e)}}catch(t){return{type:"throw",arg:t}}}r.wrap=h;var f={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var l={};c(l,i,(function(){return this}));var p=Object.getPrototypeOf,y=p&&p(p(x([])));y&&y!==e&&n.call(y,i)&&(l=y);var v=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(l);function g(t){["next","throw","return"].forEach((function(r){c(t,r,(function(t){return this._invoke(r,t)}))}))}function AsyncIterator(t,r){function e(o,i,a,u){var c=s(t[o],t,i);if("throw"!==c.type){var h=c.arg,f=h.value;return f&&"object"==typeof f&&n.call(f,"__await")?r.resolve(f.__await).then((function(t){e("next",t,a,u)}),(function(t){e("throw",t,a,u)})):r.resolve(f).then((function(t){h.value=t,a(h)}),(function(t){return e("throw",t,a,u)}))}u(c.arg)}var o;c(this,"_invoke",(function(t,n){function i(){return new r((function(r,o){e(t,n,r,o)}))}return o=o?o.then(i,i):i()}),!0)}function d(r,e){var n=e.method,o=r.i[n];if(o===t)return e.delegate=null,"throw"===n&&r.i.return&&(e.method="return",e.arg=t,d(r,e),"throw"===e.method)||"return"!==n&&(e.method="throw",e.arg=new TypeError("The iterator does not provide a \'"+n+"\' method")),f;var i=s(o,r.i,e.arg);if("throw"===i.type)return e.method="throw",e.arg=i.arg,e.delegate=null,f;var a=i.arg;return a?a.done?(e[r.r]=a.value,e.next=r.n,"return"!==e.method&&(e.method="next",e.arg=t),e.delegate=null,f):a:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,f)}function w(t){this.tryEntries.push(t)}function m(r){var e=r[4]||{};e.type="normal",e.arg=t,r[4]=e}function Context(t){this.tryEntries=[[-1]],t.forEach(w,this),this.reset(!0)}function x(r){if(null!=r){var e=r[i];if(e)return e.call(r);if("function"==typeof r.next)return r;if(!isNaN(r.length)){var o=-1,a=function e(){for(;++o<r.length;)if(n.call(r,o))return e.value=r[o],e.done=!1,e;return e.value=t,e.done=!0,e};return a.next=a}}throw new TypeError(typeof r+" is not iterable")}return GeneratorFunction.prototype=GeneratorFunctionPrototype,c(v,"constructor",GeneratorFunctionPrototype),c(GeneratorFunctionPrototype,"constructor",GeneratorFunction),GeneratorFunction.displayName=c(GeneratorFunctionPrototype,u,"GeneratorFunction"),r.isGeneratorFunction=function(t){var r="function"==typeof t&&t.constructor;return!!r&&(r===GeneratorFunction||"GeneratorFunction"===(r.displayName||r.name))},r.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,GeneratorFunctionPrototype):(t.__proto__=GeneratorFunctionPrototype,c(t,u,"GeneratorFunction")),t.prototype=Object.create(v),t},r.awrap=function(t){return{__await:t}},g(AsyncIterator.prototype),c(AsyncIterator.prototype,a,(function(){return this})),r.AsyncIterator=AsyncIterator,r.async=function(t,e,n,o,i){void 0===i&&(i=Promise);var a=new AsyncIterator(h(t,e,n,o),i);return r.isGeneratorFunction(e)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},g(v),c(v,u,"Generator"),c(v,i,(function(){return this})),c(v,"toString",(function(){return"[object Generator]"})),r.keys=function(t){var r=Object(t),e=[];for(var n in r)e.unshift(n);return function t(){for(;e.length;)if((n=e.pop())in r)return t.value=n,t.done=!1,t;return t.done=!0,t}},r.values=x,Context.prototype={constructor:Context,reset:function(r){if(this.prev=this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(m),!r)for(var e in this)"t"===e.charAt(0)&&n.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=t)},stop:function(){this.done=!0;var t=this.tryEntries[0][4];if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(r){if(this.done)throw r;var e=this;function n(t){a.type="throw",a.arg=r,e.next=t}for(var o=e.tryEntries.length-1;o>=0;--o){var i=this.tryEntries[o],a=i[4],u=this.prev,c=i[1],h=i[2];if(-1===i[0])return n("end"),!1;if(!c&&!h)throw Error("try statement without catch or finally");if(null!=i[0]&&i[0]<=u){if(u<c)return this.method="next",this.arg=t,n(c),!0;if(u<h)return n(h),!1}}},abrupt:function(t,r){for(var e=this.tryEntries.length-1;e>=0;--e){var n=this.tryEntries[e];if(n[0]>-1&&n[0]<=this.prev&&this.prev<n[2]){var o=n;break}}o&&("break"===t||"continue"===t)&&o[0]<=r&&r<=o[2]&&(o=null);var i=o?o[4]:{};return i.type=t,i.arg=r,o?(this.method="next",this.next=o[2],f):this.complete(i)},complete:function(t,r){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&r&&(this.next=r),f},finish:function(t){for(var r=this.tryEntries.length-1;r>=0;--r){var e=this.tryEntries[r];if(e[2]===t)return this.complete(e[4],e[3]),m(e),f}},catch:function(t){for(var r=this.tryEntries.length-1;r>=0;--r){var e=this.tryEntries[r];if(e[0]===t){var n=e[4];if("throw"===n.type){var o=n.arg;m(e)}return o}}throw Error("illegal catch attempt")},delegateYield:function(r,e,n){return this.delegate={i:x(r),r:e,n:n},"next"===this.method&&(this.arg=t),f}},r}',
					{
						globals: [
							'Object',
							'Symbol',
							'Error',
							'TypeError',
							'isNaN',
							'Promise',
						],
						locals: {
							_regeneratorRuntime: [
								'body.0.id',
								'body.0.body.body.0.expression.left',
							],
						},
						exportBindingAssignments: ['body.0.body.body.0.expression'],
						exportName: '_regeneratorRuntime',
						dependencies: {},
					},
				),
				set: helper(
					'7.0.0-beta.0',
					'function set(e,r,t,o){return set="undefined"!=typeof Reflect&&Reflect.set?Reflect.set:function(e,r,t,o){var f,i=superPropBase(e,r);if(i){if((f=Object.getOwnPropertyDescriptor(i,r)).set)return f.set.call(o,t),!0;if(!f.writable)return!1}if(f=Object.getOwnPropertyDescriptor(o,r)){if(!f.writable)return!1;f.value=t,Object.defineProperty(o,r,f)}else defineProperty(o,r,t);return!0},set(e,r,t,o)}function _set(e,r,t,o,f){if(!set(e,r,t,o||e)&&f)throw new TypeError("failed to set property");return t}',
					{
						globals: ['Reflect', 'Object', 'TypeError'],
						locals: {
							set: [
								'body.0.id',
								'body.0.body.body.0.argument.expressions.1.callee',
								'body.1.body.body.0.test.left.argument.callee',
								'body.0.body.body.0.argument.expressions.0.left',
							],
							_set: ['body.1.id'],
						},
						exportBindingAssignments: [],
						exportName: '_set',
						dependencies: {
							superPropBase: [
								'body.0.body.body.0.argument.expressions.0.right.alternate.body.body.0.declarations.1.init.callee',
							],
							defineProperty: [
								'body.0.body.body.0.argument.expressions.0.right.alternate.body.body.2.alternate.expression.callee',
							],
						},
					},
				),
				setFunctionName: helper(
					'7.23.6',
					'function setFunctionName(e,t,n){"symbol"==typeof t&&(t=(t=t.description)?"["+t+"]":"");try{Object.defineProperty(e,"name",{configurable:!0,value:n?n+" "+t:t})}catch(e){}return e}',
					{
						globals: ['Object'],
						locals: {
							setFunctionName: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: 'setFunctionName',
						dependencies: {},
					},
				),
				setPrototypeOf: helper(
					'7.0.0-beta.0',
					'function _setPrototypeOf(t,e){return _setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},_setPrototypeOf(t,e)}',
					{
						globals: ['Object'],
						locals: {
							_setPrototypeOf: [
								'body.0.id',
								'body.0.body.body.0.argument.expressions.1.callee',
								'body.0.body.body.0.argument.expressions.0.left',
							],
						},
						exportBindingAssignments: [
							'body.0.body.body.0.argument.expressions.0',
						],
						exportName: '_setPrototypeOf',
						dependencies: {},
					},
				),
				skipFirstGeneratorNext: helper(
					'7.0.0-beta.0',
					'function _skipFirstGeneratorNext(t){return function(){var r=t.apply(this,arguments);return r.next(),r}}',
					{
						globals: [],
						locals: {
							_skipFirstGeneratorNext: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_skipFirstGeneratorNext',
						dependencies: {},
					},
				),
				slicedToArray: helper(
					'7.0.0-beta.0',
					'function _slicedToArray(r,e){return arrayWithHoles(r)||iterableToArrayLimit(r,e)||unsupportedIterableToArray(r,e)||nonIterableRest()}',
					{
						globals: [],
						locals: {
							_slicedToArray: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_slicedToArray',
						dependencies: {
							arrayWithHoles: [
								'body.0.body.body.0.argument.left.left.left.callee',
							],
							iterableToArrayLimit: [
								'body.0.body.body.0.argument.left.left.right.callee',
							],
							unsupportedIterableToArray: [
								'body.0.body.body.0.argument.left.right.callee',
							],
							nonIterableRest: ['body.0.body.body.0.argument.right.callee'],
						},
					},
				),
				superPropBase: helper(
					'7.0.0-beta.0',
					'function _superPropBase(t,o){for(;!{}.hasOwnProperty.call(t,o)&&null!==(t=getPrototypeOf(t)););return t}',
					{
						globals: [],
						locals: {
							_superPropBase: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_superPropBase',
						dependencies: {
							getPrototypeOf: [
								'body.0.body.body.0.test.right.right.right.callee',
							],
						},
					},
				),
				superPropGet: helper(
					'7.25.0',
					'function _superPropGet(t,o,e,r){var p=get(getPrototypeOf(1&r?t.prototype:t),o,e);return 2&r&&"function"==typeof p?function(t){return p.apply(e,t)}:p}',
					{
						globals: [],
						locals: {
							_superPropGet: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_superPropGet',
						dependencies: {
							get: ['body.0.body.body.0.declarations.0.init.callee'],
							getPrototypeOf: [
								'body.0.body.body.0.declarations.0.init.arguments.0.callee',
							],
						},
					},
				),
				superPropSet: helper(
					'7.25.0',
					'function _superPropSet(t,e,o,r,p,f){return set(getPrototypeOf(f?t.prototype:t),e,o,r,p)}',
					{
						globals: [],
						locals: {
							_superPropSet: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_superPropSet',
						dependencies: {
							set: ['body.0.body.body.0.argument.callee'],
							getPrototypeOf: [
								'body.0.body.body.0.argument.arguments.0.callee',
							],
						},
					},
				),
				taggedTemplateLiteral: helper(
					'7.0.0-beta.0',
					'function _taggedTemplateLiteral(e,t){return t||(t=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(t)}}))}',
					{
						globals: ['Object'],
						locals: {
							_taggedTemplateLiteral: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_taggedTemplateLiteral',
						dependencies: {},
					},
				),
				taggedTemplateLiteralLoose: helper(
					'7.0.0-beta.0',
					'function _taggedTemplateLiteralLoose(e,t){return t||(t=e.slice(0)),e.raw=t,e}',
					{
						globals: [],
						locals: {
							_taggedTemplateLiteralLoose: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_taggedTemplateLiteralLoose',
						dependencies: {},
					},
				),
				tdz: helper(
					'7.5.5',
					'function _tdzError(e){throw new ReferenceError(e+" is not defined - temporal dead zone")}',
					{
						globals: ['ReferenceError'],
						locals: {
							_tdzError: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_tdzError',
						dependencies: {},
					},
				),
				temporalRef: helper(
					'7.0.0-beta.0',
					'function _temporalRef(r,e){return r===undef?err(e):r}',
					{
						globals: [],
						locals: {
							_temporalRef: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_temporalRef',
						dependencies: {
							temporalUndefined: ['body.0.body.body.0.argument.test.right'],
							tdz: ['body.0.body.body.0.argument.consequent.callee'],
						},
					},
				),
				temporalUndefined: helper(
					'7.0.0-beta.0',
					'function _temporalUndefined(){}',
					{
						globals: [],
						locals: {
							_temporalUndefined: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_temporalUndefined',
						dependencies: {},
					},
				),
				toArray: helper(
					'7.0.0-beta.0',
					'function _toArray(r){return arrayWithHoles(r)||iterableToArray(r)||unsupportedIterableToArray(r)||nonIterableRest()}',
					{
						globals: [],
						locals: {
							_toArray: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_toArray',
						dependencies: {
							arrayWithHoles: [
								'body.0.body.body.0.argument.left.left.left.callee',
							],
							iterableToArray: [
								'body.0.body.body.0.argument.left.left.right.callee',
							],
							unsupportedIterableToArray: [
								'body.0.body.body.0.argument.left.right.callee',
							],
							nonIterableRest: ['body.0.body.body.0.argument.right.callee'],
						},
					},
				),
				toConsumableArray: helper(
					'7.0.0-beta.0',
					'function _toConsumableArray(r){return arrayWithoutHoles(r)||iterableToArray(r)||unsupportedIterableToArray(r)||nonIterableSpread()}',
					{
						globals: [],
						locals: {
							_toConsumableArray: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_toConsumableArray',
						dependencies: {
							arrayWithoutHoles: [
								'body.0.body.body.0.argument.left.left.left.callee',
							],
							iterableToArray: [
								'body.0.body.body.0.argument.left.left.right.callee',
							],
							unsupportedIterableToArray: [
								'body.0.body.body.0.argument.left.right.callee',
							],
							nonIterableSpread: ['body.0.body.body.0.argument.right.callee'],
						},
					},
				),
				toPrimitive: helper(
					'7.1.5',
					'function toPrimitive(t,r){if("object"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||"default");if("object"!=typeof i)return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===r?String:Number)(t)}',
					{
						globals: ['Symbol', 'TypeError', 'String', 'Number'],
						locals: {
							toPrimitive: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: 'toPrimitive',
						dependencies: {},
					},
				),
				toPropertyKey: helper(
					'7.1.5',
					'function toPropertyKey(t){var i=toPrimitive(t,"string");return"symbol"==typeof i?i:i+""}',
					{
						globals: [],
						locals: {
							toPropertyKey: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: 'toPropertyKey',
						dependencies: {
							toPrimitive: ['body.0.body.body.0.declarations.0.init.callee'],
						},
					},
				),
				toSetter: helper(
					'7.24.0',
					'function _toSetter(t,e,n){e||(e=[]);var r=e.length++;return Object.defineProperty({},"_",{set:function(o){e[r]=o,t.apply(n,e)}})}',
					{
						globals: ['Object'],
						locals: {
							_toSetter: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_toSetter',
						dependencies: {},
					},
				),
				tsRewriteRelativeImportExtensions: helper(
					'7.27.0',
					'function tsRewriteRelativeImportExtensions(t,e){return"string"==typeof t&&/^\\.\\.?\\//.test(t)?t.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+)?)\\.([cm]?)ts$/i,(function(t,s,r,n,o){return s?e?".jsx":".js":!r||n&&o?r+n+"."+o.toLowerCase()+"js":t})):t}',
					{
						globals: [],
						locals: {
							tsRewriteRelativeImportExtensions: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: 'tsRewriteRelativeImportExtensions',
						dependencies: {},
					},
				),
				typeof: helper(
					'7.0.0-beta.0',
					'function _typeof(o){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o},_typeof(o)}',
					{
						globals: ['Symbol'],
						locals: {
							_typeof: [
								'body.0.id',
								'body.0.body.body.0.argument.expressions.1.callee',
								'body.0.body.body.0.argument.expressions.0.left',
							],
						},
						exportBindingAssignments: [
							'body.0.body.body.0.argument.expressions.0',
						],
						exportName: '_typeof',
						dependencies: {},
					},
				),
				unsupportedIterableToArray: helper(
					'7.9.0',
					'function _unsupportedIterableToArray(r,a){if(r){if("string"==typeof r)return arrayLikeToArray(r,a);var t={}.toString.call(r).slice(8,-1);return"Object"===t&&r.constructor&&(t=r.constructor.name),"Map"===t||"Set"===t?Array.from(r):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?arrayLikeToArray(r,a):void 0}}',
					{
						globals: ['Array'],
						locals: {
							_unsupportedIterableToArray: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_unsupportedIterableToArray',
						dependencies: {
							arrayLikeToArray: [
								'body.0.body.body.0.consequent.body.0.consequent.argument.callee',
								'body.0.body.body.0.consequent.body.2.argument.expressions.1.alternate.consequent.callee',
							],
						},
					},
				),
				usingCtx: helper(
					'7.23.9',
					'function _usingCtx(){var r="function"==typeof SuppressedError?SuppressedError:function(r,e){var n=Error();return n.name="SuppressedError",n.error=r,n.suppressed=e,n},e={},n=[];function using(r,e){if(null!=e){if(Object(e)!==e)throw new TypeError("using declarations can only be used with objects, functions, null, or undefined.");if(r)var o=e[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(void 0===o&&(o=e[Symbol.dispose||Symbol.for("Symbol.dispose")],r))var t=o;if("function"!=typeof o)throw new TypeError("Object is not disposable.");t&&(o=function(){try{t.call(e)}catch(r){return Promise.reject(r)}}),n.push({v:e,d:o,a:r})}else r&&n.push({d:e,a:r});return e}return{e:e,u:using.bind(null,!1),a:using.bind(null,!0),d:function(){var o,t=this.e,s=0;function next(){for(;o=n.pop();)try{if(!o.a&&1===s)return s=0,n.push(o),Promise.resolve().then(next);if(o.d){var r=o.d.call(o.v);if(o.a)return s|=2,Promise.resolve(r).then(next,err)}else s|=1}catch(r){return err(r)}if(1===s)return t!==e?Promise.reject(t):Promise.resolve();if(t!==e)throw t}function err(n){return t=t!==e?new r(n,t):n,next()}return next()}}}',
					{
						globals: [
							'SuppressedError',
							'Error',
							'Object',
							'TypeError',
							'Symbol',
							'Promise',
						],
						locals: {
							_usingCtx: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_usingCtx',
						dependencies: {},
					},
				),
				wrapAsyncGenerator: helper(
					'7.0.0-beta.0',
					'function _wrapAsyncGenerator(e){return function(){return new AsyncGenerator(e.apply(this,arguments))}}function AsyncGenerator(e){var r,t;function resume(r,t){try{var n=e[r](t),o=n.value,u=o instanceof OverloadYield;Promise.resolve(u?o.v:o).then((function(t){if(u){var i="return"===r?"return":"next";if(!o.k||t.done)return resume(i,t);t=e[i](t).value}settle(n.done?"return":"normal",t)}),(function(e){resume("throw",e)}))}catch(e){settle("throw",e)}}function settle(e,n){switch(e){case"return":r.resolve({value:n,done:!0});break;case"throw":r.reject(n);break;default:r.resolve({value:n,done:!1})}(r=r.next)?resume(r.key,r.arg):t=null}this._invoke=function(e,n){return new Promise((function(o,u){var i={key:e,arg:n,resolve:o,reject:u,next:null};t?t=t.next=i:(r=t=i,resume(e,n))}))},"function"!=typeof e.return&&(this.return=void 0)}AsyncGenerator.prototype["function"==typeof Symbol&&Symbol.asyncIterator||"@@asyncIterator"]=function(){return this},AsyncGenerator.prototype.next=function(e){return this._invoke("next",e)},AsyncGenerator.prototype.throw=function(e){return this._invoke("throw",e)},AsyncGenerator.prototype.return=function(e){return this._invoke("return",e)};',
					{
						globals: ['Promise', 'Symbol'],
						locals: {
							_wrapAsyncGenerator: ['body.0.id'],
							AsyncGenerator: [
								'body.1.id',
								'body.0.body.body.0.argument.body.body.0.argument.callee',
								'body.2.expression.expressions.0.left.object.object',
								'body.2.expression.expressions.1.left.object.object',
								'body.2.expression.expressions.2.left.object.object',
								'body.2.expression.expressions.3.left.object.object',
							],
						},
						exportBindingAssignments: [],
						exportName: '_wrapAsyncGenerator',
						dependencies: {
							OverloadYield: [
								'body.1.body.body.1.body.body.0.block.body.0.declarations.2.init.right',
							],
						},
					},
				),
				wrapNativeSuper: helper(
					'7.0.0-beta.0',
					'function _wrapNativeSuper(t){var r="function"==typeof Map?new Map:void 0;return _wrapNativeSuper=function(t){if(null===t||!isNativeFunction(t))return t;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==r){if(r.has(t))return r.get(t);r.set(t,Wrapper)}function Wrapper(){return construct(t,arguments,getPrototypeOf(this).constructor)}return Wrapper.prototype=Object.create(t.prototype,{constructor:{value:Wrapper,enumerable:!1,writable:!0,configurable:!0}}),setPrototypeOf(Wrapper,t)},_wrapNativeSuper(t)}',
					{
						globals: ['Map', 'TypeError', 'Object'],
						locals: {
							_wrapNativeSuper: [
								'body.0.id',
								'body.0.body.body.1.argument.expressions.1.callee',
								'body.0.body.body.1.argument.expressions.0.left',
							],
						},
						exportBindingAssignments: [
							'body.0.body.body.1.argument.expressions.0',
						],
						exportName: '_wrapNativeSuper',
						dependencies: {
							getPrototypeOf: [
								'body.0.body.body.1.argument.expressions.0.right.body.body.3.body.body.0.argument.arguments.2.object.callee',
							],
							setPrototypeOf: [
								'body.0.body.body.1.argument.expressions.0.right.body.body.4.argument.expressions.1.callee',
							],
							isNativeFunction: [
								'body.0.body.body.1.argument.expressions.0.right.body.body.0.test.right.argument.callee',
							],
							construct: [
								'body.0.body.body.1.argument.expressions.0.right.body.body.3.body.body.0.argument.callee',
							],
						},
					},
				),
				wrapRegExp: helper(
					'7.19.0',
					'function _wrapRegExp(){_wrapRegExp=function(e,r){return new BabelRegExp(e,void 0,r)};var e=RegExp.prototype,r=new WeakMap;function BabelRegExp(e,t,p){var o=RegExp(e,t);return r.set(o,p||r.get(e)),setPrototypeOf(o,BabelRegExp.prototype)}function buildGroups(e,t){var p=r.get(t);return Object.keys(p).reduce((function(r,t){var o=p[t];if("number"==typeof o)r[t]=e[o];else{for(var i=0;void 0===e[o[i]]&&i+1<o.length;)i++;r[t]=e[o[i]]}return r}),Object.create(null))}return inherits(BabelRegExp,RegExp),BabelRegExp.prototype.exec=function(r){var t=e.exec.call(this,r);if(t){t.groups=buildGroups(t,this);var p=t.indices;p&&(p.groups=buildGroups(p,this))}return t},BabelRegExp.prototype[Symbol.replace]=function(t,p){if("string"==typeof p){var o=r.get(this);return e[Symbol.replace].call(this,t,p.replace(/\\$<([^>]+)(>|$)/g,(function(e,r,t){if(""===t)return e;var p=o[r];return Array.isArray(p)?"$"+p.join("$"):"number"==typeof p?"$"+p:""})))}if("function"==typeof p){var i=this;return e[Symbol.replace].call(this,t,(function(){var e=arguments;return"object"!=typeof e[e.length-1]&&(e=[].slice.call(e)).push(buildGroups(e,i)),p.apply(this,e)}))}return e[Symbol.replace].call(this,t,p)},_wrapRegExp.apply(this,arguments)}',
					{
						globals: ['RegExp', 'WeakMap', 'Object', 'Symbol', 'Array'],
						locals: {
							_wrapRegExp: [
								'body.0.id',
								'body.0.body.body.4.argument.expressions.3.callee.object',
								'body.0.body.body.0.expression.left',
							],
						},
						exportBindingAssignments: ['body.0.body.body.0.expression'],
						exportName: '_wrapRegExp',
						dependencies: {
							setPrototypeOf: [
								'body.0.body.body.2.body.body.1.argument.expressions.1.callee',
							],
							inherits: ['body.0.body.body.4.argument.expressions.0.callee'],
						},
					},
				),
				writeOnlyError: helper(
					'7.12.13',
					"function _writeOnlyError(r){throw new TypeError('\"'+r+'\" is write-only')}",
					{
						globals: ['TypeError'],
						locals: {
							_writeOnlyError: ['body.0.id'],
						},
						exportBindingAssignments: [],
						exportName: '_writeOnlyError',
						dependencies: {},
					},
				),
			})
			{
				Object.assign(helpers, {
					AwaitValue: helper(
						'7.0.0-beta.0',
						'function _AwaitValue(t){this.wrapped=t}',
						{
							globals: [],
							locals: {
								_AwaitValue: ['body.0.id'],
							},
							exportBindingAssignments: [],
							exportName: '_AwaitValue',
							dependencies: {},
						},
					),
					applyDecs: helper(
						'7.17.8',
						'function old_createMetadataMethodsForProperty(e,t,a,r){return{getMetadata:function(o){old_assertNotFinished(r,"getMetadata"),old_assertMetadataKey(o);var i=e[o];if(void 0!==i)if(1===t){var n=i.public;if(void 0!==n)return n[a]}else if(2===t){var l=i.private;if(void 0!==l)return l.get(a)}else if(Object.hasOwnProperty.call(i,"constructor"))return i.constructor},setMetadata:function(o,i){old_assertNotFinished(r,"setMetadata"),old_assertMetadataKey(o);var n=e[o];if(void 0===n&&(n=e[o]={}),1===t){var l=n.public;void 0===l&&(l=n.public={}),l[a]=i}else if(2===t){var s=n.priv;void 0===s&&(s=n.private=new Map),s.set(a,i)}else n.constructor=i}}}function old_convertMetadataMapToFinal(e,t){var a=e[Symbol.metadata||Symbol.for("Symbol.metadata")],r=Object.getOwnPropertySymbols(t);if(0!==r.length){for(var o=0;o<r.length;o++){var i=r[o],n=t[i],l=a?a[i]:null,s=n.public,c=l?l.public:null;s&&c&&Object.setPrototypeOf(s,c);var d=n.private;if(d){var u=Array.from(d.values()),f=l?l.private:null;f&&(u=u.concat(f)),n.private=u}l&&Object.setPrototypeOf(n,l)}a&&Object.setPrototypeOf(t,a),e[Symbol.metadata||Symbol.for("Symbol.metadata")]=t}}function old_createAddInitializerMethod(e,t){return function(a){old_assertNotFinished(t,"addInitializer"),old_assertCallable(a,"An initializer"),e.push(a)}}function old_memberDec(e,t,a,r,o,i,n,l,s){var c;switch(i){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var d,u,f={kind:c,name:l?"#"+t:toPropertyKey(t),isStatic:n,isPrivate:l},p={v:!1};if(0!==i&&(f.addInitializer=old_createAddInitializerMethod(o,p)),l){d=2,u=Symbol(t);var v={};0===i?(v.get=a.get,v.set=a.set):2===i?v.get=function(){return a.value}:(1!==i&&3!==i||(v.get=function(){return a.get.call(this)}),1!==i&&4!==i||(v.set=function(e){a.set.call(this,e)})),f.access=v}else d=1,u=t;try{return e(s,Object.assign(f,old_createMetadataMethodsForProperty(r,d,u,p)))}finally{p.v=!0}}function old_assertNotFinished(e,t){if(e.v)throw Error("attempted to call "+t+" after decoration was finished")}function old_assertMetadataKey(e){if("symbol"!=typeof e)throw new TypeError("Metadata keys must be symbols, received: "+e)}function old_assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function old_assertValidReturnValue(e,t){var a=typeof t;if(1===e){if("object"!==a||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&old_assertCallable(t.get,"accessor.get"),void 0!==t.set&&old_assertCallable(t.set,"accessor.set"),void 0!==t.init&&old_assertCallable(t.init,"accessor.init"),void 0!==t.initializer&&old_assertCallable(t.initializer,"accessor.initializer")}else if("function"!==a)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function old_getInit(e){var t;return null==(t=e.init)&&(t=e.initializer)&&void 0!==console&&console.warn(".initializer has been renamed to .init as of March 2022"),t}function old_applyMemberDec(e,t,a,r,o,i,n,l,s){var c,d,u,f,p,v,y,h=a[0];if(n?(0===o||1===o?(c={get:a[3],set:a[4]},u="get"):3===o?(c={get:a[3]},u="get"):4===o?(c={set:a[3]},u="set"):c={value:a[3]},0!==o&&(1===o&&setFunctionName(a[4],"#"+r,"set"),setFunctionName(a[3],"#"+r,u))):0!==o&&(c=Object.getOwnPropertyDescriptor(t,r)),1===o?f={get:c.get,set:c.set}:2===o?f=c.value:3===o?f=c.get:4===o&&(f=c.set),"function"==typeof h)void 0!==(p=old_memberDec(h,r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?d=p:1===o?(d=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p);else for(var m=h.length-1;m>=0;m--){var b;void 0!==(p=old_memberDec(h[m],r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?b=p:1===o?(b=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p,void 0!==b&&(void 0===d?d=b:"function"==typeof d?d=[d,b]:d.push(b)))}if(0===o||1===o){if(void 0===d)d=function(e,t){return t};else if("function"!=typeof d){var g=d;d=function(e,t){for(var a=t,r=0;r<g.length;r++)a=g[r].call(e,a);return a}}else{var _=d;d=function(e,t){return _.call(e,t)}}e.push(d)}0!==o&&(1===o?(c.get=f.get,c.set=f.set):2===o?c.value=f:3===o?c.get=f:4===o&&(c.set=f),n?1===o?(e.push((function(e,t){return f.get.call(e,t)})),e.push((function(e,t){return f.set.call(e,t)}))):2===o?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(t,r,c))}function old_applyMemberDecs(e,t,a,r,o){for(var i,n,l=new Map,s=new Map,c=0;c<o.length;c++){var d=o[c];if(Array.isArray(d)){var u,f,p,v=d[1],y=d[2],h=d.length>3,m=v>=5;if(m?(u=t,f=r,0!=(v-=5)&&(p=n=n||[])):(u=t.prototype,f=a,0!==v&&(p=i=i||[])),0!==v&&!h){var b=m?s:l,g=b.get(y)||0;if(!0===g||3===g&&4!==v||4===g&&3!==v)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+y);!g&&v>2?b.set(y,v):b.set(y,!0)}old_applyMemberDec(e,u,d,y,v,m,h,f,p)}}old_pushInitializers(e,i),old_pushInitializers(e,n)}function old_pushInitializers(e,t){t&&e.push((function(e){for(var a=0;a<t.length;a++)t[a].call(e);return e}))}function old_applyClassDecs(e,t,a,r){if(r.length>0){for(var o=[],i=t,n=t.name,l=r.length-1;l>=0;l--){var s={v:!1};try{var c=Object.assign({kind:"class",name:n,addInitializer:old_createAddInitializerMethod(o,s)},old_createMetadataMethodsForProperty(a,0,n,s)),d=r[l](i,c)}finally{s.v=!0}void 0!==d&&(old_assertValidReturnValue(10,d),i=d)}e.push(i,(function(){for(var e=0;e<o.length;e++)o[e].call(i)}))}}function applyDecs(e,t,a){var r=[],o={},i={};return old_applyMemberDecs(r,e,i,o,t),old_convertMetadataMapToFinal(e.prototype,i),old_applyClassDecs(r,e,o,a),old_convertMetadataMapToFinal(e,o),r}',
						{
							globals: [
								'Object',
								'Map',
								'Symbol',
								'Array',
								'Error',
								'TypeError',
								'console',
							],
							locals: {
								old_createMetadataMethodsForProperty: [
									'body.0.id',
									'body.3.body.body.4.block.body.0.argument.arguments.1.arguments.1.callee',
									'body.12.body.body.0.consequent.body.0.body.body.1.block.body.0.declarations.0.init.arguments.1.callee',
								],
								old_convertMetadataMapToFinal: [
									'body.1.id',
									'body.13.body.body.1.argument.expressions.1.callee',
									'body.13.body.body.1.argument.expressions.3.callee',
								],
								old_createAddInitializerMethod: [
									'body.2.id',
									'body.3.body.body.3.test.expressions.0.right.right.callee',
									'body.12.body.body.0.consequent.body.0.body.body.1.block.body.0.declarations.0.init.arguments.0.properties.2.value.callee',
								],
								old_memberDec: [
									'body.3.id',
									'body.9.body.body.1.consequent.expression.left.right.right.callee',
									'body.9.body.body.1.alternate.body.body.1.expression.left.right.right.callee',
								],
								old_assertNotFinished: [
									'body.4.id',
									'body.0.body.body.0.argument.properties.0.value.body.body.0.expression.expressions.0.callee',
									'body.0.body.body.0.argument.properties.1.value.body.body.0.expression.expressions.0.callee',
									'body.2.body.body.0.argument.body.body.0.expression.expressions.0.callee',
								],
								old_assertMetadataKey: [
									'body.5.id',
									'body.0.body.body.0.argument.properties.0.value.body.body.0.expression.expressions.1.callee',
									'body.0.body.body.0.argument.properties.1.value.body.body.0.expression.expressions.1.callee',
								],
								old_assertCallable: [
									'body.6.id',
									'body.2.body.body.0.argument.body.body.0.expression.expressions.1.callee',
									'body.7.body.body.1.consequent.body.1.expression.expressions.0.right.callee',
									'body.7.body.body.1.consequent.body.1.expression.expressions.1.right.callee',
									'body.7.body.body.1.consequent.body.1.expression.expressions.2.right.callee',
									'body.7.body.body.1.consequent.body.1.expression.expressions.3.right.callee',
								],
								old_assertValidReturnValue: [
									'body.7.id',
									'body.9.body.body.1.consequent.expression.right.expressions.0.callee',
									'body.9.body.body.1.alternate.body.body.1.expression.right.expressions.0.callee',
									'body.12.body.body.0.consequent.body.0.body.body.2.expression.right.expressions.0.callee',
								],
								old_getInit: [
									'body.8.id',
									'body.9.body.body.1.consequent.expression.right.expressions.1.alternate.consequent.expressions.0.right.callee',
									'body.9.body.body.1.alternate.body.body.1.expression.right.expressions.1.alternate.consequent.expressions.0.right.callee',
								],
								old_applyMemberDec: [
									'body.9.id',
									'body.10.body.body.0.body.body.1.consequent.body.2.expression.callee',
								],
								old_applyMemberDecs: [
									'body.10.id',
									'body.13.body.body.1.argument.expressions.0.callee',
								],
								old_pushInitializers: [
									'body.11.id',
									'body.10.body.body.1.expression.expressions.0.callee',
									'body.10.body.body.1.expression.expressions.1.callee',
								],
								old_applyClassDecs: [
									'body.12.id',
									'body.13.body.body.1.argument.expressions.2.callee',
								],
								applyDecs: ['body.13.id'],
							},
							exportBindingAssignments: [],
							exportName: 'applyDecs',
							dependencies: {
								setFunctionName: [
									'body.9.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee',
									'body.9.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee',
								],
								toPropertyKey: [
									'body.3.body.body.2.declarations.2.init.properties.1.value.alternate.callee',
								],
							},
						},
					),
					applyDecs2203: helper(
						'7.19.0',
						'function applyDecs2203Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,a,n,i,s,o){var c;switch(n){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:s?"#"+t:t,static:i,private:s},p={v:!1};0!==n&&(f.addInitializer=createAddInitializerMethod(a,p)),0===n?s?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===n?l=function(){return r.value}:(1!==n&&3!==n||(l=function(){return r.get.call(this)}),1!==n&&4!==n||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(o,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,a,n,i,s,o){var c,l,u,f,p,d,h=r[0];if(s?c=0===n||1===n?{get:r[3],set:r[4]}:3===n?{get:r[3]}:4===n?{set:r[3]}:{value:r[3]}:0!==n&&(c=Object.getOwnPropertyDescriptor(t,a)),1===n?u={get:c.get,set:c.set}:2===n?u=c.value:3===n?u=c.get:4===n&&(u=c.set),"function"==typeof h)void 0!==(f=memberDec(h,a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?l=f:1===n?(l=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f);else for(var v=h.length-1;v>=0;v--){var g;void 0!==(f=memberDec(h[v],a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?g=f:1===n?(g=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f,void 0!==g&&(void 0===l?l=g:"function"==typeof l?l=[l,g]:l.push(g)))}if(0===n||1===n){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var y=l;l=function(e,t){for(var r=t,a=0;a<y.length;a++)r=y[a].call(e,r);return r}}else{var m=l;l=function(e,t){return m.call(e,t)}}e.push(l)}0!==n&&(1===n?(c.get=u.get,c.set=u.set):2===n?c.value=u:3===n?c.get=u:4===n&&(c.set=u),s?1===n?(e.push((function(e,t){return u.get.call(e,t)})),e.push((function(e,t){return u.set.call(e,t)}))):2===n?e.push(u):e.push((function(e,t){return u.call(e,t)})):Object.defineProperty(t,a,c))}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){var a=[];return function(e,t,r){for(var a,n,i=new Map,s=new Map,o=0;o<r.length;o++){var c=r[o];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=t,0!=(f-=5)&&(u=n=n||[])):(l=t.prototype,0!==f&&(u=a=a||[])),0!==f&&!d){var v=h?s:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(e,l,c,p,f,h,d,u)}}pushInitializers(e,a),pushInitializers(e,n)}(a,e,t),function(e,t,r){if(r.length>0){for(var a=[],n=t,i=t.name,s=r.length-1;s>=0;s--){var o={v:!1};try{var c=r[s](n,{kind:"class",name:i,addInitializer:createAddInitializerMethod(a,o)})}finally{o.v=!0}void 0!==c&&(assertValidReturnValue(10,c),n=c)}e.push(n,(function(){for(var e=0;e<a.length;e++)a[e].call(n)}))}}(a,e,r),a}}var applyDecs2203Impl;function applyDecs2203(e,t,r){return(applyDecs2203Impl=applyDecs2203Impl||applyDecs2203Factory())(e,t,r)}',
						{
							globals: ['Error', 'TypeError', 'Object', 'Map', 'Array'],
							locals: {
								applyDecs2203Factory: [
									'body.0.id',
									'body.2.body.body.0.argument.callee.right.right.callee',
								],
								applyDecs2203Impl: [
									'body.1.declarations.0.id',
									'body.2.body.body.0.argument.callee.right.left',
									'body.2.body.body.0.argument.callee.left',
								],
								applyDecs2203: ['body.2.id'],
							},
							exportBindingAssignments: [],
							exportName: 'applyDecs2203',
							dependencies: {},
						},
					),
					applyDecs2203R: helper(
						'7.20.0',
						'function applyDecs2203RFactory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,n,a,i,o,s){var c;switch(a){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:o?"#"+t:toPropertyKey(t),static:i,private:o},p={v:!1};0!==a&&(f.addInitializer=createAddInitializerMethod(n,p)),0===a?o?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===a?l=function(){return r.value}:(1!==a&&3!==a||(l=function(){return r.get.call(this)}),1!==a&&4!==a||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(s,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,n,a,i,o,s){var c,l,u,f,p,d,h,v=r[0];if(o?(0===a||1===a?(c={get:r[3],set:r[4]},u="get"):3===a?(c={get:r[3]},u="get"):4===a?(c={set:r[3]},u="set"):c={value:r[3]},0!==a&&(1===a&&setFunctionName(r[4],"#"+n,"set"),setFunctionName(r[3],"#"+n,u))):0!==a&&(c=Object.getOwnPropertyDescriptor(t,n)),1===a?f={get:c.get,set:c.set}:2===a?f=c.value:3===a?f=c.get:4===a&&(f=c.set),"function"==typeof v)void 0!==(p=memberDec(v,n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?l=p:1===a?(l=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p);else for(var g=v.length-1;g>=0;g--){var y;void 0!==(p=memberDec(v[g],n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?y=p:1===a?(y=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p,void 0!==y&&(void 0===l?l=y:"function"==typeof l?l=[l,y]:l.push(y)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var m=l;l=function(e,t){for(var r=t,n=0;n<m.length;n++)r=m[n].call(e,r);return r}}else{var b=l;l=function(e,t){return b.call(e,t)}}e.push(l)}0!==a&&(1===a?(c.get=f.get,c.set=f.set):2===a?c.value=f:3===a?c.get=f:4===a&&(c.set=f),o?1===a?(e.push((function(e,t){return f.get.call(e,t)})),e.push((function(e,t){return f.set.call(e,t)}))):2===a?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(t,n,c))}function applyMemberDecs(e,t){for(var r,n,a=[],i=new Map,o=new Map,s=0;s<t.length;s++){var c=t[s];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=e,0!=(f-=5)&&(u=n=n||[])):(l=e.prototype,0!==f&&(u=r=r||[])),0!==f&&!d){var v=h?o:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(a,l,c,p,f,h,d,u)}}return pushInitializers(a,r),pushInitializers(a,n),a}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){return{e:applyMemberDecs(e,t),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var o={v:!1};try{var s=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,o)})}finally{o.v=!0}void 0!==s&&(assertValidReturnValue(10,s),n=s)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}function applyDecs2203R(e,t,r){return(applyDecs2203R=applyDecs2203RFactory())(e,t,r)}',
						{
							globals: ['Error', 'TypeError', 'Object', 'Map', 'Array'],
							locals: {
								applyDecs2203RFactory: [
									'body.0.id',
									'body.1.body.body.0.argument.callee.right.callee',
								],
								applyDecs2203R: [
									'body.1.id',
									'body.1.body.body.0.argument.callee.left',
								],
							},
							exportBindingAssignments: ['body.1.body.body.0.argument.callee'],
							exportName: 'applyDecs2203R',
							dependencies: {
								setFunctionName: [
									'body.0.body.body.4.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee',
									'body.0.body.body.4.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee',
								],
								toPropertyKey: [
									'body.0.body.body.1.body.body.2.declarations.2.init.properties.1.value.alternate.callee',
								],
							},
						},
					),
					applyDecs2301: helper(
						'7.21.0',
						'function applyDecs2301Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function assertInstanceIfPrivate(e,t){if(!e(t))throw new TypeError("Attempted to access private element on non-instance")}function memberDec(e,t,r,n,a,i,s,o,c){var u;switch(a){case 1:u="accessor";break;case 2:u="method";break;case 3:u="getter";break;case 4:u="setter";break;default:u="field"}var l,f,p={kind:u,name:s?"#"+t:toPropertyKey(t),static:i,private:s},d={v:!1};if(0!==a&&(p.addInitializer=createAddInitializerMethod(n,d)),s||0!==a&&2!==a)if(2===a)l=function(e){return assertInstanceIfPrivate(c,e),r.value};else{var h=0===a||1===a;(h||3===a)&&(l=s?function(e){return assertInstanceIfPrivate(c,e),r.get.call(e)}:function(e){return r.get.call(e)}),(h||4===a)&&(f=s?function(e,t){assertInstanceIfPrivate(c,e),r.set.call(e,t)}:function(e,t){r.set.call(e,t)})}else l=function(e){return e[t]},0===a&&(f=function(e,r){e[t]=r});var v=s?c.bind():function(e){return t in e};p.access=l&&f?{get:l,set:f,has:v}:l?{get:l,has:v}:{set:f,has:v};try{return e(o,p)}finally{d.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function curryThis2(e){return function(t){e(this,t)}}function applyMemberDec(e,t,r,n,a,i,s,o,c){var u,l,f,p,d,h,v,y,g=r[0];if(s?(0===a||1===a?(u={get:(d=r[3],function(){return d(this)}),set:curryThis2(r[4])},f="get"):3===a?(u={get:r[3]},f="get"):4===a?(u={set:r[3]},f="set"):u={value:r[3]},0!==a&&(1===a&&setFunctionName(u.set,"#"+n,"set"),setFunctionName(u[f||"value"],"#"+n,f))):0!==a&&(u=Object.getOwnPropertyDescriptor(t,n)),1===a?p={get:u.get,set:u.set}:2===a?p=u.value:3===a?p=u.get:4===a&&(p=u.set),"function"==typeof g)void 0!==(h=memberDec(g,n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?l=h:1===a?(l=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h);else for(var m=g.length-1;m>=0;m--){var b;void 0!==(h=memberDec(g[m],n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?b=h:1===a?(b=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h,void 0!==b&&(void 0===l?l=b:"function"==typeof l?l=[l,b]:l.push(b)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var I=l;l=function(e,t){for(var r=t,n=0;n<I.length;n++)r=I[n].call(e,r);return r}}else{var w=l;l=function(e,t){return w.call(e,t)}}e.push(l)}0!==a&&(1===a?(u.get=p.get,u.set=p.set):2===a?u.value=p:3===a?u.get=p:4===a&&(u.set=p),s?1===a?(e.push((function(e,t){return p.get.call(e,t)})),e.push((function(e,t){return p.set.call(e,t)}))):2===a?e.push(p):e.push((function(e,t){return p.call(e,t)})):Object.defineProperty(t,n,u))}function applyMemberDecs(e,t,r){for(var n,a,i,s=[],o=new Map,c=new Map,u=0;u<t.length;u++){var l=t[u];if(Array.isArray(l)){var f,p,d=l[1],h=l[2],v=l.length>3,y=d>=5,g=r;if(y?(f=e,0!=(d-=5)&&(p=a=a||[]),v&&!i&&(i=function(t){return checkInRHS(t)===e}),g=i):(f=e.prototype,0!==d&&(p=n=n||[])),0!==d&&!v){var m=y?c:o,b=m.get(h)||0;if(!0===b||3===b&&4!==d||4===b&&3!==d)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);!b&&d>2?m.set(h,d):m.set(h,!0)}applyMemberDec(s,f,l,h,d,y,v,p,g)}}return pushInitializers(s,n),pushInitializers(s,a),s}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r,n){return{e:applyMemberDecs(e,t,n),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var s={v:!1};try{var o=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,s)})}finally{s.v=!0}void 0!==o&&(assertValidReturnValue(10,o),n=o)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}function applyDecs2301(e,t,r,n){return(applyDecs2301=applyDecs2301Factory())(e,t,r,n)}',
						{
							globals: ['Error', 'TypeError', 'Object', 'Map', 'Array'],
							locals: {
								applyDecs2301Factory: [
									'body.0.id',
									'body.1.body.body.0.argument.callee.right.callee',
								],
								applyDecs2301: [
									'body.1.id',
									'body.1.body.body.0.argument.callee.left',
								],
							},
							exportBindingAssignments: ['body.1.body.body.0.argument.callee'],
							exportName: 'applyDecs2301',
							dependencies: {
								checkInRHS: [
									'body.0.body.body.7.body.body.0.body.body.1.consequent.body.1.test.expressions.0.consequent.expressions.2.right.right.body.body.0.argument.left.callee',
								],
								setFunctionName: [
									'body.0.body.body.6.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee',
									'body.0.body.body.6.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee',
								],
								toPropertyKey: [
									'body.0.body.body.2.body.body.2.declarations.2.init.properties.1.value.alternate.callee',
								],
							},
						},
					),
					applyDecs2305: helper(
						'7.21.0',
						'function applyDecs2305(e,t,r,n,o,a){function i(e,t,r){return function(n,o){return r&&r(n),e[t].call(n,o)}}function c(e,t){for(var r=0;r<e.length;r++)e[r].call(t);return t}function s(e,t,r,n){if("function"!=typeof e&&(n||void 0!==e))throw new TypeError(t+" must "+(r||"be")+" a function"+(n?"":" or undefined"));return e}function applyDec(e,t,r,n,o,a,c,u,l,f,p,d,h){function m(e){if(!h(e))throw new TypeError("Attempted to access private element on non-instance")}var y,v=t[0],g=t[3],b=!u;if(!b){r||Array.isArray(v)||(v=[v]);var w={},S=[],A=3===o?"get":4===o||d?"set":"value";f?(p||d?w={get:setFunctionName((function(){return g(this)}),n,"get"),set:function(e){t[4](this,e)}}:w[A]=g,p||setFunctionName(w[A],n,2===o?"":A)):p||(w=Object.getOwnPropertyDescriptor(e,n))}for(var P=e,j=v.length-1;j>=0;j-=r?2:1){var D=v[j],E=r?v[j-1]:void 0,I={},O={kind:["field","accessor","method","getter","setter","class"][o],name:n,metadata:a,addInitializer:function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished");s(t,"An initializer","be",!0),c.push(t)}.bind(null,I)};try{if(b)(y=s(D.call(E,P,O),"class decorators","return"))&&(P=y);else{var k,F;O.static=l,O.private=f,f?2===o?k=function(e){return m(e),w.value}:(o<4&&(k=i(w,"get",m)),3!==o&&(F=i(w,"set",m))):(k=function(e){return e[n]},(o<2||4===o)&&(F=function(e,t){e[n]=t}));var N=O.access={has:f?h.bind():function(e){return n in e}};if(k&&(N.get=k),F&&(N.set=F),P=D.call(E,d?{get:w.get,set:w.set}:w[A],O),d){if("object"==typeof P&&P)(y=s(P.get,"accessor.get"))&&(w.get=y),(y=s(P.set,"accessor.set"))&&(w.set=y),(y=s(P.init,"accessor.init"))&&S.push(y);else if(void 0!==P)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0")}else s(P,(p?"field":"method")+" decorators","return")&&(p?S.push(P):w[A]=P)}}finally{I.v=!0}}return(p||d)&&u.push((function(e,t){for(var r=S.length-1;r>=0;r--)t=S[r].call(e,t);return t})),p||b||(f?d?u.push(i(w,"get"),i(w,"set")):u.push(2===o?w[A]:i.call.bind(w[A])):Object.defineProperty(e,n,w)),P}function u(e,t){return Object.defineProperty(e,Symbol.metadata||Symbol.for("Symbol.metadata"),{configurable:!0,enumerable:!0,value:t})}if(arguments.length>=6)var l=a[Symbol.metadata||Symbol.for("Symbol.metadata")];var f=Object.create(null==l?null:l),p=function(e,t,r,n){var o,a,i=[],s=function(t){return checkInRHS(t)===e},u=new Map;function l(e){e&&i.push(c.bind(null,e))}for(var f=0;f<t.length;f++){var p=t[f];if(Array.isArray(p)){var d=p[1],h=p[2],m=p.length>3,y=16&d,v=!!(8&d),g=0==(d&=7),b=h+"/"+v;if(!g&&!m){var w=u.get(b);if(!0===w||3===w&&4!==d||4===w&&3!==d)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);u.set(b,!(d>2)||d)}applyDec(v?e:e.prototype,p,y,m?"#"+h:toPropertyKey(h),d,n,v?a=a||[]:o=o||[],i,v,m,g,1===d,v&&m?s:r)}}return l(o),l(a),i}(e,t,o,f);return r.length||u(e,f),{e:p,get c(){var t=[];return r.length&&[u(applyDec(e,[r],n,e.name,5,f,t),f),c.bind(null,t,e)]}}}',
						{
							globals: [
								'TypeError',
								'Array',
								'Object',
								'Error',
								'Symbol',
								'Map',
							],
							locals: {
								applyDecs2305: ['body.0.id'],
							},
							exportBindingAssignments: [],
							exportName: 'applyDecs2305',
							dependencies: {
								checkInRHS: [
									'body.0.body.body.6.declarations.1.init.callee.body.body.0.declarations.3.init.body.body.0.argument.left.callee',
								],
								setFunctionName: [
									'body.0.body.body.3.body.body.2.consequent.body.2.expression.consequent.expressions.0.consequent.right.properties.0.value.callee',
									'body.0.body.body.3.body.body.2.consequent.body.2.expression.consequent.expressions.1.right.callee',
								],
								toPropertyKey: [
									'body.0.body.body.6.declarations.1.init.callee.body.body.2.body.body.1.consequent.body.2.expression.arguments.3.alternate.callee',
								],
							},
						},
					),
					classApplyDescriptorDestructureSet: helper(
						'7.13.10',
						'function _classApplyDescriptorDestructureSet(e,t){if(t.set)return"__destrObj"in t||(t.__destrObj={set value(r){t.set.call(e,r)}}),t.__destrObj;if(!t.writable)throw new TypeError("attempted to set read only private field");return t}',
						{
							globals: ['TypeError'],
							locals: {
								_classApplyDescriptorDestructureSet: ['body.0.id'],
							},
							exportBindingAssignments: [],
							exportName: '_classApplyDescriptorDestructureSet',
							dependencies: {},
						},
					),
					classApplyDescriptorGet: helper(
						'7.13.10',
						'function _classApplyDescriptorGet(e,t){return t.get?t.get.call(e):t.value}',
						{
							globals: [],
							locals: {
								_classApplyDescriptorGet: ['body.0.id'],
							},
							exportBindingAssignments: [],
							exportName: '_classApplyDescriptorGet',
							dependencies: {},
						},
					),
					classApplyDescriptorSet: helper(
						'7.13.10',
						'function _classApplyDescriptorSet(e,t,l){if(t.set)t.set.call(e,l);else{if(!t.writable)throw new TypeError("attempted to set read only private field");t.value=l}}',
						{
							globals: ['TypeError'],
							locals: {
								_classApplyDescriptorSet: ['body.0.id'],
							},
							exportBindingAssignments: [],
							exportName: '_classApplyDescriptorSet',
							dependencies: {},
						},
					),
					classCheckPrivateStaticAccess: helper(
						'7.13.10',
						'function _classCheckPrivateStaticAccess(s,a,r){return assertClassBrand(a,s,r)}',
						{
							globals: [],
							locals: {
								_classCheckPrivateStaticAccess: ['body.0.id'],
							},
							exportBindingAssignments: [],
							exportName: '_classCheckPrivateStaticAccess',
							dependencies: {
								assertClassBrand: ['body.0.body.body.0.argument.callee'],
							},
						},
					),
					classCheckPrivateStaticFieldDescriptor: helper(
						'7.13.10',
						'function _classCheckPrivateStaticFieldDescriptor(t,e){if(void 0===t)throw new TypeError("attempted to "+e+" private static field before its declaration")}',
						{
							globals: ['TypeError'],
							locals: {
								_classCheckPrivateStaticFieldDescriptor: ['body.0.id'],
							},
							exportBindingAssignments: [],
							exportName: '_classCheckPrivateStaticFieldDescriptor',
							dependencies: {},
						},
					),
					classExtractFieldDescriptor: helper(
						'7.13.10',
						'function _classExtractFieldDescriptor(e,t){return classPrivateFieldGet2(t,e)}',
						{
							globals: [],
							locals: {
								_classExtractFieldDescriptor: ['body.0.id'],
							},
							exportBindingAssignments: [],
							exportName: '_classExtractFieldDescriptor',
							dependencies: {
								classPrivateFieldGet2: ['body.0.body.body.0.argument.callee'],
							},
						},
					),
					classPrivateFieldDestructureSet: helper(
						'7.4.4',
						'function _classPrivateFieldDestructureSet(e,t){var r=classPrivateFieldGet2(t,e);return classApplyDescriptorDestructureSet(e,r)}',
						{
							globals: [],
							locals: {
								_classPrivateFieldDestructureSet: ['body.0.id'],
							},
							exportBindingAssignments: [],
							exportName: '_classPrivateFieldDestructureSet',
							dependencies: {
								classApplyDescriptorDestructureSet: [
									'body.0.body.body.1.argument.callee',
								],
								classPrivateFieldGet2: [
									'body.0.body.body.0.declarations.0.init.callee',
								],
							},
						},
					),
					classPrivateFieldGet: helper(
						'7.0.0-beta.0',
						'function _classPrivateFieldGet(e,t){var r=classPrivateFieldGet2(t,e);return classApplyDescriptorGet(e,r)}',
						{
							globals: [],
							locals: {
								_classPrivateFieldGet: ['body.0.id'],
							},
							exportBindingAssignments: [],
							exportName: '_classPrivateFieldGet',
							dependencies: {
								classApplyDescriptorGet: ['body.0.body.body.1.argument.callee'],
								classPrivateFieldGet2: [
									'body.0.body.body.0.declarations.0.init.callee',
								],
							},
						},
					),
					classPrivateFieldSet: helper(
						'7.0.0-beta.0',
						'function _classPrivateFieldSet(e,t,r){var s=classPrivateFieldGet2(t,e);return classApplyDescriptorSet(e,s,r),r}',
						{
							globals: [],
							locals: {
								_classPrivateFieldSet: ['body.0.id'],
							},
							exportBindingAssignments: [],
							exportName: '_classPrivateFieldSet',
							dependencies: {
								classApplyDescriptorSet: [
									'body.0.body.body.1.argument.expressions.0.callee',
								],
								classPrivateFieldGet2: [
									'body.0.body.body.0.declarations.0.init.callee',
								],
							},
						},
					),
					classPrivateMethodGet: helper(
						'7.1.6',
						'function _classPrivateMethodGet(s,a,r){return assertClassBrand(a,s),r}',
						{
							globals: [],
							locals: {
								_classPrivateMethodGet: ['body.0.id'],
							},
							exportBindingAssignments: [],
							exportName: '_classPrivateMethodGet',
							dependencies: {
								assertClassBrand: [
									'body.0.body.body.0.argument.expressions.0.callee',
								],
							},
						},
					),
					classPrivateMethodSet: helper(
						'7.1.6',
						'function _classPrivateMethodSet(){throw new TypeError("attempted to reassign private method")}',
						{
							globals: ['TypeError'],
							locals: {
								_classPrivateMethodSet: ['body.0.id'],
							},
							exportBindingAssignments: [],
							exportName: '_classPrivateMethodSet',
							dependencies: {},
						},
					),
					classStaticPrivateFieldDestructureSet: helper(
						'7.13.10',
						'function _classStaticPrivateFieldDestructureSet(t,r,s){return assertClassBrand(r,t),classCheckPrivateStaticFieldDescriptor(s,"set"),classApplyDescriptorDestructureSet(t,s)}',
						{
							globals: [],
							locals: {
								_classStaticPrivateFieldDestructureSet: ['body.0.id'],
							},
							exportBindingAssignments: [],
							exportName: '_classStaticPrivateFieldDestructureSet',
							dependencies: {
								classApplyDescriptorDestructureSet: [
									'body.0.body.body.0.argument.expressions.2.callee',
								],
								assertClassBrand: [
									'body.0.body.body.0.argument.expressions.0.callee',
								],
								classCheckPrivateStaticFieldDescriptor: [
									'body.0.body.body.0.argument.expressions.1.callee',
								],
							},
						},
					),
					classStaticPrivateFieldSpecGet: helper(
						'7.0.2',
						'function _classStaticPrivateFieldSpecGet(t,s,r){return assertClassBrand(s,t),classCheckPrivateStaticFieldDescriptor(r,"get"),classApplyDescriptorGet(t,r)}',
						{
							globals: [],
							locals: {
								_classStaticPrivateFieldSpecGet: ['body.0.id'],
							},
							exportBindingAssignments: [],
							exportName: '_classStaticPrivateFieldSpecGet',
							dependencies: {
								classApplyDescriptorGet: [
									'body.0.body.body.0.argument.expressions.2.callee',
								],
								assertClassBrand: [
									'body.0.body.body.0.argument.expressions.0.callee',
								],
								classCheckPrivateStaticFieldDescriptor: [
									'body.0.body.body.0.argument.expressions.1.callee',
								],
							},
						},
					),
					classStaticPrivateFieldSpecSet: helper(
						'7.0.2',
						'function _classStaticPrivateFieldSpecSet(s,t,r,e){return assertClassBrand(t,s),classCheckPrivateStaticFieldDescriptor(r,"set"),classApplyDescriptorSet(s,r,e),e}',
						{
							globals: [],
							locals: {
								_classStaticPrivateFieldSpecSet: ['body.0.id'],
							},
							exportBindingAssignments: [],
							exportName: '_classStaticPrivateFieldSpecSet',
							dependencies: {
								classApplyDescriptorSet: [
									'body.0.body.body.0.argument.expressions.2.callee',
								],
								assertClassBrand: [
									'body.0.body.body.0.argument.expressions.0.callee',
								],
								classCheckPrivateStaticFieldDescriptor: [
									'body.0.body.body.0.argument.expressions.1.callee',
								],
							},
						},
					),
					classStaticPrivateMethodSet: helper(
						'7.3.2',
						'function _classStaticPrivateMethodSet(){throw new TypeError("attempted to set read only static private field")}',
						{
							globals: ['TypeError'],
							locals: {
								_classStaticPrivateMethodSet: ['body.0.id'],
							},
							exportBindingAssignments: [],
							exportName: '_classStaticPrivateMethodSet',
							dependencies: {},
						},
					),
					defineEnumerableProperties: helper(
						'7.0.0-beta.0',
						'function _defineEnumerableProperties(e,r){for(var t in r){var n=r[t];n.configurable=n.enumerable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,t,n)}if(Object.getOwnPropertySymbols)for(var a=Object.getOwnPropertySymbols(r),b=0;b<a.length;b++){var i=a[b];(n=r[i]).configurable=n.enumerable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,i,n)}return e}',
						{
							globals: ['Object'],
							locals: {
								_defineEnumerableProperties: ['body.0.id'],
							},
							exportBindingAssignments: [],
							exportName: '_defineEnumerableProperties',
							dependencies: {},
						},
					),
					dispose: helper(
						'7.22.0',
						'function dispose_SuppressedError(r,e){return"undefined"!=typeof SuppressedError?dispose_SuppressedError=SuppressedError:(dispose_SuppressedError=function(r,e){this.suppressed=e,this.error=r,this.stack=Error().stack},dispose_SuppressedError.prototype=Object.create(Error.prototype,{constructor:{value:dispose_SuppressedError,writable:!0,configurable:!0}})),new dispose_SuppressedError(r,e)}function _dispose(r,e,s){function next(){for(;r.length>0;)try{var o=r.pop(),p=o.d.call(o.v);if(o.a)return Promise.resolve(p).then(next,err)}catch(r){return err(r)}if(s)throw e}function err(r){return e=s?new dispose_SuppressedError(e,r):r,s=!0,next()}return next()}',
						{
							globals: ['SuppressedError', 'Error', 'Object', 'Promise'],
							locals: {
								dispose_SuppressedError: [
									'body.0.id',
									'body.0.body.body.0.argument.expressions.0.alternate.expressions.1.left.object',
									'body.0.body.body.0.argument.expressions.0.alternate.expressions.1.right.arguments.1.properties.0.value.properties.0.value',
									'body.0.body.body.0.argument.expressions.1.callee',
									'body.1.body.body.1.body.body.0.argument.expressions.0.right.consequent.callee',
									'body.0.body.body.0.argument.expressions.0.consequent.left',
									'body.0.body.body.0.argument.expressions.0.alternate.expressions.0.left',
								],
								_dispose: ['body.1.id'],
							},
							exportBindingAssignments: [],
							exportName: '_dispose',
							dependencies: {},
						},
					),
					objectSpread: helper(
						'7.0.0-beta.0',
						'function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?Object(arguments[r]):{},o=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&o.push.apply(o,Object.getOwnPropertySymbols(t).filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),o.forEach((function(r){defineProperty(e,r,t[r])}))}return e}',
						{
							globals: ['Object'],
							locals: {
								_objectSpread: ['body.0.id'],
							},
							exportBindingAssignments: [],
							exportName: '_objectSpread',
							dependencies: {
								defineProperty: [
									'body.0.body.body.0.body.body.1.expression.expressions.1.arguments.0.body.body.0.expression.callee',
								],
							},
						},
					),
					using: helper(
						'7.22.0',
						'function _using(o,n,e){if(null==n)return n;if(Object(n)!==n)throw new TypeError("using declarations can only be used with objects, functions, null, or undefined.");if(e)var r=n[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(null==r&&(r=n[Symbol.dispose||Symbol.for("Symbol.dispose")]),"function"!=typeof r)throw new TypeError("Property [Symbol.dispose] is not a function.");return o.push({v:n,d:r,a:e}),n}',
						{
							globals: ['Object', 'TypeError', 'Symbol'],
							locals: {
								_using: ['body.0.id'],
							},
							exportBindingAssignments: [],
							exportName: '_using',
							dependencies: {},
						},
					),
				})
			}

			//# sourceMappingURL=helpers-generated.js.map

			/***/
		},

		/***/ 71475: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = void 0
			exports.get = get
			exports.getDependencies = getDependencies
			exports.list = void 0
			exports.minVersion = minVersion
			var _t = __nccwpck_require__(16535)
			var _helpersGenerated = __nccwpck_require__(21214)
			const { cloneNode, identifier } = _t
			function deep(obj, path, value) {
				try {
					const parts = path.split('.')
					let last = parts.shift()
					while (parts.length > 0) {
						obj = obj[last]
						last = parts.shift()
					}
					if (arguments.length > 2) {
						obj[last] = value
					} else {
						return obj[last]
					}
				} catch (e) {
					e.message += ` (when accessing ${path})`
					throw e
				}
			}
			function permuteHelperAST(
				ast,
				metadata,
				bindingName,
				localBindings,
				getDependency,
				adjustAst,
			) {
				const { locals, dependencies, exportBindingAssignments, exportName } =
					metadata
				const bindings = new Set(localBindings || [])
				if (bindingName) bindings.add(bindingName)
				for (const [name, paths] of (
					Object.entries || ((o) => Object.keys(o).map((k) => [k, o[k]]))
				)(locals)) {
					let newName = name
					if (bindingName && name === exportName) {
						newName = bindingName
					} else {
						while (bindings.has(newName)) newName = '_' + newName
					}
					if (newName !== name) {
						for (const path of paths) {
							deep(ast, path, identifier(newName))
						}
					}
				}
				for (const [name, paths] of (
					Object.entries || ((o) => Object.keys(o).map((k) => [k, o[k]]))
				)(dependencies)) {
					const ref =
						(typeof getDependency === 'function' && getDependency(name)) ||
						identifier(name)
					for (const path of paths) {
						deep(ast, path, cloneNode(ref))
					}
				}
				adjustAst == null ||
					adjustAst(ast, exportName, (map) => {
						exportBindingAssignments.forEach((p) =>
							deep(ast, p, map(deep(ast, p))),
						)
					})
			}
			const helperData = Object.create(null)
			function loadHelper(name) {
				if (!helperData[name]) {
					const helper = _helpersGenerated.default[name]
					if (!helper) {
						throw Object.assign(new ReferenceError(`Unknown helper ${name}`), {
							code: 'BABEL_HELPER_UNKNOWN',
							helper: name,
						})
					}
					helperData[name] = {
						minVersion: helper.minVersion,
						build(getDependency, bindingName, localBindings, adjustAst) {
							const ast = helper.ast()
							permuteHelperAST(
								ast,
								helper.metadata,
								bindingName,
								localBindings,
								getDependency,
								adjustAst,
							)
							return {
								nodes: ast.body,
								globals: helper.metadata.globals,
							}
						},
						getDependencies() {
							return Object.keys(helper.metadata.dependencies)
						},
					}
				}
				return helperData[name]
			}
			function get(name, getDependency, bindingName, localBindings, adjustAst) {
				{
					if (typeof bindingName === 'object') {
						const id = bindingName
						if ((id == null ? void 0 : id.type) === 'Identifier') {
							bindingName = id.name
						} else {
							bindingName = undefined
						}
					}
				}
				return loadHelper(name).build(
					getDependency,
					bindingName,
					localBindings,
					adjustAst,
				)
			}
			function minVersion(name) {
				return loadHelper(name).minVersion
			}
			function getDependencies(name) {
				return loadHelper(name).getDependencies()
			}
			{
				exports.ensure = (name) => {
					loadHelper(name)
				}
			}
			const list = (exports.list = Object.keys(_helpersGenerated.default).map(
				(name) => name.replace(/^_/, ''),
			))
			var _default = (exports['default'] = get)

			//# sourceMappingURL=index.js.map

			/***/
		},

		/***/ 5429: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			function _objectWithoutPropertiesLoose(r, e) {
				if (null == r) return {}
				var t = {}
				for (var n in r)
					if ({}.hasOwnProperty.call(r, n)) {
						if (-1 !== e.indexOf(n)) continue
						t[n] = r[n]
					}
				return t
			}
			class Position {
				constructor(line, col, index) {
					this.line = void 0
					this.column = void 0
					this.index = void 0
					this.line = line
					this.column = col
					this.index = index
				}
			}
			class SourceLocation {
				constructor(start, end) {
					this.start = void 0
					this.end = void 0
					this.filename = void 0
					this.identifierName = void 0
					this.start = start
					this.end = end
				}
			}
			function createPositionWithColumnOffset(position, columnOffset) {
				const { line, column, index } = position
				return new Position(line, column + columnOffset, index + columnOffset)
			}
			const code = 'BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED'
			var ModuleErrors = {
				ImportMetaOutsideModule: {
					message: `import.meta may appear only with 'sourceType: "module"'`,
					code,
				},
				ImportOutsideModule: {
					message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
					code,
				},
			}
			const NodeDescriptions = {
				ArrayPattern: 'array destructuring pattern',
				AssignmentExpression: 'assignment expression',
				AssignmentPattern: 'assignment expression',
				ArrowFunctionExpression: 'arrow function expression',
				ConditionalExpression: 'conditional expression',
				CatchClause: 'catch clause',
				ForOfStatement: 'for-of statement',
				ForInStatement: 'for-in statement',
				ForStatement: 'for-loop',
				FormalParameters: 'function parameter list',
				Identifier: 'identifier',
				ImportSpecifier: 'import specifier',
				ImportDefaultSpecifier: 'import default specifier',
				ImportNamespaceSpecifier: 'import namespace specifier',
				ObjectPattern: 'object destructuring pattern',
				ParenthesizedExpression: 'parenthesized expression',
				RestElement: 'rest element',
				UpdateExpression: {
					true: 'prefix operation',
					false: 'postfix operation',
				},
				VariableDeclarator: 'variable declaration',
				YieldExpression: 'yield expression',
			}
			const toNodeDescription = (node) =>
				node.type === 'UpdateExpression'
					? NodeDescriptions.UpdateExpression[`${node.prefix}`]
					: NodeDescriptions[node.type]
			var StandardErrors = {
				AccessorIsGenerator: ({ kind }) =>
					`A ${kind}ter cannot be a generator.`,
				ArgumentsInClass:
					"'arguments' is only allowed in functions and class methods.",
				AsyncFunctionInSingleStatementContext:
					'Async functions can only be declared at the top level or inside a block.',
				AwaitBindingIdentifier:
					"Can not use 'await' as identifier inside an async function.",
				AwaitBindingIdentifierInStaticBlock:
					"Can not use 'await' as identifier inside a static block.",
				AwaitExpressionFormalParameter:
					"'await' is not allowed in async function parameters.",
				AwaitUsingNotInAsyncContext:
					"'await using' is only allowed within async functions and at the top levels of modules.",
				AwaitNotInAsyncContext:
					"'await' is only allowed within async functions and at the top levels of modules.",
				BadGetterArity: "A 'get' accessor must not have any formal parameters.",
				BadSetterArity:
					"A 'set' accessor must have exactly one formal parameter.",
				BadSetterRestParameter:
					"A 'set' accessor function argument must not be a rest parameter.",
				ConstructorClassField:
					"Classes may not have a field named 'constructor'.",
				ConstructorClassPrivateField:
					"Classes may not have a private field named '#constructor'.",
				ConstructorIsAccessor: 'Class constructor may not be an accessor.',
				ConstructorIsAsync: "Constructor can't be an async function.",
				ConstructorIsGenerator: "Constructor can't be a generator.",
				DeclarationMissingInitializer: ({ kind }) =>
					`Missing initializer in ${kind} declaration.`,
				DecoratorArgumentsOutsideParentheses:
					"Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
				DecoratorBeforeExport:
					"Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
				DecoratorsBeforeAfterExport:
					"Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
				DecoratorConstructor:
					"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
				DecoratorExportClass:
					"Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
				DecoratorSemicolon: 'Decorators must not be followed by a semicolon.',
				DecoratorStaticBlock: "Decorators can't be used with a static block.",
				DeferImportRequiresNamespace:
					'Only `import defer * as x from "./module"` is valid.',
				DeletePrivateField: 'Deleting a private field is not allowed.',
				DestructureNamedImport:
					'ES2015 named imports do not destructure. Use another statement for destructuring after the import.',
				DuplicateConstructor: 'Duplicate constructor in the same class.',
				DuplicateDefaultExport: 'Only one default export allowed per module.',
				DuplicateExport: ({ exportName }) =>
					`\`${exportName}\` has already been exported. Exported identifiers must be unique.`,
				DuplicateProto: 'Redefinition of __proto__ property.',
				DuplicateRegExpFlags: 'Duplicate regular expression flag.',
				DynamicImportPhaseRequiresImportExpressions: ({ phase }) =>
					`'import.${phase}(...)' can only be parsed when using the 'createImportExpressions' option.`,
				ElementAfterRest: 'Rest element must be last element.',
				EscapedCharNotAnIdentifier: 'Invalid Unicode escape.',
				ExportBindingIsString: ({ localName, exportName }) =>
					`A string literal cannot be used as an exported binding without \`from\`.\n- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,
				ExportDefaultFromAsIdentifier:
					"'from' is not allowed as an identifier after 'export default'.",
				ForInOfLoopInitializer: ({ type }) =>
					`'${type === 'ForInStatement' ? 'for-in' : 'for-of'}' loop variable declaration may not have an initializer.`,
				ForInUsing: "For-in loop may not start with 'using' declaration.",
				ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
				ForOfLet:
					"The left-hand side of a for-of loop may not start with 'let'.",
				GeneratorInSingleStatementContext:
					'Generators can only be declared at the top level or inside a block.',
				IllegalBreakContinue: ({ type }) =>
					`Unsyntactic ${type === 'BreakStatement' ? 'break' : 'continue'}.`,
				IllegalLanguageModeDirective:
					"Illegal 'use strict' directive in function with non-simple parameter list.",
				IllegalReturn: "'return' outside of function.",
				ImportAttributesUseAssert:
					'The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.',
				ImportBindingIsString: ({ importName }) =>
					`A string literal cannot be used as an imported binding.\n- Did you mean \`import { "${importName}" as foo }\`?`,
				ImportCallArity: `\`import()\` requires exactly one or two arguments.`,
				ImportCallNotNewExpression: 'Cannot use new with import(...).',
				ImportCallSpreadArgument: '`...` is not allowed in `import()`.',
				ImportJSONBindingNotDefault:
					'A JSON module can only be imported with `default`.',
				ImportReflectionHasAssertion:
					'`import module x` cannot have assertions.',
				ImportReflectionNotBinding:
					'Only `import module x from "./module"` is valid.',
				IncompatibleRegExpUVFlags:
					"The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
				InvalidBigIntLiteral: 'Invalid BigIntLiteral.',
				InvalidCodePoint: 'Code point out of bounds.',
				InvalidCoverInitializedName: 'Invalid shorthand property initializer.',
				InvalidDecimal: 'Invalid decimal.',
				InvalidDigit: ({ radix }) => `Expected number in radix ${radix}.`,
				InvalidEscapeSequence: 'Bad character escape sequence.',
				InvalidEscapeSequenceTemplate: 'Invalid escape sequence in template.',
				InvalidEscapedReservedWord: ({ reservedWord }) =>
					`Escape sequence in keyword ${reservedWord}.`,
				InvalidIdentifier: ({ identifierName }) =>
					`Invalid identifier ${identifierName}.`,
				InvalidLhs: ({ ancestor }) =>
					`Invalid left-hand side in ${toNodeDescription(ancestor)}.`,
				InvalidLhsBinding: ({ ancestor }) =>
					`Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,
				InvalidLhsOptionalChaining: ({ ancestor }) =>
					`Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,
				InvalidNumber: 'Invalid number.',
				InvalidOrMissingExponent:
					"Floating-point numbers require a valid exponent after the 'e'.",
				InvalidOrUnexpectedToken: ({ unexpected }) =>
					`Unexpected character '${unexpected}'.`,
				InvalidParenthesizedAssignment:
					'Invalid parenthesized assignment pattern.',
				InvalidPrivateFieldResolution: ({ identifierName }) =>
					`Private name #${identifierName} is not defined.`,
				InvalidPropertyBindingPattern: 'Binding member expression.',
				InvalidRecordProperty:
					'Only properties and spread elements are allowed in record definitions.',
				InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
				LabelRedeclaration: ({ labelName }) =>
					`Label '${labelName}' is already declared.`,
				LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
				LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
				MalformedRegExpFlags: 'Invalid regular expression flag.',
				MissingClassName: 'A class name is required.',
				MissingEqInAssignment:
					"Only '=' operator can be used for specifying default value.",
				MissingSemicolon: 'Missing semicolon.',
				MissingPlugin: ({ missingPlugin }) =>
					`This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name) => JSON.stringify(name)).join(', ')}.`,
				MissingOneOfPlugins: ({ missingPlugin }) =>
					`This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name) => JSON.stringify(name)).join(', ')}.`,
				MissingUnicodeEscape: 'Expecting Unicode escape sequence \\uXXXX.',
				MixingCoalesceWithLogical:
					'Nullish coalescing operator(??) requires parens when mixing with logical operators.',
				ModuleAttributeDifferentFromType:
					'The only accepted module attribute is `type`.',
				ModuleAttributeInvalidValue:
					'Only string literals are allowed as module attribute values.',
				ModuleAttributesWithDuplicateKeys: ({ key }) =>
					`Duplicate key "${key}" is not allowed in module attributes.`,
				ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode }) =>
					`An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,
				ModuleExportUndefined: ({ localName }) =>
					`Export '${localName}' is not defined.`,
				MultipleDefaultsInSwitch: 'Multiple default clauses.',
				NewlineAfterThrow: 'Illegal newline after throw.',
				NoCatchOrFinally: 'Missing catch or finally clause.',
				NumberIdentifier: 'Identifier directly after number.',
				NumericSeparatorInEscapeSequence:
					'Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.',
				ObsoleteAwaitStar:
					"'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
				OptionalChainingNoNew:
					'Constructors in/after an Optional Chain are not allowed.',
				OptionalChainingNoTemplate:
					'Tagged Template Literals are not allowed in optionalChain.',
				OverrideOnConstructor:
					"'override' modifier cannot appear on a constructor declaration.",
				ParamDupe: 'Argument name clash.',
				PatternHasAccessor: "Object pattern can't contain getter or setter.",
				PatternHasMethod: "Object pattern can't contain methods.",
				PrivateInExpectedIn: ({ identifierName }) =>
					`Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,
				PrivateNameRedeclaration: ({ identifierName }) =>
					`Duplicate private name #${identifierName}.`,
				RecordExpressionBarIncorrectEndSyntaxType:
					"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
				RecordExpressionBarIncorrectStartSyntaxType:
					"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
				RecordExpressionHashIncorrectStartSyntaxType:
					"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
				RecordNoProto: "'__proto__' is not allowed in Record expressions.",
				RestTrailingComma: 'Unexpected trailing comma after rest element.',
				SloppyFunction:
					'In non-strict mode code, functions can only be declared at top level or inside a block.',
				SloppyFunctionAnnexB:
					'In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.',
				SourcePhaseImportRequiresDefault:
					'Only `import source x from "./module"` is valid.',
				StaticPrototype:
					'Classes may not have static property named prototype.',
				SuperNotAllowed:
					"`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
				SuperPrivateField: "Private fields can't be accessed on super.",
				TrailingDecorator: 'Decorators must be attached to a class element.',
				TupleExpressionBarIncorrectEndSyntaxType:
					"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
				TupleExpressionBarIncorrectStartSyntaxType:
					"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
				TupleExpressionHashIncorrectStartSyntaxType:
					"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
				UnexpectedArgumentPlaceholder: 'Unexpected argument placeholder.',
				UnexpectedAwaitAfterPipelineBody:
					'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
				UnexpectedDigitAfterHash: 'Unexpected digit after hash token.',
				UnexpectedImportExport:
					"'import' and 'export' may only appear at the top level.",
				UnexpectedKeyword: ({ keyword }) => `Unexpected keyword '${keyword}'.`,
				UnexpectedLeadingDecorator:
					'Leading decorators must be attached to a class declaration.',
				UnexpectedLexicalDeclaration:
					'Lexical declaration cannot appear in a single-statement context.',
				UnexpectedNewTarget:
					'`new.target` can only be used in functions or class properties.',
				UnexpectedNumericSeparator:
					'A numeric separator is only allowed between two digits.',
				UnexpectedPrivateField: 'Unexpected private name.',
				UnexpectedReservedWord: ({ reservedWord }) =>
					`Unexpected reserved word '${reservedWord}'.`,
				UnexpectedSuper:
					"'super' is only allowed in object methods and classes.",
				UnexpectedToken: ({ expected, unexpected }) =>
					`Unexpected token${unexpected ? ` '${unexpected}'.` : ''}${expected ? `, expected "${expected}"` : ''}`,
				UnexpectedTokenUnaryExponentiation:
					'Illegal expression. Wrap left hand side or entire exponentiation in parentheses.',
				UnexpectedUsingDeclaration:
					'Using declaration cannot appear in the top level when source type is `script`.',
				UnsupportedBind: 'Binding should be performed on object property.',
				UnsupportedDecoratorExport:
					'A decorated export must export a class declaration.',
				UnsupportedDefaultExport:
					'Only expressions, functions or classes are allowed as the `default` export.',
				UnsupportedImport:
					'`import` can only be used in `import()` or `import.meta`.',
				UnsupportedMetaProperty: ({ target, onlyValidPropertyName }) =>
					`The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,
				UnsupportedParameterDecorator:
					'Decorators cannot be used to decorate parameters.',
				UnsupportedPropertyDecorator:
					'Decorators cannot be used to decorate object literal properties.',
				UnsupportedSuper:
					"'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
				UnterminatedComment: 'Unterminated comment.',
				UnterminatedRegExp: 'Unterminated regular expression.',
				UnterminatedString: 'Unterminated string constant.',
				UnterminatedTemplate: 'Unterminated template.',
				UsingDeclarationExport: 'Using declaration cannot be exported.',
				UsingDeclarationHasBindingPattern:
					'Using declaration cannot have destructuring patterns.',
				VarRedeclaration: ({ identifierName }) =>
					`Identifier '${identifierName}' has already been declared.`,
				YieldBindingIdentifier:
					"Can not use 'yield' as identifier inside a generator.",
				YieldInParameter:
					'Yield expression is not allowed in formal parameters.',
				YieldNotInGeneratorFunction:
					"'yield' is only allowed within generator functions.",
				ZeroDigitNumericSeparator:
					'Numeric separator can not be used after leading 0.',
			}
			var StrictModeErrors = {
				StrictDelete: 'Deleting local variable in strict mode.',
				StrictEvalArguments: ({ referenceName }) =>
					`Assigning to '${referenceName}' in strict mode.`,
				StrictEvalArgumentsBinding: ({ bindingName }) =>
					`Binding '${bindingName}' in strict mode.`,
				StrictFunction:
					'In strict mode code, functions can only be declared at top level or inside a block.',
				StrictNumericEscape:
					"The only valid numeric escape in strict mode is '\\0'.",
				StrictOctalLiteral:
					'Legacy octal literals are not allowed in strict mode.',
				StrictWith: "'with' in strict mode.",
			}
			const UnparenthesizedPipeBodyDescriptions = new Set([
				'ArrowFunctionExpression',
				'AssignmentExpression',
				'ConditionalExpression',
				'YieldExpression',
			])
			var PipelineOperatorErrors = Object.assign(
				{
					PipeBodyIsTighter:
						'Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.',
					PipeTopicRequiresHackPipes:
						'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
					PipeTopicUnbound:
						'Topic reference is unbound; it must be inside a pipe body.',
					PipeTopicUnconfiguredToken: ({ token }) =>
						`Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`,
					PipeTopicUnused:
						'Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.',
					PipeUnparenthesizedBody: ({ type }) =>
						`Hack-style pipe body cannot be an unparenthesized ${toNodeDescription(
							{
								type,
							},
						)}; please wrap it in parentheses.`,
				},
				{
					PipelineBodyNoArrow:
						'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
					PipelineBodySequenceExpression:
						'Pipeline body may not be a comma-separated sequence expression.',
					PipelineHeadSequenceExpression:
						'Pipeline head should not be a comma-separated sequence expression.',
					PipelineTopicUnused:
						'Pipeline is in topic style but does not use topic reference.',
					PrimaryTopicNotAllowed:
						'Topic reference was used in a lexical context without topic binding.',
					PrimaryTopicRequiresSmartPipeline:
						'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
				},
			)
			const _excluded = ['message']
			function defineHidden(obj, key, value) {
				Object.defineProperty(obj, key, {
					enumerable: false,
					configurable: true,
					value,
				})
			}
			function toParseErrorConstructor({
				toMessage,
				code,
				reasonCode,
				syntaxPlugin,
			}) {
				const hasMissingPlugin =
					reasonCode === 'MissingPlugin' || reasonCode === 'MissingOneOfPlugins'
				{
					const oldReasonCodes = {
						AccessorCannotDeclareThisParameter:
							'AccesorCannotDeclareThisParameter',
						AccessorCannotHaveTypeParameters: 'AccesorCannotHaveTypeParameters',
						ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference:
							'ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference',
						SetAccessorCannotHaveOptionalParameter:
							'SetAccesorCannotHaveOptionalParameter',
						SetAccessorCannotHaveRestParameter:
							'SetAccesorCannotHaveRestParameter',
						SetAccessorCannotHaveReturnType: 'SetAccesorCannotHaveReturnType',
					}
					if (oldReasonCodes[reasonCode]) {
						reasonCode = oldReasonCodes[reasonCode]
					}
				}
				return function constructor(loc, details) {
					const error = new SyntaxError()
					error.code = code
					error.reasonCode = reasonCode
					error.loc = loc
					error.pos = loc.index
					error.syntaxPlugin = syntaxPlugin
					if (hasMissingPlugin) {
						error.missingPlugin = details.missingPlugin
					}
					defineHidden(error, 'clone', function clone(overrides = {}) {
						var _overrides$loc
						const { line, column, index } =
							(_overrides$loc = overrides.loc) != null ? _overrides$loc : loc
						return constructor(
							new Position(line, column, index),
							Object.assign({}, details, overrides.details),
						)
					})
					defineHidden(error, 'details', details)
					Object.defineProperty(error, 'message', {
						configurable: true,
						get() {
							const message = `${toMessage(details)} (${loc.line}:${loc.column})`
							this.message = message
							return message
						},
						set(value) {
							Object.defineProperty(this, 'message', {
								value,
								writable: true,
							})
						},
					})
					return error
				}
			}
			function ParseErrorEnum(argument, syntaxPlugin) {
				if (Array.isArray(argument)) {
					return (parseErrorTemplates) =>
						ParseErrorEnum(parseErrorTemplates, argument[0])
				}
				const ParseErrorConstructors = {}
				for (const reasonCode of Object.keys(argument)) {
					const template = argument[reasonCode]
					const _ref =
							typeof template === 'string'
								? {
										message: () => template,
									}
								: typeof template === 'function'
									? {
											message: template,
										}
									: template,
						{ message } = _ref,
						rest = _objectWithoutPropertiesLoose(_ref, _excluded)
					const toMessage =
						typeof message === 'string' ? () => message : message
					ParseErrorConstructors[reasonCode] = toParseErrorConstructor(
						Object.assign(
							{
								code: 'BABEL_PARSER_SYNTAX_ERROR',
								reasonCode,
								toMessage,
							},
							syntaxPlugin
								? {
										syntaxPlugin,
									}
								: {},
							rest,
						),
					)
				}
				return ParseErrorConstructors
			}
			const Errors = Object.assign(
				{},
				ParseErrorEnum(ModuleErrors),
				ParseErrorEnum(StandardErrors),
				ParseErrorEnum(StrictModeErrors),
				ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors),
			)
			function createDefaultOptions() {
				return {
					sourceType: 'script',
					sourceFilename: undefined,
					startIndex: 0,
					startColumn: 0,
					startLine: 1,
					allowAwaitOutsideFunction: false,
					allowReturnOutsideFunction: false,
					allowNewTargetOutsideFunction: false,
					allowImportExportEverywhere: false,
					allowSuperOutsideMethod: false,
					allowUndeclaredExports: false,
					allowYieldOutsideFunction: false,
					plugins: [],
					strictMode: null,
					ranges: false,
					tokens: false,
					createImportExpressions: false,
					createParenthesizedExpressions: false,
					errorRecovery: false,
					attachComment: true,
					annexB: true,
				}
			}
			function getOptions(opts) {
				const options = createDefaultOptions()
				if (opts == null) {
					return options
				}
				if (opts.annexB != null && opts.annexB !== false) {
					throw new Error('The `annexB` option can only be set to `false`.')
				}
				for (const key of Object.keys(options)) {
					if (opts[key] != null) options[key] = opts[key]
				}
				if (options.startLine === 1) {
					if (opts.startIndex == null && options.startColumn > 0) {
						options.startIndex = options.startColumn
					} else if (opts.startColumn == null && options.startIndex > 0) {
						options.startColumn = options.startIndex
					}
				} else if (opts.startColumn == null || opts.startIndex == null) {
					if (opts.startIndex != null) {
						throw new Error(
							'With a `startLine > 1` you must also specify `startIndex` and `startColumn`.',
						)
					}
				}
				return options
			}
			const { defineProperty } = Object
			const toUnenumerable = (object, key) => {
				if (object) {
					defineProperty(object, key, {
						enumerable: false,
						value: object[key],
					})
				}
			}
			function toESTreeLocation(node) {
				toUnenumerable(node.loc.start, 'index')
				toUnenumerable(node.loc.end, 'index')
				return node
			}
			var estree = (superClass) =>
				class ESTreeParserMixin extends superClass {
					parse() {
						const file = toESTreeLocation(super.parse())
						if (this.optionFlags & 256) {
							file.tokens = file.tokens.map(toESTreeLocation)
						}
						return file
					}
					parseRegExpLiteral({ pattern, flags }) {
						let regex = null
						try {
							regex = new RegExp(pattern, flags)
						} catch (_) {}
						const node = this.estreeParseLiteral(regex)
						node.regex = {
							pattern,
							flags,
						}
						return node
					}
					parseBigIntLiteral(value) {
						let bigInt
						try {
							bigInt = BigInt(value)
						} catch (_unused) {
							bigInt = null
						}
						const node = this.estreeParseLiteral(bigInt)
						node.bigint = String(node.value || value)
						return node
					}
					parseDecimalLiteral(value) {
						const decimal = null
						const node = this.estreeParseLiteral(decimal)
						node.decimal = String(node.value || value)
						return node
					}
					estreeParseLiteral(value) {
						return this.parseLiteral(value, 'Literal')
					}
					parseStringLiteral(value) {
						return this.estreeParseLiteral(value)
					}
					parseNumericLiteral(value) {
						return this.estreeParseLiteral(value)
					}
					parseNullLiteral() {
						return this.estreeParseLiteral(null)
					}
					parseBooleanLiteral(value) {
						return this.estreeParseLiteral(value)
					}
					estreeParseChainExpression(node, endLoc) {
						const chain = this.startNodeAtNode(node)
						chain.expression = node
						return this.finishNodeAt(chain, 'ChainExpression', endLoc)
					}
					directiveToStmt(directive) {
						const expression = directive.value
						delete directive.value
						this.castNodeTo(expression, 'Literal')
						expression.raw = expression.extra.raw
						expression.value = expression.extra.expressionValue
						const stmt = this.castNodeTo(directive, 'ExpressionStatement')
						stmt.expression = expression
						stmt.directive = expression.extra.rawValue
						delete expression.extra
						return stmt
					}
					fillOptionalPropertiesForTSESLint(node) {}
					cloneEstreeStringLiteral(node) {
						const { start, end, loc, range, raw, value } = node
						const cloned = Object.create(node.constructor.prototype)
						cloned.type = 'Literal'
						cloned.start = start
						cloned.end = end
						cloned.loc = loc
						cloned.range = range
						cloned.raw = raw
						cloned.value = value
						return cloned
					}
					initFunction(node, isAsync) {
						super.initFunction(node, isAsync)
						node.expression = false
					}
					checkDeclaration(node) {
						if (node != null && this.isObjectProperty(node)) {
							this.checkDeclaration(node.value)
						} else {
							super.checkDeclaration(node)
						}
					}
					getObjectOrClassMethodParams(method) {
						return method.value.params
					}
					isValidDirective(stmt) {
						var _stmt$expression$extr
						return (
							stmt.type === 'ExpressionStatement' &&
							stmt.expression.type === 'Literal' &&
							typeof stmt.expression.value === 'string' &&
							!(
								(_stmt$expression$extr = stmt.expression.extra) != null &&
								_stmt$expression$extr.parenthesized
							)
						)
					}
					parseBlockBody(
						node,
						allowDirectives,
						topLevel,
						end,
						afterBlockParse,
					) {
						super.parseBlockBody(
							node,
							allowDirectives,
							topLevel,
							end,
							afterBlockParse,
						)
						const directiveStatements = node.directives.map((d) =>
							this.directiveToStmt(d),
						)
						node.body = directiveStatements.concat(node.body)
						delete node.directives
					}
					parsePrivateName() {
						const node = super.parsePrivateName()
						{
							if (!this.getPluginOption('estree', 'classFeatures')) {
								return node
							}
						}
						return this.convertPrivateNameToPrivateIdentifier(node)
					}
					convertPrivateNameToPrivateIdentifier(node) {
						const name = super.getPrivateNameSV(node)
						node = node
						delete node.id
						node.name = name
						return this.castNodeTo(node, 'PrivateIdentifier')
					}
					isPrivateName(node) {
						{
							if (!this.getPluginOption('estree', 'classFeatures')) {
								return super.isPrivateName(node)
							}
						}
						return node.type === 'PrivateIdentifier'
					}
					getPrivateNameSV(node) {
						{
							if (!this.getPluginOption('estree', 'classFeatures')) {
								return super.getPrivateNameSV(node)
							}
						}
						return node.name
					}
					parseLiteral(value, type) {
						const node = super.parseLiteral(value, type)
						node.raw = node.extra.raw
						delete node.extra
						return node
					}
					parseFunctionBody(node, allowExpression, isMethod = false) {
						super.parseFunctionBody(node, allowExpression, isMethod)
						node.expression = node.body.type !== 'BlockStatement'
					}
					parseMethod(
						node,
						isGenerator,
						isAsync,
						isConstructor,
						allowDirectSuper,
						type,
						inClassScope = false,
					) {
						let funcNode = this.startNode()
						funcNode.kind = node.kind
						funcNode = super.parseMethod(
							funcNode,
							isGenerator,
							isAsync,
							isConstructor,
							allowDirectSuper,
							type,
							inClassScope,
						)
						delete funcNode.kind
						const { typeParameters } = node
						if (typeParameters) {
							delete node.typeParameters
							funcNode.typeParameters = typeParameters
							this.resetStartLocationFromNode(funcNode, typeParameters)
						}
						const valueNode = this.castNodeTo(funcNode, 'FunctionExpression')
						node.value = valueNode
						if (type === 'ClassPrivateMethod') {
							node.computed = false
						}
						if (type === 'ObjectMethod') {
							if (node.kind === 'method') {
								node.kind = 'init'
							}
							node.shorthand = false
							return this.finishNode(node, 'Property')
						} else {
							return this.finishNode(node, 'MethodDefinition')
						}
					}
					nameIsConstructor(key) {
						if (key.type === 'Literal') return key.value === 'constructor'
						return super.nameIsConstructor(key)
					}
					parseClassProperty(...args) {
						const propertyNode = super.parseClassProperty(...args)
						{
							if (!this.getPluginOption('estree', 'classFeatures')) {
								return propertyNode
							}
						}
						{
							this.castNodeTo(propertyNode, 'PropertyDefinition')
						}
						return propertyNode
					}
					parseClassPrivateProperty(...args) {
						const propertyNode = super.parseClassPrivateProperty(...args)
						{
							if (!this.getPluginOption('estree', 'classFeatures')) {
								return propertyNode
							}
						}
						{
							this.castNodeTo(propertyNode, 'PropertyDefinition')
						}
						propertyNode.computed = false
						return propertyNode
					}
					parseClassAccessorProperty(node) {
						const accessorPropertyNode = super.parseClassAccessorProperty(node)
						{
							if (!this.getPluginOption('estree', 'classFeatures')) {
								return accessorPropertyNode
							}
						}
						if (accessorPropertyNode.abstract && this.hasPlugin('typescript')) {
							delete accessorPropertyNode.abstract
							this.castNodeTo(
								accessorPropertyNode,
								'TSAbstractAccessorProperty',
							)
						} else {
							this.castNodeTo(accessorPropertyNode, 'AccessorProperty')
						}
						return accessorPropertyNode
					}
					parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
						const node = super.parseObjectProperty(
							prop,
							startLoc,
							isPattern,
							refExpressionErrors,
						)
						if (node) {
							node.kind = 'init'
							this.castNodeTo(node, 'Property')
						}
						return node
					}
					finishObjectProperty(node) {
						node.kind = 'init'
						return this.finishNode(node, 'Property')
					}
					isValidLVal(type, isUnparenthesizedInAssign, binding) {
						return type === 'Property'
							? 'value'
							: super.isValidLVal(type, isUnparenthesizedInAssign, binding)
					}
					isAssignable(node, isBinding) {
						if (node != null && this.isObjectProperty(node)) {
							return this.isAssignable(node.value, isBinding)
						}
						return super.isAssignable(node, isBinding)
					}
					toAssignable(node, isLHS = false) {
						if (node != null && this.isObjectProperty(node)) {
							const { key, value } = node
							if (this.isPrivateName(key)) {
								this.classScope.usePrivateName(
									this.getPrivateNameSV(key),
									key.loc.start,
								)
							}
							this.toAssignable(value, isLHS)
						} else {
							super.toAssignable(node, isLHS)
						}
					}
					toAssignableObjectExpressionProp(prop, isLast, isLHS) {
						if (
							prop.type === 'Property' &&
							(prop.kind === 'get' || prop.kind === 'set')
						) {
							this.raise(Errors.PatternHasAccessor, prop.key)
						} else if (prop.type === 'Property' && prop.method) {
							this.raise(Errors.PatternHasMethod, prop.key)
						} else {
							super.toAssignableObjectExpressionProp(prop, isLast, isLHS)
						}
					}
					finishCallExpression(unfinished, optional) {
						const node = super.finishCallExpression(unfinished, optional)
						if (node.callee.type === 'Import') {
							var _ref, _ref2
							this.castNodeTo(node, 'ImportExpression')
							node.source = node.arguments[0]
							node.options = (_ref = node.arguments[1]) != null ? _ref : null
							node.attributes =
								(_ref2 = node.arguments[1]) != null ? _ref2 : null
							delete node.arguments
							delete node.callee
						} else if (node.type === 'OptionalCallExpression') {
							this.castNodeTo(node, 'CallExpression')
						} else {
							node.optional = false
						}
						return node
					}
					toReferencedArguments(node) {
						if (node.type === 'ImportExpression') {
							return
						}
						super.toReferencedArguments(node)
					}
					parseExport(unfinished, decorators) {
						const exportStartLoc = this.state.lastTokStartLoc
						const node = super.parseExport(unfinished, decorators)
						switch (node.type) {
							case 'ExportAllDeclaration':
								node.exported = null
								break
							case 'ExportNamedDeclaration':
								if (
									node.specifiers.length === 1 &&
									node.specifiers[0].type === 'ExportNamespaceSpecifier'
								) {
									this.castNodeTo(node, 'ExportAllDeclaration')
									node.exported = node.specifiers[0].exported
									delete node.specifiers
								}
							case 'ExportDefaultDeclaration':
								{
									var _declaration$decorato
									const { declaration } = node
									if (
										(declaration == null ? void 0 : declaration.type) ===
											'ClassDeclaration' &&
										((_declaration$decorato = declaration.decorators) == null
											? void 0
											: _declaration$decorato.length) > 0 &&
										declaration.start === node.start
									) {
										this.resetStartLocation(node, exportStartLoc)
									}
								}
								break
						}
						return node
					}
					stopParseSubscript(base, state) {
						const node = super.stopParseSubscript(base, state)
						if (state.optionalChainMember) {
							return this.estreeParseChainExpression(node, base.loc.end)
						}
						return node
					}
					parseMember(base, startLoc, state, computed, optional) {
						const node = super.parseMember(
							base,
							startLoc,
							state,
							computed,
							optional,
						)
						if (node.type === 'OptionalMemberExpression') {
							this.castNodeTo(node, 'MemberExpression')
						} else {
							node.optional = false
						}
						return node
					}
					isOptionalMemberExpression(node) {
						if (node.type === 'ChainExpression') {
							return node.expression.type === 'MemberExpression'
						}
						return super.isOptionalMemberExpression(node)
					}
					hasPropertyAsPrivateName(node) {
						if (node.type === 'ChainExpression') {
							node = node.expression
						}
						return super.hasPropertyAsPrivateName(node)
					}
					isObjectProperty(node) {
						return (
							node.type === 'Property' && node.kind === 'init' && !node.method
						)
					}
					isObjectMethod(node) {
						return (
							node.type === 'Property' &&
							(node.method || node.kind === 'get' || node.kind === 'set')
						)
					}
					castNodeTo(node, type) {
						const result = super.castNodeTo(node, type)
						this.fillOptionalPropertiesForTSESLint(result)
						return result
					}
					cloneIdentifier(node) {
						const cloned = super.cloneIdentifier(node)
						this.fillOptionalPropertiesForTSESLint(cloned)
						return cloned
					}
					cloneStringLiteral(node) {
						if (node.type === 'Literal') {
							return this.cloneEstreeStringLiteral(node)
						}
						return super.cloneStringLiteral(node)
					}
					finishNodeAt(node, type, endLoc) {
						return toESTreeLocation(super.finishNodeAt(node, type, endLoc))
					}
					finishNode(node, type) {
						const result = super.finishNode(node, type)
						this.fillOptionalPropertiesForTSESLint(result)
						return result
					}
					resetStartLocation(node, startLoc) {
						super.resetStartLocation(node, startLoc)
						toESTreeLocation(node)
					}
					resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
						super.resetEndLocation(node, endLoc)
						toESTreeLocation(node)
					}
				}
			class TokContext {
				constructor(token, preserveSpace) {
					this.token = void 0
					this.preserveSpace = void 0
					this.token = token
					this.preserveSpace = !!preserveSpace
				}
			}
			const types = {
				brace: new TokContext('{'),
				j_oTag: new TokContext('<tag'),
				j_cTag: new TokContext('</tag'),
				j_expr: new TokContext('<tag>...</tag>', true),
			}
			{
				types.template = new TokContext('`', true)
			}
			const beforeExpr = true
			const startsExpr = true
			const isLoop = true
			const isAssign = true
			const prefix = true
			const postfix = true
			class ExportedTokenType {
				constructor(label, conf = {}) {
					this.label = void 0
					this.keyword = void 0
					this.beforeExpr = void 0
					this.startsExpr = void 0
					this.rightAssociative = void 0
					this.isLoop = void 0
					this.isAssign = void 0
					this.prefix = void 0
					this.postfix = void 0
					this.binop = void 0
					this.label = label
					this.keyword = conf.keyword
					this.beforeExpr = !!conf.beforeExpr
					this.startsExpr = !!conf.startsExpr
					this.rightAssociative = !!conf.rightAssociative
					this.isLoop = !!conf.isLoop
					this.isAssign = !!conf.isAssign
					this.prefix = !!conf.prefix
					this.postfix = !!conf.postfix
					this.binop = conf.binop != null ? conf.binop : null
					{
						this.updateContext = null
					}
				}
			}
			const keywords$1 = new Map()
			function createKeyword(name, options = {}) {
				options.keyword = name
				const token = createToken(name, options)
				keywords$1.set(name, token)
				return token
			}
			function createBinop(name, binop) {
				return createToken(name, {
					beforeExpr,
					binop,
				})
			}
			let tokenTypeCounter = -1
			const tokenTypes = []
			const tokenLabels = []
			const tokenBinops = []
			const tokenBeforeExprs = []
			const tokenStartsExprs = []
			const tokenPrefixes = []
			function createToken(name, options = {}) {
				var _options$binop,
					_options$beforeExpr,
					_options$startsExpr,
					_options$prefix
				++tokenTypeCounter
				tokenLabels.push(name)
				tokenBinops.push(
					(_options$binop = options.binop) != null ? _options$binop : -1,
				)
				tokenBeforeExprs.push(
					(_options$beforeExpr = options.beforeExpr) != null
						? _options$beforeExpr
						: false,
				)
				tokenStartsExprs.push(
					(_options$startsExpr = options.startsExpr) != null
						? _options$startsExpr
						: false,
				)
				tokenPrefixes.push(
					(_options$prefix = options.prefix) != null ? _options$prefix : false,
				)
				tokenTypes.push(new ExportedTokenType(name, options))
				return tokenTypeCounter
			}
			function createKeywordLike(name, options = {}) {
				var _options$binop2,
					_options$beforeExpr2,
					_options$startsExpr2,
					_options$prefix2
				++tokenTypeCounter
				keywords$1.set(name, tokenTypeCounter)
				tokenLabels.push(name)
				tokenBinops.push(
					(_options$binop2 = options.binop) != null ? _options$binop2 : -1,
				)
				tokenBeforeExprs.push(
					(_options$beforeExpr2 = options.beforeExpr) != null
						? _options$beforeExpr2
						: false,
				)
				tokenStartsExprs.push(
					(_options$startsExpr2 = options.startsExpr) != null
						? _options$startsExpr2
						: false,
				)
				tokenPrefixes.push(
					(_options$prefix2 = options.prefix) != null
						? _options$prefix2
						: false,
				)
				tokenTypes.push(new ExportedTokenType('name', options))
				return tokenTypeCounter
			}
			const tt = {
				bracketL: createToken('[', {
					beforeExpr,
					startsExpr,
				}),
				bracketHashL: createToken('#[', {
					beforeExpr,
					startsExpr,
				}),
				bracketBarL: createToken('[|', {
					beforeExpr,
					startsExpr,
				}),
				bracketR: createToken(']'),
				bracketBarR: createToken('|]'),
				braceL: createToken('{', {
					beforeExpr,
					startsExpr,
				}),
				braceBarL: createToken('{|', {
					beforeExpr,
					startsExpr,
				}),
				braceHashL: createToken('#{', {
					beforeExpr,
					startsExpr,
				}),
				braceR: createToken('}'),
				braceBarR: createToken('|}'),
				parenL: createToken('(', {
					beforeExpr,
					startsExpr,
				}),
				parenR: createToken(')'),
				comma: createToken(',', {
					beforeExpr,
				}),
				semi: createToken(';', {
					beforeExpr,
				}),
				colon: createToken(':', {
					beforeExpr,
				}),
				doubleColon: createToken('::', {
					beforeExpr,
				}),
				dot: createToken('.'),
				question: createToken('?', {
					beforeExpr,
				}),
				questionDot: createToken('?.'),
				arrow: createToken('=>', {
					beforeExpr,
				}),
				template: createToken('template'),
				ellipsis: createToken('...', {
					beforeExpr,
				}),
				backQuote: createToken('`', {
					startsExpr,
				}),
				dollarBraceL: createToken('${', {
					beforeExpr,
					startsExpr,
				}),
				templateTail: createToken('...`', {
					startsExpr,
				}),
				templateNonTail: createToken('...${', {
					beforeExpr,
					startsExpr,
				}),
				at: createToken('@'),
				hash: createToken('#', {
					startsExpr,
				}),
				interpreterDirective: createToken('#!...'),
				eq: createToken('=', {
					beforeExpr,
					isAssign,
				}),
				assign: createToken('_=', {
					beforeExpr,
					isAssign,
				}),
				slashAssign: createToken('_=', {
					beforeExpr,
					isAssign,
				}),
				xorAssign: createToken('_=', {
					beforeExpr,
					isAssign,
				}),
				moduloAssign: createToken('_=', {
					beforeExpr,
					isAssign,
				}),
				incDec: createToken('++/--', {
					prefix,
					postfix,
					startsExpr,
				}),
				bang: createToken('!', {
					beforeExpr,
					prefix,
					startsExpr,
				}),
				tilde: createToken('~', {
					beforeExpr,
					prefix,
					startsExpr,
				}),
				doubleCaret: createToken('^^', {
					startsExpr,
				}),
				doubleAt: createToken('@@', {
					startsExpr,
				}),
				pipeline: createBinop('|>', 0),
				nullishCoalescing: createBinop('??', 1),
				logicalOR: createBinop('||', 1),
				logicalAND: createBinop('&&', 2),
				bitwiseOR: createBinop('|', 3),
				bitwiseXOR: createBinop('^', 4),
				bitwiseAND: createBinop('&', 5),
				equality: createBinop('==/!=/===/!==', 6),
				lt: createBinop('</>/<=/>=', 7),
				gt: createBinop('</>/<=/>=', 7),
				relational: createBinop('</>/<=/>=', 7),
				bitShift: createBinop('<</>>/>>>', 8),
				bitShiftL: createBinop('<</>>/>>>', 8),
				bitShiftR: createBinop('<</>>/>>>', 8),
				plusMin: createToken('+/-', {
					beforeExpr,
					binop: 9,
					prefix,
					startsExpr,
				}),
				modulo: createToken('%', {
					binop: 10,
					startsExpr,
				}),
				star: createToken('*', {
					binop: 10,
				}),
				slash: createBinop('/', 10),
				exponent: createToken('**', {
					beforeExpr,
					binop: 11,
					rightAssociative: true,
				}),
				_in: createKeyword('in', {
					beforeExpr,
					binop: 7,
				}),
				_instanceof: createKeyword('instanceof', {
					beforeExpr,
					binop: 7,
				}),
				_break: createKeyword('break'),
				_case: createKeyword('case', {
					beforeExpr,
				}),
				_catch: createKeyword('catch'),
				_continue: createKeyword('continue'),
				_debugger: createKeyword('debugger'),
				_default: createKeyword('default', {
					beforeExpr,
				}),
				_else: createKeyword('else', {
					beforeExpr,
				}),
				_finally: createKeyword('finally'),
				_function: createKeyword('function', {
					startsExpr,
				}),
				_if: createKeyword('if'),
				_return: createKeyword('return', {
					beforeExpr,
				}),
				_switch: createKeyword('switch'),
				_throw: createKeyword('throw', {
					beforeExpr,
					prefix,
					startsExpr,
				}),
				_try: createKeyword('try'),
				_var: createKeyword('var'),
				_const: createKeyword('const'),
				_with: createKeyword('with'),
				_new: createKeyword('new', {
					beforeExpr,
					startsExpr,
				}),
				_this: createKeyword('this', {
					startsExpr,
				}),
				_super: createKeyword('super', {
					startsExpr,
				}),
				_class: createKeyword('class', {
					startsExpr,
				}),
				_extends: createKeyword('extends', {
					beforeExpr,
				}),
				_export: createKeyword('export'),
				_import: createKeyword('import', {
					startsExpr,
				}),
				_null: createKeyword('null', {
					startsExpr,
				}),
				_true: createKeyword('true', {
					startsExpr,
				}),
				_false: createKeyword('false', {
					startsExpr,
				}),
				_typeof: createKeyword('typeof', {
					beforeExpr,
					prefix,
					startsExpr,
				}),
				_void: createKeyword('void', {
					beforeExpr,
					prefix,
					startsExpr,
				}),
				_delete: createKeyword('delete', {
					beforeExpr,
					prefix,
					startsExpr,
				}),
				_do: createKeyword('do', {
					isLoop,
					beforeExpr,
				}),
				_for: createKeyword('for', {
					isLoop,
				}),
				_while: createKeyword('while', {
					isLoop,
				}),
				_as: createKeywordLike('as', {
					startsExpr,
				}),
				_assert: createKeywordLike('assert', {
					startsExpr,
				}),
				_async: createKeywordLike('async', {
					startsExpr,
				}),
				_await: createKeywordLike('await', {
					startsExpr,
				}),
				_defer: createKeywordLike('defer', {
					startsExpr,
				}),
				_from: createKeywordLike('from', {
					startsExpr,
				}),
				_get: createKeywordLike('get', {
					startsExpr,
				}),
				_let: createKeywordLike('let', {
					startsExpr,
				}),
				_meta: createKeywordLike('meta', {
					startsExpr,
				}),
				_of: createKeywordLike('of', {
					startsExpr,
				}),
				_sent: createKeywordLike('sent', {
					startsExpr,
				}),
				_set: createKeywordLike('set', {
					startsExpr,
				}),
				_source: createKeywordLike('source', {
					startsExpr,
				}),
				_static: createKeywordLike('static', {
					startsExpr,
				}),
				_using: createKeywordLike('using', {
					startsExpr,
				}),
				_yield: createKeywordLike('yield', {
					startsExpr,
				}),
				_asserts: createKeywordLike('asserts', {
					startsExpr,
				}),
				_checks: createKeywordLike('checks', {
					startsExpr,
				}),
				_exports: createKeywordLike('exports', {
					startsExpr,
				}),
				_global: createKeywordLike('global', {
					startsExpr,
				}),
				_implements: createKeywordLike('implements', {
					startsExpr,
				}),
				_intrinsic: createKeywordLike('intrinsic', {
					startsExpr,
				}),
				_infer: createKeywordLike('infer', {
					startsExpr,
				}),
				_is: createKeywordLike('is', {
					startsExpr,
				}),
				_mixins: createKeywordLike('mixins', {
					startsExpr,
				}),
				_proto: createKeywordLike('proto', {
					startsExpr,
				}),
				_require: createKeywordLike('require', {
					startsExpr,
				}),
				_satisfies: createKeywordLike('satisfies', {
					startsExpr,
				}),
				_keyof: createKeywordLike('keyof', {
					startsExpr,
				}),
				_readonly: createKeywordLike('readonly', {
					startsExpr,
				}),
				_unique: createKeywordLike('unique', {
					startsExpr,
				}),
				_abstract: createKeywordLike('abstract', {
					startsExpr,
				}),
				_declare: createKeywordLike('declare', {
					startsExpr,
				}),
				_enum: createKeywordLike('enum', {
					startsExpr,
				}),
				_module: createKeywordLike('module', {
					startsExpr,
				}),
				_namespace: createKeywordLike('namespace', {
					startsExpr,
				}),
				_interface: createKeywordLike('interface', {
					startsExpr,
				}),
				_type: createKeywordLike('type', {
					startsExpr,
				}),
				_opaque: createKeywordLike('opaque', {
					startsExpr,
				}),
				name: createToken('name', {
					startsExpr,
				}),
				placeholder: createToken('%%', {
					startsExpr: true,
				}),
				string: createToken('string', {
					startsExpr,
				}),
				num: createToken('num', {
					startsExpr,
				}),
				bigint: createToken('bigint', {
					startsExpr,
				}),
				decimal: createToken('decimal', {
					startsExpr,
				}),
				regexp: createToken('regexp', {
					startsExpr,
				}),
				privateName: createToken('#name', {
					startsExpr,
				}),
				eof: createToken('eof'),
				jsxName: createToken('jsxName'),
				jsxText: createToken('jsxText', {
					beforeExpr: true,
				}),
				jsxTagStart: createToken('jsxTagStart', {
					startsExpr: true,
				}),
				jsxTagEnd: createToken('jsxTagEnd'),
			}
			function tokenIsIdentifier(token) {
				return token >= 93 && token <= 133
			}
			function tokenKeywordOrIdentifierIsKeyword(token) {
				return token <= 92
			}
			function tokenIsKeywordOrIdentifier(token) {
				return token >= 58 && token <= 133
			}
			function tokenIsLiteralPropertyName(token) {
				return token >= 58 && token <= 137
			}
			function tokenComesBeforeExpression(token) {
				return tokenBeforeExprs[token]
			}
			function tokenCanStartExpression(token) {
				return tokenStartsExprs[token]
			}
			function tokenIsAssignment(token) {
				return token >= 29 && token <= 33
			}
			function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
				return token >= 129 && token <= 131
			}
			function tokenIsLoop(token) {
				return token >= 90 && token <= 92
			}
			function tokenIsKeyword(token) {
				return token >= 58 && token <= 92
			}
			function tokenIsOperator(token) {
				return token >= 39 && token <= 59
			}
			function tokenIsPostfix(token) {
				return token === 34
			}
			function tokenIsPrefix(token) {
				return tokenPrefixes[token]
			}
			function tokenIsTSTypeOperator(token) {
				return token >= 121 && token <= 123
			}
			function tokenIsTSDeclarationStart(token) {
				return token >= 124 && token <= 130
			}
			function tokenLabelName(token) {
				return tokenLabels[token]
			}
			function tokenOperatorPrecedence(token) {
				return tokenBinops[token]
			}
			function tokenIsRightAssociative(token) {
				return token === 57
			}
			function tokenIsTemplate(token) {
				return token >= 24 && token <= 25
			}
			function getExportedToken(token) {
				return tokenTypes[token]
			}
			{
				tokenTypes[8].updateContext = (context) => {
					context.pop()
				}
				tokenTypes[5].updateContext =
					tokenTypes[7].updateContext =
					tokenTypes[23].updateContext =
						(context) => {
							context.push(types.brace)
						}
				tokenTypes[22].updateContext = (context) => {
					if (context[context.length - 1] === types.template) {
						context.pop()
					} else {
						context.push(types.template)
					}
				}
				tokenTypes[143].updateContext = (context) => {
					context.push(types.j_expr, types.j_oTag)
				}
			}
			let nonASCIIidentifierStartChars =
				'\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c8a\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7cd\ua7d0\ua7d1\ua7d3\ua7d5-\ua7dc\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc'
			let nonASCIIidentifierChars =
				'\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0897-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0cf3\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ece\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\u30fb\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f\uff65'
			const nonASCIIidentifierStart = new RegExp(
				'[' + nonASCIIidentifierStartChars + ']',
			)
			const nonASCIIidentifier = new RegExp(
				'[' + nonASCIIidentifierStartChars + nonASCIIidentifierChars + ']',
			)
			nonASCIIidentifierStartChars = nonASCIIidentifierChars = null
			const astralIdentifierStartCodes = [
				0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4,
				48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35,
				5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2,
				1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2,
				43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71,
				55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28,
				53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10,
				22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22,
				13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0,
				13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2,
				14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13,
				4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2,
				31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72,
				26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2,
				0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0,
				19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22,
				0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80,
				921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582,
				6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6,
				18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9,
				1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9,
				395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3,
				3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0,
				4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2,
				30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322,
				29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196,
				60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0,
				7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0,
				2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2,
				16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467,
				541, 1507, 4938, 6, 4191,
			]
			const astralIdentifierCodes = [
				509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166,
				1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54,
				14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1,
				45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7,
				3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0,
				2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3,
				8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14,
				166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9,
				41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21,
				2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9,
				330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27,
				2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0,
				12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31,
				3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6,
				2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13,
				245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239,
			]
			function isInAstralSet(code, set) {
				let pos = 0x10000
				for (let i = 0, length = set.length; i < length; i += 2) {
					pos += set[i]
					if (pos > code) return false
					pos += set[i + 1]
					if (pos >= code) return true
				}
				return false
			}
			function isIdentifierStart(code) {
				if (code < 65) return code === 36
				if (code <= 90) return true
				if (code < 97) return code === 95
				if (code <= 122) return true
				if (code <= 0xffff) {
					return (
						code >= 0xaa &&
						nonASCIIidentifierStart.test(String.fromCharCode(code))
					)
				}
				return isInAstralSet(code, astralIdentifierStartCodes)
			}
			function isIdentifierChar(code) {
				if (code < 48) return code === 36
				if (code < 58) return true
				if (code < 65) return false
				if (code <= 90) return true
				if (code < 97) return code === 95
				if (code <= 122) return true
				if (code <= 0xffff) {
					return (
						code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code))
					)
				}
				return (
					isInAstralSet(code, astralIdentifierStartCodes) ||
					isInAstralSet(code, astralIdentifierCodes)
				)
			}
			const reservedWords = {
				keyword: [
					'break',
					'case',
					'catch',
					'continue',
					'debugger',
					'default',
					'do',
					'else',
					'finally',
					'for',
					'function',
					'if',
					'return',
					'switch',
					'throw',
					'try',
					'var',
					'const',
					'while',
					'with',
					'new',
					'this',
					'super',
					'class',
					'extends',
					'export',
					'import',
					'null',
					'true',
					'false',
					'in',
					'instanceof',
					'typeof',
					'void',
					'delete',
				],
				strict: [
					'implements',
					'interface',
					'let',
					'package',
					'private',
					'protected',
					'public',
					'static',
					'yield',
				],
				strictBind: ['eval', 'arguments'],
			}
			const keywords = new Set(reservedWords.keyword)
			const reservedWordsStrictSet = new Set(reservedWords.strict)
			const reservedWordsStrictBindSet = new Set(reservedWords.strictBind)
			function isReservedWord(word, inModule) {
				return (inModule && word === 'await') || word === 'enum'
			}
			function isStrictReservedWord(word, inModule) {
				return (
					isReservedWord(word, inModule) || reservedWordsStrictSet.has(word)
				)
			}
			function isStrictBindOnlyReservedWord(word) {
				return reservedWordsStrictBindSet.has(word)
			}
			function isStrictBindReservedWord(word, inModule) {
				return (
					isStrictReservedWord(word, inModule) ||
					isStrictBindOnlyReservedWord(word)
				)
			}
			function isKeyword(word) {
				return keywords.has(word)
			}
			function isIteratorStart(current, next, next2) {
				return current === 64 && next === 64 && isIdentifierStart(next2)
			}
			const reservedWordLikeSet = new Set([
				'break',
				'case',
				'catch',
				'continue',
				'debugger',
				'default',
				'do',
				'else',
				'finally',
				'for',
				'function',
				'if',
				'return',
				'switch',
				'throw',
				'try',
				'var',
				'const',
				'while',
				'with',
				'new',
				'this',
				'super',
				'class',
				'extends',
				'export',
				'import',
				'null',
				'true',
				'false',
				'in',
				'instanceof',
				'typeof',
				'void',
				'delete',
				'implements',
				'interface',
				'let',
				'package',
				'private',
				'protected',
				'public',
				'static',
				'yield',
				'eval',
				'arguments',
				'enum',
				'await',
			])
			function canBeReservedWord(word) {
				return reservedWordLikeSet.has(word)
			}
			class Scope {
				constructor(flags) {
					this.flags = 0
					this.names = new Map()
					this.firstLexicalName = ''
					this.flags = flags
				}
			}
			class ScopeHandler {
				constructor(parser, inModule) {
					this.parser = void 0
					this.scopeStack = []
					this.inModule = void 0
					this.undefinedExports = new Map()
					this.parser = parser
					this.inModule = inModule
				}
				get inTopLevel() {
					return (this.currentScope().flags & 1) > 0
				}
				get inFunction() {
					return (this.currentVarScopeFlags() & 2) > 0
				}
				get allowSuper() {
					return (this.currentThisScopeFlags() & 16) > 0
				}
				get allowDirectSuper() {
					return (this.currentThisScopeFlags() & 32) > 0
				}
				get inClass() {
					return (this.currentThisScopeFlags() & 64) > 0
				}
				get inClassAndNotInNonArrowFunction() {
					const flags = this.currentThisScopeFlags()
					return (flags & 64) > 0 && (flags & 2) === 0
				}
				get inStaticBlock() {
					for (let i = this.scopeStack.length - 1; ; i--) {
						const { flags } = this.scopeStack[i]
						if (flags & 128) {
							return true
						}
						if (flags & (387 | 64)) {
							return false
						}
					}
				}
				get inNonArrowFunction() {
					return (this.currentThisScopeFlags() & 2) > 0
				}
				get treatFunctionsAsVar() {
					return this.treatFunctionsAsVarInScope(this.currentScope())
				}
				createScope(flags) {
					return new Scope(flags)
				}
				enter(flags) {
					this.scopeStack.push(this.createScope(flags))
				}
				exit() {
					const scope = this.scopeStack.pop()
					return scope.flags
				}
				treatFunctionsAsVarInScope(scope) {
					return !!(
						scope.flags & (2 | 128) ||
						(!this.parser.inModule && scope.flags & 1)
					)
				}
				declareName(name, bindingType, loc) {
					let scope = this.currentScope()
					if (bindingType & 8 || bindingType & 16) {
						this.checkRedeclarationInScope(scope, name, bindingType, loc)
						let type = scope.names.get(name) || 0
						if (bindingType & 16) {
							type = type | 4
						} else {
							if (!scope.firstLexicalName) {
								scope.firstLexicalName = name
							}
							type = type | 2
						}
						scope.names.set(name, type)
						if (bindingType & 8) {
							this.maybeExportDefined(scope, name)
						}
					} else if (bindingType & 4) {
						for (let i = this.scopeStack.length - 1; i >= 0; --i) {
							scope = this.scopeStack[i]
							this.checkRedeclarationInScope(scope, name, bindingType, loc)
							scope.names.set(name, (scope.names.get(name) || 0) | 1)
							this.maybeExportDefined(scope, name)
							if (scope.flags & 387) break
						}
					}
					if (this.parser.inModule && scope.flags & 1) {
						this.undefinedExports.delete(name)
					}
				}
				maybeExportDefined(scope, name) {
					if (this.parser.inModule && scope.flags & 1) {
						this.undefinedExports.delete(name)
					}
				}
				checkRedeclarationInScope(scope, name, bindingType, loc) {
					if (this.isRedeclaredInScope(scope, name, bindingType)) {
						this.parser.raise(Errors.VarRedeclaration, loc, {
							identifierName: name,
						})
					}
				}
				isRedeclaredInScope(scope, name, bindingType) {
					if (!(bindingType & 1)) return false
					if (bindingType & 8) {
						return scope.names.has(name)
					}
					const type = scope.names.get(name)
					if (bindingType & 16) {
						return (
							(type & 2) > 0 ||
							(!this.treatFunctionsAsVarInScope(scope) && (type & 1) > 0)
						)
					}
					return (
						((type & 2) > 0 &&
							!(scope.flags & 8 && scope.firstLexicalName === name)) ||
						(!this.treatFunctionsAsVarInScope(scope) && (type & 4) > 0)
					)
				}
				checkLocalExport(id) {
					const { name } = id
					const topLevelScope = this.scopeStack[0]
					if (!topLevelScope.names.has(name)) {
						this.undefinedExports.set(name, id.loc.start)
					}
				}
				currentScope() {
					return this.scopeStack[this.scopeStack.length - 1]
				}
				currentVarScopeFlags() {
					for (let i = this.scopeStack.length - 1; ; i--) {
						const { flags } = this.scopeStack[i]
						if (flags & 387) {
							return flags
						}
					}
				}
				currentThisScopeFlags() {
					for (let i = this.scopeStack.length - 1; ; i--) {
						const { flags } = this.scopeStack[i]
						if (flags & (387 | 64) && !(flags & 4)) {
							return flags
						}
					}
				}
			}
			class FlowScope extends Scope {
				constructor(...args) {
					super(...args)
					this.declareFunctions = new Set()
				}
			}
			class FlowScopeHandler extends ScopeHandler {
				createScope(flags) {
					return new FlowScope(flags)
				}
				declareName(name, bindingType, loc) {
					const scope = this.currentScope()
					if (bindingType & 2048) {
						this.checkRedeclarationInScope(scope, name, bindingType, loc)
						this.maybeExportDefined(scope, name)
						scope.declareFunctions.add(name)
						return
					}
					super.declareName(name, bindingType, loc)
				}
				isRedeclaredInScope(scope, name, bindingType) {
					if (super.isRedeclaredInScope(scope, name, bindingType)) return true
					if (bindingType & 2048 && !scope.declareFunctions.has(name)) {
						const type = scope.names.get(name)
						return (type & 4) > 0 || (type & 2) > 0
					}
					return false
				}
				checkLocalExport(id) {
					if (!this.scopeStack[0].declareFunctions.has(id.name)) {
						super.checkLocalExport(id)
					}
				}
			}
			const reservedTypes = new Set([
				'_',
				'any',
				'bool',
				'boolean',
				'empty',
				'extends',
				'false',
				'interface',
				'mixed',
				'null',
				'number',
				'static',
				'string',
				'true',
				'typeof',
				'void',
			])
			const FlowErrors = ParseErrorEnum`flow`({
				AmbiguousConditionalArrow:
					'Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.',
				AmbiguousDeclareModuleKind:
					'Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.',
				AssignReservedType: ({ reservedType }) =>
					`Cannot overwrite reserved type ${reservedType}.`,
				DeclareClassElement:
					'The `declare` modifier can only appear on class fields.',
				DeclareClassFieldInitializer:
					'Initializers are not allowed in fields with the `declare` modifier.',
				DuplicateDeclareModuleExports:
					'Duplicate `declare module.exports` statement.',
				EnumBooleanMemberNotInitialized: ({ memberName, enumName }) =>
					`Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`,
				EnumDuplicateMemberName: ({ memberName, enumName }) =>
					`Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`,
				EnumInconsistentMemberValues: ({ enumName }) =>
					`Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
				EnumInvalidExplicitType: ({ invalidEnumType, enumName }) =>
					`Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
				EnumInvalidExplicitTypeUnknownSupplied: ({ enumName }) =>
					`Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
				EnumInvalidMemberInitializerPrimaryType: ({
					enumName,
					memberName,
					explicitType,
				}) =>
					`Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`,
				EnumInvalidMemberInitializerSymbolType: ({ enumName, memberName }) =>
					`Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`,
				EnumInvalidMemberInitializerUnknownType: ({ enumName, memberName }) =>
					`The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`,
				EnumInvalidMemberName: ({ enumName, memberName, suggestion }) =>
					`Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`,
				EnumNumberMemberNotInitialized: ({ enumName, memberName }) =>
					`Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`,
				EnumStringMemberInconsistentlyInitialized: ({ enumName }) =>
					`String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`,
				GetterMayNotHaveThisParam: 'A getter cannot have a `this` parameter.',
				ImportReflectionHasImportType:
					'An `import module` declaration can not use `type` or `typeof` keyword.',
				ImportTypeShorthandOnlyInPureImport:
					'The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.',
				InexactInsideExact:
					'Explicit inexact syntax cannot appear inside an explicit exact object type.',
				InexactInsideNonObject:
					'Explicit inexact syntax cannot appear in class or interface definitions.',
				InexactVariance: 'Explicit inexact syntax cannot have variance.',
				InvalidNonTypeImportInDeclareModule:
					'Imports within a `declare module` body must always be `import type` or `import typeof`.',
				MissingTypeParamDefault:
					'Type parameter declaration needs a default, since a preceding type parameter declaration has a default.',
				NestedDeclareModule:
					'`declare module` cannot be used inside another `declare module`.',
				NestedFlowComment:
					'Cannot have a flow comment inside another flow comment.',
				PatternIsOptional: Object.assign(
					{
						message:
							'A binding pattern parameter cannot be optional in an implementation signature.',
					},
					{
						reasonCode: 'OptionalBindingPattern',
					},
				),
				SetterMayNotHaveThisParam: 'A setter cannot have a `this` parameter.',
				SpreadVariance: 'Spread properties cannot have variance.',
				ThisParamAnnotationRequired:
					'A type annotation is required for the `this` parameter.',
				ThisParamBannedInConstructor:
					"Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
				ThisParamMayNotBeOptional: 'The `this` parameter cannot be optional.',
				ThisParamMustBeFirst:
					'The `this` parameter must be the first function parameter.',
				ThisParamNoDefault:
					'The `this` parameter may not have a default value.',
				TypeBeforeInitializer:
					'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.',
				TypeCastInPattern:
					'The type cast expression is expected to be wrapped with parenthesis.',
				UnexpectedExplicitInexactInObject:
					'Explicit inexact syntax must appear at the end of an inexact object.',
				UnexpectedReservedType: ({ reservedType }) =>
					`Unexpected reserved type ${reservedType}.`,
				UnexpectedReservedUnderscore:
					'`_` is only allowed as a type argument to call or new.',
				UnexpectedSpaceBetweenModuloChecks:
					'Spaces between `%` and `checks` are not allowed here.',
				UnexpectedSpreadType:
					'Spread operator cannot appear in class or interface definitions.',
				UnexpectedSubtractionOperand:
					'Unexpected token, expected "number" or "bigint".',
				UnexpectedTokenAfterTypeParameter:
					'Expected an arrow function after this type parameter declaration.',
				UnexpectedTypeParameterBeforeAsyncArrowFunction:
					'Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.',
				UnsupportedDeclareExportKind: ({ unsupportedExportKind, suggestion }) =>
					`\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`,
				UnsupportedStatementInDeclareModule:
					'Only declares and type imports are allowed inside declare module.',
				UnterminatedFlowComment: 'Unterminated flow-comment.',
			})
			function isEsModuleType(bodyElement) {
				return (
					bodyElement.type === 'DeclareExportAllDeclaration' ||
					(bodyElement.type === 'DeclareExportDeclaration' &&
						(!bodyElement.declaration ||
							(bodyElement.declaration.type !== 'TypeAlias' &&
								bodyElement.declaration.type !== 'InterfaceDeclaration')))
				)
			}
			function hasTypeImportKind(node) {
				return node.importKind === 'type' || node.importKind === 'typeof'
			}
			const exportSuggestions = {
				const: 'declare export var',
				let: 'declare export var',
				type: 'export type',
				interface: 'export interface',
			}
			function partition(list, test) {
				const list1 = []
				const list2 = []
				for (let i = 0; i < list.length; i++) {
					;(test(list[i], i, list) ? list1 : list2).push(list[i])
				}
				return [list1, list2]
			}
			const FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/
			var flow = (superClass) =>
				class FlowParserMixin extends superClass {
					constructor(...args) {
						super(...args)
						this.flowPragma = undefined
					}
					getScopeHandler() {
						return FlowScopeHandler
					}
					shouldParseTypes() {
						return (
							this.getPluginOption('flow', 'all') || this.flowPragma === 'flow'
						)
					}
					finishToken(type, val) {
						if (type !== 134 && type !== 13 && type !== 28) {
							if (this.flowPragma === undefined) {
								this.flowPragma = null
							}
						}
						super.finishToken(type, val)
					}
					addComment(comment) {
						if (this.flowPragma === undefined) {
							const matches = FLOW_PRAGMA_REGEX.exec(comment.value)
							if (!matches);
							else if (matches[1] === 'flow') {
								this.flowPragma = 'flow'
							} else if (matches[1] === 'noflow') {
								this.flowPragma = 'noflow'
							} else {
								throw new Error('Unexpected flow pragma')
							}
						}
						super.addComment(comment)
					}
					flowParseTypeInitialiser(tok) {
						const oldInType = this.state.inType
						this.state.inType = true
						this.expect(tok || 14)
						const type = this.flowParseType()
						this.state.inType = oldInType
						return type
					}
					flowParsePredicate() {
						const node = this.startNode()
						const moduloLoc = this.state.startLoc
						this.next()
						this.expectContextual(110)
						if (this.state.lastTokStartLoc.index > moduloLoc.index + 1) {
							this.raise(
								FlowErrors.UnexpectedSpaceBetweenModuloChecks,
								moduloLoc,
							)
						}
						if (this.eat(10)) {
							node.value = super.parseExpression()
							this.expect(11)
							return this.finishNode(node, 'DeclaredPredicate')
						} else {
							return this.finishNode(node, 'InferredPredicate')
						}
					}
					flowParseTypeAndPredicateInitialiser() {
						const oldInType = this.state.inType
						this.state.inType = true
						this.expect(14)
						let type = null
						let predicate = null
						if (this.match(54)) {
							this.state.inType = oldInType
							predicate = this.flowParsePredicate()
						} else {
							type = this.flowParseType()
							this.state.inType = oldInType
							if (this.match(54)) {
								predicate = this.flowParsePredicate()
							}
						}
						return [type, predicate]
					}
					flowParseDeclareClass(node) {
						this.next()
						this.flowParseInterfaceish(node, true)
						return this.finishNode(node, 'DeclareClass')
					}
					flowParseDeclareFunction(node) {
						this.next()
						const id = (node.id = this.parseIdentifier())
						const typeNode = this.startNode()
						const typeContainer = this.startNode()
						if (this.match(47)) {
							typeNode.typeParameters = this.flowParseTypeParameterDeclaration()
						} else {
							typeNode.typeParameters = null
						}
						this.expect(10)
						const tmp = this.flowParseFunctionTypeParams()
						typeNode.params = tmp.params
						typeNode.rest = tmp.rest
						typeNode.this = tmp._this
						this.expect(11)
						;[typeNode.returnType, node.predicate] =
							this.flowParseTypeAndPredicateInitialiser()
						typeContainer.typeAnnotation = this.finishNode(
							typeNode,
							'FunctionTypeAnnotation',
						)
						id.typeAnnotation = this.finishNode(typeContainer, 'TypeAnnotation')
						this.resetEndLocation(id)
						this.semicolon()
						this.scope.declareName(node.id.name, 2048, node.id.loc.start)
						return this.finishNode(node, 'DeclareFunction')
					}
					flowParseDeclare(node, insideModule) {
						if (this.match(80)) {
							return this.flowParseDeclareClass(node)
						} else if (this.match(68)) {
							return this.flowParseDeclareFunction(node)
						} else if (this.match(74)) {
							return this.flowParseDeclareVariable(node)
						} else if (this.eatContextual(127)) {
							if (this.match(16)) {
								return this.flowParseDeclareModuleExports(node)
							} else {
								if (insideModule) {
									this.raise(
										FlowErrors.NestedDeclareModule,
										this.state.lastTokStartLoc,
									)
								}
								return this.flowParseDeclareModule(node)
							}
						} else if (this.isContextual(130)) {
							return this.flowParseDeclareTypeAlias(node)
						} else if (this.isContextual(131)) {
							return this.flowParseDeclareOpaqueType(node)
						} else if (this.isContextual(129)) {
							return this.flowParseDeclareInterface(node)
						} else if (this.match(82)) {
							return this.flowParseDeclareExportDeclaration(node, insideModule)
						} else {
							this.unexpected()
						}
					}
					flowParseDeclareVariable(node) {
						this.next()
						node.id = this.flowParseTypeAnnotatableIdentifier(true)
						this.scope.declareName(node.id.name, 5, node.id.loc.start)
						this.semicolon()
						return this.finishNode(node, 'DeclareVariable')
					}
					flowParseDeclareModule(node) {
						this.scope.enter(0)
						if (this.match(134)) {
							node.id = super.parseExprAtom()
						} else {
							node.id = this.parseIdentifier()
						}
						const bodyNode = (node.body = this.startNode())
						const body = (bodyNode.body = [])
						this.expect(5)
						while (!this.match(8)) {
							let bodyNode = this.startNode()
							if (this.match(83)) {
								this.next()
								if (!this.isContextual(130) && !this.match(87)) {
									this.raise(
										FlowErrors.InvalidNonTypeImportInDeclareModule,
										this.state.lastTokStartLoc,
									)
								}
								super.parseImport(bodyNode)
							} else {
								this.expectContextual(
									125,
									FlowErrors.UnsupportedStatementInDeclareModule,
								)
								bodyNode = this.flowParseDeclare(bodyNode, true)
							}
							body.push(bodyNode)
						}
						this.scope.exit()
						this.expect(8)
						this.finishNode(bodyNode, 'BlockStatement')
						let kind = null
						let hasModuleExport = false
						body.forEach((bodyElement) => {
							if (isEsModuleType(bodyElement)) {
								if (kind === 'CommonJS') {
									this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement)
								}
								kind = 'ES'
							} else if (bodyElement.type === 'DeclareModuleExports') {
								if (hasModuleExport) {
									this.raise(
										FlowErrors.DuplicateDeclareModuleExports,
										bodyElement,
									)
								}
								if (kind === 'ES') {
									this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement)
								}
								kind = 'CommonJS'
								hasModuleExport = true
							}
						})
						node.kind = kind || 'CommonJS'
						return this.finishNode(node, 'DeclareModule')
					}
					flowParseDeclareExportDeclaration(node, insideModule) {
						this.expect(82)
						if (this.eat(65)) {
							if (this.match(68) || this.match(80)) {
								node.declaration = this.flowParseDeclare(this.startNode())
							} else {
								node.declaration = this.flowParseType()
								this.semicolon()
							}
							node.default = true
							return this.finishNode(node, 'DeclareExportDeclaration')
						} else {
							if (
								this.match(75) ||
								this.isLet() ||
								((this.isContextual(130) || this.isContextual(129)) &&
									!insideModule)
							) {
								const label = this.state.value
								throw this.raise(
									FlowErrors.UnsupportedDeclareExportKind,
									this.state.startLoc,
									{
										unsupportedExportKind: label,
										suggestion: exportSuggestions[label],
									},
								)
							}
							if (
								this.match(74) ||
								this.match(68) ||
								this.match(80) ||
								this.isContextual(131)
							) {
								node.declaration = this.flowParseDeclare(this.startNode())
								node.default = false
								return this.finishNode(node, 'DeclareExportDeclaration')
							} else if (
								this.match(55) ||
								this.match(5) ||
								this.isContextual(129) ||
								this.isContextual(130) ||
								this.isContextual(131)
							) {
								node = this.parseExport(node, null)
								if (node.type === 'ExportNamedDeclaration') {
									node.default = false
									delete node.exportKind
									return this.castNodeTo(node, 'DeclareExportDeclaration')
								} else {
									return this.castNodeTo(node, 'DeclareExportAllDeclaration')
								}
							}
						}
						this.unexpected()
					}
					flowParseDeclareModuleExports(node) {
						this.next()
						this.expectContextual(111)
						node.typeAnnotation = this.flowParseTypeAnnotation()
						this.semicolon()
						return this.finishNode(node, 'DeclareModuleExports')
					}
					flowParseDeclareTypeAlias(node) {
						this.next()
						const finished = this.flowParseTypeAlias(node)
						this.castNodeTo(finished, 'DeclareTypeAlias')
						return finished
					}
					flowParseDeclareOpaqueType(node) {
						this.next()
						const finished = this.flowParseOpaqueType(node, true)
						this.castNodeTo(finished, 'DeclareOpaqueType')
						return finished
					}
					flowParseDeclareInterface(node) {
						this.next()
						this.flowParseInterfaceish(node, false)
						return this.finishNode(node, 'DeclareInterface')
					}
					flowParseInterfaceish(node, isClass) {
						node.id = this.flowParseRestrictedIdentifier(!isClass, true)
						this.scope.declareName(
							node.id.name,
							isClass ? 17 : 8201,
							node.id.loc.start,
						)
						if (this.match(47)) {
							node.typeParameters = this.flowParseTypeParameterDeclaration()
						} else {
							node.typeParameters = null
						}
						node.extends = []
						if (this.eat(81)) {
							do {
								node.extends.push(this.flowParseInterfaceExtends())
							} while (!isClass && this.eat(12))
						}
						if (isClass) {
							node.implements = []
							node.mixins = []
							if (this.eatContextual(117)) {
								do {
									node.mixins.push(this.flowParseInterfaceExtends())
								} while (this.eat(12))
							}
							if (this.eatContextual(113)) {
								do {
									node.implements.push(this.flowParseInterfaceExtends())
								} while (this.eat(12))
							}
						}
						node.body = this.flowParseObjectType({
							allowStatic: isClass,
							allowExact: false,
							allowSpread: false,
							allowProto: isClass,
							allowInexact: false,
						})
					}
					flowParseInterfaceExtends() {
						const node = this.startNode()
						node.id = this.flowParseQualifiedTypeIdentifier()
						if (this.match(47)) {
							node.typeParameters = this.flowParseTypeParameterInstantiation()
						} else {
							node.typeParameters = null
						}
						return this.finishNode(node, 'InterfaceExtends')
					}
					flowParseInterface(node) {
						this.flowParseInterfaceish(node, false)
						return this.finishNode(node, 'InterfaceDeclaration')
					}
					checkNotUnderscore(word) {
						if (word === '_') {
							this.raise(
								FlowErrors.UnexpectedReservedUnderscore,
								this.state.startLoc,
							)
						}
					}
					checkReservedType(word, startLoc, declaration) {
						if (!reservedTypes.has(word)) return
						this.raise(
							declaration
								? FlowErrors.AssignReservedType
								: FlowErrors.UnexpectedReservedType,
							startLoc,
							{
								reservedType: word,
							},
						)
					}
					flowParseRestrictedIdentifier(liberal, declaration) {
						this.checkReservedType(
							this.state.value,
							this.state.startLoc,
							declaration,
						)
						return this.parseIdentifier(liberal)
					}
					flowParseTypeAlias(node) {
						node.id = this.flowParseRestrictedIdentifier(false, true)
						this.scope.declareName(node.id.name, 8201, node.id.loc.start)
						if (this.match(47)) {
							node.typeParameters = this.flowParseTypeParameterDeclaration()
						} else {
							node.typeParameters = null
						}
						node.right = this.flowParseTypeInitialiser(29)
						this.semicolon()
						return this.finishNode(node, 'TypeAlias')
					}
					flowParseOpaqueType(node, declare) {
						this.expectContextual(130)
						node.id = this.flowParseRestrictedIdentifier(true, true)
						this.scope.declareName(node.id.name, 8201, node.id.loc.start)
						if (this.match(47)) {
							node.typeParameters = this.flowParseTypeParameterDeclaration()
						} else {
							node.typeParameters = null
						}
						node.supertype = null
						if (this.match(14)) {
							node.supertype = this.flowParseTypeInitialiser(14)
						}
						node.impltype = null
						if (!declare) {
							node.impltype = this.flowParseTypeInitialiser(29)
						}
						this.semicolon()
						return this.finishNode(node, 'OpaqueType')
					}
					flowParseTypeParameter(requireDefault = false) {
						const nodeStartLoc = this.state.startLoc
						const node = this.startNode()
						const variance = this.flowParseVariance()
						const ident = this.flowParseTypeAnnotatableIdentifier()
						node.name = ident.name
						node.variance = variance
						node.bound = ident.typeAnnotation
						if (this.match(29)) {
							this.eat(29)
							node.default = this.flowParseType()
						} else {
							if (requireDefault) {
								this.raise(FlowErrors.MissingTypeParamDefault, nodeStartLoc)
							}
						}
						return this.finishNode(node, 'TypeParameter')
					}
					flowParseTypeParameterDeclaration() {
						const oldInType = this.state.inType
						const node = this.startNode()
						node.params = []
						this.state.inType = true
						if (this.match(47) || this.match(143)) {
							this.next()
						} else {
							this.unexpected()
						}
						let defaultRequired = false
						do {
							const typeParameter = this.flowParseTypeParameter(defaultRequired)
							node.params.push(typeParameter)
							if (typeParameter.default) {
								defaultRequired = true
							}
							if (!this.match(48)) {
								this.expect(12)
							}
						} while (!this.match(48))
						this.expect(48)
						this.state.inType = oldInType
						return this.finishNode(node, 'TypeParameterDeclaration')
					}
					flowInTopLevelContext(cb) {
						if (this.curContext() !== types.brace) {
							const oldContext = this.state.context
							this.state.context = [oldContext[0]]
							try {
								return cb()
							} finally {
								this.state.context = oldContext
							}
						} else {
							return cb()
						}
					}
					flowParseTypeParameterInstantiationInExpression() {
						if (this.reScan_lt() !== 47) return
						return this.flowParseTypeParameterInstantiation()
					}
					flowParseTypeParameterInstantiation() {
						const node = this.startNode()
						const oldInType = this.state.inType
						this.state.inType = true
						node.params = []
						this.flowInTopLevelContext(() => {
							this.expect(47)
							const oldNoAnonFunctionType = this.state.noAnonFunctionType
							this.state.noAnonFunctionType = false
							while (!this.match(48)) {
								node.params.push(this.flowParseType())
								if (!this.match(48)) {
									this.expect(12)
								}
							}
							this.state.noAnonFunctionType = oldNoAnonFunctionType
						})
						this.state.inType = oldInType
						if (!this.state.inType && this.curContext() === types.brace) {
							this.reScan_lt_gt()
						}
						this.expect(48)
						return this.finishNode(node, 'TypeParameterInstantiation')
					}
					flowParseTypeParameterInstantiationCallOrNew() {
						if (this.reScan_lt() !== 47) return
						const node = this.startNode()
						const oldInType = this.state.inType
						node.params = []
						this.state.inType = true
						this.expect(47)
						while (!this.match(48)) {
							node.params.push(this.flowParseTypeOrImplicitInstantiation())
							if (!this.match(48)) {
								this.expect(12)
							}
						}
						this.expect(48)
						this.state.inType = oldInType
						return this.finishNode(node, 'TypeParameterInstantiation')
					}
					flowParseInterfaceType() {
						const node = this.startNode()
						this.expectContextual(129)
						node.extends = []
						if (this.eat(81)) {
							do {
								node.extends.push(this.flowParseInterfaceExtends())
							} while (this.eat(12))
						}
						node.body = this.flowParseObjectType({
							allowStatic: false,
							allowExact: false,
							allowSpread: false,
							allowProto: false,
							allowInexact: false,
						})
						return this.finishNode(node, 'InterfaceTypeAnnotation')
					}
					flowParseObjectPropertyKey() {
						return this.match(135) || this.match(134)
							? super.parseExprAtom()
							: this.parseIdentifier(true)
					}
					flowParseObjectTypeIndexer(node, isStatic, variance) {
						node.static = isStatic
						if (this.lookahead().type === 14) {
							node.id = this.flowParseObjectPropertyKey()
							node.key = this.flowParseTypeInitialiser()
						} else {
							node.id = null
							node.key = this.flowParseType()
						}
						this.expect(3)
						node.value = this.flowParseTypeInitialiser()
						node.variance = variance
						return this.finishNode(node, 'ObjectTypeIndexer')
					}
					flowParseObjectTypeInternalSlot(node, isStatic) {
						node.static = isStatic
						node.id = this.flowParseObjectPropertyKey()
						this.expect(3)
						this.expect(3)
						if (this.match(47) || this.match(10)) {
							node.method = true
							node.optional = false
							node.value = this.flowParseObjectTypeMethodish(
								this.startNodeAt(node.loc.start),
							)
						} else {
							node.method = false
							if (this.eat(17)) {
								node.optional = true
							}
							node.value = this.flowParseTypeInitialiser()
						}
						return this.finishNode(node, 'ObjectTypeInternalSlot')
					}
					flowParseObjectTypeMethodish(node) {
						node.params = []
						node.rest = null
						node.typeParameters = null
						node.this = null
						if (this.match(47)) {
							node.typeParameters = this.flowParseTypeParameterDeclaration()
						}
						this.expect(10)
						if (this.match(78)) {
							node.this = this.flowParseFunctionTypeParam(true)
							node.this.name = null
							if (!this.match(11)) {
								this.expect(12)
							}
						}
						while (!this.match(11) && !this.match(21)) {
							node.params.push(this.flowParseFunctionTypeParam(false))
							if (!this.match(11)) {
								this.expect(12)
							}
						}
						if (this.eat(21)) {
							node.rest = this.flowParseFunctionTypeParam(false)
						}
						this.expect(11)
						node.returnType = this.flowParseTypeInitialiser()
						return this.finishNode(node, 'FunctionTypeAnnotation')
					}
					flowParseObjectTypeCallProperty(node, isStatic) {
						const valueNode = this.startNode()
						node.static = isStatic
						node.value = this.flowParseObjectTypeMethodish(valueNode)
						return this.finishNode(node, 'ObjectTypeCallProperty')
					}
					flowParseObjectType({
						allowStatic,
						allowExact,
						allowSpread,
						allowProto,
						allowInexact,
					}) {
						const oldInType = this.state.inType
						this.state.inType = true
						const nodeStart = this.startNode()
						nodeStart.callProperties = []
						nodeStart.properties = []
						nodeStart.indexers = []
						nodeStart.internalSlots = []
						let endDelim
						let exact
						let inexact = false
						if (allowExact && this.match(6)) {
							this.expect(6)
							endDelim = 9
							exact = true
						} else {
							this.expect(5)
							endDelim = 8
							exact = false
						}
						nodeStart.exact = exact
						while (!this.match(endDelim)) {
							let isStatic = false
							let protoStartLoc = null
							let inexactStartLoc = null
							const node = this.startNode()
							if (allowProto && this.isContextual(118)) {
								const lookahead = this.lookahead()
								if (lookahead.type !== 14 && lookahead.type !== 17) {
									this.next()
									protoStartLoc = this.state.startLoc
									allowStatic = false
								}
							}
							if (allowStatic && this.isContextual(106)) {
								const lookahead = this.lookahead()
								if (lookahead.type !== 14 && lookahead.type !== 17) {
									this.next()
									isStatic = true
								}
							}
							const variance = this.flowParseVariance()
							if (this.eat(0)) {
								if (protoStartLoc != null) {
									this.unexpected(protoStartLoc)
								}
								if (this.eat(0)) {
									if (variance) {
										this.unexpected(variance.loc.start)
									}
									nodeStart.internalSlots.push(
										this.flowParseObjectTypeInternalSlot(node, isStatic),
									)
								} else {
									nodeStart.indexers.push(
										this.flowParseObjectTypeIndexer(node, isStatic, variance),
									)
								}
							} else if (this.match(10) || this.match(47)) {
								if (protoStartLoc != null) {
									this.unexpected(protoStartLoc)
								}
								if (variance) {
									this.unexpected(variance.loc.start)
								}
								nodeStart.callProperties.push(
									this.flowParseObjectTypeCallProperty(node, isStatic),
								)
							} else {
								let kind = 'init'
								if (this.isContextual(99) || this.isContextual(104)) {
									const lookahead = this.lookahead()
									if (tokenIsLiteralPropertyName(lookahead.type)) {
										kind = this.state.value
										this.next()
									}
								}
								const propOrInexact = this.flowParseObjectTypeProperty(
									node,
									isStatic,
									protoStartLoc,
									variance,
									kind,
									allowSpread,
									allowInexact != null ? allowInexact : !exact,
								)
								if (propOrInexact === null) {
									inexact = true
									inexactStartLoc = this.state.lastTokStartLoc
								} else {
									nodeStart.properties.push(propOrInexact)
								}
							}
							this.flowObjectTypeSemicolon()
							if (inexactStartLoc && !this.match(8) && !this.match(9)) {
								this.raise(
									FlowErrors.UnexpectedExplicitInexactInObject,
									inexactStartLoc,
								)
							}
						}
						this.expect(endDelim)
						if (allowSpread) {
							nodeStart.inexact = inexact
						}
						const out = this.finishNode(nodeStart, 'ObjectTypeAnnotation')
						this.state.inType = oldInType
						return out
					}
					flowParseObjectTypeProperty(
						node,
						isStatic,
						protoStartLoc,
						variance,
						kind,
						allowSpread,
						allowInexact,
					) {
						if (this.eat(21)) {
							const isInexactToken =
								this.match(12) ||
								this.match(13) ||
								this.match(8) ||
								this.match(9)
							if (isInexactToken) {
								if (!allowSpread) {
									this.raise(
										FlowErrors.InexactInsideNonObject,
										this.state.lastTokStartLoc,
									)
								} else if (!allowInexact) {
									this.raise(
										FlowErrors.InexactInsideExact,
										this.state.lastTokStartLoc,
									)
								}
								if (variance) {
									this.raise(FlowErrors.InexactVariance, variance)
								}
								return null
							}
							if (!allowSpread) {
								this.raise(
									FlowErrors.UnexpectedSpreadType,
									this.state.lastTokStartLoc,
								)
							}
							if (protoStartLoc != null) {
								this.unexpected(protoStartLoc)
							}
							if (variance) {
								this.raise(FlowErrors.SpreadVariance, variance)
							}
							node.argument = this.flowParseType()
							return this.finishNode(node, 'ObjectTypeSpreadProperty')
						} else {
							node.key = this.flowParseObjectPropertyKey()
							node.static = isStatic
							node.proto = protoStartLoc != null
							node.kind = kind
							let optional = false
							if (this.match(47) || this.match(10)) {
								node.method = true
								if (protoStartLoc != null) {
									this.unexpected(protoStartLoc)
								}
								if (variance) {
									this.unexpected(variance.loc.start)
								}
								node.value = this.flowParseObjectTypeMethodish(
									this.startNodeAt(node.loc.start),
								)
								if (kind === 'get' || kind === 'set') {
									this.flowCheckGetterSetterParams(node)
								}
								if (
									!allowSpread &&
									node.key.name === 'constructor' &&
									node.value.this
								) {
									this.raise(
										FlowErrors.ThisParamBannedInConstructor,
										node.value.this,
									)
								}
							} else {
								if (kind !== 'init') this.unexpected()
								node.method = false
								if (this.eat(17)) {
									optional = true
								}
								node.value = this.flowParseTypeInitialiser()
								node.variance = variance
							}
							node.optional = optional
							return this.finishNode(node, 'ObjectTypeProperty')
						}
					}
					flowCheckGetterSetterParams(property) {
						const paramCount = property.kind === 'get' ? 0 : 1
						const length =
							property.value.params.length + (property.value.rest ? 1 : 0)
						if (property.value.this) {
							this.raise(
								property.kind === 'get'
									? FlowErrors.GetterMayNotHaveThisParam
									: FlowErrors.SetterMayNotHaveThisParam,
								property.value.this,
							)
						}
						if (length !== paramCount) {
							this.raise(
								property.kind === 'get'
									? Errors.BadGetterArity
									: Errors.BadSetterArity,
								property,
							)
						}
						if (property.kind === 'set' && property.value.rest) {
							this.raise(Errors.BadSetterRestParameter, property)
						}
					}
					flowObjectTypeSemicolon() {
						if (
							!this.eat(13) &&
							!this.eat(12) &&
							!this.match(8) &&
							!this.match(9)
						) {
							this.unexpected()
						}
					}
					flowParseQualifiedTypeIdentifier(startLoc, id) {
						startLoc != null ? startLoc : (startLoc = this.state.startLoc)
						let node = id || this.flowParseRestrictedIdentifier(true)
						while (this.eat(16)) {
							const node2 = this.startNodeAt(startLoc)
							node2.qualification = node
							node2.id = this.flowParseRestrictedIdentifier(true)
							node = this.finishNode(node2, 'QualifiedTypeIdentifier')
						}
						return node
					}
					flowParseGenericType(startLoc, id) {
						const node = this.startNodeAt(startLoc)
						node.typeParameters = null
						node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id)
						if (this.match(47)) {
							node.typeParameters = this.flowParseTypeParameterInstantiation()
						}
						return this.finishNode(node, 'GenericTypeAnnotation')
					}
					flowParseTypeofType() {
						const node = this.startNode()
						this.expect(87)
						node.argument = this.flowParsePrimaryType()
						return this.finishNode(node, 'TypeofTypeAnnotation')
					}
					flowParseTupleType() {
						const node = this.startNode()
						node.types = []
						this.expect(0)
						while (this.state.pos < this.length && !this.match(3)) {
							node.types.push(this.flowParseType())
							if (this.match(3)) break
							this.expect(12)
						}
						this.expect(3)
						return this.finishNode(node, 'TupleTypeAnnotation')
					}
					flowParseFunctionTypeParam(first) {
						let name = null
						let optional = false
						let typeAnnotation = null
						const node = this.startNode()
						const lh = this.lookahead()
						const isThis = this.state.type === 78
						if (lh.type === 14 || lh.type === 17) {
							if (isThis && !first) {
								this.raise(FlowErrors.ThisParamMustBeFirst, node)
							}
							name = this.parseIdentifier(isThis)
							if (this.eat(17)) {
								optional = true
								if (isThis) {
									this.raise(FlowErrors.ThisParamMayNotBeOptional, node)
								}
							}
							typeAnnotation = this.flowParseTypeInitialiser()
						} else {
							typeAnnotation = this.flowParseType()
						}
						node.name = name
						node.optional = optional
						node.typeAnnotation = typeAnnotation
						return this.finishNode(node, 'FunctionTypeParam')
					}
					reinterpretTypeAsFunctionTypeParam(type) {
						const node = this.startNodeAt(type.loc.start)
						node.name = null
						node.optional = false
						node.typeAnnotation = type
						return this.finishNode(node, 'FunctionTypeParam')
					}
					flowParseFunctionTypeParams(params = []) {
						let rest = null
						let _this = null
						if (this.match(78)) {
							_this = this.flowParseFunctionTypeParam(true)
							_this.name = null
							if (!this.match(11)) {
								this.expect(12)
							}
						}
						while (!this.match(11) && !this.match(21)) {
							params.push(this.flowParseFunctionTypeParam(false))
							if (!this.match(11)) {
								this.expect(12)
							}
						}
						if (this.eat(21)) {
							rest = this.flowParseFunctionTypeParam(false)
						}
						return {
							params,
							rest,
							_this,
						}
					}
					flowIdentToTypeAnnotation(startLoc, node, id) {
						switch (id.name) {
							case 'any':
								return this.finishNode(node, 'AnyTypeAnnotation')
							case 'bool':
							case 'boolean':
								return this.finishNode(node, 'BooleanTypeAnnotation')
							case 'mixed':
								return this.finishNode(node, 'MixedTypeAnnotation')
							case 'empty':
								return this.finishNode(node, 'EmptyTypeAnnotation')
							case 'number':
								return this.finishNode(node, 'NumberTypeAnnotation')
							case 'string':
								return this.finishNode(node, 'StringTypeAnnotation')
							case 'symbol':
								return this.finishNode(node, 'SymbolTypeAnnotation')
							default:
								this.checkNotUnderscore(id.name)
								return this.flowParseGenericType(startLoc, id)
						}
					}
					flowParsePrimaryType() {
						const startLoc = this.state.startLoc
						const node = this.startNode()
						let tmp
						let type
						let isGroupedType = false
						const oldNoAnonFunctionType = this.state.noAnonFunctionType
						switch (this.state.type) {
							case 5:
								return this.flowParseObjectType({
									allowStatic: false,
									allowExact: false,
									allowSpread: true,
									allowProto: false,
									allowInexact: true,
								})
							case 6:
								return this.flowParseObjectType({
									allowStatic: false,
									allowExact: true,
									allowSpread: true,
									allowProto: false,
									allowInexact: false,
								})
							case 0:
								this.state.noAnonFunctionType = false
								type = this.flowParseTupleType()
								this.state.noAnonFunctionType = oldNoAnonFunctionType
								return type
							case 47: {
								const node = this.startNode()
								node.typeParameters = this.flowParseTypeParameterDeclaration()
								this.expect(10)
								tmp = this.flowParseFunctionTypeParams()
								node.params = tmp.params
								node.rest = tmp.rest
								node.this = tmp._this
								this.expect(11)
								this.expect(19)
								node.returnType = this.flowParseType()
								return this.finishNode(node, 'FunctionTypeAnnotation')
							}
							case 10: {
								const node = this.startNode()
								this.next()
								if (!this.match(11) && !this.match(21)) {
									if (tokenIsIdentifier(this.state.type) || this.match(78)) {
										const token = this.lookahead().type
										isGroupedType = token !== 17 && token !== 14
									} else {
										isGroupedType = true
									}
								}
								if (isGroupedType) {
									this.state.noAnonFunctionType = false
									type = this.flowParseType()
									this.state.noAnonFunctionType = oldNoAnonFunctionType
									if (
										this.state.noAnonFunctionType ||
										!(
											this.match(12) ||
											(this.match(11) && this.lookahead().type === 19)
										)
									) {
										this.expect(11)
										return type
									} else {
										this.eat(12)
									}
								}
								if (type) {
									tmp = this.flowParseFunctionTypeParams([
										this.reinterpretTypeAsFunctionTypeParam(type),
									])
								} else {
									tmp = this.flowParseFunctionTypeParams()
								}
								node.params = tmp.params
								node.rest = tmp.rest
								node.this = tmp._this
								this.expect(11)
								this.expect(19)
								node.returnType = this.flowParseType()
								node.typeParameters = null
								return this.finishNode(node, 'FunctionTypeAnnotation')
							}
							case 134:
								return this.parseLiteral(
									this.state.value,
									'StringLiteralTypeAnnotation',
								)
							case 85:
							case 86:
								node.value = this.match(85)
								this.next()
								return this.finishNode(node, 'BooleanLiteralTypeAnnotation')
							case 53:
								if (this.state.value === '-') {
									this.next()
									if (this.match(135)) {
										return this.parseLiteralAtNode(
											-this.state.value,
											'NumberLiteralTypeAnnotation',
											node,
										)
									}
									if (this.match(136)) {
										return this.parseLiteralAtNode(
											-this.state.value,
											'BigIntLiteralTypeAnnotation',
											node,
										)
									}
									throw this.raise(
										FlowErrors.UnexpectedSubtractionOperand,
										this.state.startLoc,
									)
								}
								this.unexpected()
								return
							case 135:
								return this.parseLiteral(
									this.state.value,
									'NumberLiteralTypeAnnotation',
								)
							case 136:
								return this.parseLiteral(
									this.state.value,
									'BigIntLiteralTypeAnnotation',
								)
							case 88:
								this.next()
								return this.finishNode(node, 'VoidTypeAnnotation')
							case 84:
								this.next()
								return this.finishNode(node, 'NullLiteralTypeAnnotation')
							case 78:
								this.next()
								return this.finishNode(node, 'ThisTypeAnnotation')
							case 55:
								this.next()
								return this.finishNode(node, 'ExistsTypeAnnotation')
							case 87:
								return this.flowParseTypeofType()
							default:
								if (tokenIsKeyword(this.state.type)) {
									const label = tokenLabelName(this.state.type)
									this.next()
									return super.createIdentifier(node, label)
								} else if (tokenIsIdentifier(this.state.type)) {
									if (this.isContextual(129)) {
										return this.flowParseInterfaceType()
									}
									return this.flowIdentToTypeAnnotation(
										startLoc,
										node,
										this.parseIdentifier(),
									)
								}
						}
						this.unexpected()
					}
					flowParsePostfixType() {
						const startLoc = this.state.startLoc
						let type = this.flowParsePrimaryType()
						let seenOptionalIndexedAccess = false
						while (
							(this.match(0) || this.match(18)) &&
							!this.canInsertSemicolon()
						) {
							const node = this.startNodeAt(startLoc)
							const optional = this.eat(18)
							seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional
							this.expect(0)
							if (!optional && this.match(3)) {
								node.elementType = type
								this.next()
								type = this.finishNode(node, 'ArrayTypeAnnotation')
							} else {
								node.objectType = type
								node.indexType = this.flowParseType()
								this.expect(3)
								if (seenOptionalIndexedAccess) {
									node.optional = optional
									type = this.finishNode(node, 'OptionalIndexedAccessType')
								} else {
									type = this.finishNode(node, 'IndexedAccessType')
								}
							}
						}
						return type
					}
					flowParsePrefixType() {
						const node = this.startNode()
						if (this.eat(17)) {
							node.typeAnnotation = this.flowParsePrefixType()
							return this.finishNode(node, 'NullableTypeAnnotation')
						} else {
							return this.flowParsePostfixType()
						}
					}
					flowParseAnonFunctionWithoutParens() {
						const param = this.flowParsePrefixType()
						if (!this.state.noAnonFunctionType && this.eat(19)) {
							const node = this.startNodeAt(param.loc.start)
							node.params = [this.reinterpretTypeAsFunctionTypeParam(param)]
							node.rest = null
							node.this = null
							node.returnType = this.flowParseType()
							node.typeParameters = null
							return this.finishNode(node, 'FunctionTypeAnnotation')
						}
						return param
					}
					flowParseIntersectionType() {
						const node = this.startNode()
						this.eat(45)
						const type = this.flowParseAnonFunctionWithoutParens()
						node.types = [type]
						while (this.eat(45)) {
							node.types.push(this.flowParseAnonFunctionWithoutParens())
						}
						return node.types.length === 1
							? type
							: this.finishNode(node, 'IntersectionTypeAnnotation')
					}
					flowParseUnionType() {
						const node = this.startNode()
						this.eat(43)
						const type = this.flowParseIntersectionType()
						node.types = [type]
						while (this.eat(43)) {
							node.types.push(this.flowParseIntersectionType())
						}
						return node.types.length === 1
							? type
							: this.finishNode(node, 'UnionTypeAnnotation')
					}
					flowParseType() {
						const oldInType = this.state.inType
						this.state.inType = true
						const type = this.flowParseUnionType()
						this.state.inType = oldInType
						return type
					}
					flowParseTypeOrImplicitInstantiation() {
						if (this.state.type === 132 && this.state.value === '_') {
							const startLoc = this.state.startLoc
							const node = this.parseIdentifier()
							return this.flowParseGenericType(startLoc, node)
						} else {
							return this.flowParseType()
						}
					}
					flowParseTypeAnnotation() {
						const node = this.startNode()
						node.typeAnnotation = this.flowParseTypeInitialiser()
						return this.finishNode(node, 'TypeAnnotation')
					}
					flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
						const ident = allowPrimitiveOverride
							? this.parseIdentifier()
							: this.flowParseRestrictedIdentifier()
						if (this.match(14)) {
							ident.typeAnnotation = this.flowParseTypeAnnotation()
							this.resetEndLocation(ident)
						}
						return ident
					}
					typeCastToParameter(node) {
						node.expression.typeAnnotation = node.typeAnnotation
						this.resetEndLocation(node.expression, node.typeAnnotation.loc.end)
						return node.expression
					}
					flowParseVariance() {
						let variance = null
						if (this.match(53)) {
							variance = this.startNode()
							if (this.state.value === '+') {
								variance.kind = 'plus'
							} else {
								variance.kind = 'minus'
							}
							this.next()
							return this.finishNode(variance, 'Variance')
						}
						return variance
					}
					parseFunctionBody(node, allowExpressionBody, isMethod = false) {
						if (allowExpressionBody) {
							this.forwardNoArrowParamsConversionAt(node, () =>
								super.parseFunctionBody(node, true, isMethod),
							)
							return
						}
						super.parseFunctionBody(node, false, isMethod)
					}
					parseFunctionBodyAndFinish(node, type, isMethod = false) {
						if (this.match(14)) {
							const typeNode = this.startNode()
							;[typeNode.typeAnnotation, node.predicate] =
								this.flowParseTypeAndPredicateInitialiser()
							node.returnType = typeNode.typeAnnotation
								? this.finishNode(typeNode, 'TypeAnnotation')
								: null
						}
						return super.parseFunctionBodyAndFinish(node, type, isMethod)
					}
					parseStatementLike(flags) {
						if (this.state.strict && this.isContextual(129)) {
							const lookahead = this.lookahead()
							if (tokenIsKeywordOrIdentifier(lookahead.type)) {
								const node = this.startNode()
								this.next()
								return this.flowParseInterface(node)
							}
						} else if (this.isContextual(126)) {
							const node = this.startNode()
							this.next()
							return this.flowParseEnumDeclaration(node)
						}
						const stmt = super.parseStatementLike(flags)
						if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {
							this.flowPragma = null
						}
						return stmt
					}
					parseExpressionStatement(node, expr, decorators) {
						if (expr.type === 'Identifier') {
							if (expr.name === 'declare') {
								if (
									this.match(80) ||
									tokenIsIdentifier(this.state.type) ||
									this.match(68) ||
									this.match(74) ||
									this.match(82)
								) {
									return this.flowParseDeclare(node)
								}
							} else if (tokenIsIdentifier(this.state.type)) {
								if (expr.name === 'interface') {
									return this.flowParseInterface(node)
								} else if (expr.name === 'type') {
									return this.flowParseTypeAlias(node)
								} else if (expr.name === 'opaque') {
									return this.flowParseOpaqueType(node, false)
								}
							}
						}
						return super.parseExpressionStatement(node, expr, decorators)
					}
					shouldParseExportDeclaration() {
						const { type } = this.state
						if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {
							return !this.state.containsEsc
						}
						return super.shouldParseExportDeclaration()
					}
					isExportDefaultSpecifier() {
						const { type } = this.state
						if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {
							return this.state.containsEsc
						}
						return super.isExportDefaultSpecifier()
					}
					parseExportDefaultExpression() {
						if (this.isContextual(126)) {
							const node = this.startNode()
							this.next()
							return this.flowParseEnumDeclaration(node)
						}
						return super.parseExportDefaultExpression()
					}
					parseConditional(expr, startLoc, refExpressionErrors) {
						if (!this.match(17)) return expr
						if (this.state.maybeInArrowParameters) {
							const nextCh = this.lookaheadCharCode()
							if (
								nextCh === 44 ||
								nextCh === 61 ||
								nextCh === 58 ||
								nextCh === 41
							) {
								this.setOptionalParametersError(refExpressionErrors)
								return expr
							}
						}
						this.expect(17)
						const state = this.state.clone()
						const originalNoArrowAt = this.state.noArrowAt
						const node = this.startNodeAt(startLoc)
						let { consequent, failed } = this.tryParseConditionalConsequent()
						let [valid, invalid] = this.getArrowLikeExpressions(consequent)
						if (failed || invalid.length > 0) {
							const noArrowAt = [...originalNoArrowAt]
							if (invalid.length > 0) {
								this.state = state
								this.state.noArrowAt = noArrowAt
								for (let i = 0; i < invalid.length; i++) {
									noArrowAt.push(invalid[i].start)
								}
								;({ consequent, failed } = this.tryParseConditionalConsequent())
								;[valid, invalid] = this.getArrowLikeExpressions(consequent)
							}
							if (failed && valid.length > 1) {
								this.raise(FlowErrors.AmbiguousConditionalArrow, state.startLoc)
							}
							if (failed && valid.length === 1) {
								this.state = state
								noArrowAt.push(valid[0].start)
								this.state.noArrowAt = noArrowAt
								;({ consequent, failed } = this.tryParseConditionalConsequent())
							}
						}
						this.getArrowLikeExpressions(consequent, true)
						this.state.noArrowAt = originalNoArrowAt
						this.expect(14)
						node.test = expr
						node.consequent = consequent
						node.alternate = this.forwardNoArrowParamsConversionAt(node, () =>
							this.parseMaybeAssign(undefined, undefined),
						)
						return this.finishNode(node, 'ConditionalExpression')
					}
					tryParseConditionalConsequent() {
						this.state.noArrowParamsConversionAt.push(this.state.start)
						const consequent = this.parseMaybeAssignAllowIn()
						const failed = !this.match(14)
						this.state.noArrowParamsConversionAt.pop()
						return {
							consequent,
							failed,
						}
					}
					getArrowLikeExpressions(node, disallowInvalid) {
						const stack = [node]
						const arrows = []
						while (stack.length !== 0) {
							const node = stack.pop()
							if (
								node.type === 'ArrowFunctionExpression' &&
								node.body.type !== 'BlockStatement'
							) {
								if (node.typeParameters || !node.returnType) {
									this.finishArrowValidation(node)
								} else {
									arrows.push(node)
								}
								stack.push(node.body)
							} else if (node.type === 'ConditionalExpression') {
								stack.push(node.consequent)
								stack.push(node.alternate)
							}
						}
						if (disallowInvalid) {
							arrows.forEach((node) => this.finishArrowValidation(node))
							return [arrows, []]
						}
						return partition(arrows, (node) =>
							node.params.every((param) => this.isAssignable(param, true)),
						)
					}
					finishArrowValidation(node) {
						var _node$extra
						this.toAssignableList(
							node.params,
							(_node$extra = node.extra) == null
								? void 0
								: _node$extra.trailingCommaLoc,
							false,
						)
						this.scope.enter(2 | 4)
						super.checkParams(node, false, true)
						this.scope.exit()
					}
					forwardNoArrowParamsConversionAt(node, parse) {
						let result
						if (
							this.state.noArrowParamsConversionAt.includes(
								this.offsetToSourcePos(node.start),
							)
						) {
							this.state.noArrowParamsConversionAt.push(this.state.start)
							result = parse()
							this.state.noArrowParamsConversionAt.pop()
						} else {
							result = parse()
						}
						return result
					}
					parseParenItem(node, startLoc) {
						const newNode = super.parseParenItem(node, startLoc)
						if (this.eat(17)) {
							newNode.optional = true
							this.resetEndLocation(node)
						}
						if (this.match(14)) {
							const typeCastNode = this.startNodeAt(startLoc)
							typeCastNode.expression = newNode
							typeCastNode.typeAnnotation = this.flowParseTypeAnnotation()
							return this.finishNode(typeCastNode, 'TypeCastExpression')
						}
						return newNode
					}
					assertModuleNodeAllowed(node) {
						if (
							(node.type === 'ImportDeclaration' &&
								(node.importKind === 'type' || node.importKind === 'typeof')) ||
							(node.type === 'ExportNamedDeclaration' &&
								node.exportKind === 'type') ||
							(node.type === 'ExportAllDeclaration' &&
								node.exportKind === 'type')
						) {
							return
						}
						super.assertModuleNodeAllowed(node)
					}
					parseExportDeclaration(node) {
						if (this.isContextual(130)) {
							node.exportKind = 'type'
							const declarationNode = this.startNode()
							this.next()
							if (this.match(5)) {
								node.specifiers = this.parseExportSpecifiers(true)
								super.parseExportFrom(node)
								return null
							} else {
								return this.flowParseTypeAlias(declarationNode)
							}
						} else if (this.isContextual(131)) {
							node.exportKind = 'type'
							const declarationNode = this.startNode()
							this.next()
							return this.flowParseOpaqueType(declarationNode, false)
						} else if (this.isContextual(129)) {
							node.exportKind = 'type'
							const declarationNode = this.startNode()
							this.next()
							return this.flowParseInterface(declarationNode)
						} else if (this.isContextual(126)) {
							node.exportKind = 'value'
							const declarationNode = this.startNode()
							this.next()
							return this.flowParseEnumDeclaration(declarationNode)
						} else {
							return super.parseExportDeclaration(node)
						}
					}
					eatExportStar(node) {
						if (super.eatExportStar(node)) return true
						if (this.isContextual(130) && this.lookahead().type === 55) {
							node.exportKind = 'type'
							this.next()
							this.next()
							return true
						}
						return false
					}
					maybeParseExportNamespaceSpecifier(node) {
						const { startLoc } = this.state
						const hasNamespace = super.maybeParseExportNamespaceSpecifier(node)
						if (hasNamespace && node.exportKind === 'type') {
							this.unexpected(startLoc)
						}
						return hasNamespace
					}
					parseClassId(node, isStatement, optionalId) {
						super.parseClassId(node, isStatement, optionalId)
						if (this.match(47)) {
							node.typeParameters = this.flowParseTypeParameterDeclaration()
						}
					}
					parseClassMember(classBody, member, state) {
						const { startLoc } = this.state
						if (this.isContextual(125)) {
							if (super.parseClassMemberFromModifier(classBody, member)) {
								return
							}
							member.declare = true
						}
						super.parseClassMember(classBody, member, state)
						if (member.declare) {
							if (
								member.type !== 'ClassProperty' &&
								member.type !== 'ClassPrivateProperty' &&
								member.type !== 'PropertyDefinition'
							) {
								this.raise(FlowErrors.DeclareClassElement, startLoc)
							} else if (member.value) {
								this.raise(
									FlowErrors.DeclareClassFieldInitializer,
									member.value,
								)
							}
						}
					}
					isIterator(word) {
						return word === 'iterator' || word === 'asyncIterator'
					}
					readIterator() {
						const word = super.readWord1()
						const fullWord = '@@' + word
						if (!this.isIterator(word) || !this.state.inType) {
							this.raise(Errors.InvalidIdentifier, this.state.curPosition(), {
								identifierName: fullWord,
							})
						}
						this.finishToken(132, fullWord)
					}
					getTokenFromCode(code) {
						const next = this.input.charCodeAt(this.state.pos + 1)
						if (code === 123 && next === 124) {
							this.finishOp(6, 2)
						} else if (this.state.inType && (code === 62 || code === 60)) {
							this.finishOp(code === 62 ? 48 : 47, 1)
						} else if (this.state.inType && code === 63) {
							if (next === 46) {
								this.finishOp(18, 2)
							} else {
								this.finishOp(17, 1)
							}
						} else if (
							isIteratorStart(
								code,
								next,
								this.input.charCodeAt(this.state.pos + 2),
							)
						) {
							this.state.pos += 2
							this.readIterator()
						} else {
							super.getTokenFromCode(code)
						}
					}
					isAssignable(node, isBinding) {
						if (node.type === 'TypeCastExpression') {
							return this.isAssignable(node.expression, isBinding)
						} else {
							return super.isAssignable(node, isBinding)
						}
					}
					toAssignable(node, isLHS = false) {
						if (
							!isLHS &&
							node.type === 'AssignmentExpression' &&
							node.left.type === 'TypeCastExpression'
						) {
							node.left = this.typeCastToParameter(node.left)
						}
						super.toAssignable(node, isLHS)
					}
					toAssignableList(exprList, trailingCommaLoc, isLHS) {
						for (let i = 0; i < exprList.length; i++) {
							const expr = exprList[i]
							if (
								(expr == null ? void 0 : expr.type) === 'TypeCastExpression'
							) {
								exprList[i] = this.typeCastToParameter(expr)
							}
						}
						super.toAssignableList(exprList, trailingCommaLoc, isLHS)
					}
					toReferencedList(exprList, isParenthesizedExpr) {
						for (let i = 0; i < exprList.length; i++) {
							var _expr$extra
							const expr = exprList[i]
							if (
								expr &&
								expr.type === 'TypeCastExpression' &&
								!(
									(_expr$extra = expr.extra) != null &&
									_expr$extra.parenthesized
								) &&
								(exprList.length > 1 || !isParenthesizedExpr)
							) {
								this.raise(FlowErrors.TypeCastInPattern, expr.typeAnnotation)
							}
						}
						return exprList
					}
					parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
						const node = super.parseArrayLike(
							close,
							canBePattern,
							isTuple,
							refExpressionErrors,
						)
						if (canBePattern && !this.state.maybeInArrowParameters) {
							this.toReferencedList(node.elements)
						}
						return node
					}
					isValidLVal(type, isParenthesized, binding) {
						return (
							type === 'TypeCastExpression' ||
							super.isValidLVal(type, isParenthesized, binding)
						)
					}
					parseClassProperty(node) {
						if (this.match(14)) {
							node.typeAnnotation = this.flowParseTypeAnnotation()
						}
						return super.parseClassProperty(node)
					}
					parseClassPrivateProperty(node) {
						if (this.match(14)) {
							node.typeAnnotation = this.flowParseTypeAnnotation()
						}
						return super.parseClassPrivateProperty(node)
					}
					isClassMethod() {
						return this.match(47) || super.isClassMethod()
					}
					isClassProperty() {
						return this.match(14) || super.isClassProperty()
					}
					isNonstaticConstructor(method) {
						return !this.match(14) && super.isNonstaticConstructor(method)
					}
					pushClassMethod(
						classBody,
						method,
						isGenerator,
						isAsync,
						isConstructor,
						allowsDirectSuper,
					) {
						if (method.variance) {
							this.unexpected(method.variance.loc.start)
						}
						delete method.variance
						if (this.match(47)) {
							method.typeParameters = this.flowParseTypeParameterDeclaration()
						}
						super.pushClassMethod(
							classBody,
							method,
							isGenerator,
							isAsync,
							isConstructor,
							allowsDirectSuper,
						)
						if (method.params && isConstructor) {
							const params = method.params
							if (params.length > 0 && this.isThisParam(params[0])) {
								this.raise(FlowErrors.ThisParamBannedInConstructor, method)
							}
						} else if (
							method.type === 'MethodDefinition' &&
							isConstructor &&
							method.value.params
						) {
							const params = method.value.params
							if (params.length > 0 && this.isThisParam(params[0])) {
								this.raise(FlowErrors.ThisParamBannedInConstructor, method)
							}
						}
					}
					pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
						if (method.variance) {
							this.unexpected(method.variance.loc.start)
						}
						delete method.variance
						if (this.match(47)) {
							method.typeParameters = this.flowParseTypeParameterDeclaration()
						}
						super.pushClassPrivateMethod(
							classBody,
							method,
							isGenerator,
							isAsync,
						)
					}
					parseClassSuper(node) {
						super.parseClassSuper(node)
						if (node.superClass && (this.match(47) || this.match(51))) {
							{
								node.superTypeParameters =
									this.flowParseTypeParameterInstantiationInExpression()
							}
						}
						if (this.isContextual(113)) {
							this.next()
							const implemented = (node.implements = [])
							do {
								const node = this.startNode()
								node.id = this.flowParseRestrictedIdentifier(true)
								if (this.match(47)) {
									node.typeParameters =
										this.flowParseTypeParameterInstantiation()
								} else {
									node.typeParameters = null
								}
								implemented.push(this.finishNode(node, 'ClassImplements'))
							} while (this.eat(12))
						}
					}
					checkGetterSetterParams(method) {
						super.checkGetterSetterParams(method)
						const params = this.getObjectOrClassMethodParams(method)
						if (params.length > 0) {
							const param = params[0]
							if (this.isThisParam(param) && method.kind === 'get') {
								this.raise(FlowErrors.GetterMayNotHaveThisParam, param)
							} else if (this.isThisParam(param)) {
								this.raise(FlowErrors.SetterMayNotHaveThisParam, param)
							}
						}
					}
					parsePropertyNamePrefixOperator(node) {
						node.variance = this.flowParseVariance()
					}
					parseObjPropValue(
						prop,
						startLoc,
						isGenerator,
						isAsync,
						isPattern,
						isAccessor,
						refExpressionErrors,
					) {
						if (prop.variance) {
							this.unexpected(prop.variance.loc.start)
						}
						delete prop.variance
						let typeParameters
						if (this.match(47) && !isAccessor) {
							typeParameters = this.flowParseTypeParameterDeclaration()
							if (!this.match(10)) this.unexpected()
						}
						const result = super.parseObjPropValue(
							prop,
							startLoc,
							isGenerator,
							isAsync,
							isPattern,
							isAccessor,
							refExpressionErrors,
						)
						if (typeParameters) {
							;(result.value || result).typeParameters = typeParameters
						}
						return result
					}
					parseFunctionParamType(param) {
						if (this.eat(17)) {
							if (param.type !== 'Identifier') {
								this.raise(FlowErrors.PatternIsOptional, param)
							}
							if (this.isThisParam(param)) {
								this.raise(FlowErrors.ThisParamMayNotBeOptional, param)
							}
							param.optional = true
						}
						if (this.match(14)) {
							param.typeAnnotation = this.flowParseTypeAnnotation()
						} else if (this.isThisParam(param)) {
							this.raise(FlowErrors.ThisParamAnnotationRequired, param)
						}
						if (this.match(29) && this.isThisParam(param)) {
							this.raise(FlowErrors.ThisParamNoDefault, param)
						}
						this.resetEndLocation(param)
						return param
					}
					parseMaybeDefault(startLoc, left) {
						const node = super.parseMaybeDefault(startLoc, left)
						if (
							node.type === 'AssignmentPattern' &&
							node.typeAnnotation &&
							node.right.start < node.typeAnnotation.start
						) {
							this.raise(FlowErrors.TypeBeforeInitializer, node.typeAnnotation)
						}
						return node
					}
					checkImportReflection(node) {
						super.checkImportReflection(node)
						if (node.module && node.importKind !== 'value') {
							this.raise(
								FlowErrors.ImportReflectionHasImportType,
								node.specifiers[0].loc.start,
							)
						}
					}
					parseImportSpecifierLocal(node, specifier, type) {
						specifier.local = hasTypeImportKind(node)
							? this.flowParseRestrictedIdentifier(true, true)
							: this.parseIdentifier()
						node.specifiers.push(this.finishImportSpecifier(specifier, type))
					}
					isPotentialImportPhase(isExport) {
						if (super.isPotentialImportPhase(isExport)) return true
						if (this.isContextual(130)) {
							if (!isExport) return true
							const ch = this.lookaheadCharCode()
							return ch === 123 || ch === 42
						}
						return !isExport && this.isContextual(87)
					}
					applyImportPhase(node, isExport, phase, loc) {
						super.applyImportPhase(node, isExport, phase, loc)
						if (isExport) {
							if (!phase && this.match(65)) {
								return
							}
							node.exportKind = phase === 'type' ? phase : 'value'
						} else {
							if (phase === 'type' && this.match(55)) this.unexpected()
							node.importKind =
								phase === 'type' || phase === 'typeof' ? phase : 'value'
						}
					}
					parseImportSpecifier(
						specifier,
						importedIsString,
						isInTypeOnlyImport,
						isMaybeTypeOnly,
						bindingType,
					) {
						const firstIdent = specifier.imported
						let specifierTypeKind = null
						if (firstIdent.type === 'Identifier') {
							if (firstIdent.name === 'type') {
								specifierTypeKind = 'type'
							} else if (firstIdent.name === 'typeof') {
								specifierTypeKind = 'typeof'
							}
						}
						let isBinding = false
						if (this.isContextual(93) && !this.isLookaheadContextual('as')) {
							const as_ident = this.parseIdentifier(true)
							if (
								specifierTypeKind !== null &&
								!tokenIsKeywordOrIdentifier(this.state.type)
							) {
								specifier.imported = as_ident
								specifier.importKind = specifierTypeKind
								specifier.local = this.cloneIdentifier(as_ident)
							} else {
								specifier.imported = firstIdent
								specifier.importKind = null
								specifier.local = this.parseIdentifier()
							}
						} else {
							if (
								specifierTypeKind !== null &&
								tokenIsKeywordOrIdentifier(this.state.type)
							) {
								specifier.imported = this.parseIdentifier(true)
								specifier.importKind = specifierTypeKind
							} else {
								if (importedIsString) {
									throw this.raise(Errors.ImportBindingIsString, specifier, {
										importName: firstIdent.value,
									})
								}
								specifier.imported = firstIdent
								specifier.importKind = null
							}
							if (this.eatContextual(93)) {
								specifier.local = this.parseIdentifier()
							} else {
								isBinding = true
								specifier.local = this.cloneIdentifier(specifier.imported)
							}
						}
						const specifierIsTypeImport = hasTypeImportKind(specifier)
						if (isInTypeOnlyImport && specifierIsTypeImport) {
							this.raise(
								FlowErrors.ImportTypeShorthandOnlyInPureImport,
								specifier,
							)
						}
						if (isInTypeOnlyImport || specifierIsTypeImport) {
							this.checkReservedType(
								specifier.local.name,
								specifier.local.loc.start,
								true,
							)
						}
						if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {
							this.checkReservedWord(
								specifier.local.name,
								specifier.loc.start,
								true,
								true,
							)
						}
						return this.finishImportSpecifier(specifier, 'ImportSpecifier')
					}
					parseBindingAtom() {
						switch (this.state.type) {
							case 78:
								return this.parseIdentifier(true)
							default:
								return super.parseBindingAtom()
						}
					}
					parseFunctionParams(node, isConstructor) {
						const kind = node.kind
						if (kind !== 'get' && kind !== 'set' && this.match(47)) {
							node.typeParameters = this.flowParseTypeParameterDeclaration()
						}
						super.parseFunctionParams(node, isConstructor)
					}
					parseVarId(decl, kind) {
						super.parseVarId(decl, kind)
						if (this.match(14)) {
							decl.id.typeAnnotation = this.flowParseTypeAnnotation()
							this.resetEndLocation(decl.id)
						}
					}
					parseAsyncArrowFromCallExpression(node, call) {
						if (this.match(14)) {
							const oldNoAnonFunctionType = this.state.noAnonFunctionType
							this.state.noAnonFunctionType = true
							node.returnType = this.flowParseTypeAnnotation()
							this.state.noAnonFunctionType = oldNoAnonFunctionType
						}
						return super.parseAsyncArrowFromCallExpression(node, call)
					}
					shouldParseAsyncArrow() {
						return this.match(14) || super.shouldParseAsyncArrow()
					}
					parseMaybeAssign(refExpressionErrors, afterLeftParse) {
						var _jsx
						let state = null
						let jsx
						if (this.hasPlugin('jsx') && (this.match(143) || this.match(47))) {
							state = this.state.clone()
							jsx = this.tryParse(
								() =>
									super.parseMaybeAssign(refExpressionErrors, afterLeftParse),
								state,
							)
							if (!jsx.error) return jsx.node
							const { context } = this.state
							const currentContext = context[context.length - 1]
							if (
								currentContext === types.j_oTag ||
								currentContext === types.j_expr
							) {
								context.pop()
							}
						}
						if (((_jsx = jsx) != null && _jsx.error) || this.match(47)) {
							var _jsx2, _jsx3
							state = state || this.state.clone()
							let typeParameters
							const arrow = this.tryParse((abort) => {
								var _arrowExpression$extr
								typeParameters = this.flowParseTypeParameterDeclaration()
								const arrowExpression = this.forwardNoArrowParamsConversionAt(
									typeParameters,
									() => {
										const result = super.parseMaybeAssign(
											refExpressionErrors,
											afterLeftParse,
										)
										this.resetStartLocationFromNode(result, typeParameters)
										return result
									},
								)
								if (
									(_arrowExpression$extr = arrowExpression.extra) != null &&
									_arrowExpression$extr.parenthesized
								)
									abort()
								const expr = this.maybeUnwrapTypeCastExpression(arrowExpression)
								if (expr.type !== 'ArrowFunctionExpression') abort()
								expr.typeParameters = typeParameters
								this.resetStartLocationFromNode(expr, typeParameters)
								return arrowExpression
							}, state)
							let arrowExpression = null
							if (
								arrow.node &&
								this.maybeUnwrapTypeCastExpression(arrow.node).type ===
									'ArrowFunctionExpression'
							) {
								if (!arrow.error && !arrow.aborted) {
									if (arrow.node.async) {
										this.raise(
											FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction,
											typeParameters,
										)
									}
									return arrow.node
								}
								arrowExpression = arrow.node
							}
							if ((_jsx2 = jsx) != null && _jsx2.node) {
								this.state = jsx.failState
								return jsx.node
							}
							if (arrowExpression) {
								this.state = arrow.failState
								return arrowExpression
							}
							if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error
							if (arrow.thrown) throw arrow.error
							throw this.raise(
								FlowErrors.UnexpectedTokenAfterTypeParameter,
								typeParameters,
							)
						}
						return super.parseMaybeAssign(refExpressionErrors, afterLeftParse)
					}
					parseArrow(node) {
						if (this.match(14)) {
							const result = this.tryParse(() => {
								const oldNoAnonFunctionType = this.state.noAnonFunctionType
								this.state.noAnonFunctionType = true
								const typeNode = this.startNode()
								;[typeNode.typeAnnotation, node.predicate] =
									this.flowParseTypeAndPredicateInitialiser()
								this.state.noAnonFunctionType = oldNoAnonFunctionType
								if (this.canInsertSemicolon()) this.unexpected()
								if (!this.match(19)) this.unexpected()
								return typeNode
							})
							if (result.thrown) return null
							if (result.error) this.state = result.failState
							node.returnType = result.node.typeAnnotation
								? this.finishNode(result.node, 'TypeAnnotation')
								: null
						}
						return super.parseArrow(node)
					}
					shouldParseArrow(params) {
						return this.match(14) || super.shouldParseArrow(params)
					}
					setArrowFunctionParameters(node, params) {
						if (
							this.state.noArrowParamsConversionAt.includes(
								this.offsetToSourcePos(node.start),
							)
						) {
							node.params = params
						} else {
							super.setArrowFunctionParameters(node, params)
						}
					}
					checkParams(
						node,
						allowDuplicates,
						isArrowFunction,
						strictModeChanged = true,
					) {
						if (
							isArrowFunction &&
							this.state.noArrowParamsConversionAt.includes(
								this.offsetToSourcePos(node.start),
							)
						) {
							return
						}
						for (let i = 0; i < node.params.length; i++) {
							if (this.isThisParam(node.params[i]) && i > 0) {
								this.raise(FlowErrors.ThisParamMustBeFirst, node.params[i])
							}
						}
						super.checkParams(
							node,
							allowDuplicates,
							isArrowFunction,
							strictModeChanged,
						)
					}
					parseParenAndDistinguishExpression(canBeArrow) {
						return super.parseParenAndDistinguishExpression(
							canBeArrow &&
								!this.state.noArrowAt.includes(
									this.sourceToOffsetPos(this.state.start),
								),
						)
					}
					parseSubscripts(base, startLoc, noCalls) {
						if (
							base.type === 'Identifier' &&
							base.name === 'async' &&
							this.state.noArrowAt.includes(startLoc.index)
						) {
							this.next()
							const node = this.startNodeAt(startLoc)
							node.callee = base
							node.arguments = super.parseCallExpressionArguments(11)
							base = this.finishNode(node, 'CallExpression')
						} else if (
							base.type === 'Identifier' &&
							base.name === 'async' &&
							this.match(47)
						) {
							const state = this.state.clone()
							const arrow = this.tryParse(
								(abort) =>
									this.parseAsyncArrowWithTypeParameters(startLoc) || abort(),
								state,
							)
							if (!arrow.error && !arrow.aborted) return arrow.node
							const result = this.tryParse(
								() => super.parseSubscripts(base, startLoc, noCalls),
								state,
							)
							if (result.node && !result.error) return result.node
							if (arrow.node) {
								this.state = arrow.failState
								return arrow.node
							}
							if (result.node) {
								this.state = result.failState
								return result.node
							}
							throw arrow.error || result.error
						}
						return super.parseSubscripts(base, startLoc, noCalls)
					}
					parseSubscript(base, startLoc, noCalls, subscriptState) {
						if (this.match(18) && this.isLookaheadToken_lt()) {
							subscriptState.optionalChainMember = true
							if (noCalls) {
								subscriptState.stop = true
								return base
							}
							this.next()
							const node = this.startNodeAt(startLoc)
							node.callee = base
							node.typeArguments =
								this.flowParseTypeParameterInstantiationInExpression()
							this.expect(10)
							node.arguments = this.parseCallExpressionArguments(11)
							node.optional = true
							return this.finishCallExpression(node, true)
						} else if (
							!noCalls &&
							this.shouldParseTypes() &&
							(this.match(47) || this.match(51))
						) {
							const node = this.startNodeAt(startLoc)
							node.callee = base
							const result = this.tryParse(() => {
								node.typeArguments =
									this.flowParseTypeParameterInstantiationCallOrNew()
								this.expect(10)
								node.arguments = super.parseCallExpressionArguments(11)
								if (subscriptState.optionalChainMember) {
									node.optional = false
								}
								return this.finishCallExpression(
									node,
									subscriptState.optionalChainMember,
								)
							})
							if (result.node) {
								if (result.error) this.state = result.failState
								return result.node
							}
						}
						return super.parseSubscript(base, startLoc, noCalls, subscriptState)
					}
					parseNewCallee(node) {
						super.parseNewCallee(node)
						let targs = null
						if (this.shouldParseTypes() && this.match(47)) {
							targs = this.tryParse(() =>
								this.flowParseTypeParameterInstantiationCallOrNew(),
							).node
						}
						node.typeArguments = targs
					}
					parseAsyncArrowWithTypeParameters(startLoc) {
						const node = this.startNodeAt(startLoc)
						this.parseFunctionParams(node, false)
						if (!this.parseArrow(node)) return
						return super.parseArrowExpression(node, undefined, true)
					}
					readToken_mult_modulo(code) {
						const next = this.input.charCodeAt(this.state.pos + 1)
						if (code === 42 && next === 47 && this.state.hasFlowComment) {
							this.state.hasFlowComment = false
							this.state.pos += 2
							this.nextToken()
							return
						}
						super.readToken_mult_modulo(code)
					}
					readToken_pipe_amp(code) {
						const next = this.input.charCodeAt(this.state.pos + 1)
						if (code === 124 && next === 125) {
							this.finishOp(9, 2)
							return
						}
						super.readToken_pipe_amp(code)
					}
					parseTopLevel(file, program) {
						const fileNode = super.parseTopLevel(file, program)
						if (this.state.hasFlowComment) {
							this.raise(
								FlowErrors.UnterminatedFlowComment,
								this.state.curPosition(),
							)
						}
						return fileNode
					}
					skipBlockComment() {
						if (this.hasPlugin('flowComments') && this.skipFlowComment()) {
							if (this.state.hasFlowComment) {
								throw this.raise(
									FlowErrors.NestedFlowComment,
									this.state.startLoc,
								)
							}
							this.hasFlowCommentCompletion()
							const commentSkip = this.skipFlowComment()
							if (commentSkip) {
								this.state.pos += commentSkip
								this.state.hasFlowComment = true
							}
							return
						}
						return super.skipBlockComment(
							this.state.hasFlowComment ? '*-/' : '*/',
						)
					}
					skipFlowComment() {
						const { pos } = this.state
						let shiftToFirstNonWhiteSpace = 2
						while (
							[32, 9].includes(
								this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace),
							)
						) {
							shiftToFirstNonWhiteSpace++
						}
						const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos)
						const ch3 = this.input.charCodeAt(
							shiftToFirstNonWhiteSpace + pos + 1,
						)
						if (ch2 === 58 && ch3 === 58) {
							return shiftToFirstNonWhiteSpace + 2
						}
						if (
							this.input.slice(
								shiftToFirstNonWhiteSpace + pos,
								shiftToFirstNonWhiteSpace + pos + 12,
							) === 'flow-include'
						) {
							return shiftToFirstNonWhiteSpace + 12
						}
						if (ch2 === 58 && ch3 !== 58) {
							return shiftToFirstNonWhiteSpace
						}
						return false
					}
					hasFlowCommentCompletion() {
						const end = this.input.indexOf('*/', this.state.pos)
						if (end === -1) {
							throw this.raise(
								Errors.UnterminatedComment,
								this.state.curPosition(),
							)
						}
					}
					flowEnumErrorBooleanMemberNotInitialized(
						loc,
						{ enumName, memberName },
					) {
						this.raise(FlowErrors.EnumBooleanMemberNotInitialized, loc, {
							memberName,
							enumName,
						})
					}
					flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
						return this.raise(
							!enumContext.explicitType
								? FlowErrors.EnumInvalidMemberInitializerUnknownType
								: enumContext.explicitType === 'symbol'
									? FlowErrors.EnumInvalidMemberInitializerSymbolType
									: FlowErrors.EnumInvalidMemberInitializerPrimaryType,
							loc,
							enumContext,
						)
					}
					flowEnumErrorNumberMemberNotInitialized(loc, details) {
						this.raise(FlowErrors.EnumNumberMemberNotInitialized, loc, details)
					}
					flowEnumErrorStringMemberInconsistentlyInitialized(node, details) {
						this.raise(
							FlowErrors.EnumStringMemberInconsistentlyInitialized,
							node,
							details,
						)
					}
					flowEnumMemberInit() {
						const startLoc = this.state.startLoc
						const endOfInit = () => this.match(12) || this.match(8)
						switch (this.state.type) {
							case 135: {
								const literal = this.parseNumericLiteral(this.state.value)
								if (endOfInit()) {
									return {
										type: 'number',
										loc: literal.loc.start,
										value: literal,
									}
								}
								return {
									type: 'invalid',
									loc: startLoc,
								}
							}
							case 134: {
								const literal = this.parseStringLiteral(this.state.value)
								if (endOfInit()) {
									return {
										type: 'string',
										loc: literal.loc.start,
										value: literal,
									}
								}
								return {
									type: 'invalid',
									loc: startLoc,
								}
							}
							case 85:
							case 86: {
								const literal = this.parseBooleanLiteral(this.match(85))
								if (endOfInit()) {
									return {
										type: 'boolean',
										loc: literal.loc.start,
										value: literal,
									}
								}
								return {
									type: 'invalid',
									loc: startLoc,
								}
							}
							default:
								return {
									type: 'invalid',
									loc: startLoc,
								}
						}
					}
					flowEnumMemberRaw() {
						const loc = this.state.startLoc
						const id = this.parseIdentifier(true)
						const init = this.eat(29)
							? this.flowEnumMemberInit()
							: {
									type: 'none',
									loc,
								}
						return {
							id,
							init,
						}
					}
					flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
						const { explicitType } = context
						if (explicitType === null) {
							return
						}
						if (explicitType !== expectedType) {
							this.flowEnumErrorInvalidMemberInitializer(loc, context)
						}
					}
					flowEnumMembers({ enumName, explicitType }) {
						const seenNames = new Set()
						const members = {
							booleanMembers: [],
							numberMembers: [],
							stringMembers: [],
							defaultedMembers: [],
						}
						let hasUnknownMembers = false
						while (!this.match(8)) {
							if (this.eat(21)) {
								hasUnknownMembers = true
								break
							}
							const memberNode = this.startNode()
							const { id, init } = this.flowEnumMemberRaw()
							const memberName = id.name
							if (memberName === '') {
								continue
							}
							if (/^[a-z]/.test(memberName)) {
								this.raise(FlowErrors.EnumInvalidMemberName, id, {
									memberName,
									suggestion: memberName[0].toUpperCase() + memberName.slice(1),
									enumName,
								})
							}
							if (seenNames.has(memberName)) {
								this.raise(FlowErrors.EnumDuplicateMemberName, id, {
									memberName,
									enumName,
								})
							}
							seenNames.add(memberName)
							const context = {
								enumName,
								explicitType,
								memberName,
							}
							memberNode.id = id
							switch (init.type) {
								case 'boolean': {
									this.flowEnumCheckExplicitTypeMismatch(
										init.loc,
										context,
										'boolean',
									)
									memberNode.init = init.value
									members.booleanMembers.push(
										this.finishNode(memberNode, 'EnumBooleanMember'),
									)
									break
								}
								case 'number': {
									this.flowEnumCheckExplicitTypeMismatch(
										init.loc,
										context,
										'number',
									)
									memberNode.init = init.value
									members.numberMembers.push(
										this.finishNode(memberNode, 'EnumNumberMember'),
									)
									break
								}
								case 'string': {
									this.flowEnumCheckExplicitTypeMismatch(
										init.loc,
										context,
										'string',
									)
									memberNode.init = init.value
									members.stringMembers.push(
										this.finishNode(memberNode, 'EnumStringMember'),
									)
									break
								}
								case 'invalid': {
									throw this.flowEnumErrorInvalidMemberInitializer(
										init.loc,
										context,
									)
								}
								case 'none': {
									switch (explicitType) {
										case 'boolean':
											this.flowEnumErrorBooleanMemberNotInitialized(
												init.loc,
												context,
											)
											break
										case 'number':
											this.flowEnumErrorNumberMemberNotInitialized(
												init.loc,
												context,
											)
											break
										default:
											members.defaultedMembers.push(
												this.finishNode(memberNode, 'EnumDefaultedMember'),
											)
									}
								}
							}
							if (!this.match(8)) {
								this.expect(12)
							}
						}
						return {
							members,
							hasUnknownMembers,
						}
					}
					flowEnumStringMembers(
						initializedMembers,
						defaultedMembers,
						{ enumName },
					) {
						if (initializedMembers.length === 0) {
							return defaultedMembers
						} else if (defaultedMembers.length === 0) {
							return initializedMembers
						} else if (defaultedMembers.length > initializedMembers.length) {
							for (const member of initializedMembers) {
								this.flowEnumErrorStringMemberInconsistentlyInitialized(
									member,
									{
										enumName,
									},
								)
							}
							return defaultedMembers
						} else {
							for (const member of defaultedMembers) {
								this.flowEnumErrorStringMemberInconsistentlyInitialized(
									member,
									{
										enumName,
									},
								)
							}
							return initializedMembers
						}
					}
					flowEnumParseExplicitType({ enumName }) {
						if (!this.eatContextual(102)) return null
						if (!tokenIsIdentifier(this.state.type)) {
							throw this.raise(
								FlowErrors.EnumInvalidExplicitTypeUnknownSupplied,
								this.state.startLoc,
								{
									enumName,
								},
							)
						}
						const { value } = this.state
						this.next()
						if (
							value !== 'boolean' &&
							value !== 'number' &&
							value !== 'string' &&
							value !== 'symbol'
						) {
							this.raise(
								FlowErrors.EnumInvalidExplicitType,
								this.state.startLoc,
								{
									enumName,
									invalidEnumType: value,
								},
							)
						}
						return value
					}
					flowEnumBody(node, id) {
						const enumName = id.name
						const nameLoc = id.loc.start
						const explicitType = this.flowEnumParseExplicitType({
							enumName,
						})
						this.expect(5)
						const { members, hasUnknownMembers } = this.flowEnumMembers({
							enumName,
							explicitType,
						})
						node.hasUnknownMembers = hasUnknownMembers
						switch (explicitType) {
							case 'boolean':
								node.explicitType = true
								node.members = members.booleanMembers
								this.expect(8)
								return this.finishNode(node, 'EnumBooleanBody')
							case 'number':
								node.explicitType = true
								node.members = members.numberMembers
								this.expect(8)
								return this.finishNode(node, 'EnumNumberBody')
							case 'string':
								node.explicitType = true
								node.members = this.flowEnumStringMembers(
									members.stringMembers,
									members.defaultedMembers,
									{
										enumName,
									},
								)
								this.expect(8)
								return this.finishNode(node, 'EnumStringBody')
							case 'symbol':
								node.members = members.defaultedMembers
								this.expect(8)
								return this.finishNode(node, 'EnumSymbolBody')
							default: {
								const empty = () => {
									node.members = []
									this.expect(8)
									return this.finishNode(node, 'EnumStringBody')
								}
								node.explicitType = false
								const boolsLen = members.booleanMembers.length
								const numsLen = members.numberMembers.length
								const strsLen = members.stringMembers.length
								const defaultedLen = members.defaultedMembers.length
								if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
									return empty()
								} else if (!boolsLen && !numsLen) {
									node.members = this.flowEnumStringMembers(
										members.stringMembers,
										members.defaultedMembers,
										{
											enumName,
										},
									)
									this.expect(8)
									return this.finishNode(node, 'EnumStringBody')
								} else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
									for (const member of members.defaultedMembers) {
										this.flowEnumErrorBooleanMemberNotInitialized(
											member.loc.start,
											{
												enumName,
												memberName: member.id.name,
											},
										)
									}
									node.members = members.booleanMembers
									this.expect(8)
									return this.finishNode(node, 'EnumBooleanBody')
								} else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
									for (const member of members.defaultedMembers) {
										this.flowEnumErrorNumberMemberNotInitialized(
											member.loc.start,
											{
												enumName,
												memberName: member.id.name,
											},
										)
									}
									node.members = members.numberMembers
									this.expect(8)
									return this.finishNode(node, 'EnumNumberBody')
								} else {
									this.raise(FlowErrors.EnumInconsistentMemberValues, nameLoc, {
										enumName,
									})
									return empty()
								}
							}
						}
					}
					flowParseEnumDeclaration(node) {
						const id = this.parseIdentifier()
						node.id = id
						node.body = this.flowEnumBody(this.startNode(), id)
						return this.finishNode(node, 'EnumDeclaration')
					}
					jsxParseOpeningElementAfterName(node) {
						if (this.shouldParseTypes()) {
							if (this.match(47) || this.match(51)) {
								node.typeArguments =
									this.flowParseTypeParameterInstantiationInExpression()
							}
						}
						return super.jsxParseOpeningElementAfterName(node)
					}
					isLookaheadToken_lt() {
						const next = this.nextTokenStart()
						if (this.input.charCodeAt(next) === 60) {
							const afterNext = this.input.charCodeAt(next + 1)
							return afterNext !== 60 && afterNext !== 61
						}
						return false
					}
					reScan_lt_gt() {
						const { type } = this.state
						if (type === 47) {
							this.state.pos -= 1
							this.readToken_lt()
						} else if (type === 48) {
							this.state.pos -= 1
							this.readToken_gt()
						}
					}
					reScan_lt() {
						const { type } = this.state
						if (type === 51) {
							this.state.pos -= 2
							this.finishOp(47, 1)
							return 47
						}
						return type
					}
					maybeUnwrapTypeCastExpression(node) {
						return node.type === 'TypeCastExpression' ? node.expression : node
					}
				}
			const entities = {
				__proto__: null,
				quot: '\u0022',
				amp: '&',
				apos: '\u0027',
				lt: '<',
				gt: '>',
				nbsp: '\u00A0',
				iexcl: '\u00A1',
				cent: '\u00A2',
				pound: '\u00A3',
				curren: '\u00A4',
				yen: '\u00A5',
				brvbar: '\u00A6',
				sect: '\u00A7',
				uml: '\u00A8',
				copy: '\u00A9',
				ordf: '\u00AA',
				laquo: '\u00AB',
				not: '\u00AC',
				shy: '\u00AD',
				reg: '\u00AE',
				macr: '\u00AF',
				deg: '\u00B0',
				plusmn: '\u00B1',
				sup2: '\u00B2',
				sup3: '\u00B3',
				acute: '\u00B4',
				micro: '\u00B5',
				para: '\u00B6',
				middot: '\u00B7',
				cedil: '\u00B8',
				sup1: '\u00B9',
				ordm: '\u00BA',
				raquo: '\u00BB',
				frac14: '\u00BC',
				frac12: '\u00BD',
				frac34: '\u00BE',
				iquest: '\u00BF',
				Agrave: '\u00C0',
				Aacute: '\u00C1',
				Acirc: '\u00C2',
				Atilde: '\u00C3',
				Auml: '\u00C4',
				Aring: '\u00C5',
				AElig: '\u00C6',
				Ccedil: '\u00C7',
				Egrave: '\u00C8',
				Eacute: '\u00C9',
				Ecirc: '\u00CA',
				Euml: '\u00CB',
				Igrave: '\u00CC',
				Iacute: '\u00CD',
				Icirc: '\u00CE',
				Iuml: '\u00CF',
				ETH: '\u00D0',
				Ntilde: '\u00D1',
				Ograve: '\u00D2',
				Oacute: '\u00D3',
				Ocirc: '\u00D4',
				Otilde: '\u00D5',
				Ouml: '\u00D6',
				times: '\u00D7',
				Oslash: '\u00D8',
				Ugrave: '\u00D9',
				Uacute: '\u00DA',
				Ucirc: '\u00DB',
				Uuml: '\u00DC',
				Yacute: '\u00DD',
				THORN: '\u00DE',
				szlig: '\u00DF',
				agrave: '\u00E0',
				aacute: '\u00E1',
				acirc: '\u00E2',
				atilde: '\u00E3',
				auml: '\u00E4',
				aring: '\u00E5',
				aelig: '\u00E6',
				ccedil: '\u00E7',
				egrave: '\u00E8',
				eacute: '\u00E9',
				ecirc: '\u00EA',
				euml: '\u00EB',
				igrave: '\u00EC',
				iacute: '\u00ED',
				icirc: '\u00EE',
				iuml: '\u00EF',
				eth: '\u00F0',
				ntilde: '\u00F1',
				ograve: '\u00F2',
				oacute: '\u00F3',
				ocirc: '\u00F4',
				otilde: '\u00F5',
				ouml: '\u00F6',
				divide: '\u00F7',
				oslash: '\u00F8',
				ugrave: '\u00F9',
				uacute: '\u00FA',
				ucirc: '\u00FB',
				uuml: '\u00FC',
				yacute: '\u00FD',
				thorn: '\u00FE',
				yuml: '\u00FF',
				OElig: '\u0152',
				oelig: '\u0153',
				Scaron: '\u0160',
				scaron: '\u0161',
				Yuml: '\u0178',
				fnof: '\u0192',
				circ: '\u02C6',
				tilde: '\u02DC',
				Alpha: '\u0391',
				Beta: '\u0392',
				Gamma: '\u0393',
				Delta: '\u0394',
				Epsilon: '\u0395',
				Zeta: '\u0396',
				Eta: '\u0397',
				Theta: '\u0398',
				Iota: '\u0399',
				Kappa: '\u039A',
				Lambda: '\u039B',
				Mu: '\u039C',
				Nu: '\u039D',
				Xi: '\u039E',
				Omicron: '\u039F',
				Pi: '\u03A0',
				Rho: '\u03A1',
				Sigma: '\u03A3',
				Tau: '\u03A4',
				Upsilon: '\u03A5',
				Phi: '\u03A6',
				Chi: '\u03A7',
				Psi: '\u03A8',
				Omega: '\u03A9',
				alpha: '\u03B1',
				beta: '\u03B2',
				gamma: '\u03B3',
				delta: '\u03B4',
				epsilon: '\u03B5',
				zeta: '\u03B6',
				eta: '\u03B7',
				theta: '\u03B8',
				iota: '\u03B9',
				kappa: '\u03BA',
				lambda: '\u03BB',
				mu: '\u03BC',
				nu: '\u03BD',
				xi: '\u03BE',
				omicron: '\u03BF',
				pi: '\u03C0',
				rho: '\u03C1',
				sigmaf: '\u03C2',
				sigma: '\u03C3',
				tau: '\u03C4',
				upsilon: '\u03C5',
				phi: '\u03C6',
				chi: '\u03C7',
				psi: '\u03C8',
				omega: '\u03C9',
				thetasym: '\u03D1',
				upsih: '\u03D2',
				piv: '\u03D6',
				ensp: '\u2002',
				emsp: '\u2003',
				thinsp: '\u2009',
				zwnj: '\u200C',
				zwj: '\u200D',
				lrm: '\u200E',
				rlm: '\u200F',
				ndash: '\u2013',
				mdash: '\u2014',
				lsquo: '\u2018',
				rsquo: '\u2019',
				sbquo: '\u201A',
				ldquo: '\u201C',
				rdquo: '\u201D',
				bdquo: '\u201E',
				dagger: '\u2020',
				Dagger: '\u2021',
				bull: '\u2022',
				hellip: '\u2026',
				permil: '\u2030',
				prime: '\u2032',
				Prime: '\u2033',
				lsaquo: '\u2039',
				rsaquo: '\u203A',
				oline: '\u203E',
				frasl: '\u2044',
				euro: '\u20AC',
				image: '\u2111',
				weierp: '\u2118',
				real: '\u211C',
				trade: '\u2122',
				alefsym: '\u2135',
				larr: '\u2190',
				uarr: '\u2191',
				rarr: '\u2192',
				darr: '\u2193',
				harr: '\u2194',
				crarr: '\u21B5',
				lArr: '\u21D0',
				uArr: '\u21D1',
				rArr: '\u21D2',
				dArr: '\u21D3',
				hArr: '\u21D4',
				forall: '\u2200',
				part: '\u2202',
				exist: '\u2203',
				empty: '\u2205',
				nabla: '\u2207',
				isin: '\u2208',
				notin: '\u2209',
				ni: '\u220B',
				prod: '\u220F',
				sum: '\u2211',
				minus: '\u2212',
				lowast: '\u2217',
				radic: '\u221A',
				prop: '\u221D',
				infin: '\u221E',
				ang: '\u2220',
				and: '\u2227',
				or: '\u2228',
				cap: '\u2229',
				cup: '\u222A',
				int: '\u222B',
				there4: '\u2234',
				sim: '\u223C',
				cong: '\u2245',
				asymp: '\u2248',
				ne: '\u2260',
				equiv: '\u2261',
				le: '\u2264',
				ge: '\u2265',
				sub: '\u2282',
				sup: '\u2283',
				nsub: '\u2284',
				sube: '\u2286',
				supe: '\u2287',
				oplus: '\u2295',
				otimes: '\u2297',
				perp: '\u22A5',
				sdot: '\u22C5',
				lceil: '\u2308',
				rceil: '\u2309',
				lfloor: '\u230A',
				rfloor: '\u230B',
				lang: '\u2329',
				rang: '\u232A',
				loz: '\u25CA',
				spades: '\u2660',
				clubs: '\u2663',
				hearts: '\u2665',
				diams: '\u2666',
			}
			const lineBreak = /\r\n|[\r\n\u2028\u2029]/
			const lineBreakG = new RegExp(lineBreak.source, 'g')
			function isNewLine(code) {
				switch (code) {
					case 10:
					case 13:
					case 8232:
					case 8233:
						return true
					default:
						return false
				}
			}
			function hasNewLine(input, start, end) {
				for (let i = start; i < end; i++) {
					if (isNewLine(input.charCodeAt(i))) {
						return true
					}
				}
				return false
			}
			const skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g
			const skipWhiteSpaceInLine =
				/(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g
			function isWhitespace(code) {
				switch (code) {
					case 0x0009:
					case 0x000b:
					case 0x000c:
					case 32:
					case 160:
					case 5760:
					case 0x2000:
					case 0x2001:
					case 0x2002:
					case 0x2003:
					case 0x2004:
					case 0x2005:
					case 0x2006:
					case 0x2007:
					case 0x2008:
					case 0x2009:
					case 0x200a:
					case 0x202f:
					case 0x205f:
					case 0x3000:
					case 0xfeff:
						return true
					default:
						return false
				}
			}
			const JsxErrors = ParseErrorEnum`jsx`({
				AttributeIsEmpty:
					'JSX attributes must only be assigned a non-empty expression.',
				MissingClosingTagElement: ({ openingTagName }) =>
					`Expected corresponding JSX closing tag for <${openingTagName}>.`,
				MissingClosingTagFragment:
					'Expected corresponding JSX closing tag for <>.',
				UnexpectedSequenceExpression:
					'Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?',
				UnexpectedToken: ({ unexpected, HTMLEntity }) =>
					`Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,
				UnsupportedJsxValue:
					'JSX value should be either an expression or a quoted JSX text.',
				UnterminatedJsxContent: 'Unterminated JSX contents.',
				UnwrappedAdjacentJSXElements:
					'Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?',
			})
			function isFragment(object) {
				return object
					? object.type === 'JSXOpeningFragment' ||
							object.type === 'JSXClosingFragment'
					: false
			}
			function getQualifiedJSXName(object) {
				if (object.type === 'JSXIdentifier') {
					return object.name
				}
				if (object.type === 'JSXNamespacedName') {
					return object.namespace.name + ':' + object.name.name
				}
				if (object.type === 'JSXMemberExpression') {
					return (
						getQualifiedJSXName(object.object) +
						'.' +
						getQualifiedJSXName(object.property)
					)
				}
				throw new Error('Node had unexpected type: ' + object.type)
			}
			var jsx = (superClass) =>
				class JSXParserMixin extends superClass {
					jsxReadToken() {
						let out = ''
						let chunkStart = this.state.pos
						for (;;) {
							if (this.state.pos >= this.length) {
								throw this.raise(
									JsxErrors.UnterminatedJsxContent,
									this.state.startLoc,
								)
							}
							const ch = this.input.charCodeAt(this.state.pos)
							switch (ch) {
								case 60:
								case 123:
									if (this.state.pos === this.state.start) {
										if (ch === 60 && this.state.canStartJSXElement) {
											++this.state.pos
											this.finishToken(143)
										} else {
											super.getTokenFromCode(ch)
										}
										return
									}
									out += this.input.slice(chunkStart, this.state.pos)
									this.finishToken(142, out)
									return
								case 38:
									out += this.input.slice(chunkStart, this.state.pos)
									out += this.jsxReadEntity()
									chunkStart = this.state.pos
									break
								case 62:
								case 125:
								default:
									if (isNewLine(ch)) {
										out += this.input.slice(chunkStart, this.state.pos)
										out += this.jsxReadNewLine(true)
										chunkStart = this.state.pos
									} else {
										++this.state.pos
									}
							}
						}
					}
					jsxReadNewLine(normalizeCRLF) {
						const ch = this.input.charCodeAt(this.state.pos)
						let out
						++this.state.pos
						if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
							++this.state.pos
							out = normalizeCRLF ? '\n' : '\r\n'
						} else {
							out = String.fromCharCode(ch)
						}
						++this.state.curLine
						this.state.lineStart = this.state.pos
						return out
					}
					jsxReadString(quote) {
						let out = ''
						let chunkStart = ++this.state.pos
						for (;;) {
							if (this.state.pos >= this.length) {
								throw this.raise(Errors.UnterminatedString, this.state.startLoc)
							}
							const ch = this.input.charCodeAt(this.state.pos)
							if (ch === quote) break
							if (ch === 38) {
								out += this.input.slice(chunkStart, this.state.pos)
								out += this.jsxReadEntity()
								chunkStart = this.state.pos
							} else if (isNewLine(ch)) {
								out += this.input.slice(chunkStart, this.state.pos)
								out += this.jsxReadNewLine(false)
								chunkStart = this.state.pos
							} else {
								++this.state.pos
							}
						}
						out += this.input.slice(chunkStart, this.state.pos++)
						this.finishToken(134, out)
					}
					jsxReadEntity() {
						const startPos = ++this.state.pos
						if (this.codePointAtPos(this.state.pos) === 35) {
							++this.state.pos
							let radix = 10
							if (this.codePointAtPos(this.state.pos) === 120) {
								radix = 16
								++this.state.pos
							}
							const codePoint = this.readInt(radix, undefined, false, 'bail')
							if (
								codePoint !== null &&
								this.codePointAtPos(this.state.pos) === 59
							) {
								++this.state.pos
								return String.fromCodePoint(codePoint)
							}
						} else {
							let count = 0
							let semi = false
							while (
								count++ < 10 &&
								this.state.pos < this.length &&
								!(semi = this.codePointAtPos(this.state.pos) === 59)
							) {
								++this.state.pos
							}
							if (semi) {
								const desc = this.input.slice(startPos, this.state.pos)
								const entity = entities[desc]
								++this.state.pos
								if (entity) {
									return entity
								}
							}
						}
						this.state.pos = startPos
						return '&'
					}
					jsxReadWord() {
						let ch
						const start = this.state.pos
						do {
							ch = this.input.charCodeAt(++this.state.pos)
						} while (isIdentifierChar(ch) || ch === 45)
						this.finishToken(141, this.input.slice(start, this.state.pos))
					}
					jsxParseIdentifier() {
						const node = this.startNode()
						if (this.match(141)) {
							node.name = this.state.value
						} else if (tokenIsKeyword(this.state.type)) {
							node.name = tokenLabelName(this.state.type)
						} else {
							this.unexpected()
						}
						this.next()
						return this.finishNode(node, 'JSXIdentifier')
					}
					jsxParseNamespacedName() {
						const startLoc = this.state.startLoc
						const name = this.jsxParseIdentifier()
						if (!this.eat(14)) return name
						const node = this.startNodeAt(startLoc)
						node.namespace = name
						node.name = this.jsxParseIdentifier()
						return this.finishNode(node, 'JSXNamespacedName')
					}
					jsxParseElementName() {
						const startLoc = this.state.startLoc
						let node = this.jsxParseNamespacedName()
						if (node.type === 'JSXNamespacedName') {
							return node
						}
						while (this.eat(16)) {
							const newNode = this.startNodeAt(startLoc)
							newNode.object = node
							newNode.property = this.jsxParseIdentifier()
							node = this.finishNode(newNode, 'JSXMemberExpression')
						}
						return node
					}
					jsxParseAttributeValue() {
						let node
						switch (this.state.type) {
							case 5:
								node = this.startNode()
								this.setContext(types.brace)
								this.next()
								node = this.jsxParseExpressionContainer(node, types.j_oTag)
								if (node.expression.type === 'JSXEmptyExpression') {
									this.raise(JsxErrors.AttributeIsEmpty, node)
								}
								return node
							case 143:
							case 134:
								return this.parseExprAtom()
							default:
								throw this.raise(
									JsxErrors.UnsupportedJsxValue,
									this.state.startLoc,
								)
						}
					}
					jsxParseEmptyExpression() {
						const node = this.startNodeAt(this.state.lastTokEndLoc)
						return this.finishNodeAt(
							node,
							'JSXEmptyExpression',
							this.state.startLoc,
						)
					}
					jsxParseSpreadChild(node) {
						this.next()
						node.expression = this.parseExpression()
						this.setContext(types.j_expr)
						this.state.canStartJSXElement = true
						this.expect(8)
						return this.finishNode(node, 'JSXSpreadChild')
					}
					jsxParseExpressionContainer(node, previousContext) {
						if (this.match(8)) {
							node.expression = this.jsxParseEmptyExpression()
						} else {
							const expression = this.parseExpression()
							node.expression = expression
						}
						this.setContext(previousContext)
						this.state.canStartJSXElement = true
						this.expect(8)
						return this.finishNode(node, 'JSXExpressionContainer')
					}
					jsxParseAttribute() {
						const node = this.startNode()
						if (this.match(5)) {
							this.setContext(types.brace)
							this.next()
							this.expect(21)
							node.argument = this.parseMaybeAssignAllowIn()
							this.setContext(types.j_oTag)
							this.state.canStartJSXElement = true
							this.expect(8)
							return this.finishNode(node, 'JSXSpreadAttribute')
						}
						node.name = this.jsxParseNamespacedName()
						node.value = this.eat(29) ? this.jsxParseAttributeValue() : null
						return this.finishNode(node, 'JSXAttribute')
					}
					jsxParseOpeningElementAt(startLoc) {
						const node = this.startNodeAt(startLoc)
						if (this.eat(144)) {
							return this.finishNode(node, 'JSXOpeningFragment')
						}
						node.name = this.jsxParseElementName()
						return this.jsxParseOpeningElementAfterName(node)
					}
					jsxParseOpeningElementAfterName(node) {
						const attributes = []
						while (!this.match(56) && !this.match(144)) {
							attributes.push(this.jsxParseAttribute())
						}
						node.attributes = attributes
						node.selfClosing = this.eat(56)
						this.expect(144)
						return this.finishNode(node, 'JSXOpeningElement')
					}
					jsxParseClosingElementAt(startLoc) {
						const node = this.startNodeAt(startLoc)
						if (this.eat(144)) {
							return this.finishNode(node, 'JSXClosingFragment')
						}
						node.name = this.jsxParseElementName()
						this.expect(144)
						return this.finishNode(node, 'JSXClosingElement')
					}
					jsxParseElementAt(startLoc) {
						const node = this.startNodeAt(startLoc)
						const children = []
						const openingElement = this.jsxParseOpeningElementAt(startLoc)
						let closingElement = null
						if (!openingElement.selfClosing) {
							contents: for (;;) {
								switch (this.state.type) {
									case 143:
										startLoc = this.state.startLoc
										this.next()
										if (this.eat(56)) {
											closingElement = this.jsxParseClosingElementAt(startLoc)
											break contents
										}
										children.push(this.jsxParseElementAt(startLoc))
										break
									case 142:
										children.push(
											this.parseLiteral(this.state.value, 'JSXText'),
										)
										break
									case 5: {
										const node = this.startNode()
										this.setContext(types.brace)
										this.next()
										if (this.match(21)) {
											children.push(this.jsxParseSpreadChild(node))
										} else {
											children.push(
												this.jsxParseExpressionContainer(node, types.j_expr),
											)
										}
										break
									}
									default:
										this.unexpected()
								}
							}
							if (
								isFragment(openingElement) &&
								!isFragment(closingElement) &&
								closingElement !== null
							) {
								this.raise(JsxErrors.MissingClosingTagFragment, closingElement)
							} else if (
								!isFragment(openingElement) &&
								isFragment(closingElement)
							) {
								this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
									openingTagName: getQualifiedJSXName(openingElement.name),
								})
							} else if (
								!isFragment(openingElement) &&
								!isFragment(closingElement)
							) {
								if (
									getQualifiedJSXName(closingElement.name) !==
									getQualifiedJSXName(openingElement.name)
								) {
									this.raise(
										JsxErrors.MissingClosingTagElement,
										closingElement,
										{
											openingTagName: getQualifiedJSXName(openingElement.name),
										},
									)
								}
							}
						}
						if (isFragment(openingElement)) {
							node.openingFragment = openingElement
							node.closingFragment = closingElement
						} else {
							node.openingElement = openingElement
							node.closingElement = closingElement
						}
						node.children = children
						if (this.match(47)) {
							throw this.raise(
								JsxErrors.UnwrappedAdjacentJSXElements,
								this.state.startLoc,
							)
						}
						return isFragment(openingElement)
							? this.finishNode(node, 'JSXFragment')
							: this.finishNode(node, 'JSXElement')
					}
					jsxParseElement() {
						const startLoc = this.state.startLoc
						this.next()
						return this.jsxParseElementAt(startLoc)
					}
					setContext(newContext) {
						const { context } = this.state
						context[context.length - 1] = newContext
					}
					parseExprAtom(refExpressionErrors) {
						if (this.match(143)) {
							return this.jsxParseElement()
						} else if (
							this.match(47) &&
							this.input.charCodeAt(this.state.pos) !== 33
						) {
							this.replaceToken(143)
							return this.jsxParseElement()
						} else {
							return super.parseExprAtom(refExpressionErrors)
						}
					}
					skipSpace() {
						const curContext = this.curContext()
						if (!curContext.preserveSpace) super.skipSpace()
					}
					getTokenFromCode(code) {
						const context = this.curContext()
						if (context === types.j_expr) {
							this.jsxReadToken()
							return
						}
						if (context === types.j_oTag || context === types.j_cTag) {
							if (isIdentifierStart(code)) {
								this.jsxReadWord()
								return
							}
							if (code === 62) {
								++this.state.pos
								this.finishToken(144)
								return
							}
							if ((code === 34 || code === 39) && context === types.j_oTag) {
								this.jsxReadString(code)
								return
							}
						}
						if (
							code === 60 &&
							this.state.canStartJSXElement &&
							this.input.charCodeAt(this.state.pos + 1) !== 33
						) {
							++this.state.pos
							this.finishToken(143)
							return
						}
						super.getTokenFromCode(code)
					}
					updateContext(prevType) {
						const { context, type } = this.state
						if (type === 56 && prevType === 143) {
							context.splice(-2, 2, types.j_cTag)
							this.state.canStartJSXElement = false
						} else if (type === 143) {
							context.push(types.j_oTag)
						} else if (type === 144) {
							const out = context[context.length - 1]
							if (
								(out === types.j_oTag && prevType === 56) ||
								out === types.j_cTag
							) {
								context.pop()
								this.state.canStartJSXElement =
									context[context.length - 1] === types.j_expr
							} else {
								this.setContext(types.j_expr)
								this.state.canStartJSXElement = true
							}
						} else {
							this.state.canStartJSXElement = tokenComesBeforeExpression(type)
						}
					}
				}
			class TypeScriptScope extends Scope {
				constructor(...args) {
					super(...args)
					this.tsNames = new Map()
				}
			}
			class TypeScriptScopeHandler extends ScopeHandler {
				constructor(...args) {
					super(...args)
					this.importsStack = []
				}
				createScope(flags) {
					this.importsStack.push(new Set())
					return new TypeScriptScope(flags)
				}
				enter(flags) {
					if (flags === 256) {
						this.importsStack.push(new Set())
					}
					super.enter(flags)
				}
				exit() {
					const flags = super.exit()
					if (flags === 256) {
						this.importsStack.pop()
					}
					return flags
				}
				hasImport(name, allowShadow) {
					const len = this.importsStack.length
					if (this.importsStack[len - 1].has(name)) {
						return true
					}
					if (!allowShadow && len > 1) {
						for (let i = 0; i < len - 1; i++) {
							if (this.importsStack[i].has(name)) return true
						}
					}
					return false
				}
				declareName(name, bindingType, loc) {
					if (bindingType & 4096) {
						if (this.hasImport(name, true)) {
							this.parser.raise(Errors.VarRedeclaration, loc, {
								identifierName: name,
							})
						}
						this.importsStack[this.importsStack.length - 1].add(name)
						return
					}
					const scope = this.currentScope()
					let type = scope.tsNames.get(name) || 0
					if (bindingType & 1024) {
						this.maybeExportDefined(scope, name)
						scope.tsNames.set(name, type | 16)
						return
					}
					super.declareName(name, bindingType, loc)
					if (bindingType & 2) {
						if (!(bindingType & 1)) {
							this.checkRedeclarationInScope(scope, name, bindingType, loc)
							this.maybeExportDefined(scope, name)
						}
						type = type | 1
					}
					if (bindingType & 256) {
						type = type | 2
					}
					if (bindingType & 512) {
						type = type | 4
					}
					if (bindingType & 128) {
						type = type | 8
					}
					if (type) scope.tsNames.set(name, type)
				}
				isRedeclaredInScope(scope, name, bindingType) {
					const type = scope.tsNames.get(name)
					if ((type & 2) > 0) {
						if (bindingType & 256) {
							const isConst = !!(bindingType & 512)
							const wasConst = (type & 4) > 0
							return isConst !== wasConst
						}
						return true
					}
					if (bindingType & 128 && (type & 8) > 0) {
						if (scope.names.get(name) & 2) {
							return !!(bindingType & 1)
						} else {
							return false
						}
					}
					if (bindingType & 2 && (type & 1) > 0) {
						return true
					}
					return super.isRedeclaredInScope(scope, name, bindingType)
				}
				checkLocalExport(id) {
					const { name } = id
					if (this.hasImport(name)) return
					const len = this.scopeStack.length
					for (let i = len - 1; i >= 0; i--) {
						const scope = this.scopeStack[i]
						const type = scope.tsNames.get(name)
						if ((type & 1) > 0 || (type & 16) > 0) {
							return
						}
					}
					super.checkLocalExport(id)
				}
			}
			class ProductionParameterHandler {
				constructor() {
					this.stacks = []
				}
				enter(flags) {
					this.stacks.push(flags)
				}
				exit() {
					this.stacks.pop()
				}
				currentFlags() {
					return this.stacks[this.stacks.length - 1]
				}
				get hasAwait() {
					return (this.currentFlags() & 2) > 0
				}
				get hasYield() {
					return (this.currentFlags() & 1) > 0
				}
				get hasReturn() {
					return (this.currentFlags() & 4) > 0
				}
				get hasIn() {
					return (this.currentFlags() & 8) > 0
				}
			}
			function functionFlags(isAsync, isGenerator) {
				return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0)
			}
			class BaseParser {
				constructor() {
					this.sawUnambiguousESM = false
					this.ambiguousScriptDifferentAst = false
				}
				sourceToOffsetPos(sourcePos) {
					return sourcePos + this.startIndex
				}
				offsetToSourcePos(offsetPos) {
					return offsetPos - this.startIndex
				}
				hasPlugin(pluginConfig) {
					if (typeof pluginConfig === 'string') {
						return this.plugins.has(pluginConfig)
					} else {
						const [pluginName, pluginOptions] = pluginConfig
						if (!this.hasPlugin(pluginName)) {
							return false
						}
						const actualOptions = this.plugins.get(pluginName)
						for (const key of Object.keys(pluginOptions)) {
							if (
								(actualOptions == null ? void 0 : actualOptions[key]) !==
								pluginOptions[key]
							) {
								return false
							}
						}
						return true
					}
				}
				getPluginOption(plugin, name) {
					var _this$plugins$get
					return (_this$plugins$get = this.plugins.get(plugin)) == null
						? void 0
						: _this$plugins$get[name]
				}
			}
			function setTrailingComments(node, comments) {
				if (node.trailingComments === undefined) {
					node.trailingComments = comments
				} else {
					node.trailingComments.unshift(...comments)
				}
			}
			function setLeadingComments(node, comments) {
				if (node.leadingComments === undefined) {
					node.leadingComments = comments
				} else {
					node.leadingComments.unshift(...comments)
				}
			}
			function setInnerComments(node, comments) {
				if (node.innerComments === undefined) {
					node.innerComments = comments
				} else {
					node.innerComments.unshift(...comments)
				}
			}
			function adjustInnerComments(node, elements, commentWS) {
				let lastElement = null
				let i = elements.length
				while (lastElement === null && i > 0) {
					lastElement = elements[--i]
				}
				if (lastElement === null || lastElement.start > commentWS.start) {
					setInnerComments(node, commentWS.comments)
				} else {
					setTrailingComments(lastElement, commentWS.comments)
				}
			}
			class CommentsParser extends BaseParser {
				addComment(comment) {
					if (this.filename) comment.loc.filename = this.filename
					const { commentsLen } = this.state
					if (this.comments.length !== commentsLen) {
						this.comments.length = commentsLen
					}
					this.comments.push(comment)
					this.state.commentsLen++
				}
				processComment(node) {
					const { commentStack } = this.state
					const commentStackLength = commentStack.length
					if (commentStackLength === 0) return
					let i = commentStackLength - 1
					const lastCommentWS = commentStack[i]
					if (lastCommentWS.start === node.end) {
						lastCommentWS.leadingNode = node
						i--
					}
					const { start: nodeStart } = node
					for (; i >= 0; i--) {
						const commentWS = commentStack[i]
						const commentEnd = commentWS.end
						if (commentEnd > nodeStart) {
							commentWS.containingNode = node
							this.finalizeComment(commentWS)
							commentStack.splice(i, 1)
						} else {
							if (commentEnd === nodeStart) {
								commentWS.trailingNode = node
							}
							break
						}
					}
				}
				finalizeComment(commentWS) {
					const { comments } = commentWS
					if (
						commentWS.leadingNode !== null ||
						commentWS.trailingNode !== null
					) {
						if (commentWS.leadingNode !== null) {
							setTrailingComments(commentWS.leadingNode, comments)
						}
						if (commentWS.trailingNode !== null) {
							setLeadingComments(commentWS.trailingNode, comments)
						}
					} else {
						const { containingNode: node, start: commentStart } = commentWS
						if (
							this.input.charCodeAt(
								this.offsetToSourcePos(commentStart) - 1,
							) === 44
						) {
							switch (node.type) {
								case 'ObjectExpression':
								case 'ObjectPattern':
								case 'RecordExpression':
									adjustInnerComments(node, node.properties, commentWS)
									break
								case 'CallExpression':
								case 'OptionalCallExpression':
									adjustInnerComments(node, node.arguments, commentWS)
									break
								case 'FunctionDeclaration':
								case 'FunctionExpression':
								case 'ArrowFunctionExpression':
								case 'ObjectMethod':
								case 'ClassMethod':
								case 'ClassPrivateMethod':
									adjustInnerComments(node, node.params, commentWS)
									break
								case 'ArrayExpression':
								case 'ArrayPattern':
								case 'TupleExpression':
									adjustInnerComments(node, node.elements, commentWS)
									break
								case 'ExportNamedDeclaration':
								case 'ImportDeclaration':
									adjustInnerComments(node, node.specifiers, commentWS)
									break
								case 'TSEnumDeclaration':
									{
										adjustInnerComments(node, node.members, commentWS)
									}
									break
								case 'TSEnumBody':
									adjustInnerComments(node, node.members, commentWS)
									break
								default: {
									setInnerComments(node, comments)
								}
							}
						} else {
							setInnerComments(node, comments)
						}
					}
				}
				finalizeRemainingComments() {
					const { commentStack } = this.state
					for (let i = commentStack.length - 1; i >= 0; i--) {
						this.finalizeComment(commentStack[i])
					}
					this.state.commentStack = []
				}
				resetPreviousNodeTrailingComments(node) {
					const { commentStack } = this.state
					const { length } = commentStack
					if (length === 0) return
					const commentWS = commentStack[length - 1]
					if (commentWS.leadingNode === node) {
						commentWS.leadingNode = null
					}
				}
				resetPreviousIdentifierLeadingComments(node) {
					const { commentStack } = this.state
					const { length } = commentStack
					if (length === 0) return
					if (commentStack[length - 1].trailingNode === node) {
						commentStack[length - 1].trailingNode = null
					} else if (
						length >= 2 &&
						commentStack[length - 2].trailingNode === node
					) {
						commentStack[length - 2].trailingNode = null
					}
				}
				takeSurroundingComments(node, start, end) {
					const { commentStack } = this.state
					const commentStackLength = commentStack.length
					if (commentStackLength === 0) return
					let i = commentStackLength - 1
					for (; i >= 0; i--) {
						const commentWS = commentStack[i]
						const commentEnd = commentWS.end
						const commentStart = commentWS.start
						if (commentStart === end) {
							commentWS.leadingNode = node
						} else if (commentEnd === start) {
							commentWS.trailingNode = node
						} else if (commentEnd < start) {
							break
						}
					}
				}
			}
			class State {
				constructor() {
					this.flags = 1024
					this.startIndex = void 0
					this.curLine = void 0
					this.lineStart = void 0
					this.startLoc = void 0
					this.endLoc = void 0
					this.errors = []
					this.potentialArrowAt = -1
					this.noArrowAt = []
					this.noArrowParamsConversionAt = []
					this.topicContext = {
						maxNumOfResolvableTopics: 0,
						maxTopicIndex: null,
					}
					this.labels = []
					this.commentsLen = 0
					this.commentStack = []
					this.pos = 0
					this.type = 140
					this.value = null
					this.start = 0
					this.end = 0
					this.lastTokEndLoc = null
					this.lastTokStartLoc = null
					this.context = [types.brace]
					this.firstInvalidTemplateEscapePos = null
					this.strictErrors = new Map()
					this.tokensLength = 0
				}
				get strict() {
					return (this.flags & 1) > 0
				}
				set strict(v) {
					if (v) this.flags |= 1
					else this.flags &= -2
				}
				init({ strictMode, sourceType, startIndex, startLine, startColumn }) {
					this.strict =
						strictMode === false
							? false
							: strictMode === true
								? true
								: sourceType === 'module'
					this.startIndex = startIndex
					this.curLine = startLine
					this.lineStart = -startColumn
					this.startLoc = this.endLoc = new Position(
						startLine,
						startColumn,
						startIndex,
					)
				}
				get maybeInArrowParameters() {
					return (this.flags & 2) > 0
				}
				set maybeInArrowParameters(v) {
					if (v) this.flags |= 2
					else this.flags &= -3
				}
				get inType() {
					return (this.flags & 4) > 0
				}
				set inType(v) {
					if (v) this.flags |= 4
					else this.flags &= -5
				}
				get noAnonFunctionType() {
					return (this.flags & 8) > 0
				}
				set noAnonFunctionType(v) {
					if (v) this.flags |= 8
					else this.flags &= -9
				}
				get hasFlowComment() {
					return (this.flags & 16) > 0
				}
				set hasFlowComment(v) {
					if (v) this.flags |= 16
					else this.flags &= -17
				}
				get isAmbientContext() {
					return (this.flags & 32) > 0
				}
				set isAmbientContext(v) {
					if (v) this.flags |= 32
					else this.flags &= -33
				}
				get inAbstractClass() {
					return (this.flags & 64) > 0
				}
				set inAbstractClass(v) {
					if (v) this.flags |= 64
					else this.flags &= -65
				}
				get inDisallowConditionalTypesContext() {
					return (this.flags & 128) > 0
				}
				set inDisallowConditionalTypesContext(v) {
					if (v) this.flags |= 128
					else this.flags &= -129
				}
				get soloAwait() {
					return (this.flags & 256) > 0
				}
				set soloAwait(v) {
					if (v) this.flags |= 256
					else this.flags &= -257
				}
				get inFSharpPipelineDirectBody() {
					return (this.flags & 512) > 0
				}
				set inFSharpPipelineDirectBody(v) {
					if (v) this.flags |= 512
					else this.flags &= -513
				}
				get canStartJSXElement() {
					return (this.flags & 1024) > 0
				}
				set canStartJSXElement(v) {
					if (v) this.flags |= 1024
					else this.flags &= -1025
				}
				get containsEsc() {
					return (this.flags & 2048) > 0
				}
				set containsEsc(v) {
					if (v) this.flags |= 2048
					else this.flags &= -2049
				}
				get hasTopLevelAwait() {
					return (this.flags & 4096) > 0
				}
				set hasTopLevelAwait(v) {
					if (v) this.flags |= 4096
					else this.flags &= -4097
				}
				curPosition() {
					return new Position(
						this.curLine,
						this.pos - this.lineStart,
						this.pos + this.startIndex,
					)
				}
				clone() {
					const state = new State()
					state.flags = this.flags
					state.startIndex = this.startIndex
					state.curLine = this.curLine
					state.lineStart = this.lineStart
					state.startLoc = this.startLoc
					state.endLoc = this.endLoc
					state.errors = this.errors.slice()
					state.potentialArrowAt = this.potentialArrowAt
					state.noArrowAt = this.noArrowAt.slice()
					state.noArrowParamsConversionAt =
						this.noArrowParamsConversionAt.slice()
					state.topicContext = this.topicContext
					state.labels = this.labels.slice()
					state.commentsLen = this.commentsLen
					state.commentStack = this.commentStack.slice()
					state.pos = this.pos
					state.type = this.type
					state.value = this.value
					state.start = this.start
					state.end = this.end
					state.lastTokEndLoc = this.lastTokEndLoc
					state.lastTokStartLoc = this.lastTokStartLoc
					state.context = this.context.slice()
					state.firstInvalidTemplateEscapePos =
						this.firstInvalidTemplateEscapePos
					state.strictErrors = this.strictErrors
					state.tokensLength = this.tokensLength
					return state
				}
			}
			var _isDigit = function isDigit(code) {
				return code >= 48 && code <= 57
			}
			const forbiddenNumericSeparatorSiblings = {
				decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),
				hex: new Set([46, 88, 95, 120]),
			}
			const isAllowedNumericSeparatorSibling = {
				bin: (ch) => ch === 48 || ch === 49,
				oct: (ch) => ch >= 48 && ch <= 55,
				dec: (ch) => ch >= 48 && ch <= 57,
				hex: (ch) =>
					(ch >= 48 && ch <= 57) ||
					(ch >= 65 && ch <= 70) ||
					(ch >= 97 && ch <= 102),
			}
			function readStringContents(
				type,
				input,
				pos,
				lineStart,
				curLine,
				errors,
			) {
				const initialPos = pos
				const initialLineStart = lineStart
				const initialCurLine = curLine
				let out = ''
				let firstInvalidLoc = null
				let chunkStart = pos
				const { length } = input
				for (;;) {
					if (pos >= length) {
						errors.unterminated(initialPos, initialLineStart, initialCurLine)
						out += input.slice(chunkStart, pos)
						break
					}
					const ch = input.charCodeAt(pos)
					if (isStringEnd(type, ch, input, pos)) {
						out += input.slice(chunkStart, pos)
						break
					}
					if (ch === 92) {
						out += input.slice(chunkStart, pos)
						const res = readEscapedChar(
							input,
							pos,
							lineStart,
							curLine,
							type === 'template',
							errors,
						)
						if (res.ch === null && !firstInvalidLoc) {
							firstInvalidLoc = {
								pos,
								lineStart,
								curLine,
							}
						} else {
							out += res.ch
						}
						;({ pos, lineStart, curLine } = res)
						chunkStart = pos
					} else if (ch === 8232 || ch === 8233) {
						++pos
						++curLine
						lineStart = pos
					} else if (ch === 10 || ch === 13) {
						if (type === 'template') {
							out += input.slice(chunkStart, pos) + '\n'
							++pos
							if (ch === 13 && input.charCodeAt(pos) === 10) {
								++pos
							}
							++curLine
							chunkStart = lineStart = pos
						} else {
							errors.unterminated(initialPos, initialLineStart, initialCurLine)
						}
					} else {
						++pos
					}
				}
				return {
					pos,
					str: out,
					firstInvalidLoc,
					lineStart,
					curLine,
					containsInvalid: !!firstInvalidLoc,
				}
			}
			function isStringEnd(type, ch, input, pos) {
				if (type === 'template') {
					return ch === 96 || (ch === 36 && input.charCodeAt(pos + 1) === 123)
				}
				return ch === (type === 'double' ? 34 : 39)
			}
			function readEscapedChar(
				input,
				pos,
				lineStart,
				curLine,
				inTemplate,
				errors,
			) {
				const throwOnInvalid = !inTemplate
				pos++
				const res = (ch) => ({
					pos,
					ch,
					lineStart,
					curLine,
				})
				const ch = input.charCodeAt(pos++)
				switch (ch) {
					case 110:
						return res('\n')
					case 114:
						return res('\r')
					case 120: {
						let code
						;({ code, pos } = readHexChar(
							input,
							pos,
							lineStart,
							curLine,
							2,
							false,
							throwOnInvalid,
							errors,
						))
						return res(code === null ? null : String.fromCharCode(code))
					}
					case 117: {
						let code
						;({ code, pos } = readCodePoint(
							input,
							pos,
							lineStart,
							curLine,
							throwOnInvalid,
							errors,
						))
						return res(code === null ? null : String.fromCodePoint(code))
					}
					case 116:
						return res('\t')
					case 98:
						return res('\b')
					case 118:
						return res('\u000b')
					case 102:
						return res('\f')
					case 13:
						if (input.charCodeAt(pos) === 10) {
							++pos
						}
					case 10:
						lineStart = pos
						++curLine
					case 8232:
					case 8233:
						return res('')
					case 56:
					case 57:
						if (inTemplate) {
							return res(null)
						} else {
							errors.strictNumericEscape(pos - 1, lineStart, curLine)
						}
					default:
						if (ch >= 48 && ch <= 55) {
							const startPos = pos - 1
							const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2))
							let octalStr = match[0]
							let octal = parseInt(octalStr, 8)
							if (octal > 255) {
								octalStr = octalStr.slice(0, -1)
								octal = parseInt(octalStr, 8)
							}
							pos += octalStr.length - 1
							const next = input.charCodeAt(pos)
							if (octalStr !== '0' || next === 56 || next === 57) {
								if (inTemplate) {
									return res(null)
								} else {
									errors.strictNumericEscape(startPos, lineStart, curLine)
								}
							}
							return res(String.fromCharCode(octal))
						}
						return res(String.fromCharCode(ch))
				}
			}
			function readHexChar(
				input,
				pos,
				lineStart,
				curLine,
				len,
				forceLen,
				throwOnInvalid,
				errors,
			) {
				const initialPos = pos
				let n
				;({ n, pos } = readInt(
					input,
					pos,
					lineStart,
					curLine,
					16,
					len,
					forceLen,
					false,
					errors,
					!throwOnInvalid,
				))
				if (n === null) {
					if (throwOnInvalid) {
						errors.invalidEscapeSequence(initialPos, lineStart, curLine)
					} else {
						pos = initialPos - 1
					}
				}
				return {
					code: n,
					pos,
				}
			}
			function readInt(
				input,
				pos,
				lineStart,
				curLine,
				radix,
				len,
				forceLen,
				allowNumSeparator,
				errors,
				bailOnError,
			) {
				const start = pos
				const forbiddenSiblings =
					radix === 16
						? forbiddenNumericSeparatorSiblings.hex
						: forbiddenNumericSeparatorSiblings.decBinOct
				const isAllowedSibling =
					radix === 16
						? isAllowedNumericSeparatorSibling.hex
						: radix === 10
							? isAllowedNumericSeparatorSibling.dec
							: radix === 8
								? isAllowedNumericSeparatorSibling.oct
								: isAllowedNumericSeparatorSibling.bin
				let invalid = false
				let total = 0
				for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
					const code = input.charCodeAt(pos)
					let val
					if (code === 95 && allowNumSeparator !== 'bail') {
						const prev = input.charCodeAt(pos - 1)
						const next = input.charCodeAt(pos + 1)
						if (!allowNumSeparator) {
							if (bailOnError)
								return {
									n: null,
									pos,
								}
							errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine)
						} else if (
							Number.isNaN(next) ||
							!isAllowedSibling(next) ||
							forbiddenSiblings.has(prev) ||
							forbiddenSiblings.has(next)
						) {
							if (bailOnError)
								return {
									n: null,
									pos,
								}
							errors.unexpectedNumericSeparator(pos, lineStart, curLine)
						}
						++pos
						continue
					}
					if (code >= 97) {
						val = code - 97 + 10
					} else if (code >= 65) {
						val = code - 65 + 10
					} else if (_isDigit(code)) {
						val = code - 48
					} else {
						val = Infinity
					}
					if (val >= radix) {
						if (val <= 9 && bailOnError) {
							return {
								n: null,
								pos,
							}
						} else if (
							val <= 9 &&
							errors.invalidDigit(pos, lineStart, curLine, radix)
						) {
							val = 0
						} else if (forceLen) {
							val = 0
							invalid = true
						} else {
							break
						}
					}
					++pos
					total = total * radix + val
				}
				if (pos === start || (len != null && pos - start !== len) || invalid) {
					return {
						n: null,
						pos,
					}
				}
				return {
					n: total,
					pos,
				}
			}
			function readCodePoint(
				input,
				pos,
				lineStart,
				curLine,
				throwOnInvalid,
				errors,
			) {
				const ch = input.charCodeAt(pos)
				let code
				if (ch === 123) {
					++pos
					;({ code, pos } = readHexChar(
						input,
						pos,
						lineStart,
						curLine,
						input.indexOf('}', pos) - pos,
						true,
						throwOnInvalid,
						errors,
					))
					++pos
					if (code !== null && code > 0x10ffff) {
						if (throwOnInvalid) {
							errors.invalidCodePoint(pos, lineStart, curLine)
						} else {
							return {
								code: null,
								pos,
							}
						}
					}
				} else {
					;({ code, pos } = readHexChar(
						input,
						pos,
						lineStart,
						curLine,
						4,
						false,
						throwOnInvalid,
						errors,
					))
				}
				return {
					code,
					pos,
				}
			}
			function buildPosition(pos, lineStart, curLine) {
				return new Position(curLine, pos - lineStart, pos)
			}
			const VALID_REGEX_FLAGS = new Set([
				103, 109, 115, 105, 121, 117, 100, 118,
			])
			class Token {
				constructor(state) {
					const startIndex = state.startIndex || 0
					this.type = state.type
					this.value = state.value
					this.start = startIndex + state.start
					this.end = startIndex + state.end
					this.loc = new SourceLocation(state.startLoc, state.endLoc)
				}
			}
			class Tokenizer extends CommentsParser {
				constructor(options, input) {
					super()
					this.isLookahead = void 0
					this.tokens = []
					this.errorHandlers_readInt = {
						invalidDigit: (pos, lineStart, curLine, radix) => {
							if (!(this.optionFlags & 2048)) return false
							this.raise(
								Errors.InvalidDigit,
								buildPosition(pos, lineStart, curLine),
								{
									radix,
								},
							)
							return true
						},
						numericSeparatorInEscapeSequence: this.errorBuilder(
							Errors.NumericSeparatorInEscapeSequence,
						),
						unexpectedNumericSeparator: this.errorBuilder(
							Errors.UnexpectedNumericSeparator,
						),
					}
					this.errorHandlers_readCodePoint = Object.assign(
						{},
						this.errorHandlers_readInt,
						{
							invalidEscapeSequence: this.errorBuilder(
								Errors.InvalidEscapeSequence,
							),
							invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint),
						},
					)
					this.errorHandlers_readStringContents_string = Object.assign(
						{},
						this.errorHandlers_readCodePoint,
						{
							strictNumericEscape: (pos, lineStart, curLine) => {
								this.recordStrictModeErrors(
									Errors.StrictNumericEscape,
									buildPosition(pos, lineStart, curLine),
								)
							},
							unterminated: (pos, lineStart, curLine) => {
								throw this.raise(
									Errors.UnterminatedString,
									buildPosition(pos - 1, lineStart, curLine),
								)
							},
						},
					)
					this.errorHandlers_readStringContents_template = Object.assign(
						{},
						this.errorHandlers_readCodePoint,
						{
							strictNumericEscape: this.errorBuilder(
								Errors.StrictNumericEscape,
							),
							unterminated: (pos, lineStart, curLine) => {
								throw this.raise(
									Errors.UnterminatedTemplate,
									buildPosition(pos, lineStart, curLine),
								)
							},
						},
					)
					this.state = new State()
					this.state.init(options)
					this.input = input
					this.length = input.length
					this.comments = []
					this.isLookahead = false
				}
				pushToken(token) {
					this.tokens.length = this.state.tokensLength
					this.tokens.push(token)
					++this.state.tokensLength
				}
				next() {
					this.checkKeywordEscapes()
					if (this.optionFlags & 256) {
						this.pushToken(new Token(this.state))
					}
					this.state.lastTokEndLoc = this.state.endLoc
					this.state.lastTokStartLoc = this.state.startLoc
					this.nextToken()
				}
				eat(type) {
					if (this.match(type)) {
						this.next()
						return true
					} else {
						return false
					}
				}
				match(type) {
					return this.state.type === type
				}
				createLookaheadState(state) {
					return {
						pos: state.pos,
						value: null,
						type: state.type,
						start: state.start,
						end: state.end,
						context: [this.curContext()],
						inType: state.inType,
						startLoc: state.startLoc,
						lastTokEndLoc: state.lastTokEndLoc,
						curLine: state.curLine,
						lineStart: state.lineStart,
						curPosition: state.curPosition,
					}
				}
				lookahead() {
					const old = this.state
					this.state = this.createLookaheadState(old)
					this.isLookahead = true
					this.nextToken()
					this.isLookahead = false
					const curr = this.state
					this.state = old
					return curr
				}
				nextTokenStart() {
					return this.nextTokenStartSince(this.state.pos)
				}
				nextTokenStartSince(pos) {
					skipWhiteSpace.lastIndex = pos
					return skipWhiteSpace.test(this.input)
						? skipWhiteSpace.lastIndex
						: pos
				}
				lookaheadCharCode() {
					return this.lookaheadCharCodeSince(this.state.pos)
				}
				lookaheadCharCodeSince(pos) {
					return this.input.charCodeAt(this.nextTokenStartSince(pos))
				}
				nextTokenInLineStart() {
					return this.nextTokenInLineStartSince(this.state.pos)
				}
				nextTokenInLineStartSince(pos) {
					skipWhiteSpaceInLine.lastIndex = pos
					return skipWhiteSpaceInLine.test(this.input)
						? skipWhiteSpaceInLine.lastIndex
						: pos
				}
				lookaheadInLineCharCode() {
					return this.input.charCodeAt(this.nextTokenInLineStart())
				}
				codePointAtPos(pos) {
					let cp = this.input.charCodeAt(pos)
					if ((cp & 0xfc00) === 0xd800 && ++pos < this.input.length) {
						const trail = this.input.charCodeAt(pos)
						if ((trail & 0xfc00) === 0xdc00) {
							cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff)
						}
					}
					return cp
				}
				setStrict(strict) {
					this.state.strict = strict
					if (strict) {
						this.state.strictErrors.forEach(([toParseError, at]) =>
							this.raise(toParseError, at),
						)
						this.state.strictErrors.clear()
					}
				}
				curContext() {
					return this.state.context[this.state.context.length - 1]
				}
				nextToken() {
					this.skipSpace()
					this.state.start = this.state.pos
					if (!this.isLookahead) this.state.startLoc = this.state.curPosition()
					if (this.state.pos >= this.length) {
						this.finishToken(140)
						return
					}
					this.getTokenFromCode(this.codePointAtPos(this.state.pos))
				}
				skipBlockComment(commentEnd) {
					let startLoc
					if (!this.isLookahead) startLoc = this.state.curPosition()
					const start = this.state.pos
					const end = this.input.indexOf(commentEnd, start + 2)
					if (end === -1) {
						throw this.raise(
							Errors.UnterminatedComment,
							this.state.curPosition(),
						)
					}
					this.state.pos = end + commentEnd.length
					lineBreakG.lastIndex = start + 2
					while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
						++this.state.curLine
						this.state.lineStart = lineBreakG.lastIndex
					}
					if (this.isLookahead) return
					const comment = {
						type: 'CommentBlock',
						value: this.input.slice(start + 2, end),
						start: this.sourceToOffsetPos(start),
						end: this.sourceToOffsetPos(end + commentEnd.length),
						loc: new SourceLocation(startLoc, this.state.curPosition()),
					}
					if (this.optionFlags & 256) this.pushToken(comment)
					return comment
				}
				skipLineComment(startSkip) {
					const start = this.state.pos
					let startLoc
					if (!this.isLookahead) startLoc = this.state.curPosition()
					let ch = this.input.charCodeAt((this.state.pos += startSkip))
					if (this.state.pos < this.length) {
						while (!isNewLine(ch) && ++this.state.pos < this.length) {
							ch = this.input.charCodeAt(this.state.pos)
						}
					}
					if (this.isLookahead) return
					const end = this.state.pos
					const value = this.input.slice(start + startSkip, end)
					const comment = {
						type: 'CommentLine',
						value,
						start: this.sourceToOffsetPos(start),
						end: this.sourceToOffsetPos(end),
						loc: new SourceLocation(startLoc, this.state.curPosition()),
					}
					if (this.optionFlags & 256) this.pushToken(comment)
					return comment
				}
				skipSpace() {
					const spaceStart = this.state.pos
					const comments = this.optionFlags & 4096 ? [] : null
					loop: while (this.state.pos < this.length) {
						const ch = this.input.charCodeAt(this.state.pos)
						switch (ch) {
							case 32:
							case 160:
							case 9:
								++this.state.pos
								break
							case 13:
								if (this.input.charCodeAt(this.state.pos + 1) === 10) {
									++this.state.pos
								}
							case 10:
							case 8232:
							case 8233:
								++this.state.pos
								++this.state.curLine
								this.state.lineStart = this.state.pos
								break
							case 47:
								switch (this.input.charCodeAt(this.state.pos + 1)) {
									case 42: {
										const comment = this.skipBlockComment('*/')
										if (comment !== undefined) {
											this.addComment(comment)
											comments == null || comments.push(comment)
										}
										break
									}
									case 47: {
										const comment = this.skipLineComment(2)
										if (comment !== undefined) {
											this.addComment(comment)
											comments == null || comments.push(comment)
										}
										break
									}
									default:
										break loop
								}
								break
							default:
								if (isWhitespace(ch)) {
									++this.state.pos
								} else if (
									ch === 45 &&
									!this.inModule &&
									this.optionFlags & 8192
								) {
									const pos = this.state.pos
									if (
										this.input.charCodeAt(pos + 1) === 45 &&
										this.input.charCodeAt(pos + 2) === 62 &&
										(spaceStart === 0 || this.state.lineStart > spaceStart)
									) {
										const comment = this.skipLineComment(3)
										if (comment !== undefined) {
											this.addComment(comment)
											comments == null || comments.push(comment)
										}
									} else {
										break loop
									}
								} else if (
									ch === 60 &&
									!this.inModule &&
									this.optionFlags & 8192
								) {
									const pos = this.state.pos
									if (
										this.input.charCodeAt(pos + 1) === 33 &&
										this.input.charCodeAt(pos + 2) === 45 &&
										this.input.charCodeAt(pos + 3) === 45
									) {
										const comment = this.skipLineComment(4)
										if (comment !== undefined) {
											this.addComment(comment)
											comments == null || comments.push(comment)
										}
									} else {
										break loop
									}
								} else {
									break loop
								}
						}
					}
					if ((comments == null ? void 0 : comments.length) > 0) {
						const end = this.state.pos
						const commentWhitespace = {
							start: this.sourceToOffsetPos(spaceStart),
							end: this.sourceToOffsetPos(end),
							comments,
							leadingNode: null,
							trailingNode: null,
							containingNode: null,
						}
						this.state.commentStack.push(commentWhitespace)
					}
				}
				finishToken(type, val) {
					this.state.end = this.state.pos
					this.state.endLoc = this.state.curPosition()
					const prevType = this.state.type
					this.state.type = type
					this.state.value = val
					if (!this.isLookahead) {
						this.updateContext(prevType)
					}
				}
				replaceToken(type) {
					this.state.type = type
					this.updateContext()
				}
				readToken_numberSign() {
					if (this.state.pos === 0 && this.readToken_interpreter()) {
						return
					}
					const nextPos = this.state.pos + 1
					const next = this.codePointAtPos(nextPos)
					if (next >= 48 && next <= 57) {
						throw this.raise(
							Errors.UnexpectedDigitAfterHash,
							this.state.curPosition(),
						)
					}
					if (
						next === 123 ||
						(next === 91 && this.hasPlugin('recordAndTuple'))
					) {
						this.expectPlugin('recordAndTuple')
						if (
							this.getPluginOption('recordAndTuple', 'syntaxType') === 'bar'
						) {
							throw this.raise(
								next === 123
									? Errors.RecordExpressionHashIncorrectStartSyntaxType
									: Errors.TupleExpressionHashIncorrectStartSyntaxType,
								this.state.curPosition(),
							)
						}
						this.state.pos += 2
						if (next === 123) {
							this.finishToken(7)
						} else {
							this.finishToken(1)
						}
					} else if (isIdentifierStart(next)) {
						++this.state.pos
						this.finishToken(139, this.readWord1(next))
					} else if (next === 92) {
						++this.state.pos
						this.finishToken(139, this.readWord1())
					} else {
						this.finishOp(27, 1)
					}
				}
				readToken_dot() {
					const next = this.input.charCodeAt(this.state.pos + 1)
					if (next >= 48 && next <= 57) {
						this.readNumber(true)
						return
					}
					if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
						this.state.pos += 3
						this.finishToken(21)
					} else {
						++this.state.pos
						this.finishToken(16)
					}
				}
				readToken_slash() {
					const next = this.input.charCodeAt(this.state.pos + 1)
					if (next === 61) {
						this.finishOp(31, 2)
					} else {
						this.finishOp(56, 1)
					}
				}
				readToken_interpreter() {
					if (this.state.pos !== 0 || this.length < 2) return false
					let ch = this.input.charCodeAt(this.state.pos + 1)
					if (ch !== 33) return false
					const start = this.state.pos
					this.state.pos += 1
					while (!isNewLine(ch) && ++this.state.pos < this.length) {
						ch = this.input.charCodeAt(this.state.pos)
					}
					const value = this.input.slice(start + 2, this.state.pos)
					this.finishToken(28, value)
					return true
				}
				readToken_mult_modulo(code) {
					let type = code === 42 ? 55 : 54
					let width = 1
					let next = this.input.charCodeAt(this.state.pos + 1)
					if (code === 42 && next === 42) {
						width++
						next = this.input.charCodeAt(this.state.pos + 2)
						type = 57
					}
					if (next === 61 && !this.state.inType) {
						width++
						type = code === 37 ? 33 : 30
					}
					this.finishOp(type, width)
				}
				readToken_pipe_amp(code) {
					const next = this.input.charCodeAt(this.state.pos + 1)
					if (next === code) {
						if (this.input.charCodeAt(this.state.pos + 2) === 61) {
							this.finishOp(30, 3)
						} else {
							this.finishOp(code === 124 ? 41 : 42, 2)
						}
						return
					}
					if (code === 124) {
						if (next === 62) {
							this.finishOp(39, 2)
							return
						}
						if (this.hasPlugin('recordAndTuple') && next === 125) {
							if (
								this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar'
							) {
								throw this.raise(
									Errors.RecordExpressionBarIncorrectEndSyntaxType,
									this.state.curPosition(),
								)
							}
							this.state.pos += 2
							this.finishToken(9)
							return
						}
						if (this.hasPlugin('recordAndTuple') && next === 93) {
							if (
								this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar'
							) {
								throw this.raise(
									Errors.TupleExpressionBarIncorrectEndSyntaxType,
									this.state.curPosition(),
								)
							}
							this.state.pos += 2
							this.finishToken(4)
							return
						}
					}
					if (next === 61) {
						this.finishOp(30, 2)
						return
					}
					this.finishOp(code === 124 ? 43 : 45, 1)
				}
				readToken_caret() {
					const next = this.input.charCodeAt(this.state.pos + 1)
					if (next === 61 && !this.state.inType) {
						this.finishOp(32, 2)
					} else if (
						next === 94 &&
						this.hasPlugin([
							'pipelineOperator',
							{
								proposal: 'hack',
								topicToken: '^^',
							},
						])
					) {
						this.finishOp(37, 2)
						const lookaheadCh = this.input.codePointAt(this.state.pos)
						if (lookaheadCh === 94) {
							this.unexpected()
						}
					} else {
						this.finishOp(44, 1)
					}
				}
				readToken_atSign() {
					const next = this.input.charCodeAt(this.state.pos + 1)
					if (
						next === 64 &&
						this.hasPlugin([
							'pipelineOperator',
							{
								proposal: 'hack',
								topicToken: '@@',
							},
						])
					) {
						this.finishOp(38, 2)
					} else {
						this.finishOp(26, 1)
					}
				}
				readToken_plus_min(code) {
					const next = this.input.charCodeAt(this.state.pos + 1)
					if (next === code) {
						this.finishOp(34, 2)
						return
					}
					if (next === 61) {
						this.finishOp(30, 2)
					} else {
						this.finishOp(53, 1)
					}
				}
				readToken_lt() {
					const { pos } = this.state
					const next = this.input.charCodeAt(pos + 1)
					if (next === 60) {
						if (this.input.charCodeAt(pos + 2) === 61) {
							this.finishOp(30, 3)
							return
						}
						this.finishOp(51, 2)
						return
					}
					if (next === 61) {
						this.finishOp(49, 2)
						return
					}
					this.finishOp(47, 1)
				}
				readToken_gt() {
					const { pos } = this.state
					const next = this.input.charCodeAt(pos + 1)
					if (next === 62) {
						const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2
						if (this.input.charCodeAt(pos + size) === 61) {
							this.finishOp(30, size + 1)
							return
						}
						this.finishOp(52, size)
						return
					}
					if (next === 61) {
						this.finishOp(49, 2)
						return
					}
					this.finishOp(48, 1)
				}
				readToken_eq_excl(code) {
					const next = this.input.charCodeAt(this.state.pos + 1)
					if (next === 61) {
						this.finishOp(
							46,
							this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2,
						)
						return
					}
					if (code === 61 && next === 62) {
						this.state.pos += 2
						this.finishToken(19)
						return
					}
					this.finishOp(code === 61 ? 29 : 35, 1)
				}
				readToken_question() {
					const next = this.input.charCodeAt(this.state.pos + 1)
					const next2 = this.input.charCodeAt(this.state.pos + 2)
					if (next === 63) {
						if (next2 === 61) {
							this.finishOp(30, 3)
						} else {
							this.finishOp(40, 2)
						}
					} else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
						this.state.pos += 2
						this.finishToken(18)
					} else {
						++this.state.pos
						this.finishToken(17)
					}
				}
				getTokenFromCode(code) {
					switch (code) {
						case 46:
							this.readToken_dot()
							return
						case 40:
							++this.state.pos
							this.finishToken(10)
							return
						case 41:
							++this.state.pos
							this.finishToken(11)
							return
						case 59:
							++this.state.pos
							this.finishToken(13)
							return
						case 44:
							++this.state.pos
							this.finishToken(12)
							return
						case 91:
							if (
								this.hasPlugin('recordAndTuple') &&
								this.input.charCodeAt(this.state.pos + 1) === 124
							) {
								if (
									this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar'
								) {
									throw this.raise(
										Errors.TupleExpressionBarIncorrectStartSyntaxType,
										this.state.curPosition(),
									)
								}
								this.state.pos += 2
								this.finishToken(2)
							} else {
								++this.state.pos
								this.finishToken(0)
							}
							return
						case 93:
							++this.state.pos
							this.finishToken(3)
							return
						case 123:
							if (
								this.hasPlugin('recordAndTuple') &&
								this.input.charCodeAt(this.state.pos + 1) === 124
							) {
								if (
									this.getPluginOption('recordAndTuple', 'syntaxType') !== 'bar'
								) {
									throw this.raise(
										Errors.RecordExpressionBarIncorrectStartSyntaxType,
										this.state.curPosition(),
									)
								}
								this.state.pos += 2
								this.finishToken(6)
							} else {
								++this.state.pos
								this.finishToken(5)
							}
							return
						case 125:
							++this.state.pos
							this.finishToken(8)
							return
						case 58:
							if (
								this.hasPlugin('functionBind') &&
								this.input.charCodeAt(this.state.pos + 1) === 58
							) {
								this.finishOp(15, 2)
							} else {
								++this.state.pos
								this.finishToken(14)
							}
							return
						case 63:
							this.readToken_question()
							return
						case 96:
							this.readTemplateToken()
							return
						case 48: {
							const next = this.input.charCodeAt(this.state.pos + 1)
							if (next === 120 || next === 88) {
								this.readRadixNumber(16)
								return
							}
							if (next === 111 || next === 79) {
								this.readRadixNumber(8)
								return
							}
							if (next === 98 || next === 66) {
								this.readRadixNumber(2)
								return
							}
						}
						case 49:
						case 50:
						case 51:
						case 52:
						case 53:
						case 54:
						case 55:
						case 56:
						case 57:
							this.readNumber(false)
							return
						case 34:
						case 39:
							this.readString(code)
							return
						case 47:
							this.readToken_slash()
							return
						case 37:
						case 42:
							this.readToken_mult_modulo(code)
							return
						case 124:
						case 38:
							this.readToken_pipe_amp(code)
							return
						case 94:
							this.readToken_caret()
							return
						case 43:
						case 45:
							this.readToken_plus_min(code)
							return
						case 60:
							this.readToken_lt()
							return
						case 62:
							this.readToken_gt()
							return
						case 61:
						case 33:
							this.readToken_eq_excl(code)
							return
						case 126:
							this.finishOp(36, 1)
							return
						case 64:
							this.readToken_atSign()
							return
						case 35:
							this.readToken_numberSign()
							return
						case 92:
							this.readWord()
							return
						default:
							if (isIdentifierStart(code)) {
								this.readWord(code)
								return
							}
					}
					throw this.raise(
						Errors.InvalidOrUnexpectedToken,
						this.state.curPosition(),
						{
							unexpected: String.fromCodePoint(code),
						},
					)
				}
				finishOp(type, size) {
					const str = this.input.slice(this.state.pos, this.state.pos + size)
					this.state.pos += size
					this.finishToken(type, str)
				}
				readRegexp() {
					const startLoc = this.state.startLoc
					const start = this.state.start + 1
					let escaped, inClass
					let { pos } = this.state
					for (; ; ++pos) {
						if (pos >= this.length) {
							throw this.raise(
								Errors.UnterminatedRegExp,
								createPositionWithColumnOffset(startLoc, 1),
							)
						}
						const ch = this.input.charCodeAt(pos)
						if (isNewLine(ch)) {
							throw this.raise(
								Errors.UnterminatedRegExp,
								createPositionWithColumnOffset(startLoc, 1),
							)
						}
						if (escaped) {
							escaped = false
						} else {
							if (ch === 91) {
								inClass = true
							} else if (ch === 93 && inClass) {
								inClass = false
							} else if (ch === 47 && !inClass) {
								break
							}
							escaped = ch === 92
						}
					}
					const content = this.input.slice(start, pos)
					++pos
					let mods = ''
					const nextPos = () =>
						createPositionWithColumnOffset(startLoc, pos + 2 - start)
					while (pos < this.length) {
						const cp = this.codePointAtPos(pos)
						const char = String.fromCharCode(cp)
						if (VALID_REGEX_FLAGS.has(cp)) {
							if (cp === 118) {
								if (mods.includes('u')) {
									this.raise(Errors.IncompatibleRegExpUVFlags, nextPos())
								}
							} else if (cp === 117) {
								if (mods.includes('v')) {
									this.raise(Errors.IncompatibleRegExpUVFlags, nextPos())
								}
							}
							if (mods.includes(char)) {
								this.raise(Errors.DuplicateRegExpFlags, nextPos())
							}
						} else if (isIdentifierChar(cp) || cp === 92) {
							this.raise(Errors.MalformedRegExpFlags, nextPos())
						} else {
							break
						}
						++pos
						mods += char
					}
					this.state.pos = pos
					this.finishToken(138, {
						pattern: content,
						flags: mods,
					})
				}
				readInt(radix, len, forceLen = false, allowNumSeparator = true) {
					const { n, pos } = readInt(
						this.input,
						this.state.pos,
						this.state.lineStart,
						this.state.curLine,
						radix,
						len,
						forceLen,
						allowNumSeparator,
						this.errorHandlers_readInt,
						false,
					)
					this.state.pos = pos
					return n
				}
				readRadixNumber(radix) {
					const start = this.state.pos
					const startLoc = this.state.curPosition()
					let isBigInt = false
					this.state.pos += 2
					const val = this.readInt(radix)
					if (val == null) {
						this.raise(
							Errors.InvalidDigit,
							createPositionWithColumnOffset(startLoc, 2),
							{
								radix,
							},
						)
					}
					const next = this.input.charCodeAt(this.state.pos)
					if (next === 110) {
						++this.state.pos
						isBigInt = true
					} else if (next === 109) {
						throw this.raise(Errors.InvalidDecimal, startLoc)
					}
					if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
						throw this.raise(Errors.NumberIdentifier, this.state.curPosition())
					}
					if (isBigInt) {
						const str = this.input
							.slice(start, this.state.pos)
							.replace(/[_n]/g, '')
						this.finishToken(136, str)
						return
					}
					this.finishToken(135, val)
				}
				readNumber(startsWithDot) {
					const start = this.state.pos
					const startLoc = this.state.curPosition()
					let isFloat = false
					let isBigInt = false
					let hasExponent = false
					let isOctal = false
					if (!startsWithDot && this.readInt(10) === null) {
						this.raise(Errors.InvalidNumber, this.state.curPosition())
					}
					const hasLeadingZero =
						this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48
					if (hasLeadingZero) {
						const integer = this.input.slice(start, this.state.pos)
						this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc)
						if (!this.state.strict) {
							const underscorePos = integer.indexOf('_')
							if (underscorePos > 0) {
								this.raise(
									Errors.ZeroDigitNumericSeparator,
									createPositionWithColumnOffset(startLoc, underscorePos),
								)
							}
						}
						isOctal = hasLeadingZero && !/[89]/.test(integer)
					}
					let next = this.input.charCodeAt(this.state.pos)
					if (next === 46 && !isOctal) {
						++this.state.pos
						this.readInt(10)
						isFloat = true
						next = this.input.charCodeAt(this.state.pos)
					}
					if ((next === 69 || next === 101) && !isOctal) {
						next = this.input.charCodeAt(++this.state.pos)
						if (next === 43 || next === 45) {
							++this.state.pos
						}
						if (this.readInt(10) === null) {
							this.raise(Errors.InvalidOrMissingExponent, startLoc)
						}
						isFloat = true
						hasExponent = true
						next = this.input.charCodeAt(this.state.pos)
					}
					if (next === 110) {
						if (isFloat || hasLeadingZero) {
							this.raise(Errors.InvalidBigIntLiteral, startLoc)
						}
						++this.state.pos
						isBigInt = true
					}
					if (next === 109) {
						this.expectPlugin('decimal', this.state.curPosition())
						if (hasExponent || hasLeadingZero) {
							this.raise(Errors.InvalidDecimal, startLoc)
						}
						++this.state.pos
						var isDecimal = true
					}
					if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
						throw this.raise(Errors.NumberIdentifier, this.state.curPosition())
					}
					const str = this.input
						.slice(start, this.state.pos)
						.replace(/[_mn]/g, '')
					if (isBigInt) {
						this.finishToken(136, str)
						return
					}
					if (isDecimal) {
						this.finishToken(137, str)
						return
					}
					const val = isOctal ? parseInt(str, 8) : parseFloat(str)
					this.finishToken(135, val)
				}
				readCodePoint(throwOnInvalid) {
					const { code, pos } = readCodePoint(
						this.input,
						this.state.pos,
						this.state.lineStart,
						this.state.curLine,
						throwOnInvalid,
						this.errorHandlers_readCodePoint,
					)
					this.state.pos = pos
					return code
				}
				readString(quote) {
					const { str, pos, curLine, lineStart } = readStringContents(
						quote === 34 ? 'double' : 'single',
						this.input,
						this.state.pos + 1,
						this.state.lineStart,
						this.state.curLine,
						this.errorHandlers_readStringContents_string,
					)
					this.state.pos = pos + 1
					this.state.lineStart = lineStart
					this.state.curLine = curLine
					this.finishToken(134, str)
				}
				readTemplateContinuation() {
					if (!this.match(8)) {
						this.unexpected(null, 8)
					}
					this.state.pos--
					this.readTemplateToken()
				}
				readTemplateToken() {
					const opening = this.input[this.state.pos]
					const { str, firstInvalidLoc, pos, curLine, lineStart } =
						readStringContents(
							'template',
							this.input,
							this.state.pos + 1,
							this.state.lineStart,
							this.state.curLine,
							this.errorHandlers_readStringContents_template,
						)
					this.state.pos = pos + 1
					this.state.lineStart = lineStart
					this.state.curLine = curLine
					if (firstInvalidLoc) {
						this.state.firstInvalidTemplateEscapePos = new Position(
							firstInvalidLoc.curLine,
							firstInvalidLoc.pos - firstInvalidLoc.lineStart,
							this.sourceToOffsetPos(firstInvalidLoc.pos),
						)
					}
					if (this.input.codePointAt(pos) === 96) {
						this.finishToken(24, firstInvalidLoc ? null : opening + str + '`')
					} else {
						this.state.pos++
						this.finishToken(25, firstInvalidLoc ? null : opening + str + '${')
					}
				}
				recordStrictModeErrors(toParseError, at) {
					const index = at.index
					if (this.state.strict && !this.state.strictErrors.has(index)) {
						this.raise(toParseError, at)
					} else {
						this.state.strictErrors.set(index, [toParseError, at])
					}
				}
				readWord1(firstCode) {
					this.state.containsEsc = false
					let word = ''
					const start = this.state.pos
					let chunkStart = this.state.pos
					if (firstCode !== undefined) {
						this.state.pos += firstCode <= 0xffff ? 1 : 2
					}
					while (this.state.pos < this.length) {
						const ch = this.codePointAtPos(this.state.pos)
						if (isIdentifierChar(ch)) {
							this.state.pos += ch <= 0xffff ? 1 : 2
						} else if (ch === 92) {
							this.state.containsEsc = true
							word += this.input.slice(chunkStart, this.state.pos)
							const escStart = this.state.curPosition()
							const identifierCheck =
								this.state.pos === start ? isIdentifierStart : isIdentifierChar
							if (this.input.charCodeAt(++this.state.pos) !== 117) {
								this.raise(
									Errors.MissingUnicodeEscape,
									this.state.curPosition(),
								)
								chunkStart = this.state.pos - 1
								continue
							}
							++this.state.pos
							const esc = this.readCodePoint(true)
							if (esc !== null) {
								if (!identifierCheck(esc)) {
									this.raise(Errors.EscapedCharNotAnIdentifier, escStart)
								}
								word += String.fromCodePoint(esc)
							}
							chunkStart = this.state.pos
						} else {
							break
						}
					}
					return word + this.input.slice(chunkStart, this.state.pos)
				}
				readWord(firstCode) {
					const word = this.readWord1(firstCode)
					const type = keywords$1.get(word)
					if (type !== undefined) {
						this.finishToken(type, tokenLabelName(type))
					} else {
						this.finishToken(132, word)
					}
				}
				checkKeywordEscapes() {
					const { type } = this.state
					if (tokenIsKeyword(type) && this.state.containsEsc) {
						this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {
							reservedWord: tokenLabelName(type),
						})
					}
				}
				raise(toParseError, at, details = {}) {
					const loc = at instanceof Position ? at : at.loc.start
					const error = toParseError(loc, details)
					if (!(this.optionFlags & 2048)) throw error
					if (!this.isLookahead) this.state.errors.push(error)
					return error
				}
				raiseOverwrite(toParseError, at, details = {}) {
					const loc = at instanceof Position ? at : at.loc.start
					const pos = loc.index
					const errors = this.state.errors
					for (let i = errors.length - 1; i >= 0; i--) {
						const error = errors[i]
						if (error.loc.index === pos) {
							return (errors[i] = toParseError(loc, details))
						}
						if (error.loc.index < pos) break
					}
					return this.raise(toParseError, at, details)
				}
				updateContext(prevType) {}
				unexpected(loc, type) {
					throw this.raise(
						Errors.UnexpectedToken,
						loc != null ? loc : this.state.startLoc,
						{
							expected: type ? tokenLabelName(type) : null,
						},
					)
				}
				expectPlugin(pluginName, loc) {
					if (this.hasPlugin(pluginName)) {
						return true
					}
					throw this.raise(
						Errors.MissingPlugin,
						loc != null ? loc : this.state.startLoc,
						{
							missingPlugin: [pluginName],
						},
					)
				}
				expectOnePlugin(pluginNames) {
					if (!pluginNames.some((name) => this.hasPlugin(name))) {
						throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {
							missingPlugin: pluginNames,
						})
					}
				}
				errorBuilder(error) {
					return (pos, lineStart, curLine) => {
						this.raise(error, buildPosition(pos, lineStart, curLine))
					}
				}
			}
			class ClassScope {
				constructor() {
					this.privateNames = new Set()
					this.loneAccessors = new Map()
					this.undefinedPrivateNames = new Map()
				}
			}
			class ClassScopeHandler {
				constructor(parser) {
					this.parser = void 0
					this.stack = []
					this.undefinedPrivateNames = new Map()
					this.parser = parser
				}
				current() {
					return this.stack[this.stack.length - 1]
				}
				enter() {
					this.stack.push(new ClassScope())
				}
				exit() {
					const oldClassScope = this.stack.pop()
					const current = this.current()
					for (const [name, loc] of Array.from(
						oldClassScope.undefinedPrivateNames,
					)) {
						if (current) {
							if (!current.undefinedPrivateNames.has(name)) {
								current.undefinedPrivateNames.set(name, loc)
							}
						} else {
							this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
								identifierName: name,
							})
						}
					}
				}
				declarePrivateName(name, elementType, loc) {
					const { privateNames, loneAccessors, undefinedPrivateNames } =
						this.current()
					let redefined = privateNames.has(name)
					if (elementType & 3) {
						const accessor = redefined && loneAccessors.get(name)
						if (accessor) {
							const oldStatic = accessor & 4
							const newStatic = elementType & 4
							const oldKind = accessor & 3
							const newKind = elementType & 3
							redefined = oldKind === newKind || oldStatic !== newStatic
							if (!redefined) loneAccessors.delete(name)
						} else if (!redefined) {
							loneAccessors.set(name, elementType)
						}
					}
					if (redefined) {
						this.parser.raise(Errors.PrivateNameRedeclaration, loc, {
							identifierName: name,
						})
					}
					privateNames.add(name)
					undefinedPrivateNames.delete(name)
				}
				usePrivateName(name, loc) {
					let classScope
					for (classScope of this.stack) {
						if (classScope.privateNames.has(name)) return
					}
					if (classScope) {
						classScope.undefinedPrivateNames.set(name, loc)
					} else {
						this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
							identifierName: name,
						})
					}
				}
			}
			class ExpressionScope {
				constructor(type = 0) {
					this.type = type
				}
				canBeArrowParameterDeclaration() {
					return this.type === 2 || this.type === 1
				}
				isCertainlyParameterDeclaration() {
					return this.type === 3
				}
			}
			class ArrowHeadParsingScope extends ExpressionScope {
				constructor(type) {
					super(type)
					this.declarationErrors = new Map()
				}
				recordDeclarationError(ParsingErrorClass, at) {
					const index = at.index
					this.declarationErrors.set(index, [ParsingErrorClass, at])
				}
				clearDeclarationError(index) {
					this.declarationErrors.delete(index)
				}
				iterateErrors(iterator) {
					this.declarationErrors.forEach(iterator)
				}
			}
			class ExpressionScopeHandler {
				constructor(parser) {
					this.parser = void 0
					this.stack = [new ExpressionScope()]
					this.parser = parser
				}
				enter(scope) {
					this.stack.push(scope)
				}
				exit() {
					this.stack.pop()
				}
				recordParameterInitializerError(toParseError, node) {
					const origin = node.loc.start
					const { stack } = this
					let i = stack.length - 1
					let scope = stack[i]
					while (!scope.isCertainlyParameterDeclaration()) {
						if (scope.canBeArrowParameterDeclaration()) {
							scope.recordDeclarationError(toParseError, origin)
						} else {
							return
						}
						scope = stack[--i]
					}
					this.parser.raise(toParseError, origin)
				}
				recordArrowParameterBindingError(error, node) {
					const { stack } = this
					const scope = stack[stack.length - 1]
					const origin = node.loc.start
					if (scope.isCertainlyParameterDeclaration()) {
						this.parser.raise(error, origin)
					} else if (scope.canBeArrowParameterDeclaration()) {
						scope.recordDeclarationError(error, origin)
					} else {
						return
					}
				}
				recordAsyncArrowParametersError(at) {
					const { stack } = this
					let i = stack.length - 1
					let scope = stack[i]
					while (scope.canBeArrowParameterDeclaration()) {
						if (scope.type === 2) {
							scope.recordDeclarationError(Errors.AwaitBindingIdentifier, at)
						}
						scope = stack[--i]
					}
				}
				validateAsPattern() {
					const { stack } = this
					const currentScope = stack[stack.length - 1]
					if (!currentScope.canBeArrowParameterDeclaration()) return
					currentScope.iterateErrors(([toParseError, loc]) => {
						this.parser.raise(toParseError, loc)
						let i = stack.length - 2
						let scope = stack[i]
						while (scope.canBeArrowParameterDeclaration()) {
							scope.clearDeclarationError(loc.index)
							scope = stack[--i]
						}
					})
				}
			}
			function newParameterDeclarationScope() {
				return new ExpressionScope(3)
			}
			function newArrowHeadScope() {
				return new ArrowHeadParsingScope(1)
			}
			function newAsyncArrowScope() {
				return new ArrowHeadParsingScope(2)
			}
			function newExpressionScope() {
				return new ExpressionScope()
			}
			class UtilParser extends Tokenizer {
				addExtra(node, key, value, enumerable = true) {
					if (!node) return
					let { extra } = node
					if (extra == null) {
						extra = {}
						node.extra = extra
					}
					if (enumerable) {
						extra[key] = value
					} else {
						Object.defineProperty(extra, key, {
							enumerable,
							value,
						})
					}
				}
				isContextual(token) {
					return this.state.type === token && !this.state.containsEsc
				}
				isUnparsedContextual(nameStart, name) {
					const nameEnd = nameStart + name.length
					if (this.input.slice(nameStart, nameEnd) === name) {
						const nextCh = this.input.charCodeAt(nameEnd)
						return !(isIdentifierChar(nextCh) || (nextCh & 0xfc00) === 0xd800)
					}
					return false
				}
				isLookaheadContextual(name) {
					const next = this.nextTokenStart()
					return this.isUnparsedContextual(next, name)
				}
				eatContextual(token) {
					if (this.isContextual(token)) {
						this.next()
						return true
					}
					return false
				}
				expectContextual(token, toParseError) {
					if (!this.eatContextual(token)) {
						if (toParseError != null) {
							throw this.raise(toParseError, this.state.startLoc)
						}
						this.unexpected(null, token)
					}
				}
				canInsertSemicolon() {
					return (
						this.match(140) || this.match(8) || this.hasPrecedingLineBreak()
					)
				}
				hasPrecedingLineBreak() {
					return hasNewLine(
						this.input,
						this.offsetToSourcePos(this.state.lastTokEndLoc.index),
						this.state.start,
					)
				}
				hasFollowingLineBreak() {
					return hasNewLine(this.input, this.state.end, this.nextTokenStart())
				}
				isLineTerminator() {
					return this.eat(13) || this.canInsertSemicolon()
				}
				semicolon(allowAsi = true) {
					if (allowAsi ? this.isLineTerminator() : this.eat(13)) return
					this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc)
				}
				expect(type, loc) {
					if (!this.eat(type)) {
						this.unexpected(loc, type)
					}
				}
				tryParse(fn, oldState = this.state.clone()) {
					const abortSignal = {
						node: null,
					}
					try {
						const node = fn((node = null) => {
							abortSignal.node = node
							throw abortSignal
						})
						if (this.state.errors.length > oldState.errors.length) {
							const failState = this.state
							this.state = oldState
							this.state.tokensLength = failState.tokensLength
							return {
								node,
								error: failState.errors[oldState.errors.length],
								thrown: false,
								aborted: false,
								failState,
							}
						}
						return {
							node,
							error: null,
							thrown: false,
							aborted: false,
							failState: null,
						}
					} catch (error) {
						const failState = this.state
						this.state = oldState
						if (error instanceof SyntaxError) {
							return {
								node: null,
								error,
								thrown: true,
								aborted: false,
								failState,
							}
						}
						if (error === abortSignal) {
							return {
								node: abortSignal.node,
								error: null,
								thrown: false,
								aborted: true,
								failState,
							}
						}
						throw error
					}
				}
				checkExpressionErrors(refExpressionErrors, andThrow) {
					if (!refExpressionErrors) return false
					const {
						shorthandAssignLoc,
						doubleProtoLoc,
						privateKeyLoc,
						optionalParametersLoc,
					} = refExpressionErrors
					const hasErrors =
						!!shorthandAssignLoc ||
						!!doubleProtoLoc ||
						!!optionalParametersLoc ||
						!!privateKeyLoc
					if (!andThrow) {
						return hasErrors
					}
					if (shorthandAssignLoc != null) {
						this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc)
					}
					if (doubleProtoLoc != null) {
						this.raise(Errors.DuplicateProto, doubleProtoLoc)
					}
					if (privateKeyLoc != null) {
						this.raise(Errors.UnexpectedPrivateField, privateKeyLoc)
					}
					if (optionalParametersLoc != null) {
						this.unexpected(optionalParametersLoc)
					}
				}
				isLiteralPropertyName() {
					return tokenIsLiteralPropertyName(this.state.type)
				}
				isPrivateName(node) {
					return node.type === 'PrivateName'
				}
				getPrivateNameSV(node) {
					return node.id.name
				}
				hasPropertyAsPrivateName(node) {
					return (
						(node.type === 'MemberExpression' ||
							node.type === 'OptionalMemberExpression') &&
						this.isPrivateName(node.property)
					)
				}
				isObjectProperty(node) {
					return node.type === 'ObjectProperty'
				}
				isObjectMethod(node) {
					return node.type === 'ObjectMethod'
				}
				initializeScopes(inModule = this.options.sourceType === 'module') {
					const oldLabels = this.state.labels
					this.state.labels = []
					const oldExportedIdentifiers = this.exportedIdentifiers
					this.exportedIdentifiers = new Set()
					const oldInModule = this.inModule
					this.inModule = inModule
					const oldScope = this.scope
					const ScopeHandler = this.getScopeHandler()
					this.scope = new ScopeHandler(this, inModule)
					const oldProdParam = this.prodParam
					this.prodParam = new ProductionParameterHandler()
					const oldClassScope = this.classScope
					this.classScope = new ClassScopeHandler(this)
					const oldExpressionScope = this.expressionScope
					this.expressionScope = new ExpressionScopeHandler(this)
					return () => {
						this.state.labels = oldLabels
						this.exportedIdentifiers = oldExportedIdentifiers
						this.inModule = oldInModule
						this.scope = oldScope
						this.prodParam = oldProdParam
						this.classScope = oldClassScope
						this.expressionScope = oldExpressionScope
					}
				}
				enterInitialScopes() {
					let paramFlags = 0
					if (this.inModule) {
						paramFlags |= 2
					}
					if (this.optionFlags & 32) {
						paramFlags |= 1
					}
					this.scope.enter(1)
					this.prodParam.enter(paramFlags)
				}
				checkDestructuringPrivate(refExpressionErrors) {
					const { privateKeyLoc } = refExpressionErrors
					if (privateKeyLoc !== null) {
						this.expectPlugin('destructuringPrivate', privateKeyLoc)
					}
				}
			}
			class ExpressionErrors {
				constructor() {
					this.shorthandAssignLoc = null
					this.doubleProtoLoc = null
					this.privateKeyLoc = null
					this.optionalParametersLoc = null
				}
			}
			class Node {
				constructor(parser, pos, loc) {
					this.type = ''
					this.start = pos
					this.end = 0
					this.loc = new SourceLocation(loc)
					if ((parser == null ? void 0 : parser.optionFlags) & 128)
						this.range = [pos, 0]
					if (parser != null && parser.filename)
						this.loc.filename = parser.filename
				}
			}
			const NodePrototype = Node.prototype
			{
				NodePrototype.__clone = function () {
					const newNode = new Node(undefined, this.start, this.loc.start)
					const keys = Object.keys(this)
					for (let i = 0, length = keys.length; i < length; i++) {
						const key = keys[i]
						if (
							key !== 'leadingComments' &&
							key !== 'trailingComments' &&
							key !== 'innerComments'
						) {
							newNode[key] = this[key]
						}
					}
					return newNode
				}
			}
			class NodeUtils extends UtilParser {
				startNode() {
					const loc = this.state.startLoc
					return new Node(this, loc.index, loc)
				}
				startNodeAt(loc) {
					return new Node(this, loc.index, loc)
				}
				startNodeAtNode(type) {
					return this.startNodeAt(type.loc.start)
				}
				finishNode(node, type) {
					return this.finishNodeAt(node, type, this.state.lastTokEndLoc)
				}
				finishNodeAt(node, type, endLoc) {
					node.type = type
					node.end = endLoc.index
					node.loc.end = endLoc
					if (this.optionFlags & 128) node.range[1] = endLoc.index
					if (this.optionFlags & 4096) {
						this.processComment(node)
					}
					return node
				}
				resetStartLocation(node, startLoc) {
					node.start = startLoc.index
					node.loc.start = startLoc
					if (this.optionFlags & 128) node.range[0] = startLoc.index
				}
				resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
					node.end = endLoc.index
					node.loc.end = endLoc
					if (this.optionFlags & 128) node.range[1] = endLoc.index
				}
				resetStartLocationFromNode(node, locationNode) {
					this.resetStartLocation(node, locationNode.loc.start)
				}
				castNodeTo(node, type) {
					node.type = type
					return node
				}
				cloneIdentifier(node) {
					const { type, start, end, loc, range, name } = node
					const cloned = Object.create(NodePrototype)
					cloned.type = type
					cloned.start = start
					cloned.end = end
					cloned.loc = loc
					cloned.range = range
					cloned.name = name
					if (node.extra) cloned.extra = node.extra
					return cloned
				}
				cloneStringLiteral(node) {
					const { type, start, end, loc, range, extra } = node
					const cloned = Object.create(NodePrototype)
					cloned.type = type
					cloned.start = start
					cloned.end = end
					cloned.loc = loc
					cloned.range = range
					cloned.extra = extra
					cloned.value = node.value
					return cloned
				}
			}
			const unwrapParenthesizedExpression = (node) => {
				return node.type === 'ParenthesizedExpression'
					? unwrapParenthesizedExpression(node.expression)
					: node
			}
			class LValParser extends NodeUtils {
				toAssignable(node, isLHS = false) {
					var _node$extra, _node$extra3
					let parenthesized = undefined
					if (
						node.type === 'ParenthesizedExpression' ||
						((_node$extra = node.extra) != null && _node$extra.parenthesized)
					) {
						parenthesized = unwrapParenthesizedExpression(node)
						if (isLHS) {
							if (parenthesized.type === 'Identifier') {
								this.expressionScope.recordArrowParameterBindingError(
									Errors.InvalidParenthesizedAssignment,
									node,
								)
							} else if (
								parenthesized.type !== 'MemberExpression' &&
								!this.isOptionalMemberExpression(parenthesized)
							) {
								this.raise(Errors.InvalidParenthesizedAssignment, node)
							}
						} else {
							this.raise(Errors.InvalidParenthesizedAssignment, node)
						}
					}
					switch (node.type) {
						case 'Identifier':
						case 'ObjectPattern':
						case 'ArrayPattern':
						case 'AssignmentPattern':
						case 'RestElement':
							break
						case 'ObjectExpression':
							this.castNodeTo(node, 'ObjectPattern')
							for (
								let i = 0, length = node.properties.length, last = length - 1;
								i < length;
								i++
							) {
								var _node$extra2
								const prop = node.properties[i]
								const isLast = i === last
								this.toAssignableObjectExpressionProp(prop, isLast, isLHS)
								if (
									isLast &&
									prop.type === 'RestElement' &&
									(_node$extra2 = node.extra) != null &&
									_node$extra2.trailingCommaLoc
								) {
									this.raise(
										Errors.RestTrailingComma,
										node.extra.trailingCommaLoc,
									)
								}
							}
							break
						case 'ObjectProperty': {
							const { key, value } = node
							if (this.isPrivateName(key)) {
								this.classScope.usePrivateName(
									this.getPrivateNameSV(key),
									key.loc.start,
								)
							}
							this.toAssignable(value, isLHS)
							break
						}
						case 'SpreadElement': {
							throw new Error(
								'Internal @babel/parser error (this is a bug, please report it).' +
									" SpreadElement should be converted by .toAssignable's caller.",
							)
						}
						case 'ArrayExpression':
							this.castNodeTo(node, 'ArrayPattern')
							this.toAssignableList(
								node.elements,
								(_node$extra3 = node.extra) == null
									? void 0
									: _node$extra3.trailingCommaLoc,
								isLHS,
							)
							break
						case 'AssignmentExpression':
							if (node.operator !== '=') {
								this.raise(Errors.MissingEqInAssignment, node.left.loc.end)
							}
							this.castNodeTo(node, 'AssignmentPattern')
							delete node.operator
							this.toAssignable(node.left, isLHS)
							break
						case 'ParenthesizedExpression':
							this.toAssignable(parenthesized, isLHS)
							break
					}
				}
				toAssignableObjectExpressionProp(prop, isLast, isLHS) {
					if (prop.type === 'ObjectMethod') {
						this.raise(
							prop.kind === 'get' || prop.kind === 'set'
								? Errors.PatternHasAccessor
								: Errors.PatternHasMethod,
							prop.key,
						)
					} else if (prop.type === 'SpreadElement') {
						this.castNodeTo(prop, 'RestElement')
						const arg = prop.argument
						this.checkToRestConversion(arg, false)
						this.toAssignable(arg, isLHS)
						if (!isLast) {
							this.raise(Errors.RestTrailingComma, prop)
						}
					} else {
						this.toAssignable(prop, isLHS)
					}
				}
				toAssignableList(exprList, trailingCommaLoc, isLHS) {
					const end = exprList.length - 1
					for (let i = 0; i <= end; i++) {
						const elt = exprList[i]
						if (!elt) continue
						this.toAssignableListItem(exprList, i, isLHS)
						if (elt.type === 'RestElement') {
							if (i < end) {
								this.raise(Errors.RestTrailingComma, elt)
							} else if (trailingCommaLoc) {
								this.raise(Errors.RestTrailingComma, trailingCommaLoc)
							}
						}
					}
				}
				toAssignableListItem(exprList, index, isLHS) {
					const node = exprList[index]
					if (node.type === 'SpreadElement') {
						this.castNodeTo(node, 'RestElement')
						const arg = node.argument
						this.checkToRestConversion(arg, true)
						this.toAssignable(arg, isLHS)
					} else {
						this.toAssignable(node, isLHS)
					}
				}
				isAssignable(node, isBinding) {
					switch (node.type) {
						case 'Identifier':
						case 'ObjectPattern':
						case 'ArrayPattern':
						case 'AssignmentPattern':
						case 'RestElement':
							return true
						case 'ObjectExpression': {
							const last = node.properties.length - 1
							return node.properties.every((prop, i) => {
								return (
									prop.type !== 'ObjectMethod' &&
									(i === last || prop.type !== 'SpreadElement') &&
									this.isAssignable(prop)
								)
							})
						}
						case 'ObjectProperty':
							return this.isAssignable(node.value)
						case 'SpreadElement':
							return this.isAssignable(node.argument)
						case 'ArrayExpression':
							return node.elements.every(
								(element) => element === null || this.isAssignable(element),
							)
						case 'AssignmentExpression':
							return node.operator === '='
						case 'ParenthesizedExpression':
							return this.isAssignable(node.expression)
						case 'MemberExpression':
						case 'OptionalMemberExpression':
							return !isBinding
						default:
							return false
					}
				}
				toReferencedList(exprList, isParenthesizedExpr) {
					return exprList
				}
				toReferencedListDeep(exprList, isParenthesizedExpr) {
					this.toReferencedList(exprList, isParenthesizedExpr)
					for (const expr of exprList) {
						if ((expr == null ? void 0 : expr.type) === 'ArrayExpression') {
							this.toReferencedListDeep(expr.elements)
						}
					}
				}
				parseSpread(refExpressionErrors) {
					const node = this.startNode()
					this.next()
					node.argument = this.parseMaybeAssignAllowIn(
						refExpressionErrors,
						undefined,
					)
					return this.finishNode(node, 'SpreadElement')
				}
				parseRestBinding() {
					const node = this.startNode()
					this.next()
					node.argument = this.parseBindingAtom()
					return this.finishNode(node, 'RestElement')
				}
				parseBindingAtom() {
					switch (this.state.type) {
						case 0: {
							const node = this.startNode()
							this.next()
							node.elements = this.parseBindingList(3, 93, 1)
							return this.finishNode(node, 'ArrayPattern')
						}
						case 5:
							return this.parseObjectLike(8, true)
					}
					return this.parseIdentifier()
				}
				parseBindingList(close, closeCharCode, flags) {
					const allowEmpty = flags & 1
					const elts = []
					let first = true
					while (!this.eat(close)) {
						if (first) {
							first = false
						} else {
							this.expect(12)
						}
						if (allowEmpty && this.match(12)) {
							elts.push(null)
						} else if (this.eat(close)) {
							break
						} else if (this.match(21)) {
							let rest = this.parseRestBinding()
							if (this.hasPlugin('flow') || flags & 2) {
								rest = this.parseFunctionParamType(rest)
							}
							elts.push(rest)
							if (!this.checkCommaAfterRest(closeCharCode)) {
								this.expect(close)
								break
							}
						} else {
							const decorators = []
							if (flags & 2) {
								if (this.match(26) && this.hasPlugin('decorators')) {
									this.raise(
										Errors.UnsupportedParameterDecorator,
										this.state.startLoc,
									)
								}
								while (this.match(26)) {
									decorators.push(this.parseDecorator())
								}
							}
							elts.push(this.parseBindingElement(flags, decorators))
						}
					}
					return elts
				}
				parseBindingRestProperty(prop) {
					this.next()
					prop.argument = this.parseIdentifier()
					this.checkCommaAfterRest(125)
					return this.finishNode(prop, 'RestElement')
				}
				parseBindingProperty() {
					const { type, startLoc } = this.state
					if (type === 21) {
						return this.parseBindingRestProperty(this.startNode())
					}
					const prop = this.startNode()
					if (type === 139) {
						this.expectPlugin('destructuringPrivate', startLoc)
						this.classScope.usePrivateName(this.state.value, startLoc)
						prop.key = this.parsePrivateName()
					} else {
						this.parsePropertyName(prop)
					}
					prop.method = false
					return this.parseObjPropValue(
						prop,
						startLoc,
						false,
						false,
						true,
						false,
					)
				}
				parseBindingElement(flags, decorators) {
					const left = this.parseMaybeDefault()
					if (this.hasPlugin('flow') || flags & 2) {
						this.parseFunctionParamType(left)
					}
					if (decorators.length) {
						left.decorators = decorators
						this.resetStartLocationFromNode(left, decorators[0])
					}
					const elt = this.parseMaybeDefault(left.loc.start, left)
					return elt
				}
				parseFunctionParamType(param) {
					return param
				}
				parseMaybeDefault(startLoc, left) {
					startLoc != null ? startLoc : (startLoc = this.state.startLoc)
					left = left != null ? left : this.parseBindingAtom()
					if (!this.eat(29)) return left
					const node = this.startNodeAt(startLoc)
					node.left = left
					node.right = this.parseMaybeAssignAllowIn()
					return this.finishNode(node, 'AssignmentPattern')
				}
				isValidLVal(type, isUnparenthesizedInAssign, binding) {
					switch (type) {
						case 'AssignmentPattern':
							return 'left'
						case 'RestElement':
							return 'argument'
						case 'ObjectProperty':
							return 'value'
						case 'ParenthesizedExpression':
							return 'expression'
						case 'ArrayPattern':
							return 'elements'
						case 'ObjectPattern':
							return 'properties'
					}
					return false
				}
				isOptionalMemberExpression(expression) {
					return expression.type === 'OptionalMemberExpression'
				}
				checkLVal(
					expression,
					ancestor,
					binding = 64,
					checkClashes = false,
					strictModeChanged = false,
					hasParenthesizedAncestor = false,
				) {
					var _expression$extra
					const type = expression.type
					if (this.isObjectMethod(expression)) return
					const isOptionalMemberExpression =
						this.isOptionalMemberExpression(expression)
					if (isOptionalMemberExpression || type === 'MemberExpression') {
						if (isOptionalMemberExpression) {
							this.expectPlugin('optionalChainingAssign', expression.loc.start)
							if (ancestor.type !== 'AssignmentExpression') {
								this.raise(Errors.InvalidLhsOptionalChaining, expression, {
									ancestor,
								})
							}
						}
						if (binding !== 64) {
							this.raise(Errors.InvalidPropertyBindingPattern, expression)
						}
						return
					}
					if (type === 'Identifier') {
						this.checkIdentifier(expression, binding, strictModeChanged)
						const { name } = expression
						if (checkClashes) {
							if (checkClashes.has(name)) {
								this.raise(Errors.ParamDupe, expression)
							} else {
								checkClashes.add(name)
							}
						}
						return
					}
					const validity = this.isValidLVal(
						type,
						!(
							hasParenthesizedAncestor ||
							((_expression$extra = expression.extra) != null &&
								_expression$extra.parenthesized)
						) && ancestor.type === 'AssignmentExpression',
						binding,
					)
					if (validity === true) return
					if (validity === false) {
						const ParseErrorClass =
							binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding
						this.raise(ParseErrorClass, expression, {
							ancestor,
						})
						return
					}
					let key, isParenthesizedExpression
					if (typeof validity === 'string') {
						key = validity
						isParenthesizedExpression = type === 'ParenthesizedExpression'
					} else {
						;[key, isParenthesizedExpression] = validity
					}
					const nextAncestor =
						type === 'ArrayPattern' || type === 'ObjectPattern'
							? {
									type,
								}
							: ancestor
					const val = expression[key]
					if (Array.isArray(val)) {
						for (const child of val) {
							if (child) {
								this.checkLVal(
									child,
									nextAncestor,
									binding,
									checkClashes,
									strictModeChanged,
									isParenthesizedExpression,
								)
							}
						}
					} else if (val) {
						this.checkLVal(
							val,
							nextAncestor,
							binding,
							checkClashes,
							strictModeChanged,
							isParenthesizedExpression,
						)
					}
				}
				checkIdentifier(at, bindingType, strictModeChanged = false) {
					if (
						this.state.strict &&
						(strictModeChanged
							? isStrictBindReservedWord(at.name, this.inModule)
							: isStrictBindOnlyReservedWord(at.name))
					) {
						if (bindingType === 64) {
							this.raise(Errors.StrictEvalArguments, at, {
								referenceName: at.name,
							})
						} else {
							this.raise(Errors.StrictEvalArgumentsBinding, at, {
								bindingName: at.name,
							})
						}
					}
					if (bindingType & 8192 && at.name === 'let') {
						this.raise(Errors.LetInLexicalBinding, at)
					}
					if (!(bindingType & 64)) {
						this.declareNameFromIdentifier(at, bindingType)
					}
				}
				declareNameFromIdentifier(identifier, binding) {
					this.scope.declareName(identifier.name, binding, identifier.loc.start)
				}
				checkToRestConversion(node, allowPattern) {
					switch (node.type) {
						case 'ParenthesizedExpression':
							this.checkToRestConversion(node.expression, allowPattern)
							break
						case 'Identifier':
						case 'MemberExpression':
							break
						case 'ArrayExpression':
						case 'ObjectExpression':
							if (allowPattern) break
						default:
							this.raise(Errors.InvalidRestAssignmentPattern, node)
					}
				}
				checkCommaAfterRest(close) {
					if (!this.match(12)) {
						return false
					}
					this.raise(
						this.lookaheadCharCode() === close
							? Errors.RestTrailingComma
							: Errors.ElementAfterRest,
						this.state.startLoc,
					)
					return true
				}
			}
			function nonNull(x) {
				if (x == null) {
					throw new Error(`Unexpected ${x} value.`)
				}
				return x
			}
			function assert(x) {
				if (!x) {
					throw new Error('Assert fail')
				}
			}
			const TSErrors = ParseErrorEnum`typescript`({
				AbstractMethodHasImplementation: ({ methodName }) =>
					`Method '${methodName}' cannot have an implementation because it is marked abstract.`,
				AbstractPropertyHasInitializer: ({ propertyName }) =>
					`Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
				AccessorCannotBeOptional:
					"An 'accessor' property cannot be declared optional.",
				AccessorCannotDeclareThisParameter:
					"'get' and 'set' accessors cannot declare 'this' parameters.",
				AccessorCannotHaveTypeParameters:
					'An accessor cannot have type parameters.',
				ClassMethodHasDeclare:
					"Class methods cannot have the 'declare' modifier.",
				ClassMethodHasReadonly:
					"Class methods cannot have the 'readonly' modifier.",
				ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference:
					"A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
				ConstructorHasTypeParameters:
					'Type parameters cannot appear on a constructor declaration.',
				DeclareAccessor: ({ kind }) =>
					`'declare' is not allowed in ${kind}ters.`,
				DeclareClassFieldHasInitializer:
					'Initializers are not allowed in ambient contexts.',
				DeclareFunctionHasImplementation:
					'An implementation cannot be declared in ambient contexts.',
				DuplicateAccessibilityModifier: ({ modifier }) =>
					`Accessibility modifier already seen.`,
				DuplicateModifier: ({ modifier }) =>
					`Duplicate modifier: '${modifier}'.`,
				EmptyHeritageClauseType: ({ token }) =>
					`'${token}' list cannot be empty.`,
				EmptyTypeArguments: 'Type argument list cannot be empty.',
				EmptyTypeParameters: 'Type parameter list cannot be empty.',
				ExpectedAmbientAfterExportDeclare:
					"'export declare' must be followed by an ambient declaration.",
				ImportAliasHasImportType: "An import alias can not use 'import type'.",
				ImportReflectionHasImportType:
					'An `import module` declaration can not use `type` modifier',
				IncompatibleModifiers: ({ modifiers }) =>
					`'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
				IndexSignatureHasAbstract:
					"Index signatures cannot have the 'abstract' modifier.",
				IndexSignatureHasAccessibility: ({ modifier }) =>
					`Index signatures cannot have an accessibility modifier ('${modifier}').`,
				IndexSignatureHasDeclare:
					"Index signatures cannot have the 'declare' modifier.",
				IndexSignatureHasOverride:
					"'override' modifier cannot appear on an index signature.",
				IndexSignatureHasStatic:
					"Index signatures cannot have the 'static' modifier.",
				InitializerNotAllowedInAmbientContext:
					'Initializers are not allowed in ambient contexts.',
				InvalidHeritageClauseType: ({ token }) =>
					`'${token}' list can only include identifiers or qualified-names with optional type arguments.`,
				InvalidModifierOnTypeMember: ({ modifier }) =>
					`'${modifier}' modifier cannot appear on a type member.`,
				InvalidModifierOnTypeParameter: ({ modifier }) =>
					`'${modifier}' modifier cannot appear on a type parameter.`,
				InvalidModifierOnTypeParameterPositions: ({ modifier }) =>
					`'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
				InvalidModifiersOrder: ({ orderedModifiers }) =>
					`'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
				InvalidPropertyAccessAfterInstantiationExpression:
					'Invalid property access after an instantiation expression. ' +
					'You can either wrap the instantiation expression in parentheses, or delete the type arguments.',
				InvalidTupleMemberLabel:
					'Tuple members must be labeled with a simple identifier.',
				MissingInterfaceName:
					"'interface' declarations must be followed by an identifier.",
				NonAbstractClassHasAbstractMethod:
					'Abstract methods can only appear within an abstract class.',
				NonClassMethodPropertyHasAbstractModifer:
					"'abstract' modifier can only appear on a class, method, or property declaration.",
				OptionalTypeBeforeRequired:
					'A required element cannot follow an optional element.',
				OverrideNotInSubClass:
					"This member cannot have an 'override' modifier because its containing class does not extend another class.",
				PatternIsOptional:
					'A binding pattern parameter cannot be optional in an implementation signature.',
				PrivateElementHasAbstract:
					"Private elements cannot have the 'abstract' modifier.",
				PrivateElementHasAccessibility: ({ modifier }) =>
					`Private elements cannot have an accessibility modifier ('${modifier}').`,
				ReadonlyForMethodSignature:
					"'readonly' modifier can only appear on a property declaration or index signature.",
				ReservedArrowTypeParam:
					'This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.',
				ReservedTypeAssertion:
					'This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.',
				SetAccessorCannotHaveOptionalParameter:
					"A 'set' accessor cannot have an optional parameter.",
				SetAccessorCannotHaveRestParameter:
					"A 'set' accessor cannot have rest parameter.",
				SetAccessorCannotHaveReturnType:
					"A 'set' accessor cannot have a return type annotation.",
				SingleTypeParameterWithoutTrailingComma: ({ typeParameterName }) =>
					`Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
				StaticBlockCannotHaveModifier:
					'Static class blocks cannot have any modifier.',
				TupleOptionalAfterType:
					'A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).',
				TypeAnnotationAfterAssign:
					'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.',
				TypeImportCannotSpecifyDefaultAndNamed:
					'A type-only import can specify a default import or named bindings, but not both.',
				TypeModifierIsUsedInTypeExports:
					"The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
				TypeModifierIsUsedInTypeImports:
					"The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
				UnexpectedParameterModifier:
					'A parameter property is only allowed in a constructor implementation.',
				UnexpectedReadonly:
					"'readonly' type modifier is only permitted on array and tuple literal types.",
				UnexpectedTypeAnnotation: 'Did not expect a type annotation here.',
				UnexpectedTypeCastInParameter:
					'Unexpected type cast in parameter position.',
				UnsupportedImportTypeArgument:
					'Argument in a type import must be a string literal.',
				UnsupportedParameterPropertyKind:
					'A parameter property may not be declared using a binding pattern.',
				UnsupportedSignatureParameterKind: ({ type }) =>
					`Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`,
			})
			function keywordTypeFromName(value) {
				switch (value) {
					case 'any':
						return 'TSAnyKeyword'
					case 'boolean':
						return 'TSBooleanKeyword'
					case 'bigint':
						return 'TSBigIntKeyword'
					case 'never':
						return 'TSNeverKeyword'
					case 'number':
						return 'TSNumberKeyword'
					case 'object':
						return 'TSObjectKeyword'
					case 'string':
						return 'TSStringKeyword'
					case 'symbol':
						return 'TSSymbolKeyword'
					case 'undefined':
						return 'TSUndefinedKeyword'
					case 'unknown':
						return 'TSUnknownKeyword'
					default:
						return undefined
				}
			}
			function tsIsAccessModifier(modifier) {
				return (
					modifier === 'private' ||
					modifier === 'public' ||
					modifier === 'protected'
				)
			}
			function tsIsVarianceAnnotations(modifier) {
				return modifier === 'in' || modifier === 'out'
			}
			var typescript = (superClass) =>
				class TypeScriptParserMixin extends superClass {
					constructor(...args) {
						super(...args)
						this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
							allowedModifiers: ['in', 'out'],
							disallowedModifiers: [
								'const',
								'public',
								'private',
								'protected',
								'readonly',
								'declare',
								'abstract',
								'override',
							],
							errorTemplate: TSErrors.InvalidModifierOnTypeParameter,
						})
						this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
							allowedModifiers: ['const'],
							disallowedModifiers: ['in', 'out'],
							errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions,
						})
						this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
							allowedModifiers: ['in', 'out', 'const'],
							disallowedModifiers: [
								'public',
								'private',
								'protected',
								'readonly',
								'declare',
								'abstract',
								'override',
							],
							errorTemplate: TSErrors.InvalidModifierOnTypeParameter,
						})
					}
					getScopeHandler() {
						return TypeScriptScopeHandler
					}
					tsIsIdentifier() {
						return tokenIsIdentifier(this.state.type)
					}
					tsTokenCanFollowModifier() {
						return (
							this.match(0) ||
							this.match(5) ||
							this.match(55) ||
							this.match(21) ||
							this.match(139) ||
							this.isLiteralPropertyName()
						)
					}
					tsNextTokenOnSameLineAndCanFollowModifier() {
						this.next()
						if (this.hasPrecedingLineBreak()) {
							return false
						}
						return this.tsTokenCanFollowModifier()
					}
					tsNextTokenCanFollowModifier() {
						if (this.match(106)) {
							this.next()
							return this.tsTokenCanFollowModifier()
						}
						return this.tsNextTokenOnSameLineAndCanFollowModifier()
					}
					tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
						if (
							!tokenIsIdentifier(this.state.type) &&
							this.state.type !== 58 &&
							this.state.type !== 75
						) {
							return undefined
						}
						const modifier = this.state.value
						if (allowedModifiers.includes(modifier)) {
							if (
								stopOnStartOfClassStaticBlock &&
								this.tsIsStartOfStaticBlocks()
							) {
								return undefined
							}
							if (
								this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))
							) {
								return modifier
							}
						}
						return undefined
					}
					tsParseModifiers(
						{
							allowedModifiers,
							disallowedModifiers,
							stopOnStartOfClassStaticBlock,
							errorTemplate = TSErrors.InvalidModifierOnTypeMember,
						},
						modified,
					) {
						const enforceOrder = (loc, modifier, before, after) => {
							if (modifier === before && modified[after]) {
								this.raise(TSErrors.InvalidModifiersOrder, loc, {
									orderedModifiers: [before, after],
								})
							}
						}
						const incompatible = (loc, modifier, mod1, mod2) => {
							if (
								(modified[mod1] && modifier === mod2) ||
								(modified[mod2] && modifier === mod1)
							) {
								this.raise(TSErrors.IncompatibleModifiers, loc, {
									modifiers: [mod1, mod2],
								})
							}
						}
						for (;;) {
							const { startLoc } = this.state
							const modifier = this.tsParseModifier(
								allowedModifiers.concat(
									disallowedModifiers != null ? disallowedModifiers : [],
								),
								stopOnStartOfClassStaticBlock,
							)
							if (!modifier) break
							if (tsIsAccessModifier(modifier)) {
								if (modified.accessibility) {
									this.raise(
										TSErrors.DuplicateAccessibilityModifier,
										startLoc,
										{
											modifier,
										},
									)
								} else {
									enforceOrder(startLoc, modifier, modifier, 'override')
									enforceOrder(startLoc, modifier, modifier, 'static')
									enforceOrder(startLoc, modifier, modifier, 'readonly')
									modified.accessibility = modifier
								}
							} else if (tsIsVarianceAnnotations(modifier)) {
								if (modified[modifier]) {
									this.raise(TSErrors.DuplicateModifier, startLoc, {
										modifier,
									})
								}
								modified[modifier] = true
								enforceOrder(startLoc, modifier, 'in', 'out')
							} else {
								if (hasOwnProperty.call(modified, modifier)) {
									this.raise(TSErrors.DuplicateModifier, startLoc, {
										modifier,
									})
								} else {
									enforceOrder(startLoc, modifier, 'static', 'readonly')
									enforceOrder(startLoc, modifier, 'static', 'override')
									enforceOrder(startLoc, modifier, 'override', 'readonly')
									enforceOrder(startLoc, modifier, 'abstract', 'override')
									incompatible(startLoc, modifier, 'declare', 'override')
									incompatible(startLoc, modifier, 'static', 'abstract')
								}
								modified[modifier] = true
							}
							if (
								disallowedModifiers != null &&
								disallowedModifiers.includes(modifier)
							) {
								this.raise(errorTemplate, startLoc, {
									modifier,
								})
							}
						}
					}
					tsIsListTerminator(kind) {
						switch (kind) {
							case 'EnumMembers':
							case 'TypeMembers':
								return this.match(8)
							case 'HeritageClauseElement':
								return this.match(5)
							case 'TupleElementTypes':
								return this.match(3)
							case 'TypeParametersOrArguments':
								return this.match(48)
						}
					}
					tsParseList(kind, parseElement) {
						const result = []
						while (!this.tsIsListTerminator(kind)) {
							result.push(parseElement())
						}
						return result
					}
					tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
						return nonNull(
							this.tsParseDelimitedListWorker(
								kind,
								parseElement,
								true,
								refTrailingCommaPos,
							),
						)
					}
					tsParseDelimitedListWorker(
						kind,
						parseElement,
						expectSuccess,
						refTrailingCommaPos,
					) {
						const result = []
						let trailingCommaPos = -1
						for (;;) {
							if (this.tsIsListTerminator(kind)) {
								break
							}
							trailingCommaPos = -1
							const element = parseElement()
							if (element == null) {
								return undefined
							}
							result.push(element)
							if (this.eat(12)) {
								trailingCommaPos = this.state.lastTokStartLoc.index
								continue
							}
							if (this.tsIsListTerminator(kind)) {
								break
							}
							if (expectSuccess) {
								this.expect(12)
							}
							return undefined
						}
						if (refTrailingCommaPos) {
							refTrailingCommaPos.value = trailingCommaPos
						}
						return result
					}
					tsParseBracketedList(
						kind,
						parseElement,
						bracket,
						skipFirstToken,
						refTrailingCommaPos,
					) {
						if (!skipFirstToken) {
							if (bracket) {
								this.expect(0)
							} else {
								this.expect(47)
							}
						}
						const result = this.tsParseDelimitedList(
							kind,
							parseElement,
							refTrailingCommaPos,
						)
						if (bracket) {
							this.expect(3)
						} else {
							this.expect(48)
						}
						return result
					}
					tsParseImportType() {
						const node = this.startNode()
						this.expect(83)
						this.expect(10)
						if (!this.match(134)) {
							this.raise(
								TSErrors.UnsupportedImportTypeArgument,
								this.state.startLoc,
							)
							{
								node.argument = super.parseExprAtom()
							}
						} else {
							{
								node.argument = this.parseStringLiteral(this.state.value)
							}
						}
						if (this.eat(12)) {
							node.options = this.tsParseImportTypeOptions()
						} else {
							node.options = null
						}
						this.expect(11)
						if (this.eat(16)) {
							node.qualifier = this.tsParseEntityName(1 | 2)
						}
						if (this.match(47)) {
							{
								node.typeParameters = this.tsParseTypeArguments()
							}
						}
						return this.finishNode(node, 'TSImportType')
					}
					tsParseImportTypeOptions() {
						const node = this.startNode()
						this.expect(5)
						const withProperty = this.startNode()
						if (this.isContextual(76)) {
							withProperty.method = false
							withProperty.key = this.parseIdentifier(true)
							withProperty.computed = false
							withProperty.shorthand = false
						} else {
							this.unexpected(null, 76)
						}
						this.expect(14)
						withProperty.value = this.tsParseImportTypeWithPropertyValue()
						node.properties = [this.finishObjectProperty(withProperty)]
						this.expect(8)
						return this.finishNode(node, 'ObjectExpression')
					}
					tsParseImportTypeWithPropertyValue() {
						const node = this.startNode()
						const properties = []
						this.expect(5)
						while (!this.match(8)) {
							const type = this.state.type
							if (tokenIsIdentifier(type) || type === 134) {
								properties.push(super.parsePropertyDefinition(null))
							} else {
								this.unexpected()
							}
							this.eat(12)
						}
						node.properties = properties
						this.next()
						return this.finishNode(node, 'ObjectExpression')
					}
					tsParseEntityName(flags) {
						let entity
						if (flags & 1 && this.match(78)) {
							if (flags & 2) {
								entity = this.parseIdentifier(true)
							} else {
								const node = this.startNode()
								this.next()
								entity = this.finishNode(node, 'ThisExpression')
							}
						} else {
							entity = this.parseIdentifier(!!(flags & 1))
						}
						while (this.eat(16)) {
							const node = this.startNodeAtNode(entity)
							node.left = entity
							node.right = this.parseIdentifier(!!(flags & 1))
							entity = this.finishNode(node, 'TSQualifiedName')
						}
						return entity
					}
					tsParseTypeReference() {
						const node = this.startNode()
						node.typeName = this.tsParseEntityName(1)
						if (!this.hasPrecedingLineBreak() && this.match(47)) {
							{
								node.typeParameters = this.tsParseTypeArguments()
							}
						}
						return this.finishNode(node, 'TSTypeReference')
					}
					tsParseThisTypePredicate(lhs) {
						this.next()
						const node = this.startNodeAtNode(lhs)
						node.parameterName = lhs
						node.typeAnnotation = this.tsParseTypeAnnotation(false)
						node.asserts = false
						return this.finishNode(node, 'TSTypePredicate')
					}
					tsParseThisTypeNode() {
						const node = this.startNode()
						this.next()
						return this.finishNode(node, 'TSThisType')
					}
					tsParseTypeQuery() {
						const node = this.startNode()
						this.expect(87)
						if (this.match(83)) {
							node.exprName = this.tsParseImportType()
						} else {
							{
								node.exprName = this.tsParseEntityName(1 | 2)
							}
						}
						if (!this.hasPrecedingLineBreak() && this.match(47)) {
							{
								node.typeParameters = this.tsParseTypeArguments()
							}
						}
						return this.finishNode(node, 'TSTypeQuery')
					}
					tsParseTypeParameter(parseModifiers) {
						const node = this.startNode()
						parseModifiers(node)
						node.name = this.tsParseTypeParameterName()
						node.constraint = this.tsEatThenParseType(81)
						node.default = this.tsEatThenParseType(29)
						return this.finishNode(node, 'TSTypeParameter')
					}
					tsTryParseTypeParameters(parseModifiers) {
						if (this.match(47)) {
							return this.tsParseTypeParameters(parseModifiers)
						}
					}
					tsParseTypeParameters(parseModifiers) {
						const node = this.startNode()
						if (this.match(47) || this.match(143)) {
							this.next()
						} else {
							this.unexpected()
						}
						const refTrailingCommaPos = {
							value: -1,
						}
						node.params = this.tsParseBracketedList(
							'TypeParametersOrArguments',
							this.tsParseTypeParameter.bind(this, parseModifiers),
							false,
							true,
							refTrailingCommaPos,
						)
						if (node.params.length === 0) {
							this.raise(TSErrors.EmptyTypeParameters, node)
						}
						if (refTrailingCommaPos.value !== -1) {
							this.addExtra(node, 'trailingComma', refTrailingCommaPos.value)
						}
						return this.finishNode(node, 'TSTypeParameterDeclaration')
					}
					tsFillSignature(returnToken, signature) {
						const returnTokenRequired = returnToken === 19
						const paramsKey = 'parameters'
						const returnTypeKey = 'typeAnnotation'
						signature.typeParameters = this.tsTryParseTypeParameters(
							this.tsParseConstModifier,
						)
						this.expect(10)
						signature[paramsKey] = this.tsParseBindingListForSignature()
						if (returnTokenRequired) {
							signature[returnTypeKey] =
								this.tsParseTypeOrTypePredicateAnnotation(returnToken)
						} else if (this.match(returnToken)) {
							signature[returnTypeKey] =
								this.tsParseTypeOrTypePredicateAnnotation(returnToken)
						}
					}
					tsParseBindingListForSignature() {
						const list = super.parseBindingList(11, 41, 2)
						for (const pattern of list) {
							const { type } = pattern
							if (
								type === 'AssignmentPattern' ||
								type === 'TSParameterProperty'
							) {
								this.raise(
									TSErrors.UnsupportedSignatureParameterKind,
									pattern,
									{
										type,
									},
								)
							}
						}
						return list
					}
					tsParseTypeMemberSemicolon() {
						if (!this.eat(12) && !this.isLineTerminator()) {
							this.expect(13)
						}
					}
					tsParseSignatureMember(kind, node) {
						this.tsFillSignature(14, node)
						this.tsParseTypeMemberSemicolon()
						return this.finishNode(node, kind)
					}
					tsIsUnambiguouslyIndexSignature() {
						this.next()
						if (tokenIsIdentifier(this.state.type)) {
							this.next()
							return this.match(14)
						}
						return false
					}
					tsTryParseIndexSignature(node) {
						if (
							!(
								this.match(0) &&
								this.tsLookAhead(
									this.tsIsUnambiguouslyIndexSignature.bind(this),
								)
							)
						) {
							return
						}
						this.expect(0)
						const id = this.parseIdentifier()
						id.typeAnnotation = this.tsParseTypeAnnotation()
						this.resetEndLocation(id)
						this.expect(3)
						node.parameters = [id]
						const type = this.tsTryParseTypeAnnotation()
						if (type) node.typeAnnotation = type
						this.tsParseTypeMemberSemicolon()
						return this.finishNode(node, 'TSIndexSignature')
					}
					tsParsePropertyOrMethodSignature(node, readonly) {
						if (this.eat(17)) node.optional = true
						if (this.match(10) || this.match(47)) {
							if (readonly) {
								this.raise(TSErrors.ReadonlyForMethodSignature, node)
							}
							const method = node
							if (method.kind && this.match(47)) {
								this.raise(
									TSErrors.AccessorCannotHaveTypeParameters,
									this.state.curPosition(),
								)
							}
							this.tsFillSignature(14, method)
							this.tsParseTypeMemberSemicolon()
							const paramsKey = 'parameters'
							const returnTypeKey = 'typeAnnotation'
							if (method.kind === 'get') {
								if (method[paramsKey].length > 0) {
									this.raise(Errors.BadGetterArity, this.state.curPosition())
									if (this.isThisParam(method[paramsKey][0])) {
										this.raise(
											TSErrors.AccessorCannotDeclareThisParameter,
											this.state.curPosition(),
										)
									}
								}
							} else if (method.kind === 'set') {
								if (method[paramsKey].length !== 1) {
									this.raise(Errors.BadSetterArity, this.state.curPosition())
								} else {
									const firstParameter = method[paramsKey][0]
									if (this.isThisParam(firstParameter)) {
										this.raise(
											TSErrors.AccessorCannotDeclareThisParameter,
											this.state.curPosition(),
										)
									}
									if (
										firstParameter.type === 'Identifier' &&
										firstParameter.optional
									) {
										this.raise(
											TSErrors.SetAccessorCannotHaveOptionalParameter,
											this.state.curPosition(),
										)
									}
									if (firstParameter.type === 'RestElement') {
										this.raise(
											TSErrors.SetAccessorCannotHaveRestParameter,
											this.state.curPosition(),
										)
									}
								}
								if (method[returnTypeKey]) {
									this.raise(
										TSErrors.SetAccessorCannotHaveReturnType,
										method[returnTypeKey],
									)
								}
							} else {
								method.kind = 'method'
							}
							return this.finishNode(method, 'TSMethodSignature')
						} else {
							const property = node
							if (readonly) property.readonly = true
							const type = this.tsTryParseTypeAnnotation()
							if (type) property.typeAnnotation = type
							this.tsParseTypeMemberSemicolon()
							return this.finishNode(property, 'TSPropertySignature')
						}
					}
					tsParseTypeMember() {
						const node = this.startNode()
						if (this.match(10) || this.match(47)) {
							return this.tsParseSignatureMember(
								'TSCallSignatureDeclaration',
								node,
							)
						}
						if (this.match(77)) {
							const id = this.startNode()
							this.next()
							if (this.match(10) || this.match(47)) {
								return this.tsParseSignatureMember(
									'TSConstructSignatureDeclaration',
									node,
								)
							} else {
								node.key = this.createIdentifier(id, 'new')
								return this.tsParsePropertyOrMethodSignature(node, false)
							}
						}
						this.tsParseModifiers(
							{
								allowedModifiers: ['readonly'],
								disallowedModifiers: [
									'declare',
									'abstract',
									'private',
									'protected',
									'public',
									'static',
									'override',
								],
							},
							node,
						)
						const idx = this.tsTryParseIndexSignature(node)
						if (idx) {
							return idx
						}
						super.parsePropertyName(node)
						if (
							!node.computed &&
							node.key.type === 'Identifier' &&
							(node.key.name === 'get' || node.key.name === 'set') &&
							this.tsTokenCanFollowModifier()
						) {
							node.kind = node.key.name
							super.parsePropertyName(node)
							if (!this.match(10) && !this.match(47)) {
								this.unexpected(null, 10)
							}
						}
						return this.tsParsePropertyOrMethodSignature(node, !!node.readonly)
					}
					tsParseTypeLiteral() {
						const node = this.startNode()
						node.members = this.tsParseObjectTypeMembers()
						return this.finishNode(node, 'TSTypeLiteral')
					}
					tsParseObjectTypeMembers() {
						this.expect(5)
						const members = this.tsParseList(
							'TypeMembers',
							this.tsParseTypeMember.bind(this),
						)
						this.expect(8)
						return members
					}
					tsIsStartOfMappedType() {
						this.next()
						if (this.eat(53)) {
							return this.isContextual(122)
						}
						if (this.isContextual(122)) {
							this.next()
						}
						if (!this.match(0)) {
							return false
						}
						this.next()
						if (!this.tsIsIdentifier()) {
							return false
						}
						this.next()
						return this.match(58)
					}
					tsParseMappedType() {
						const node = this.startNode()
						this.expect(5)
						if (this.match(53)) {
							node.readonly = this.state.value
							this.next()
							this.expectContextual(122)
						} else if (this.eatContextual(122)) {
							node.readonly = true
						}
						this.expect(0)
						{
							const typeParameter = this.startNode()
							typeParameter.name = this.tsParseTypeParameterName()
							typeParameter.constraint = this.tsExpectThenParseType(58)
							node.typeParameter = this.finishNode(
								typeParameter,
								'TSTypeParameter',
							)
						}
						node.nameType = this.eatContextual(93) ? this.tsParseType() : null
						this.expect(3)
						if (this.match(53)) {
							node.optional = this.state.value
							this.next()
							this.expect(17)
						} else if (this.eat(17)) {
							node.optional = true
						}
						node.typeAnnotation = this.tsTryParseType()
						this.semicolon()
						this.expect(8)
						return this.finishNode(node, 'TSMappedType')
					}
					tsParseTupleType() {
						const node = this.startNode()
						node.elementTypes = this.tsParseBracketedList(
							'TupleElementTypes',
							this.tsParseTupleElementType.bind(this),
							true,
							false,
						)
						let seenOptionalElement = false
						node.elementTypes.forEach((elementNode) => {
							const { type } = elementNode
							if (
								seenOptionalElement &&
								type !== 'TSRestType' &&
								type !== 'TSOptionalType' &&
								!(type === 'TSNamedTupleMember' && elementNode.optional)
							) {
								this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode)
							}
							seenOptionalElement ||
								(seenOptionalElement =
									(type === 'TSNamedTupleMember' && elementNode.optional) ||
									type === 'TSOptionalType')
						})
						return this.finishNode(node, 'TSTupleType')
					}
					tsParseTupleElementType() {
						const restStartLoc = this.state.startLoc
						const rest = this.eat(21)
						const { startLoc } = this.state
						let labeled
						let label
						let optional
						let type
						const isWord = tokenIsKeywordOrIdentifier(this.state.type)
						const chAfterWord = isWord ? this.lookaheadCharCode() : null
						if (chAfterWord === 58) {
							labeled = true
							optional = false
							label = this.parseIdentifier(true)
							this.expect(14)
							type = this.tsParseType()
						} else if (chAfterWord === 63) {
							optional = true
							const wordName = this.state.value
							const typeOrLabel = this.tsParseNonArrayType()
							if (this.lookaheadCharCode() === 58) {
								labeled = true
								label = this.createIdentifier(
									this.startNodeAt(startLoc),
									wordName,
								)
								this.expect(17)
								this.expect(14)
								type = this.tsParseType()
							} else {
								labeled = false
								type = typeOrLabel
								this.expect(17)
							}
						} else {
							type = this.tsParseType()
							optional = this.eat(17)
							labeled = this.eat(14)
						}
						if (labeled) {
							let labeledNode
							if (label) {
								labeledNode = this.startNodeAt(startLoc)
								labeledNode.optional = optional
								labeledNode.label = label
								labeledNode.elementType = type
								if (this.eat(17)) {
									labeledNode.optional = true
									this.raise(
										TSErrors.TupleOptionalAfterType,
										this.state.lastTokStartLoc,
									)
								}
							} else {
								labeledNode = this.startNodeAt(startLoc)
								labeledNode.optional = optional
								this.raise(TSErrors.InvalidTupleMemberLabel, type)
								labeledNode.label = type
								labeledNode.elementType = this.tsParseType()
							}
							type = this.finishNode(labeledNode, 'TSNamedTupleMember')
						} else if (optional) {
							const optionalTypeNode = this.startNodeAt(startLoc)
							optionalTypeNode.typeAnnotation = type
							type = this.finishNode(optionalTypeNode, 'TSOptionalType')
						}
						if (rest) {
							const restNode = this.startNodeAt(restStartLoc)
							restNode.typeAnnotation = type
							type = this.finishNode(restNode, 'TSRestType')
						}
						return type
					}
					tsParseParenthesizedType() {
						const node = this.startNode()
						this.expect(10)
						node.typeAnnotation = this.tsParseType()
						this.expect(11)
						return this.finishNode(node, 'TSParenthesizedType')
					}
					tsParseFunctionOrConstructorType(type, abstract) {
						const node = this.startNode()
						if (type === 'TSConstructorType') {
							node.abstract = !!abstract
							if (abstract) this.next()
							this.next()
						}
						this.tsInAllowConditionalTypesContext(() =>
							this.tsFillSignature(19, node),
						)
						return this.finishNode(node, type)
					}
					tsParseLiteralTypeNode() {
						const node = this.startNode()
						switch (this.state.type) {
							case 135:
							case 136:
							case 134:
							case 85:
							case 86:
								node.literal = super.parseExprAtom()
								break
							default:
								this.unexpected()
						}
						return this.finishNode(node, 'TSLiteralType')
					}
					tsParseTemplateLiteralType() {
						{
							const node = this.startNode()
							node.literal = super.parseTemplate(false)
							return this.finishNode(node, 'TSLiteralType')
						}
					}
					parseTemplateSubstitution() {
						if (this.state.inType) return this.tsParseType()
						return super.parseTemplateSubstitution()
					}
					tsParseThisTypeOrThisTypePredicate() {
						const thisKeyword = this.tsParseThisTypeNode()
						if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
							return this.tsParseThisTypePredicate(thisKeyword)
						} else {
							return thisKeyword
						}
					}
					tsParseNonArrayType() {
						switch (this.state.type) {
							case 134:
							case 135:
							case 136:
							case 85:
							case 86:
								return this.tsParseLiteralTypeNode()
							case 53:
								if (this.state.value === '-') {
									const node = this.startNode()
									const nextToken = this.lookahead()
									if (nextToken.type !== 135 && nextToken.type !== 136) {
										this.unexpected()
									}
									node.literal = this.parseMaybeUnary()
									return this.finishNode(node, 'TSLiteralType')
								}
								break
							case 78:
								return this.tsParseThisTypeOrThisTypePredicate()
							case 87:
								return this.tsParseTypeQuery()
							case 83:
								return this.tsParseImportType()
							case 5:
								return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this))
									? this.tsParseMappedType()
									: this.tsParseTypeLiteral()
							case 0:
								return this.tsParseTupleType()
							case 10:
								return this.tsParseParenthesizedType()
							case 25:
							case 24:
								return this.tsParseTemplateLiteralType()
							default: {
								const { type } = this.state
								if (tokenIsIdentifier(type) || type === 88 || type === 84) {
									const nodeType =
										type === 88
											? 'TSVoidKeyword'
											: type === 84
												? 'TSNullKeyword'
												: keywordTypeFromName(this.state.value)
									if (
										nodeType !== undefined &&
										this.lookaheadCharCode() !== 46
									) {
										const node = this.startNode()
										this.next()
										return this.finishNode(node, nodeType)
									}
									return this.tsParseTypeReference()
								}
							}
						}
						this.unexpected()
					}
					tsParseArrayTypeOrHigher() {
						const { startLoc } = this.state
						let type = this.tsParseNonArrayType()
						while (!this.hasPrecedingLineBreak() && this.eat(0)) {
							if (this.match(3)) {
								const node = this.startNodeAt(startLoc)
								node.elementType = type
								this.expect(3)
								type = this.finishNode(node, 'TSArrayType')
							} else {
								const node = this.startNodeAt(startLoc)
								node.objectType = type
								node.indexType = this.tsParseType()
								this.expect(3)
								type = this.finishNode(node, 'TSIndexedAccessType')
							}
						}
						return type
					}
					tsParseTypeOperator() {
						const node = this.startNode()
						const operator = this.state.value
						this.next()
						node.operator = operator
						node.typeAnnotation = this.tsParseTypeOperatorOrHigher()
						if (operator === 'readonly') {
							this.tsCheckTypeAnnotationForReadOnly(node)
						}
						return this.finishNode(node, 'TSTypeOperator')
					}
					tsCheckTypeAnnotationForReadOnly(node) {
						switch (node.typeAnnotation.type) {
							case 'TSTupleType':
							case 'TSArrayType':
								return
							default:
								this.raise(TSErrors.UnexpectedReadonly, node)
						}
					}
					tsParseInferType() {
						const node = this.startNode()
						this.expectContextual(115)
						const typeParameter = this.startNode()
						typeParameter.name = this.tsParseTypeParameterName()
						typeParameter.constraint = this.tsTryParse(() =>
							this.tsParseConstraintForInferType(),
						)
						node.typeParameter = this.finishNode(
							typeParameter,
							'TSTypeParameter',
						)
						return this.finishNode(node, 'TSInferType')
					}
					tsParseConstraintForInferType() {
						if (this.eat(81)) {
							const constraint = this.tsInDisallowConditionalTypesContext(() =>
								this.tsParseType(),
							)
							if (
								this.state.inDisallowConditionalTypesContext ||
								!this.match(17)
							) {
								return constraint
							}
						}
					}
					tsParseTypeOperatorOrHigher() {
						const isTypeOperator =
							tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc
						return isTypeOperator
							? this.tsParseTypeOperator()
							: this.isContextual(115)
								? this.tsParseInferType()
								: this.tsInAllowConditionalTypesContext(() =>
										this.tsParseArrayTypeOrHigher(),
									)
					}
					tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
						const node = this.startNode()
						const hasLeadingOperator = this.eat(operator)
						const types = []
						do {
							types.push(parseConstituentType())
						} while (this.eat(operator))
						if (types.length === 1 && !hasLeadingOperator) {
							return types[0]
						}
						node.types = types
						return this.finishNode(node, kind)
					}
					tsParseIntersectionTypeOrHigher() {
						return this.tsParseUnionOrIntersectionType(
							'TSIntersectionType',
							this.tsParseTypeOperatorOrHigher.bind(this),
							45,
						)
					}
					tsParseUnionTypeOrHigher() {
						return this.tsParseUnionOrIntersectionType(
							'TSUnionType',
							this.tsParseIntersectionTypeOrHigher.bind(this),
							43,
						)
					}
					tsIsStartOfFunctionType() {
						if (this.match(47)) {
							return true
						}
						return (
							this.match(10) &&
							this.tsLookAhead(
								this.tsIsUnambiguouslyStartOfFunctionType.bind(this),
							)
						)
					}
					tsSkipParameterStart() {
						if (tokenIsIdentifier(this.state.type) || this.match(78)) {
							this.next()
							return true
						}
						if (this.match(5)) {
							const { errors } = this.state
							const previousErrorCount = errors.length
							try {
								this.parseObjectLike(8, true)
								return errors.length === previousErrorCount
							} catch (_unused) {
								return false
							}
						}
						if (this.match(0)) {
							this.next()
							const { errors } = this.state
							const previousErrorCount = errors.length
							try {
								super.parseBindingList(3, 93, 1)
								return errors.length === previousErrorCount
							} catch (_unused2) {
								return false
							}
						}
						return false
					}
					tsIsUnambiguouslyStartOfFunctionType() {
						this.next()
						if (this.match(11) || this.match(21)) {
							return true
						}
						if (this.tsSkipParameterStart()) {
							if (
								this.match(14) ||
								this.match(12) ||
								this.match(17) ||
								this.match(29)
							) {
								return true
							}
							if (this.match(11)) {
								this.next()
								if (this.match(19)) {
									return true
								}
							}
						}
						return false
					}
					tsParseTypeOrTypePredicateAnnotation(returnToken) {
						return this.tsInType(() => {
							const t = this.startNode()
							this.expect(returnToken)
							const node = this.startNode()
							const asserts = !!this.tsTryParse(
								this.tsParseTypePredicateAsserts.bind(this),
							)
							if (asserts && this.match(78)) {
								let thisTypePredicate =
									this.tsParseThisTypeOrThisTypePredicate()
								if (thisTypePredicate.type === 'TSThisType') {
									node.parameterName = thisTypePredicate
									node.asserts = true
									node.typeAnnotation = null
									thisTypePredicate = this.finishNode(node, 'TSTypePredicate')
								} else {
									this.resetStartLocationFromNode(thisTypePredicate, node)
									thisTypePredicate.asserts = true
								}
								t.typeAnnotation = thisTypePredicate
								return this.finishNode(t, 'TSTypeAnnotation')
							}
							const typePredicateVariable =
								this.tsIsIdentifier() &&
								this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this))
							if (!typePredicateVariable) {
								if (!asserts) {
									return this.tsParseTypeAnnotation(false, t)
								}
								node.parameterName = this.parseIdentifier()
								node.asserts = asserts
								node.typeAnnotation = null
								t.typeAnnotation = this.finishNode(node, 'TSTypePredicate')
								return this.finishNode(t, 'TSTypeAnnotation')
							}
							const type = this.tsParseTypeAnnotation(false)
							node.parameterName = typePredicateVariable
							node.typeAnnotation = type
							node.asserts = asserts
							t.typeAnnotation = this.finishNode(node, 'TSTypePredicate')
							return this.finishNode(t, 'TSTypeAnnotation')
						})
					}
					tsTryParseTypeOrTypePredicateAnnotation() {
						if (this.match(14)) {
							return this.tsParseTypeOrTypePredicateAnnotation(14)
						}
					}
					tsTryParseTypeAnnotation() {
						if (this.match(14)) {
							return this.tsParseTypeAnnotation()
						}
					}
					tsTryParseType() {
						return this.tsEatThenParseType(14)
					}
					tsParseTypePredicatePrefix() {
						const id = this.parseIdentifier()
						if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
							this.next()
							return id
						}
					}
					tsParseTypePredicateAsserts() {
						if (this.state.type !== 109) {
							return false
						}
						const containsEsc = this.state.containsEsc
						this.next()
						if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
							return false
						}
						if (containsEsc) {
							this.raise(
								Errors.InvalidEscapedReservedWord,
								this.state.lastTokStartLoc,
								{
									reservedWord: 'asserts',
								},
							)
						}
						return true
					}
					tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
						this.tsInType(() => {
							if (eatColon) this.expect(14)
							t.typeAnnotation = this.tsParseType()
						})
						return this.finishNode(t, 'TSTypeAnnotation')
					}
					tsParseType() {
						assert(this.state.inType)
						const type = this.tsParseNonConditionalType()
						if (
							this.state.inDisallowConditionalTypesContext ||
							this.hasPrecedingLineBreak() ||
							!this.eat(81)
						) {
							return type
						}
						const node = this.startNodeAtNode(type)
						node.checkType = type
						node.extendsType = this.tsInDisallowConditionalTypesContext(() =>
							this.tsParseNonConditionalType(),
						)
						this.expect(17)
						node.trueType = this.tsInAllowConditionalTypesContext(() =>
							this.tsParseType(),
						)
						this.expect(14)
						node.falseType = this.tsInAllowConditionalTypesContext(() =>
							this.tsParseType(),
						)
						return this.finishNode(node, 'TSConditionalType')
					}
					isAbstractConstructorSignature() {
						return this.isContextual(124) && this.lookahead().type === 77
					}
					tsParseNonConditionalType() {
						if (this.tsIsStartOfFunctionType()) {
							return this.tsParseFunctionOrConstructorType('TSFunctionType')
						}
						if (this.match(77)) {
							return this.tsParseFunctionOrConstructorType('TSConstructorType')
						} else if (this.isAbstractConstructorSignature()) {
							return this.tsParseFunctionOrConstructorType(
								'TSConstructorType',
								true,
							)
						}
						return this.tsParseUnionTypeOrHigher()
					}
					tsParseTypeAssertion() {
						if (
							this.getPluginOption('typescript', 'disallowAmbiguousJSXLike')
						) {
							this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc)
						}
						const node = this.startNode()
						node.typeAnnotation = this.tsInType(() => {
							this.next()
							return this.match(75)
								? this.tsParseTypeReference()
								: this.tsParseType()
						})
						this.expect(48)
						node.expression = this.parseMaybeUnary()
						return this.finishNode(node, 'TSTypeAssertion')
					}
					tsParseHeritageClause(token) {
						const originalStartLoc = this.state.startLoc
						const delimitedList = this.tsParseDelimitedList(
							'HeritageClauseElement',
							() => {
								{
									const node = this.startNode()
									node.expression = this.tsParseEntityName(1 | 2)
									if (this.match(47)) {
										node.typeParameters = this.tsParseTypeArguments()
									}
									return this.finishNode(node, 'TSExpressionWithTypeArguments')
								}
							},
						)
						if (!delimitedList.length) {
							this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {
								token,
							})
						}
						return delimitedList
					}
					tsParseInterfaceDeclaration(node, properties = {}) {
						if (this.hasFollowingLineBreak()) return null
						this.expectContextual(129)
						if (properties.declare) node.declare = true
						if (tokenIsIdentifier(this.state.type)) {
							node.id = this.parseIdentifier()
							this.checkIdentifier(node.id, 130)
						} else {
							node.id = null
							this.raise(TSErrors.MissingInterfaceName, this.state.startLoc)
						}
						node.typeParameters = this.tsTryParseTypeParameters(
							this.tsParseInOutConstModifiers,
						)
						if (this.eat(81)) {
							node.extends = this.tsParseHeritageClause('extends')
						}
						const body = this.startNode()
						body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this))
						node.body = this.finishNode(body, 'TSInterfaceBody')
						return this.finishNode(node, 'TSInterfaceDeclaration')
					}
					tsParseTypeAliasDeclaration(node) {
						node.id = this.parseIdentifier()
						this.checkIdentifier(node.id, 2)
						node.typeAnnotation = this.tsInType(() => {
							node.typeParameters = this.tsTryParseTypeParameters(
								this.tsParseInOutModifiers,
							)
							this.expect(29)
							if (this.isContextual(114) && this.lookahead().type !== 16) {
								const node = this.startNode()
								this.next()
								return this.finishNode(node, 'TSIntrinsicKeyword')
							}
							return this.tsParseType()
						})
						this.semicolon()
						return this.finishNode(node, 'TSTypeAliasDeclaration')
					}
					tsInTopLevelContext(cb) {
						if (this.curContext() !== types.brace) {
							const oldContext = this.state.context
							this.state.context = [oldContext[0]]
							try {
								return cb()
							} finally {
								this.state.context = oldContext
							}
						} else {
							return cb()
						}
					}
					tsInType(cb) {
						const oldInType = this.state.inType
						this.state.inType = true
						try {
							return cb()
						} finally {
							this.state.inType = oldInType
						}
					}
					tsInDisallowConditionalTypesContext(cb) {
						const oldInDisallowConditionalTypesContext =
							this.state.inDisallowConditionalTypesContext
						this.state.inDisallowConditionalTypesContext = true
						try {
							return cb()
						} finally {
							this.state.inDisallowConditionalTypesContext =
								oldInDisallowConditionalTypesContext
						}
					}
					tsInAllowConditionalTypesContext(cb) {
						const oldInDisallowConditionalTypesContext =
							this.state.inDisallowConditionalTypesContext
						this.state.inDisallowConditionalTypesContext = false
						try {
							return cb()
						} finally {
							this.state.inDisallowConditionalTypesContext =
								oldInDisallowConditionalTypesContext
						}
					}
					tsEatThenParseType(token) {
						if (this.match(token)) {
							return this.tsNextThenParseType()
						}
					}
					tsExpectThenParseType(token) {
						return this.tsInType(() => {
							this.expect(token)
							return this.tsParseType()
						})
					}
					tsNextThenParseType() {
						return this.tsInType(() => {
							this.next()
							return this.tsParseType()
						})
					}
					tsParseEnumMember() {
						const node = this.startNode()
						node.id = this.match(134)
							? super.parseStringLiteral(this.state.value)
							: this.parseIdentifier(true)
						if (this.eat(29)) {
							node.initializer = super.parseMaybeAssignAllowIn()
						}
						return this.finishNode(node, 'TSEnumMember')
					}
					tsParseEnumDeclaration(node, properties = {}) {
						if (properties.const) node.const = true
						if (properties.declare) node.declare = true
						this.expectContextual(126)
						node.id = this.parseIdentifier()
						this.checkIdentifier(node.id, node.const ? 8971 : 8459)
						{
							this.expect(5)
							node.members = this.tsParseDelimitedList(
								'EnumMembers',
								this.tsParseEnumMember.bind(this),
							)
							this.expect(8)
						}
						return this.finishNode(node, 'TSEnumDeclaration')
					}
					tsParseEnumBody() {
						const node = this.startNode()
						this.expect(5)
						node.members = this.tsParseDelimitedList(
							'EnumMembers',
							this.tsParseEnumMember.bind(this),
						)
						this.expect(8)
						return this.finishNode(node, 'TSEnumBody')
					}
					tsParseModuleBlock() {
						const node = this.startNode()
						this.scope.enter(0)
						this.expect(5)
						super.parseBlockOrModuleBlockBody(
							(node.body = []),
							undefined,
							true,
							8,
						)
						this.scope.exit()
						return this.finishNode(node, 'TSModuleBlock')
					}
					tsParseModuleOrNamespaceDeclaration(node, nested = false) {
						node.id = this.parseIdentifier()
						if (!nested) {
							this.checkIdentifier(node.id, 1024)
						}
						if (this.eat(16)) {
							const inner = this.startNode()
							this.tsParseModuleOrNamespaceDeclaration(inner, true)
							node.body = inner
						} else {
							this.scope.enter(256)
							this.prodParam.enter(0)
							node.body = this.tsParseModuleBlock()
							this.prodParam.exit()
							this.scope.exit()
						}
						return this.finishNode(node, 'TSModuleDeclaration')
					}
					tsParseAmbientExternalModuleDeclaration(node) {
						if (this.isContextual(112)) {
							node.kind = 'global'
							{
								node.global = true
							}
							node.id = this.parseIdentifier()
						} else if (this.match(134)) {
							node.kind = 'module'
							node.id = super.parseStringLiteral(this.state.value)
						} else {
							this.unexpected()
						}
						if (this.match(5)) {
							this.scope.enter(256)
							this.prodParam.enter(0)
							node.body = this.tsParseModuleBlock()
							this.prodParam.exit()
							this.scope.exit()
						} else {
							this.semicolon()
						}
						return this.finishNode(node, 'TSModuleDeclaration')
					}
					tsParseImportEqualsDeclaration(
						node,
						maybeDefaultIdentifier,
						isExport,
					) {
						{
							node.isExport = isExport || false
						}
						node.id = maybeDefaultIdentifier || this.parseIdentifier()
						this.checkIdentifier(node.id, 4096)
						this.expect(29)
						const moduleReference = this.tsParseModuleReference()
						if (
							node.importKind === 'type' &&
							moduleReference.type !== 'TSExternalModuleReference'
						) {
							this.raise(TSErrors.ImportAliasHasImportType, moduleReference)
						}
						node.moduleReference = moduleReference
						this.semicolon()
						return this.finishNode(node, 'TSImportEqualsDeclaration')
					}
					tsIsExternalModuleReference() {
						return this.isContextual(119) && this.lookaheadCharCode() === 40
					}
					tsParseModuleReference() {
						return this.tsIsExternalModuleReference()
							? this.tsParseExternalModuleReference()
							: this.tsParseEntityName(0)
					}
					tsParseExternalModuleReference() {
						const node = this.startNode()
						this.expectContextual(119)
						this.expect(10)
						if (!this.match(134)) {
							this.unexpected()
						}
						node.expression = super.parseExprAtom()
						this.expect(11)
						this.sawUnambiguousESM = true
						return this.finishNode(node, 'TSExternalModuleReference')
					}
					tsLookAhead(f) {
						const state = this.state.clone()
						const res = f()
						this.state = state
						return res
					}
					tsTryParseAndCatch(f) {
						const result = this.tryParse((abort) => f() || abort())
						if (result.aborted || !result.node) return
						if (result.error) this.state = result.failState
						return result.node
					}
					tsTryParse(f) {
						const state = this.state.clone()
						const result = f()
						if (result !== undefined && result !== false) {
							return result
						}
						this.state = state
					}
					tsTryParseDeclare(nany) {
						if (this.isLineTerminator()) {
							return
						}
						let startType = this.state.type
						let kind
						if (this.isContextual(100)) {
							startType = 74
							kind = 'let'
						}
						return this.tsInAmbientContext(() => {
							switch (startType) {
								case 68:
									nany.declare = true
									return super.parseFunctionStatement(nany, false, false)
								case 80:
									nany.declare = true
									return this.parseClass(nany, true, false)
								case 126:
									return this.tsParseEnumDeclaration(nany, {
										declare: true,
									})
								case 112:
									return this.tsParseAmbientExternalModuleDeclaration(nany)
								case 75:
								case 74:
									if (!this.match(75) || !this.isLookaheadContextual('enum')) {
										nany.declare = true
										return this.parseVarStatement(
											nany,
											kind || this.state.value,
											true,
										)
									}
									this.expect(75)
									return this.tsParseEnumDeclaration(nany, {
										const: true,
										declare: true,
									})
								case 129: {
									const result = this.tsParseInterfaceDeclaration(nany, {
										declare: true,
									})
									if (result) return result
								}
								default:
									if (tokenIsIdentifier(startType)) {
										return this.tsParseDeclaration(
											nany,
											this.state.value,
											true,
											null,
										)
									}
							}
						})
					}
					tsTryParseExportDeclaration() {
						return this.tsParseDeclaration(
							this.startNode(),
							this.state.value,
							true,
							null,
						)
					}
					tsParseExpressionStatement(node, expr, decorators) {
						switch (expr.name) {
							case 'declare': {
								const declaration = this.tsTryParseDeclare(node)
								if (declaration) {
									declaration.declare = true
								}
								return declaration
							}
							case 'global':
								if (this.match(5)) {
									this.scope.enter(256)
									this.prodParam.enter(0)
									const mod = node
									mod.kind = 'global'
									{
										node.global = true
									}
									mod.id = expr
									mod.body = this.tsParseModuleBlock()
									this.scope.exit()
									this.prodParam.exit()
									return this.finishNode(mod, 'TSModuleDeclaration')
								}
								break
							default:
								return this.tsParseDeclaration(
									node,
									expr.name,
									false,
									decorators,
								)
						}
					}
					tsParseDeclaration(node, value, next, decorators) {
						switch (value) {
							case 'abstract':
								if (
									this.tsCheckLineTerminator(next) &&
									(this.match(80) || tokenIsIdentifier(this.state.type))
								) {
									return this.tsParseAbstractDeclaration(node, decorators)
								}
								break
							case 'module':
								if (this.tsCheckLineTerminator(next)) {
									if (this.match(134)) {
										return this.tsParseAmbientExternalModuleDeclaration(node)
									} else if (tokenIsIdentifier(this.state.type)) {
										node.kind = 'module'
										return this.tsParseModuleOrNamespaceDeclaration(node)
									}
								}
								break
							case 'namespace':
								if (
									this.tsCheckLineTerminator(next) &&
									tokenIsIdentifier(this.state.type)
								) {
									node.kind = 'namespace'
									return this.tsParseModuleOrNamespaceDeclaration(node)
								}
								break
							case 'type':
								if (
									this.tsCheckLineTerminator(next) &&
									tokenIsIdentifier(this.state.type)
								) {
									return this.tsParseTypeAliasDeclaration(node)
								}
								break
						}
					}
					tsCheckLineTerminator(next) {
						if (next) {
							if (this.hasFollowingLineBreak()) return false
							this.next()
							return true
						}
						return !this.isLineTerminator()
					}
					tsTryParseGenericAsyncArrowFunction(startLoc) {
						if (!this.match(47)) return
						const oldMaybeInArrowParameters = this.state.maybeInArrowParameters
						this.state.maybeInArrowParameters = true
						const res = this.tsTryParseAndCatch(() => {
							const node = this.startNodeAt(startLoc)
							node.typeParameters = this.tsParseTypeParameters(
								this.tsParseConstModifier,
							)
							super.parseFunctionParams(node)
							node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation()
							this.expect(19)
							return node
						})
						this.state.maybeInArrowParameters = oldMaybeInArrowParameters
						if (!res) return
						return super.parseArrowExpression(res, null, true)
					}
					tsParseTypeArgumentsInExpression() {
						if (this.reScan_lt() !== 47) return
						return this.tsParseTypeArguments()
					}
					tsParseTypeArguments() {
						const node = this.startNode()
						node.params = this.tsInType(() =>
							this.tsInTopLevelContext(() => {
								this.expect(47)
								return this.tsParseDelimitedList(
									'TypeParametersOrArguments',
									this.tsParseType.bind(this),
								)
							}),
						)
						if (node.params.length === 0) {
							this.raise(TSErrors.EmptyTypeArguments, node)
						} else if (
							!this.state.inType &&
							this.curContext() === types.brace
						) {
							this.reScan_lt_gt()
						}
						this.expect(48)
						return this.finishNode(node, 'TSTypeParameterInstantiation')
					}
					tsIsDeclarationStart() {
						return tokenIsTSDeclarationStart(this.state.type)
					}
					isExportDefaultSpecifier() {
						if (this.tsIsDeclarationStart()) return false
						return super.isExportDefaultSpecifier()
					}
					parseBindingElement(flags, decorators) {
						const startLoc = decorators.length
							? decorators[0].loc.start
							: this.state.startLoc
						const modified = {}
						this.tsParseModifiers(
							{
								allowedModifiers: [
									'public',
									'private',
									'protected',
									'override',
									'readonly',
								],
							},
							modified,
						)
						const accessibility = modified.accessibility
						const override = modified.override
						const readonly = modified.readonly
						if (!(flags & 4) && (accessibility || readonly || override)) {
							this.raise(TSErrors.UnexpectedParameterModifier, startLoc)
						}
						const left = this.parseMaybeDefault()
						if (flags & 2) {
							this.parseFunctionParamType(left)
						}
						const elt = this.parseMaybeDefault(left.loc.start, left)
						if (accessibility || readonly || override) {
							const pp = this.startNodeAt(startLoc)
							if (decorators.length) {
								pp.decorators = decorators
							}
							if (accessibility) pp.accessibility = accessibility
							if (readonly) pp.readonly = readonly
							if (override) pp.override = override
							if (
								elt.type !== 'Identifier' &&
								elt.type !== 'AssignmentPattern'
							) {
								this.raise(TSErrors.UnsupportedParameterPropertyKind, pp)
							}
							pp.parameter = elt
							return this.finishNode(pp, 'TSParameterProperty')
						}
						if (decorators.length) {
							left.decorators = decorators
						}
						return elt
					}
					isSimpleParameter(node) {
						return (
							(node.type === 'TSParameterProperty' &&
								super.isSimpleParameter(node.parameter)) ||
							super.isSimpleParameter(node)
						)
					}
					tsDisallowOptionalPattern(node) {
						for (const param of node.params) {
							if (
								param.type !== 'Identifier' &&
								param.optional &&
								!this.state.isAmbientContext
							) {
								this.raise(TSErrors.PatternIsOptional, param)
							}
						}
					}
					setArrowFunctionParameters(node, params, trailingCommaLoc) {
						super.setArrowFunctionParameters(node, params, trailingCommaLoc)
						this.tsDisallowOptionalPattern(node)
					}
					parseFunctionBodyAndFinish(node, type, isMethod = false) {
						if (this.match(14)) {
							node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14)
						}
						const bodilessType =
							type === 'FunctionDeclaration'
								? 'TSDeclareFunction'
								: type === 'ClassMethod' || type === 'ClassPrivateMethod'
									? 'TSDeclareMethod'
									: undefined
						if (bodilessType && !this.match(5) && this.isLineTerminator()) {
							return this.finishNode(node, bodilessType)
						}
						if (
							bodilessType === 'TSDeclareFunction' &&
							this.state.isAmbientContext
						) {
							this.raise(TSErrors.DeclareFunctionHasImplementation, node)
							if (node.declare) {
								return super.parseFunctionBodyAndFinish(
									node,
									bodilessType,
									isMethod,
								)
							}
						}
						this.tsDisallowOptionalPattern(node)
						return super.parseFunctionBodyAndFinish(node, type, isMethod)
					}
					registerFunctionStatementId(node) {
						if (!node.body && node.id) {
							this.checkIdentifier(node.id, 1024)
						} else {
							super.registerFunctionStatementId(node)
						}
					}
					tsCheckForInvalidTypeCasts(items) {
						items.forEach((node) => {
							if (
								(node == null ? void 0 : node.type) === 'TSTypeCastExpression'
							) {
								this.raise(
									TSErrors.UnexpectedTypeAnnotation,
									node.typeAnnotation,
								)
							}
						})
					}
					toReferencedList(exprList, isInParens) {
						this.tsCheckForInvalidTypeCasts(exprList)
						return exprList
					}
					parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
						const node = super.parseArrayLike(
							close,
							canBePattern,
							isTuple,
							refExpressionErrors,
						)
						if (node.type === 'ArrayExpression') {
							this.tsCheckForInvalidTypeCasts(node.elements)
						}
						return node
					}
					parseSubscript(base, startLoc, noCalls, state) {
						if (!this.hasPrecedingLineBreak() && this.match(35)) {
							this.state.canStartJSXElement = false
							this.next()
							const nonNullExpression = this.startNodeAt(startLoc)
							nonNullExpression.expression = base
							return this.finishNode(nonNullExpression, 'TSNonNullExpression')
						}
						let isOptionalCall = false
						if (this.match(18) && this.lookaheadCharCode() === 60) {
							if (noCalls) {
								state.stop = true
								return base
							}
							state.optionalChainMember = isOptionalCall = true
							this.next()
						}
						if (this.match(47) || this.match(51)) {
							let missingParenErrorLoc
							const result = this.tsTryParseAndCatch(() => {
								if (!noCalls && this.atPossibleAsyncArrow(base)) {
									const asyncArrowFn =
										this.tsTryParseGenericAsyncArrowFunction(startLoc)
									if (asyncArrowFn) {
										return asyncArrowFn
									}
								}
								const typeArguments = this.tsParseTypeArgumentsInExpression()
								if (!typeArguments) return
								if (isOptionalCall && !this.match(10)) {
									missingParenErrorLoc = this.state.curPosition()
									return
								}
								if (tokenIsTemplate(this.state.type)) {
									const result = super.parseTaggedTemplateExpression(
										base,
										startLoc,
										state,
									)
									{
										result.typeParameters = typeArguments
									}
									return result
								}
								if (!noCalls && this.eat(10)) {
									const node = this.startNodeAt(startLoc)
									node.callee = base
									node.arguments = this.parseCallExpressionArguments(11)
									this.tsCheckForInvalidTypeCasts(node.arguments)
									{
										node.typeParameters = typeArguments
									}
									if (state.optionalChainMember) {
										node.optional = isOptionalCall
									}
									return this.finishCallExpression(
										node,
										state.optionalChainMember,
									)
								}
								const tokenType = this.state.type
								if (
									tokenType === 48 ||
									tokenType === 52 ||
									(tokenType !== 10 &&
										tokenCanStartExpression(tokenType) &&
										!this.hasPrecedingLineBreak())
								) {
									return
								}
								const node = this.startNodeAt(startLoc)
								node.expression = base
								{
									node.typeParameters = typeArguments
								}
								return this.finishNode(node, 'TSInstantiationExpression')
							})
							if (missingParenErrorLoc) {
								this.unexpected(missingParenErrorLoc, 10)
							}
							if (result) {
								if (result.type === 'TSInstantiationExpression') {
									if (
										this.match(16) ||
										(this.match(18) && this.lookaheadCharCode() !== 40)
									) {
										this.raise(
											TSErrors.InvalidPropertyAccessAfterInstantiationExpression,
											this.state.startLoc,
										)
									}
									if (!this.match(16) && !this.match(18)) {
										result.expression = super.stopParseSubscript(base, state)
									}
								}
								return result
							}
						}
						return super.parseSubscript(base, startLoc, noCalls, state)
					}
					parseNewCallee(node) {
						var _callee$extra
						super.parseNewCallee(node)
						const { callee } = node
						if (
							callee.type === 'TSInstantiationExpression' &&
							!(
								(_callee$extra = callee.extra) != null &&
								_callee$extra.parenthesized
							)
						) {
							{
								node.typeParameters = callee.typeParameters
							}
							node.callee = callee.expression
						}
					}
					parseExprOp(left, leftStartLoc, minPrec) {
						let isSatisfies
						if (
							tokenOperatorPrecedence(58) > minPrec &&
							!this.hasPrecedingLineBreak() &&
							(this.isContextual(93) || (isSatisfies = this.isContextual(120)))
						) {
							const node = this.startNodeAt(leftStartLoc)
							node.expression = left
							node.typeAnnotation = this.tsInType(() => {
								this.next()
								if (this.match(75)) {
									if (isSatisfies) {
										this.raise(Errors.UnexpectedKeyword, this.state.startLoc, {
											keyword: 'const',
										})
									}
									return this.tsParseTypeReference()
								}
								return this.tsParseType()
							})
							this.finishNode(
								node,
								isSatisfies ? 'TSSatisfiesExpression' : 'TSAsExpression',
							)
							this.reScan_lt_gt()
							return this.parseExprOp(node, leftStartLoc, minPrec)
						}
						return super.parseExprOp(left, leftStartLoc, minPrec)
					}
					checkReservedWord(word, startLoc, checkKeywords, isBinding) {
						if (!this.state.isAmbientContext) {
							super.checkReservedWord(word, startLoc, checkKeywords, isBinding)
						}
					}
					checkImportReflection(node) {
						super.checkImportReflection(node)
						if (node.module && node.importKind !== 'value') {
							this.raise(
								TSErrors.ImportReflectionHasImportType,
								node.specifiers[0].loc.start,
							)
						}
					}
					checkDuplicateExports() {}
					isPotentialImportPhase(isExport) {
						if (super.isPotentialImportPhase(isExport)) return true
						if (this.isContextual(130)) {
							const ch = this.lookaheadCharCode()
							return isExport ? ch === 123 || ch === 42 : ch !== 61
						}
						return !isExport && this.isContextual(87)
					}
					applyImportPhase(node, isExport, phase, loc) {
						super.applyImportPhase(node, isExport, phase, loc)
						if (isExport) {
							node.exportKind = phase === 'type' ? 'type' : 'value'
						} else {
							node.importKind =
								phase === 'type' || phase === 'typeof' ? phase : 'value'
						}
					}
					parseImport(node) {
						if (this.match(134)) {
							node.importKind = 'value'
							return super.parseImport(node)
						}
						let importNode
						if (
							tokenIsIdentifier(this.state.type) &&
							this.lookaheadCharCode() === 61
						) {
							node.importKind = 'value'
							return this.tsParseImportEqualsDeclaration(node)
						} else if (this.isContextual(130)) {
							const maybeDefaultIdentifier = this.parseMaybeImportPhase(
								node,
								false,
							)
							if (this.lookaheadCharCode() === 61) {
								return this.tsParseImportEqualsDeclaration(
									node,
									maybeDefaultIdentifier,
								)
							} else {
								importNode = super.parseImportSpecifiersAndAfter(
									node,
									maybeDefaultIdentifier,
								)
							}
						} else {
							importNode = super.parseImport(node)
						}
						if (
							importNode.importKind === 'type' &&
							importNode.specifiers.length > 1 &&
							importNode.specifiers[0].type === 'ImportDefaultSpecifier'
						) {
							this.raise(
								TSErrors.TypeImportCannotSpecifyDefaultAndNamed,
								importNode,
							)
						}
						return importNode
					}
					parseExport(node, decorators) {
						if (this.match(83)) {
							const nodeImportEquals = node
							this.next()
							let maybeDefaultIdentifier = null
							if (
								this.isContextual(130) &&
								this.isPotentialImportPhase(false)
							) {
								maybeDefaultIdentifier = this.parseMaybeImportPhase(
									nodeImportEquals,
									false,
								)
							} else {
								nodeImportEquals.importKind = 'value'
							}
							const declaration = this.tsParseImportEqualsDeclaration(
								nodeImportEquals,
								maybeDefaultIdentifier,
								true,
							)
							{
								return declaration
							}
						} else if (this.eat(29)) {
							const assign = node
							assign.expression = super.parseExpression()
							this.semicolon()
							this.sawUnambiguousESM = true
							return this.finishNode(assign, 'TSExportAssignment')
						} else if (this.eatContextual(93)) {
							const decl = node
							this.expectContextual(128)
							decl.id = this.parseIdentifier()
							this.semicolon()
							return this.finishNode(decl, 'TSNamespaceExportDeclaration')
						} else {
							return super.parseExport(node, decorators)
						}
					}
					isAbstractClass() {
						return this.isContextual(124) && this.lookahead().type === 80
					}
					parseExportDefaultExpression() {
						if (this.isAbstractClass()) {
							const cls = this.startNode()
							this.next()
							cls.abstract = true
							return this.parseClass(cls, true, true)
						}
						if (this.match(129)) {
							const result = this.tsParseInterfaceDeclaration(this.startNode())
							if (result) return result
						}
						return super.parseExportDefaultExpression()
					}
					parseVarStatement(node, kind, allowMissingInitializer = false) {
						const { isAmbientContext } = this.state
						const declaration = super.parseVarStatement(
							node,
							kind,
							allowMissingInitializer || isAmbientContext,
						)
						if (!isAmbientContext) return declaration
						for (const { id, init } of declaration.declarations) {
							if (!init) continue
							if (kind !== 'const' || !!id.typeAnnotation) {
								this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init)
							} else if (
								!isValidAmbientConstInitializer(init, this.hasPlugin('estree'))
							) {
								this.raise(
									TSErrors.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference,
									init,
								)
							}
						}
						return declaration
					}
					parseStatementContent(flags, decorators) {
						if (this.match(75) && this.isLookaheadContextual('enum')) {
							const node = this.startNode()
							this.expect(75)
							return this.tsParseEnumDeclaration(node, {
								const: true,
							})
						}
						if (this.isContextual(126)) {
							return this.tsParseEnumDeclaration(this.startNode())
						}
						if (this.isContextual(129)) {
							const result = this.tsParseInterfaceDeclaration(this.startNode())
							if (result) return result
						}
						return super.parseStatementContent(flags, decorators)
					}
					parseAccessModifier() {
						return this.tsParseModifier(['public', 'protected', 'private'])
					}
					tsHasSomeModifiers(member, modifiers) {
						return modifiers.some((modifier) => {
							if (tsIsAccessModifier(modifier)) {
								return member.accessibility === modifier
							}
							return !!member[modifier]
						})
					}
					tsIsStartOfStaticBlocks() {
						return this.isContextual(106) && this.lookaheadCharCode() === 123
					}
					parseClassMember(classBody, member, state) {
						const modifiers = [
							'declare',
							'private',
							'public',
							'protected',
							'override',
							'abstract',
							'readonly',
							'static',
						]
						this.tsParseModifiers(
							{
								allowedModifiers: modifiers,
								disallowedModifiers: ['in', 'out'],
								stopOnStartOfClassStaticBlock: true,
								errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions,
							},
							member,
						)
						const callParseClassMemberWithIsStatic = () => {
							if (this.tsIsStartOfStaticBlocks()) {
								this.next()
								this.next()
								if (this.tsHasSomeModifiers(member, modifiers)) {
									this.raise(
										TSErrors.StaticBlockCannotHaveModifier,
										this.state.curPosition(),
									)
								}
								super.parseClassStaticBlock(classBody, member)
							} else {
								this.parseClassMemberWithIsStatic(
									classBody,
									member,
									state,
									!!member.static,
								)
							}
						}
						if (member.declare) {
							this.tsInAmbientContext(callParseClassMemberWithIsStatic)
						} else {
							callParseClassMemberWithIsStatic()
						}
					}
					parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
						const idx = this.tsTryParseIndexSignature(member)
						if (idx) {
							classBody.body.push(idx)
							if (member.abstract) {
								this.raise(TSErrors.IndexSignatureHasAbstract, member)
							}
							if (member.accessibility) {
								this.raise(TSErrors.IndexSignatureHasAccessibility, member, {
									modifier: member.accessibility,
								})
							}
							if (member.declare) {
								this.raise(TSErrors.IndexSignatureHasDeclare, member)
							}
							if (member.override) {
								this.raise(TSErrors.IndexSignatureHasOverride, member)
							}
							return
						}
						if (!this.state.inAbstractClass && member.abstract) {
							this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member)
						}
						if (member.override) {
							if (!state.hadSuperClass) {
								this.raise(TSErrors.OverrideNotInSubClass, member)
							}
						}
						super.parseClassMemberWithIsStatic(
							classBody,
							member,
							state,
							isStatic,
						)
					}
					parsePostMemberNameModifiers(methodOrProp) {
						const optional = this.eat(17)
						if (optional) methodOrProp.optional = true
						if (methodOrProp.readonly && this.match(10)) {
							this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp)
						}
						if (methodOrProp.declare && this.match(10)) {
							this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp)
						}
					}
					parseExpressionStatement(node, expr, decorators) {
						const decl =
							expr.type === 'Identifier'
								? this.tsParseExpressionStatement(node, expr, decorators)
								: undefined
						return (
							decl || super.parseExpressionStatement(node, expr, decorators)
						)
					}
					shouldParseExportDeclaration() {
						if (this.tsIsDeclarationStart()) return true
						return super.shouldParseExportDeclaration()
					}
					parseConditional(expr, startLoc, refExpressionErrors) {
						if (!this.match(17)) return expr
						if (this.state.maybeInArrowParameters) {
							const nextCh = this.lookaheadCharCode()
							if (
								nextCh === 44 ||
								nextCh === 61 ||
								nextCh === 58 ||
								nextCh === 41
							) {
								this.setOptionalParametersError(refExpressionErrors)
								return expr
							}
						}
						return super.parseConditional(expr, startLoc, refExpressionErrors)
					}
					parseParenItem(node, startLoc) {
						const newNode = super.parseParenItem(node, startLoc)
						if (this.eat(17)) {
							newNode.optional = true
							this.resetEndLocation(node)
						}
						if (this.match(14)) {
							const typeCastNode = this.startNodeAt(startLoc)
							typeCastNode.expression = node
							typeCastNode.typeAnnotation = this.tsParseTypeAnnotation()
							return this.finishNode(typeCastNode, 'TSTypeCastExpression')
						}
						return node
					}
					parseExportDeclaration(node) {
						if (!this.state.isAmbientContext && this.isContextual(125)) {
							return this.tsInAmbientContext(() =>
								this.parseExportDeclaration(node),
							)
						}
						const startLoc = this.state.startLoc
						const isDeclare = this.eatContextual(125)
						if (
							isDeclare &&
							(this.isContextual(125) || !this.shouldParseExportDeclaration())
						) {
							throw this.raise(
								TSErrors.ExpectedAmbientAfterExportDeclare,
								this.state.startLoc,
							)
						}
						const isIdentifier = tokenIsIdentifier(this.state.type)
						const declaration =
							(isIdentifier && this.tsTryParseExportDeclaration()) ||
							super.parseExportDeclaration(node)
						if (!declaration) return null
						if (
							declaration.type === 'TSInterfaceDeclaration' ||
							declaration.type === 'TSTypeAliasDeclaration' ||
							isDeclare
						) {
							node.exportKind = 'type'
						}
						if (isDeclare && declaration.type !== 'TSImportEqualsDeclaration') {
							this.resetStartLocation(declaration, startLoc)
							declaration.declare = true
						}
						return declaration
					}
					parseClassId(node, isStatement, optionalId, bindingType) {
						if ((!isStatement || optionalId) && this.isContextual(113)) {
							return
						}
						super.parseClassId(
							node,
							isStatement,
							optionalId,
							node.declare ? 1024 : 8331,
						)
						const typeParameters = this.tsTryParseTypeParameters(
							this.tsParseInOutConstModifiers,
						)
						if (typeParameters) node.typeParameters = typeParameters
					}
					parseClassPropertyAnnotation(node) {
						if (!node.optional) {
							if (this.eat(35)) {
								node.definite = true
							} else if (this.eat(17)) {
								node.optional = true
							}
						}
						const type = this.tsTryParseTypeAnnotation()
						if (type) node.typeAnnotation = type
					}
					parseClassProperty(node) {
						this.parseClassPropertyAnnotation(node)
						if (
							this.state.isAmbientContext &&
							!(node.readonly && !node.typeAnnotation) &&
							this.match(29)
						) {
							this.raise(
								TSErrors.DeclareClassFieldHasInitializer,
								this.state.startLoc,
							)
						}
						if (node.abstract && this.match(29)) {
							const { key } = node
							this.raise(
								TSErrors.AbstractPropertyHasInitializer,
								this.state.startLoc,
								{
									propertyName:
										key.type === 'Identifier' && !node.computed
											? key.name
											: `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`,
								},
							)
						}
						return super.parseClassProperty(node)
					}
					parseClassPrivateProperty(node) {
						if (node.abstract) {
							this.raise(TSErrors.PrivateElementHasAbstract, node)
						}
						if (node.accessibility) {
							this.raise(TSErrors.PrivateElementHasAccessibility, node, {
								modifier: node.accessibility,
							})
						}
						this.parseClassPropertyAnnotation(node)
						return super.parseClassPrivateProperty(node)
					}
					parseClassAccessorProperty(node) {
						this.parseClassPropertyAnnotation(node)
						if (node.optional) {
							this.raise(TSErrors.AccessorCannotBeOptional, node)
						}
						return super.parseClassAccessorProperty(node)
					}
					pushClassMethod(
						classBody,
						method,
						isGenerator,
						isAsync,
						isConstructor,
						allowsDirectSuper,
					) {
						const typeParameters = this.tsTryParseTypeParameters(
							this.tsParseConstModifier,
						)
						if (typeParameters && isConstructor) {
							this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters)
						}
						const { declare = false, kind } = method
						if (declare && (kind === 'get' || kind === 'set')) {
							this.raise(TSErrors.DeclareAccessor, method, {
								kind,
							})
						}
						if (typeParameters) method.typeParameters = typeParameters
						super.pushClassMethod(
							classBody,
							method,
							isGenerator,
							isAsync,
							isConstructor,
							allowsDirectSuper,
						)
					}
					pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
						const typeParameters = this.tsTryParseTypeParameters(
							this.tsParseConstModifier,
						)
						if (typeParameters) method.typeParameters = typeParameters
						super.pushClassPrivateMethod(
							classBody,
							method,
							isGenerator,
							isAsync,
						)
					}
					declareClassPrivateMethodInScope(node, kind) {
						if (node.type === 'TSDeclareMethod') return
						if (node.type === 'MethodDefinition' && node.value.body == null) {
							return
						}
						super.declareClassPrivateMethodInScope(node, kind)
					}
					parseClassSuper(node) {
						super.parseClassSuper(node)
						if (node.superClass && (this.match(47) || this.match(51))) {
							{
								node.superTypeParameters =
									this.tsParseTypeArgumentsInExpression()
							}
						}
						if (this.eatContextual(113)) {
							node.implements = this.tsParseHeritageClause('implements')
						}
					}
					parseObjPropValue(
						prop,
						startLoc,
						isGenerator,
						isAsync,
						isPattern,
						isAccessor,
						refExpressionErrors,
					) {
						const typeParameters = this.tsTryParseTypeParameters(
							this.tsParseConstModifier,
						)
						if (typeParameters) prop.typeParameters = typeParameters
						return super.parseObjPropValue(
							prop,
							startLoc,
							isGenerator,
							isAsync,
							isPattern,
							isAccessor,
							refExpressionErrors,
						)
					}
					parseFunctionParams(node, isConstructor) {
						const typeParameters = this.tsTryParseTypeParameters(
							this.tsParseConstModifier,
						)
						if (typeParameters) node.typeParameters = typeParameters
						super.parseFunctionParams(node, isConstructor)
					}
					parseVarId(decl, kind) {
						super.parseVarId(decl, kind)
						if (
							decl.id.type === 'Identifier' &&
							!this.hasPrecedingLineBreak() &&
							this.eat(35)
						) {
							decl.definite = true
						}
						const type = this.tsTryParseTypeAnnotation()
						if (type) {
							decl.id.typeAnnotation = type
							this.resetEndLocation(decl.id)
						}
					}
					parseAsyncArrowFromCallExpression(node, call) {
						if (this.match(14)) {
							node.returnType = this.tsParseTypeAnnotation()
						}
						return super.parseAsyncArrowFromCallExpression(node, call)
					}
					parseMaybeAssign(refExpressionErrors, afterLeftParse) {
						var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2
						let state
						let jsx
						let typeCast
						if (this.hasPlugin('jsx') && (this.match(143) || this.match(47))) {
							state = this.state.clone()
							jsx = this.tryParse(
								() =>
									super.parseMaybeAssign(refExpressionErrors, afterLeftParse),
								state,
							)
							if (!jsx.error) return jsx.node
							const { context } = this.state
							const currentContext = context[context.length - 1]
							if (
								currentContext === types.j_oTag ||
								currentContext === types.j_expr
							) {
								context.pop()
							}
						}
						if (!((_jsx = jsx) != null && _jsx.error) && !this.match(47)) {
							return super.parseMaybeAssign(refExpressionErrors, afterLeftParse)
						}
						if (!state || state === this.state) state = this.state.clone()
						let typeParameters
						const arrow = this.tryParse((abort) => {
							var _expr$extra, _typeParameters
							typeParameters = this.tsParseTypeParameters(
								this.tsParseConstModifier,
							)
							const expr = super.parseMaybeAssign(
								refExpressionErrors,
								afterLeftParse,
							)
							if (
								expr.type !== 'ArrowFunctionExpression' ||
								((_expr$extra = expr.extra) != null &&
									_expr$extra.parenthesized)
							) {
								abort()
							}
							if (
								((_typeParameters = typeParameters) == null
									? void 0
									: _typeParameters.params.length) !== 0
							) {
								this.resetStartLocationFromNode(expr, typeParameters)
							}
							expr.typeParameters = typeParameters
							return expr
						}, state)
						if (!arrow.error && !arrow.aborted) {
							if (typeParameters)
								this.reportReservedArrowTypeParam(typeParameters)
							return arrow.node
						}
						if (!jsx) {
							assert(!this.hasPlugin('jsx'))
							typeCast = this.tryParse(
								() =>
									super.parseMaybeAssign(refExpressionErrors, afterLeftParse),
								state,
							)
							if (!typeCast.error) return typeCast.node
						}
						if ((_jsx2 = jsx) != null && _jsx2.node) {
							this.state = jsx.failState
							return jsx.node
						}
						if (arrow.node) {
							this.state = arrow.failState
							if (typeParameters)
								this.reportReservedArrowTypeParam(typeParameters)
							return arrow.node
						}
						if ((_typeCast = typeCast) != null && _typeCast.node) {
							this.state = typeCast.failState
							return typeCast.node
						}
						throw (
							((_jsx3 = jsx) == null ? void 0 : _jsx3.error) ||
							arrow.error ||
							((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error)
						)
					}
					reportReservedArrowTypeParam(node) {
						var _node$extra2
						if (
							node.params.length === 1 &&
							!node.params[0].constraint &&
							!(
								(_node$extra2 = node.extra) != null &&
								_node$extra2.trailingComma
							) &&
							this.getPluginOption('typescript', 'disallowAmbiguousJSXLike')
						) {
							this.raise(TSErrors.ReservedArrowTypeParam, node)
						}
					}
					parseMaybeUnary(refExpressionErrors, sawUnary) {
						if (!this.hasPlugin('jsx') && this.match(47)) {
							return this.tsParseTypeAssertion()
						}
						return super.parseMaybeUnary(refExpressionErrors, sawUnary)
					}
					parseArrow(node) {
						if (this.match(14)) {
							const result = this.tryParse((abort) => {
								const returnType = this.tsParseTypeOrTypePredicateAnnotation(14)
								if (this.canInsertSemicolon() || !this.match(19)) abort()
								return returnType
							})
							if (result.aborted) return
							if (!result.thrown) {
								if (result.error) this.state = result.failState
								node.returnType = result.node
							}
						}
						return super.parseArrow(node)
					}
					parseFunctionParamType(param) {
						if (this.eat(17)) {
							param.optional = true
						}
						const type = this.tsTryParseTypeAnnotation()
						if (type) param.typeAnnotation = type
						this.resetEndLocation(param)
						return param
					}
					isAssignable(node, isBinding) {
						switch (node.type) {
							case 'TSTypeCastExpression':
								return this.isAssignable(node.expression, isBinding)
							case 'TSParameterProperty':
								return true
							default:
								return super.isAssignable(node, isBinding)
						}
					}
					toAssignable(node, isLHS = false) {
						switch (node.type) {
							case 'ParenthesizedExpression':
								this.toAssignableParenthesizedExpression(node, isLHS)
								break
							case 'TSAsExpression':
							case 'TSSatisfiesExpression':
							case 'TSNonNullExpression':
							case 'TSTypeAssertion':
								if (isLHS) {
									this.expressionScope.recordArrowParameterBindingError(
										TSErrors.UnexpectedTypeCastInParameter,
										node,
									)
								} else {
									this.raise(TSErrors.UnexpectedTypeCastInParameter, node)
								}
								this.toAssignable(node.expression, isLHS)
								break
							case 'AssignmentExpression':
								if (!isLHS && node.left.type === 'TSTypeCastExpression') {
									node.left = this.typeCastToParameter(node.left)
								}
							default:
								super.toAssignable(node, isLHS)
						}
					}
					toAssignableParenthesizedExpression(node, isLHS) {
						switch (node.expression.type) {
							case 'TSAsExpression':
							case 'TSSatisfiesExpression':
							case 'TSNonNullExpression':
							case 'TSTypeAssertion':
							case 'ParenthesizedExpression':
								this.toAssignable(node.expression, isLHS)
								break
							default:
								super.toAssignable(node, isLHS)
						}
					}
					checkToRestConversion(node, allowPattern) {
						switch (node.type) {
							case 'TSAsExpression':
							case 'TSSatisfiesExpression':
							case 'TSTypeAssertion':
							case 'TSNonNullExpression':
								this.checkToRestConversion(node.expression, false)
								break
							default:
								super.checkToRestConversion(node, allowPattern)
						}
					}
					isValidLVal(type, isUnparenthesizedInAssign, binding) {
						switch (type) {
							case 'TSTypeCastExpression':
								return true
							case 'TSParameterProperty':
								return 'parameter'
							case 'TSNonNullExpression':
								return 'expression'
							case 'TSAsExpression':
							case 'TSSatisfiesExpression':
							case 'TSTypeAssertion':
								return (
									(binding !== 64 || !isUnparenthesizedInAssign) && [
										'expression',
										true,
									]
								)
							default:
								return super.isValidLVal(
									type,
									isUnparenthesizedInAssign,
									binding,
								)
						}
					}
					parseBindingAtom() {
						if (this.state.type === 78) {
							return this.parseIdentifier(true)
						}
						return super.parseBindingAtom()
					}
					parseMaybeDecoratorArguments(expr, startLoc) {
						if (this.match(47) || this.match(51)) {
							const typeArguments = this.tsParseTypeArgumentsInExpression()
							if (this.match(10)) {
								const call = super.parseMaybeDecoratorArguments(expr, startLoc)
								{
									call.typeParameters = typeArguments
								}
								return call
							}
							this.unexpected(null, 10)
						}
						return super.parseMaybeDecoratorArguments(expr, startLoc)
					}
					checkCommaAfterRest(close) {
						if (
							this.state.isAmbientContext &&
							this.match(12) &&
							this.lookaheadCharCode() === close
						) {
							this.next()
							return false
						}
						return super.checkCommaAfterRest(close)
					}
					isClassMethod() {
						return this.match(47) || super.isClassMethod()
					}
					isClassProperty() {
						return this.match(35) || this.match(14) || super.isClassProperty()
					}
					parseMaybeDefault(startLoc, left) {
						const node = super.parseMaybeDefault(startLoc, left)
						if (
							node.type === 'AssignmentPattern' &&
							node.typeAnnotation &&
							node.right.start < node.typeAnnotation.start
						) {
							this.raise(
								TSErrors.TypeAnnotationAfterAssign,
								node.typeAnnotation,
							)
						}
						return node
					}
					getTokenFromCode(code) {
						if (this.state.inType) {
							if (code === 62) {
								this.finishOp(48, 1)
								return
							}
							if (code === 60) {
								this.finishOp(47, 1)
								return
							}
						}
						super.getTokenFromCode(code)
					}
					reScan_lt_gt() {
						const { type } = this.state
						if (type === 47) {
							this.state.pos -= 1
							this.readToken_lt()
						} else if (type === 48) {
							this.state.pos -= 1
							this.readToken_gt()
						}
					}
					reScan_lt() {
						const { type } = this.state
						if (type === 51) {
							this.state.pos -= 2
							this.finishOp(47, 1)
							return 47
						}
						return type
					}
					toAssignableListItem(exprList, index, isLHS) {
						const node = exprList[index]
						if (node.type === 'TSTypeCastExpression') {
							exprList[index] = this.typeCastToParameter(node)
						}
						super.toAssignableListItem(exprList, index, isLHS)
					}
					typeCastToParameter(node) {
						node.expression.typeAnnotation = node.typeAnnotation
						this.resetEndLocation(node.expression, node.typeAnnotation.loc.end)
						return node.expression
					}
					shouldParseArrow(params) {
						if (this.match(14)) {
							return params.every((expr) => this.isAssignable(expr, true))
						}
						return super.shouldParseArrow(params)
					}
					shouldParseAsyncArrow() {
						return this.match(14) || super.shouldParseAsyncArrow()
					}
					canHaveLeadingDecorator() {
						return super.canHaveLeadingDecorator() || this.isAbstractClass()
					}
					jsxParseOpeningElementAfterName(node) {
						if (this.match(47) || this.match(51)) {
							const typeArguments = this.tsTryParseAndCatch(() =>
								this.tsParseTypeArgumentsInExpression(),
							)
							if (typeArguments) {
								{
									node.typeParameters = typeArguments
								}
							}
						}
						return super.jsxParseOpeningElementAfterName(node)
					}
					getGetterSetterExpectedParamCount(method) {
						const baseCount = super.getGetterSetterExpectedParamCount(method)
						const params = this.getObjectOrClassMethodParams(method)
						const firstParam = params[0]
						const hasContextParam = firstParam && this.isThisParam(firstParam)
						return hasContextParam ? baseCount + 1 : baseCount
					}
					parseCatchClauseParam() {
						const param = super.parseCatchClauseParam()
						const type = this.tsTryParseTypeAnnotation()
						if (type) {
							param.typeAnnotation = type
							this.resetEndLocation(param)
						}
						return param
					}
					tsInAmbientContext(cb) {
						const { isAmbientContext: oldIsAmbientContext, strict: oldStrict } =
							this.state
						this.state.isAmbientContext = true
						this.state.strict = false
						try {
							return cb()
						} finally {
							this.state.isAmbientContext = oldIsAmbientContext
							this.state.strict = oldStrict
						}
					}
					parseClass(node, isStatement, optionalId) {
						const oldInAbstractClass = this.state.inAbstractClass
						this.state.inAbstractClass = !!node.abstract
						try {
							return super.parseClass(node, isStatement, optionalId)
						} finally {
							this.state.inAbstractClass = oldInAbstractClass
						}
					}
					tsParseAbstractDeclaration(node, decorators) {
						if (this.match(80)) {
							node.abstract = true
							return this.maybeTakeDecorators(
								decorators,
								this.parseClass(node, true, false),
							)
						} else if (this.isContextual(129)) {
							if (!this.hasFollowingLineBreak()) {
								node.abstract = true
								this.raise(
									TSErrors.NonClassMethodPropertyHasAbstractModifer,
									node,
								)
								return this.tsParseInterfaceDeclaration(node)
							}
						} else {
							this.unexpected(null, 80)
						}
					}
					parseMethod(
						node,
						isGenerator,
						isAsync,
						isConstructor,
						allowDirectSuper,
						type,
						inClassScope,
					) {
						const method = super.parseMethod(
							node,
							isGenerator,
							isAsync,
							isConstructor,
							allowDirectSuper,
							type,
							inClassScope,
						)
						if (
							method.abstract ||
							method.type === 'TSAbstractMethodDefinition'
						) {
							const hasEstreePlugin = this.hasPlugin('estree')
							const methodFn = hasEstreePlugin ? method.value : method
							if (methodFn.body) {
								const { key } = method
								this.raise(TSErrors.AbstractMethodHasImplementation, method, {
									methodName:
										key.type === 'Identifier' && !method.computed
											? key.name
											: `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`,
								})
							}
						}
						return method
					}
					tsParseTypeParameterName() {
						const typeName = this.parseIdentifier()
						return typeName.name
					}
					shouldParseAsAmbientContext() {
						return !!this.getPluginOption('typescript', 'dts')
					}
					parse() {
						if (this.shouldParseAsAmbientContext()) {
							this.state.isAmbientContext = true
						}
						return super.parse()
					}
					getExpression() {
						if (this.shouldParseAsAmbientContext()) {
							this.state.isAmbientContext = true
						}
						return super.getExpression()
					}
					parseExportSpecifier(
						node,
						isString,
						isInTypeExport,
						isMaybeTypeOnly,
					) {
						if (!isString && isMaybeTypeOnly) {
							this.parseTypeOnlyImportExportSpecifier(
								node,
								false,
								isInTypeExport,
							)
							return this.finishNode(node, 'ExportSpecifier')
						}
						node.exportKind = 'value'
						return super.parseExportSpecifier(
							node,
							isString,
							isInTypeExport,
							isMaybeTypeOnly,
						)
					}
					parseImportSpecifier(
						specifier,
						importedIsString,
						isInTypeOnlyImport,
						isMaybeTypeOnly,
						bindingType,
					) {
						if (!importedIsString && isMaybeTypeOnly) {
							this.parseTypeOnlyImportExportSpecifier(
								specifier,
								true,
								isInTypeOnlyImport,
							)
							return this.finishNode(specifier, 'ImportSpecifier')
						}
						specifier.importKind = 'value'
						return super.parseImportSpecifier(
							specifier,
							importedIsString,
							isInTypeOnlyImport,
							isMaybeTypeOnly,
							isInTypeOnlyImport ? 4098 : 4096,
						)
					}
					parseTypeOnlyImportExportSpecifier(
						node,
						isImport,
						isInTypeOnlyImportExport,
					) {
						const leftOfAsKey = isImport ? 'imported' : 'local'
						const rightOfAsKey = isImport ? 'local' : 'exported'
						let leftOfAs = node[leftOfAsKey]
						let rightOfAs
						let hasTypeSpecifier = false
						let canParseAsKeyword = true
						const loc = leftOfAs.loc.start
						if (this.isContextual(93)) {
							const firstAs = this.parseIdentifier()
							if (this.isContextual(93)) {
								const secondAs = this.parseIdentifier()
								if (tokenIsKeywordOrIdentifier(this.state.type)) {
									hasTypeSpecifier = true
									leftOfAs = firstAs
									rightOfAs = isImport
										? this.parseIdentifier()
										: this.parseModuleExportName()
									canParseAsKeyword = false
								} else {
									rightOfAs = secondAs
									canParseAsKeyword = false
								}
							} else if (tokenIsKeywordOrIdentifier(this.state.type)) {
								canParseAsKeyword = false
								rightOfAs = isImport
									? this.parseIdentifier()
									: this.parseModuleExportName()
							} else {
								hasTypeSpecifier = true
								leftOfAs = firstAs
							}
						} else if (tokenIsKeywordOrIdentifier(this.state.type)) {
							hasTypeSpecifier = true
							if (isImport) {
								leftOfAs = this.parseIdentifier(true)
								if (!this.isContextual(93)) {
									this.checkReservedWord(
										leftOfAs.name,
										leftOfAs.loc.start,
										true,
										true,
									)
								}
							} else {
								leftOfAs = this.parseModuleExportName()
							}
						}
						if (hasTypeSpecifier && isInTypeOnlyImportExport) {
							this.raise(
								isImport
									? TSErrors.TypeModifierIsUsedInTypeImports
									: TSErrors.TypeModifierIsUsedInTypeExports,
								loc,
							)
						}
						node[leftOfAsKey] = leftOfAs
						node[rightOfAsKey] = rightOfAs
						const kindKey = isImport ? 'importKind' : 'exportKind'
						node[kindKey] = hasTypeSpecifier ? 'type' : 'value'
						if (canParseAsKeyword && this.eatContextual(93)) {
							node[rightOfAsKey] = isImport
								? this.parseIdentifier()
								: this.parseModuleExportName()
						}
						if (!node[rightOfAsKey]) {
							node[rightOfAsKey] = this.cloneIdentifier(node[leftOfAsKey])
						}
						if (isImport) {
							this.checkIdentifier(
								node[rightOfAsKey],
								hasTypeSpecifier ? 4098 : 4096,
							)
						}
					}
					fillOptionalPropertiesForTSESLint(node) {
						var _node$directive,
							_node$decorators,
							_node$optional,
							_node$typeAnnotation,
							_node$accessibility,
							_node$decorators2,
							_node$override,
							_node$readonly,
							_node$static,
							_node$declare,
							_node$returnType,
							_node$typeParameters,
							_node$optional2,
							_node$optional3,
							_node$accessibility2,
							_node$readonly2,
							_node$static2,
							_node$declare2,
							_node$definite,
							_node$readonly3,
							_node$typeAnnotation2,
							_node$accessibility3,
							_node$decorators3,
							_node$override2,
							_node$optional4,
							_node$id,
							_node$abstract,
							_node$declare3,
							_node$decorators4,
							_node$implements,
							_node$superTypeArgume,
							_node$typeParameters2,
							_node$declare4,
							_node$definite2,
							_node$const,
							_node$declare5,
							_node$computed,
							_node$qualifier,
							_node$options,
							_node$declare6,
							_node$extends,
							_node$declare7,
							_node$global,
							_node$const2,
							_node$in,
							_node$out
						switch (node.type) {
							case 'ExpressionStatement':
								;(_node$directive = node.directive) != null
									? _node$directive
									: (node.directive = undefined)
								return
							case 'RestElement':
								node.value = undefined
							case 'Identifier':
							case 'ArrayPattern':
							case 'AssignmentPattern':
							case 'ObjectPattern':
								;(_node$decorators = node.decorators) != null
									? _node$decorators
									: (node.decorators = [])
								;(_node$optional = node.optional) != null
									? _node$optional
									: (node.optional = false)
								;(_node$typeAnnotation = node.typeAnnotation) != null
									? _node$typeAnnotation
									: (node.typeAnnotation = undefined)
								return
							case 'TSParameterProperty':
								;(_node$accessibility = node.accessibility) != null
									? _node$accessibility
									: (node.accessibility = undefined)
								;(_node$decorators2 = node.decorators) != null
									? _node$decorators2
									: (node.decorators = [])
								;(_node$override = node.override) != null
									? _node$override
									: (node.override = false)
								;(_node$readonly = node.readonly) != null
									? _node$readonly
									: (node.readonly = false)
								;(_node$static = node.static) != null
									? _node$static
									: (node.static = false)
								return
							case 'TSEmptyBodyFunctionExpression':
								node.body = null
							case 'TSDeclareFunction':
							case 'FunctionDeclaration':
							case 'FunctionExpression':
							case 'ClassMethod':
							case 'ClassPrivateMethod':
								;(_node$declare = node.declare) != null
									? _node$declare
									: (node.declare = false)
								;(_node$returnType = node.returnType) != null
									? _node$returnType
									: (node.returnType = undefined)
								;(_node$typeParameters = node.typeParameters) != null
									? _node$typeParameters
									: (node.typeParameters = undefined)
								return
							case 'Property':
								;(_node$optional2 = node.optional) != null
									? _node$optional2
									: (node.optional = false)
								return
							case 'TSMethodSignature':
							case 'TSPropertySignature':
								;(_node$optional3 = node.optional) != null
									? _node$optional3
									: (node.optional = false)
							case 'TSIndexSignature':
								;(_node$accessibility2 = node.accessibility) != null
									? _node$accessibility2
									: (node.accessibility = undefined)
								;(_node$readonly2 = node.readonly) != null
									? _node$readonly2
									: (node.readonly = false)
								;(_node$static2 = node.static) != null
									? _node$static2
									: (node.static = false)
								return
							case 'TSAbstractPropertyDefinition':
							case 'PropertyDefinition':
							case 'TSAbstractAccessorProperty':
							case 'AccessorProperty':
								;(_node$declare2 = node.declare) != null
									? _node$declare2
									: (node.declare = false)
								;(_node$definite = node.definite) != null
									? _node$definite
									: (node.definite = false)
								;(_node$readonly3 = node.readonly) != null
									? _node$readonly3
									: (node.readonly = false)
								;(_node$typeAnnotation2 = node.typeAnnotation) != null
									? _node$typeAnnotation2
									: (node.typeAnnotation = undefined)
							case 'TSAbstractMethodDefinition':
							case 'MethodDefinition':
								;(_node$accessibility3 = node.accessibility) != null
									? _node$accessibility3
									: (node.accessibility = undefined)
								;(_node$decorators3 = node.decorators) != null
									? _node$decorators3
									: (node.decorators = [])
								;(_node$override2 = node.override) != null
									? _node$override2
									: (node.override = false)
								;(_node$optional4 = node.optional) != null
									? _node$optional4
									: (node.optional = false)
								return
							case 'ClassExpression':
								;(_node$id = node.id) != null ? _node$id : (node.id = null)
							case 'ClassDeclaration':
								;(_node$abstract = node.abstract) != null
									? _node$abstract
									: (node.abstract = false)
								;(_node$declare3 = node.declare) != null
									? _node$declare3
									: (node.declare = false)
								;(_node$decorators4 = node.decorators) != null
									? _node$decorators4
									: (node.decorators = [])
								;(_node$implements = node.implements) != null
									? _node$implements
									: (node.implements = [])
								;(_node$superTypeArgume = node.superTypeArguments) != null
									? _node$superTypeArgume
									: (node.superTypeArguments = undefined)
								;(_node$typeParameters2 = node.typeParameters) != null
									? _node$typeParameters2
									: (node.typeParameters = undefined)
								return
							case 'TSTypeAliasDeclaration':
							case 'VariableDeclaration':
								;(_node$declare4 = node.declare) != null
									? _node$declare4
									: (node.declare = false)
								return
							case 'VariableDeclarator':
								;(_node$definite2 = node.definite) != null
									? _node$definite2
									: (node.definite = false)
								return
							case 'TSEnumDeclaration':
								;(_node$const = node.const) != null
									? _node$const
									: (node.const = false)
								;(_node$declare5 = node.declare) != null
									? _node$declare5
									: (node.declare = false)
								return
							case 'TSEnumMember':
								;(_node$computed = node.computed) != null
									? _node$computed
									: (node.computed = false)
								return
							case 'TSImportType':
								;(_node$qualifier = node.qualifier) != null
									? _node$qualifier
									: (node.qualifier = null)
								;(_node$options = node.options) != null
									? _node$options
									: (node.options = null)
								return
							case 'TSInterfaceDeclaration':
								;(_node$declare6 = node.declare) != null
									? _node$declare6
									: (node.declare = false)
								;(_node$extends = node.extends) != null
									? _node$extends
									: (node.extends = [])
								return
							case 'TSModuleDeclaration':
								;(_node$declare7 = node.declare) != null
									? _node$declare7
									: (node.declare = false)
								;(_node$global = node.global) != null
									? _node$global
									: (node.global = node.kind === 'global')
								return
							case 'TSTypeParameter':
								;(_node$const2 = node.const) != null
									? _node$const2
									: (node.const = false)
								;(_node$in = node.in) != null ? _node$in : (node.in = false)
								;(_node$out = node.out) != null ? _node$out : (node.out = false)
								return
						}
					}
				}
			function isPossiblyLiteralEnum(expression) {
				if (expression.type !== 'MemberExpression') return false
				const { computed, property } = expression
				if (
					computed &&
					property.type !== 'StringLiteral' &&
					(property.type !== 'TemplateLiteral' ||
						property.expressions.length > 0)
				) {
					return false
				}
				return isUncomputedMemberExpressionChain(expression.object)
			}
			function isValidAmbientConstInitializer(expression, estree) {
				var _expression$extra
				const { type } = expression
				if (
					(_expression$extra = expression.extra) != null &&
					_expression$extra.parenthesized
				) {
					return false
				}
				if (estree) {
					if (type === 'Literal') {
						const { value } = expression
						if (typeof value === 'string' || typeof value === 'boolean') {
							return true
						}
					}
				} else {
					if (type === 'StringLiteral' || type === 'BooleanLiteral') {
						return true
					}
				}
				if (
					isNumber(expression, estree) ||
					isNegativeNumber(expression, estree)
				) {
					return true
				}
				if (type === 'TemplateLiteral' && expression.expressions.length === 0) {
					return true
				}
				if (isPossiblyLiteralEnum(expression)) {
					return true
				}
				return false
			}
			function isNumber(expression, estree) {
				if (estree) {
					return (
						expression.type === 'Literal' &&
						(typeof expression.value === 'number' || 'bigint' in expression)
					)
				}
				return (
					expression.type === 'NumericLiteral' ||
					expression.type === 'BigIntLiteral'
				)
			}
			function isNegativeNumber(expression, estree) {
				if (expression.type === 'UnaryExpression') {
					const { operator, argument } = expression
					if (operator === '-' && isNumber(argument, estree)) {
						return true
					}
				}
				return false
			}
			function isUncomputedMemberExpressionChain(expression) {
				if (expression.type === 'Identifier') return true
				if (expression.type !== 'MemberExpression' || expression.computed) {
					return false
				}
				return isUncomputedMemberExpressionChain(expression.object)
			}
			const PlaceholderErrors = ParseErrorEnum`placeholders`({
				ClassNameIsRequired: 'A class name is required.',
				UnexpectedSpace: 'Unexpected space in placeholder.',
			})
			var placeholders = (superClass) =>
				class PlaceholdersParserMixin extends superClass {
					parsePlaceholder(expectedNode) {
						if (this.match(133)) {
							const node = this.startNode()
							this.next()
							this.assertNoSpace()
							node.name = super.parseIdentifier(true)
							this.assertNoSpace()
							this.expect(133)
							return this.finishPlaceholder(node, expectedNode)
						}
					}
					finishPlaceholder(node, expectedNode) {
						let placeholder = node
						if (!placeholder.expectedNode || !placeholder.type) {
							placeholder = this.finishNode(placeholder, 'Placeholder')
						}
						placeholder.expectedNode = expectedNode
						return placeholder
					}
					getTokenFromCode(code) {
						if (
							code === 37 &&
							this.input.charCodeAt(this.state.pos + 1) === 37
						) {
							this.finishOp(133, 2)
						} else {
							super.getTokenFromCode(code)
						}
					}
					parseExprAtom(refExpressionErrors) {
						return (
							this.parsePlaceholder('Expression') ||
							super.parseExprAtom(refExpressionErrors)
						)
					}
					parseIdentifier(liberal) {
						return (
							this.parsePlaceholder('Identifier') ||
							super.parseIdentifier(liberal)
						)
					}
					checkReservedWord(word, startLoc, checkKeywords, isBinding) {
						if (word !== undefined) {
							super.checkReservedWord(word, startLoc, checkKeywords, isBinding)
						}
					}
					cloneIdentifier(node) {
						const cloned = super.cloneIdentifier(node)
						if (cloned.type === 'Placeholder') {
							cloned.expectedNode = node.expectedNode
						}
						return cloned
					}
					cloneStringLiteral(node) {
						if (node.type === 'Placeholder') {
							return this.cloneIdentifier(node)
						}
						return super.cloneStringLiteral(node)
					}
					parseBindingAtom() {
						return this.parsePlaceholder('Pattern') || super.parseBindingAtom()
					}
					isValidLVal(type, isParenthesized, binding) {
						return (
							type === 'Placeholder' ||
							super.isValidLVal(type, isParenthesized, binding)
						)
					}
					toAssignable(node, isLHS) {
						if (
							node &&
							node.type === 'Placeholder' &&
							node.expectedNode === 'Expression'
						) {
							node.expectedNode = 'Pattern'
						} else {
							super.toAssignable(node, isLHS)
						}
					}
					chStartsBindingIdentifier(ch, pos) {
						if (super.chStartsBindingIdentifier(ch, pos)) {
							return true
						}
						const nextToken = this.lookahead()
						if (nextToken.type === 133) {
							return true
						}
						return false
					}
					verifyBreakContinue(node, isBreak) {
						if (node.label && node.label.type === 'Placeholder') return
						super.verifyBreakContinue(node, isBreak)
					}
					parseExpressionStatement(node, expr) {
						var _expr$extra
						if (
							expr.type !== 'Placeholder' ||
							((_expr$extra = expr.extra) != null && _expr$extra.parenthesized)
						) {
							return super.parseExpressionStatement(node, expr)
						}
						if (this.match(14)) {
							const stmt = node
							stmt.label = this.finishPlaceholder(expr, 'Identifier')
							this.next()
							stmt.body =
								super.parseStatementOrSloppyAnnexBFunctionDeclaration()
							return this.finishNode(stmt, 'LabeledStatement')
						}
						this.semicolon()
						const stmtPlaceholder = node
						stmtPlaceholder.name = expr.name
						return this.finishPlaceholder(stmtPlaceholder, 'Statement')
					}
					parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
						return (
							this.parsePlaceholder('BlockStatement') ||
							super.parseBlock(
								allowDirectives,
								createNewLexicalScope,
								afterBlockParse,
							)
						)
					}
					parseFunctionId(requireId) {
						return (
							this.parsePlaceholder('Identifier') ||
							super.parseFunctionId(requireId)
						)
					}
					parseClass(node, isStatement, optionalId) {
						const type = isStatement ? 'ClassDeclaration' : 'ClassExpression'
						this.next()
						const oldStrict = this.state.strict
						const placeholder = this.parsePlaceholder('Identifier')
						if (placeholder) {
							if (this.match(81) || this.match(133) || this.match(5)) {
								node.id = placeholder
							} else if (optionalId || !isStatement) {
								node.id = null
								node.body = this.finishPlaceholder(placeholder, 'ClassBody')
								return this.finishNode(node, type)
							} else {
								throw this.raise(
									PlaceholderErrors.ClassNameIsRequired,
									this.state.startLoc,
								)
							}
						} else {
							this.parseClassId(node, isStatement, optionalId)
						}
						super.parseClassSuper(node)
						node.body =
							this.parsePlaceholder('ClassBody') ||
							super.parseClassBody(!!node.superClass, oldStrict)
						return this.finishNode(node, type)
					}
					parseExport(node, decorators) {
						const placeholder = this.parsePlaceholder('Identifier')
						if (!placeholder) return super.parseExport(node, decorators)
						const node2 = node
						if (!this.isContextual(98) && !this.match(12)) {
							node2.specifiers = []
							node2.source = null
							node2.declaration = this.finishPlaceholder(
								placeholder,
								'Declaration',
							)
							return this.finishNode(node2, 'ExportNamedDeclaration')
						}
						this.expectPlugin('exportDefaultFrom')
						const specifier = this.startNode()
						specifier.exported = placeholder
						node2.specifiers = [
							this.finishNode(specifier, 'ExportDefaultSpecifier'),
						]
						return super.parseExport(node2, decorators)
					}
					isExportDefaultSpecifier() {
						if (this.match(65)) {
							const next = this.nextTokenStart()
							if (this.isUnparsedContextual(next, 'from')) {
								if (
									this.input.startsWith(
										tokenLabelName(133),
										this.nextTokenStartSince(next + 4),
									)
								) {
									return true
								}
							}
						}
						return super.isExportDefaultSpecifier()
					}
					maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
						var _specifiers
						if ((_specifiers = node.specifiers) != null && _specifiers.length) {
							return true
						}
						return super.maybeParseExportDefaultSpecifier(
							node,
							maybeDefaultIdentifier,
						)
					}
					checkExport(node) {
						const { specifiers } = node
						if (specifiers != null && specifiers.length) {
							node.specifiers = specifiers.filter(
								(node) => node.exported.type === 'Placeholder',
							)
						}
						super.checkExport(node)
						node.specifiers = specifiers
					}
					parseImport(node) {
						const placeholder = this.parsePlaceholder('Identifier')
						if (!placeholder) return super.parseImport(node)
						node.specifiers = []
						if (!this.isContextual(98) && !this.match(12)) {
							node.source = this.finishPlaceholder(placeholder, 'StringLiteral')
							this.semicolon()
							return this.finishNode(node, 'ImportDeclaration')
						}
						const specifier = this.startNodeAtNode(placeholder)
						specifier.local = placeholder
						node.specifiers.push(
							this.finishNode(specifier, 'ImportDefaultSpecifier'),
						)
						if (this.eat(12)) {
							const hasStarImport = this.maybeParseStarImportSpecifier(node)
							if (!hasStarImport) this.parseNamedImportSpecifiers(node)
						}
						this.expectContextual(98)
						node.source = this.parseImportSource()
						this.semicolon()
						return this.finishNode(node, 'ImportDeclaration')
					}
					parseImportSource() {
						return (
							this.parsePlaceholder('StringLiteral') ||
							super.parseImportSource()
						)
					}
					assertNoSpace() {
						if (
							this.state.start >
							this.offsetToSourcePos(this.state.lastTokEndLoc.index)
						) {
							this.raise(
								PlaceholderErrors.UnexpectedSpace,
								this.state.lastTokEndLoc,
							)
						}
					}
				}
			var v8intrinsic = (superClass) =>
				class V8IntrinsicMixin extends superClass {
					parseV8Intrinsic() {
						if (this.match(54)) {
							const v8IntrinsicStartLoc = this.state.startLoc
							const node = this.startNode()
							this.next()
							if (tokenIsIdentifier(this.state.type)) {
								const name = this.parseIdentifierName()
								const identifier = this.createIdentifier(node, name)
								this.castNodeTo(identifier, 'V8IntrinsicIdentifier')
								if (this.match(10)) {
									return identifier
								}
							}
							this.unexpected(v8IntrinsicStartLoc)
						}
					}
					parseExprAtom(refExpressionErrors) {
						return (
							this.parseV8Intrinsic() ||
							super.parseExprAtom(refExpressionErrors)
						)
					}
				}
			const PIPELINE_PROPOSALS = ['minimal', 'fsharp', 'hack', 'smart']
			const TOPIC_TOKENS = ['^^', '@@', '^', '%', '#']
			function validatePlugins(pluginsMap) {
				if (pluginsMap.has('decorators')) {
					if (pluginsMap.has('decorators-legacy')) {
						throw new Error(
							'Cannot use the decorators and decorators-legacy plugin together',
						)
					}
					const decoratorsBeforeExport =
						pluginsMap.get('decorators').decoratorsBeforeExport
					if (
						decoratorsBeforeExport != null &&
						typeof decoratorsBeforeExport !== 'boolean'
					) {
						throw new Error(
							"'decoratorsBeforeExport' must be a boolean, if specified.",
						)
					}
					const allowCallParenthesized =
						pluginsMap.get('decorators').allowCallParenthesized
					if (
						allowCallParenthesized != null &&
						typeof allowCallParenthesized !== 'boolean'
					) {
						throw new Error("'allowCallParenthesized' must be a boolean.")
					}
				}
				if (pluginsMap.has('flow') && pluginsMap.has('typescript')) {
					throw new Error('Cannot combine flow and typescript plugins.')
				}
				if (pluginsMap.has('placeholders') && pluginsMap.has('v8intrinsic')) {
					throw new Error(
						'Cannot combine placeholders and v8intrinsic plugins.',
					)
				}
				if (pluginsMap.has('pipelineOperator')) {
					var _pluginsMap$get2
					const proposal = pluginsMap.get('pipelineOperator').proposal
					if (!PIPELINE_PROPOSALS.includes(proposal)) {
						const proposalList = PIPELINE_PROPOSALS.map((p) => `"${p}"`).join(
							', ',
						)
						throw new Error(
							`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`,
						)
					}
					if (proposal === 'hack') {
						if (pluginsMap.has('placeholders')) {
							throw new Error(
								'Cannot combine placeholders plugin and Hack-style pipes.',
							)
						}
						if (pluginsMap.has('v8intrinsic')) {
							throw new Error(
								'Cannot combine v8intrinsic plugin and Hack-style pipes.',
							)
						}
						const topicToken = pluginsMap.get('pipelineOperator').topicToken
						if (!TOPIC_TOKENS.includes(topicToken)) {
							const tokenList = TOPIC_TOKENS.map((t) => `"${t}"`).join(', ')
							throw new Error(
								`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`,
							)
						}
						{
							var _pluginsMap$get
							if (
								topicToken === '#' &&
								((_pluginsMap$get = pluginsMap.get('recordAndTuple')) == null
									? void 0
									: _pluginsMap$get.syntaxType) === 'hash'
							) {
								throw new Error(
									`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(['recordAndTuple', pluginsMap.get('recordAndTuple')])}\`.`,
								)
							}
						}
					} else if (
						proposal === 'smart' &&
						((_pluginsMap$get2 = pluginsMap.get('recordAndTuple')) == null
							? void 0
							: _pluginsMap$get2.syntaxType) === 'hash'
					) {
						throw new Error(
							`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(['recordAndTuple', pluginsMap.get('recordAndTuple')])}\`.`,
						)
					}
				}
				if (pluginsMap.has('moduleAttributes')) {
					{
						if (
							pluginsMap.has('deprecatedImportAssert') ||
							pluginsMap.has('importAssertions')
						) {
							throw new Error(
								'Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.',
							)
						}
						const moduleAttributesVersionPluginOption =
							pluginsMap.get('moduleAttributes').version
						if (moduleAttributesVersionPluginOption !== 'may-2020') {
							throw new Error(
								"The 'moduleAttributes' plugin requires a 'version' option," +
									' representing the last proposal update. Currently, the' +
									" only supported value is 'may-2020'.",
							)
						}
					}
				}
				if (pluginsMap.has('importAssertions')) {
					if (pluginsMap.has('deprecatedImportAssert')) {
						throw new Error(
							'Cannot combine importAssertions and deprecatedImportAssert plugins.',
						)
					}
				}
				if (
					!pluginsMap.has('deprecatedImportAssert') &&
					pluginsMap.has('importAttributes') &&
					pluginsMap.get('importAttributes').deprecatedAssertSyntax
				) {
					{
						pluginsMap.set('deprecatedImportAssert', {})
					}
				}
				if (pluginsMap.has('recordAndTuple')) {
					{
						const syntaxType = pluginsMap.get('recordAndTuple').syntaxType
						if (syntaxType != null) {
							const RECORD_AND_TUPLE_SYNTAX_TYPES = ['hash', 'bar']
							if (!RECORD_AND_TUPLE_SYNTAX_TYPES.includes(syntaxType)) {
								throw new Error(
									"The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " +
										RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(
											', ',
										),
								)
							}
						}
					}
				}
				if (
					pluginsMap.has('asyncDoExpressions') &&
					!pluginsMap.has('doExpressions')
				) {
					const error = new Error(
						"'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.",
					)
					error.missingPlugins = 'doExpressions'
					throw error
				}
				if (
					pluginsMap.has('optionalChainingAssign') &&
					pluginsMap.get('optionalChainingAssign').version !== '2023-07'
				) {
					throw new Error(
						"The 'optionalChainingAssign' plugin requires a 'version' option," +
							' representing the last proposal update. Currently, the' +
							" only supported value is '2023-07'.",
					)
				}
			}
			const mixinPlugins = {
				estree,
				jsx,
				flow,
				typescript,
				v8intrinsic,
				placeholders,
			}
			const mixinPluginNames = Object.keys(mixinPlugins)
			class ExpressionParser extends LValParser {
				checkProto(prop, isRecord, sawProto, refExpressionErrors) {
					if (
						prop.type === 'SpreadElement' ||
						this.isObjectMethod(prop) ||
						prop.computed ||
						prop.shorthand
					) {
						return sawProto
					}
					const key = prop.key
					const name = key.type === 'Identifier' ? key.name : key.value
					if (name === '__proto__') {
						if (isRecord) {
							this.raise(Errors.RecordNoProto, key)
							return true
						}
						if (sawProto) {
							if (refExpressionErrors) {
								if (refExpressionErrors.doubleProtoLoc === null) {
									refExpressionErrors.doubleProtoLoc = key.loc.start
								}
							} else {
								this.raise(Errors.DuplicateProto, key)
							}
						}
						return true
					}
					return sawProto
				}
				shouldExitDescending(expr, potentialArrowAt) {
					return (
						expr.type === 'ArrowFunctionExpression' &&
						this.offsetToSourcePos(expr.start) === potentialArrowAt
					)
				}
				getExpression() {
					this.enterInitialScopes()
					this.nextToken()
					const expr = this.parseExpression()
					if (!this.match(140)) {
						this.unexpected()
					}
					this.finalizeRemainingComments()
					expr.comments = this.comments
					expr.errors = this.state.errors
					if (this.optionFlags & 256) {
						expr.tokens = this.tokens
					}
					return expr
				}
				parseExpression(disallowIn, refExpressionErrors) {
					if (disallowIn) {
						return this.disallowInAnd(() =>
							this.parseExpressionBase(refExpressionErrors),
						)
					}
					return this.allowInAnd(() =>
						this.parseExpressionBase(refExpressionErrors),
					)
				}
				parseExpressionBase(refExpressionErrors) {
					const startLoc = this.state.startLoc
					const expr = this.parseMaybeAssign(refExpressionErrors)
					if (this.match(12)) {
						const node = this.startNodeAt(startLoc)
						node.expressions = [expr]
						while (this.eat(12)) {
							node.expressions.push(this.parseMaybeAssign(refExpressionErrors))
						}
						this.toReferencedList(node.expressions)
						return this.finishNode(node, 'SequenceExpression')
					}
					return expr
				}
				parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
					return this.disallowInAnd(() =>
						this.parseMaybeAssign(refExpressionErrors, afterLeftParse),
					)
				}
				parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
					return this.allowInAnd(() =>
						this.parseMaybeAssign(refExpressionErrors, afterLeftParse),
					)
				}
				setOptionalParametersError(refExpressionErrors) {
					refExpressionErrors.optionalParametersLoc = this.state.startLoc
				}
				parseMaybeAssign(refExpressionErrors, afterLeftParse) {
					const startLoc = this.state.startLoc
					const isYield = this.isContextual(108)
					if (isYield) {
						if (this.prodParam.hasYield) {
							this.next()
							let left = this.parseYield(startLoc)
							if (afterLeftParse) {
								left = afterLeftParse.call(this, left, startLoc)
							}
							return left
						}
					}
					let ownExpressionErrors
					if (refExpressionErrors) {
						ownExpressionErrors = false
					} else {
						refExpressionErrors = new ExpressionErrors()
						ownExpressionErrors = true
					}
					const { type } = this.state
					if (type === 10 || tokenIsIdentifier(type)) {
						this.state.potentialArrowAt = this.state.start
					}
					let left = this.parseMaybeConditional(refExpressionErrors)
					if (afterLeftParse) {
						left = afterLeftParse.call(this, left, startLoc)
					}
					if (tokenIsAssignment(this.state.type)) {
						const node = this.startNodeAt(startLoc)
						const operator = this.state.value
						node.operator = operator
						if (this.match(29)) {
							this.toAssignable(left, true)
							node.left = left
							const startIndex = startLoc.index
							if (
								refExpressionErrors.doubleProtoLoc != null &&
								refExpressionErrors.doubleProtoLoc.index >= startIndex
							) {
								refExpressionErrors.doubleProtoLoc = null
							}
							if (
								refExpressionErrors.shorthandAssignLoc != null &&
								refExpressionErrors.shorthandAssignLoc.index >= startIndex
							) {
								refExpressionErrors.shorthandAssignLoc = null
							}
							if (
								refExpressionErrors.privateKeyLoc != null &&
								refExpressionErrors.privateKeyLoc.index >= startIndex
							) {
								this.checkDestructuringPrivate(refExpressionErrors)
								refExpressionErrors.privateKeyLoc = null
							}
						} else {
							node.left = left
						}
						this.next()
						node.right = this.parseMaybeAssign()
						this.checkLVal(left, this.finishNode(node, 'AssignmentExpression'))
						return node
					} else if (ownExpressionErrors) {
						this.checkExpressionErrors(refExpressionErrors, true)
					}
					if (isYield) {
						const { type } = this.state
						const startsExpr = this.hasPlugin('v8intrinsic')
							? tokenCanStartExpression(type)
							: tokenCanStartExpression(type) && !this.match(54)
						if (startsExpr && !this.isAmbiguousPrefixOrIdentifier()) {
							this.raiseOverwrite(Errors.YieldNotInGeneratorFunction, startLoc)
							return this.parseYield(startLoc)
						}
					}
					return left
				}
				parseMaybeConditional(refExpressionErrors) {
					const startLoc = this.state.startLoc
					const potentialArrowAt = this.state.potentialArrowAt
					const expr = this.parseExprOps(refExpressionErrors)
					if (this.shouldExitDescending(expr, potentialArrowAt)) {
						return expr
					}
					return this.parseConditional(expr, startLoc, refExpressionErrors)
				}
				parseConditional(expr, startLoc, refExpressionErrors) {
					if (this.eat(17)) {
						const node = this.startNodeAt(startLoc)
						node.test = expr
						node.consequent = this.parseMaybeAssignAllowIn()
						this.expect(14)
						node.alternate = this.parseMaybeAssign()
						return this.finishNode(node, 'ConditionalExpression')
					}
					return expr
				}
				parseMaybeUnaryOrPrivate(refExpressionErrors) {
					return this.match(139)
						? this.parsePrivateName()
						: this.parseMaybeUnary(refExpressionErrors)
				}
				parseExprOps(refExpressionErrors) {
					const startLoc = this.state.startLoc
					const potentialArrowAt = this.state.potentialArrowAt
					const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors)
					if (this.shouldExitDescending(expr, potentialArrowAt)) {
						return expr
					}
					return this.parseExprOp(expr, startLoc, -1)
				}
				parseExprOp(left, leftStartLoc, minPrec) {
					if (this.isPrivateName(left)) {
						const value = this.getPrivateNameSV(left)
						if (
							minPrec >= tokenOperatorPrecedence(58) ||
							!this.prodParam.hasIn ||
							!this.match(58)
						) {
							this.raise(Errors.PrivateInExpectedIn, left, {
								identifierName: value,
							})
						}
						this.classScope.usePrivateName(value, left.loc.start)
					}
					const op = this.state.type
					if (
						tokenIsOperator(op) &&
						(this.prodParam.hasIn || !this.match(58))
					) {
						let prec = tokenOperatorPrecedence(op)
						if (prec > minPrec) {
							if (op === 39) {
								this.expectPlugin('pipelineOperator')
								if (this.state.inFSharpPipelineDirectBody) {
									return left
								}
								this.checkPipelineAtInfixOperator(left, leftStartLoc)
							}
							const node = this.startNodeAt(leftStartLoc)
							node.left = left
							node.operator = this.state.value
							const logical = op === 41 || op === 42
							const coalesce = op === 40
							if (coalesce) {
								prec = tokenOperatorPrecedence(42)
							}
							this.next()
							if (
								op === 39 &&
								this.hasPlugin([
									'pipelineOperator',
									{
										proposal: 'minimal',
									},
								])
							) {
								if (this.state.type === 96 && this.prodParam.hasAwait) {
									throw this.raise(
										Errors.UnexpectedAwaitAfterPipelineBody,
										this.state.startLoc,
									)
								}
							}
							node.right = this.parseExprOpRightExpr(op, prec)
							const finishedNode = this.finishNode(
								node,
								logical || coalesce ? 'LogicalExpression' : 'BinaryExpression',
							)
							const nextOp = this.state.type
							if (
								(coalesce && (nextOp === 41 || nextOp === 42)) ||
								(logical && nextOp === 40)
							) {
								throw this.raise(
									Errors.MixingCoalesceWithLogical,
									this.state.startLoc,
								)
							}
							return this.parseExprOp(finishedNode, leftStartLoc, minPrec)
						}
					}
					return left
				}
				parseExprOpRightExpr(op, prec) {
					const startLoc = this.state.startLoc
					switch (op) {
						case 39:
							switch (this.getPluginOption('pipelineOperator', 'proposal')) {
								case 'hack':
									return this.withTopicBindingContext(() => {
										return this.parseHackPipeBody()
									})
								case 'fsharp':
									return this.withSoloAwaitPermittingContext(() => {
										return this.parseFSharpPipelineBody(prec)
									})
							}
							if (
								this.getPluginOption('pipelineOperator', 'proposal') === 'smart'
							) {
								return this.withTopicBindingContext(() => {
									if (this.prodParam.hasYield && this.isContextual(108)) {
										throw this.raise(
											Errors.PipeBodyIsTighter,
											this.state.startLoc,
										)
									}
									return this.parseSmartPipelineBodyInStyle(
										this.parseExprOpBaseRightExpr(op, prec),
										startLoc,
									)
								})
							}
						default:
							return this.parseExprOpBaseRightExpr(op, prec)
					}
				}
				parseExprOpBaseRightExpr(op, prec) {
					const startLoc = this.state.startLoc
					return this.parseExprOp(
						this.parseMaybeUnaryOrPrivate(),
						startLoc,
						tokenIsRightAssociative(op) ? prec - 1 : prec,
					)
				}
				parseHackPipeBody() {
					var _body$extra
					const { startLoc } = this.state
					const body = this.parseMaybeAssign()
					const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(
						body.type,
					)
					if (
						requiredParentheses &&
						!((_body$extra = body.extra) != null && _body$extra.parenthesized)
					) {
						this.raise(Errors.PipeUnparenthesizedBody, startLoc, {
							type: body.type,
						})
					}
					if (!this.topicReferenceWasUsedInCurrentContext()) {
						this.raise(Errors.PipeTopicUnused, startLoc)
					}
					return body
				}
				checkExponentialAfterUnary(node) {
					if (this.match(57)) {
						this.raise(Errors.UnexpectedTokenUnaryExponentiation, node.argument)
					}
				}
				parseMaybeUnary(refExpressionErrors, sawUnary) {
					const startLoc = this.state.startLoc
					const isAwait = this.isContextual(96)
					if (isAwait && this.recordAwaitIfAllowed()) {
						this.next()
						const expr = this.parseAwait(startLoc)
						if (!sawUnary) this.checkExponentialAfterUnary(expr)
						return expr
					}
					const update = this.match(34)
					const node = this.startNode()
					if (tokenIsPrefix(this.state.type)) {
						node.operator = this.state.value
						node.prefix = true
						if (this.match(72)) {
							this.expectPlugin('throwExpressions')
						}
						const isDelete = this.match(89)
						this.next()
						node.argument = this.parseMaybeUnary(null, true)
						this.checkExpressionErrors(refExpressionErrors, true)
						if (this.state.strict && isDelete) {
							const arg = node.argument
							if (arg.type === 'Identifier') {
								this.raise(Errors.StrictDelete, node)
							} else if (this.hasPropertyAsPrivateName(arg)) {
								this.raise(Errors.DeletePrivateField, node)
							}
						}
						if (!update) {
							if (!sawUnary) {
								this.checkExponentialAfterUnary(node)
							}
							return this.finishNode(node, 'UnaryExpression')
						}
					}
					const expr = this.parseUpdate(node, update, refExpressionErrors)
					if (isAwait) {
						const { type } = this.state
						const startsExpr = this.hasPlugin('v8intrinsic')
							? tokenCanStartExpression(type)
							: tokenCanStartExpression(type) && !this.match(54)
						if (startsExpr && !this.isAmbiguousPrefixOrIdentifier()) {
							this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc)
							return this.parseAwait(startLoc)
						}
					}
					return expr
				}
				parseUpdate(node, update, refExpressionErrors) {
					if (update) {
						const updateExpressionNode = node
						this.checkLVal(
							updateExpressionNode.argument,
							this.finishNode(updateExpressionNode, 'UpdateExpression'),
						)
						return node
					}
					const startLoc = this.state.startLoc
					let expr = this.parseExprSubscripts(refExpressionErrors)
					if (this.checkExpressionErrors(refExpressionErrors, false))
						return expr
					while (
						tokenIsPostfix(this.state.type) &&
						!this.canInsertSemicolon()
					) {
						const node = this.startNodeAt(startLoc)
						node.operator = this.state.value
						node.prefix = false
						node.argument = expr
						this.next()
						this.checkLVal(
							expr,
							(expr = this.finishNode(node, 'UpdateExpression')),
						)
					}
					return expr
				}
				parseExprSubscripts(refExpressionErrors) {
					const startLoc = this.state.startLoc
					const potentialArrowAt = this.state.potentialArrowAt
					const expr = this.parseExprAtom(refExpressionErrors)
					if (this.shouldExitDescending(expr, potentialArrowAt)) {
						return expr
					}
					return this.parseSubscripts(expr, startLoc)
				}
				parseSubscripts(base, startLoc, noCalls) {
					const state = {
						optionalChainMember: false,
						maybeAsyncArrow: this.atPossibleAsyncArrow(base),
						stop: false,
					}
					do {
						base = this.parseSubscript(base, startLoc, noCalls, state)
						state.maybeAsyncArrow = false
					} while (!state.stop)
					return base
				}
				parseSubscript(base, startLoc, noCalls, state) {
					const { type } = this.state
					if (!noCalls && type === 15) {
						return this.parseBind(base, startLoc, noCalls, state)
					} else if (tokenIsTemplate(type)) {
						return this.parseTaggedTemplateExpression(base, startLoc, state)
					}
					let optional = false
					if (type === 18) {
						if (noCalls) {
							this.raise(Errors.OptionalChainingNoNew, this.state.startLoc)
							if (this.lookaheadCharCode() === 40) {
								return this.stopParseSubscript(base, state)
							}
						}
						state.optionalChainMember = optional = true
						this.next()
					}
					if (!noCalls && this.match(10)) {
						return this.parseCoverCallAndAsyncArrowHead(
							base,
							startLoc,
							state,
							optional,
						)
					} else {
						const computed = this.eat(0)
						if (computed || optional || this.eat(16)) {
							return this.parseMember(base, startLoc, state, computed, optional)
						} else {
							return this.stopParseSubscript(base, state)
						}
					}
				}
				stopParseSubscript(base, state) {
					state.stop = true
					return base
				}
				parseMember(base, startLoc, state, computed, optional) {
					const node = this.startNodeAt(startLoc)
					node.object = base
					node.computed = computed
					if (computed) {
						node.property = this.parseExpression()
						this.expect(3)
					} else if (this.match(139)) {
						if (base.type === 'Super') {
							this.raise(Errors.SuperPrivateField, startLoc)
						}
						this.classScope.usePrivateName(
							this.state.value,
							this.state.startLoc,
						)
						node.property = this.parsePrivateName()
					} else {
						node.property = this.parseIdentifier(true)
					}
					if (state.optionalChainMember) {
						node.optional = optional
						return this.finishNode(node, 'OptionalMemberExpression')
					} else {
						return this.finishNode(node, 'MemberExpression')
					}
				}
				parseBind(base, startLoc, noCalls, state) {
					const node = this.startNodeAt(startLoc)
					node.object = base
					this.next()
					node.callee = this.parseNoCallExpr()
					state.stop = true
					return this.parseSubscripts(
						this.finishNode(node, 'BindExpression'),
						startLoc,
						noCalls,
					)
				}
				parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {
					const oldMaybeInArrowParameters = this.state.maybeInArrowParameters
					let refExpressionErrors = null
					this.state.maybeInArrowParameters = true
					this.next()
					const node = this.startNodeAt(startLoc)
					node.callee = base
					const { maybeAsyncArrow, optionalChainMember } = state
					if (maybeAsyncArrow) {
						this.expressionScope.enter(newAsyncArrowScope())
						refExpressionErrors = new ExpressionErrors()
					}
					if (optionalChainMember) {
						node.optional = optional
					}
					if (optional) {
						node.arguments = this.parseCallExpressionArguments(11)
					} else {
						node.arguments = this.parseCallExpressionArguments(
							11,
							base.type !== 'Super',
							node,
							refExpressionErrors,
						)
					}
					let finishedNode = this.finishCallExpression(
						node,
						optionalChainMember,
					)
					if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
						state.stop = true
						this.checkDestructuringPrivate(refExpressionErrors)
						this.expressionScope.validateAsPattern()
						this.expressionScope.exit()
						finishedNode = this.parseAsyncArrowFromCallExpression(
							this.startNodeAt(startLoc),
							finishedNode,
						)
					} else {
						if (maybeAsyncArrow) {
							this.checkExpressionErrors(refExpressionErrors, true)
							this.expressionScope.exit()
						}
						this.toReferencedArguments(finishedNode)
					}
					this.state.maybeInArrowParameters = oldMaybeInArrowParameters
					return finishedNode
				}
				toReferencedArguments(node, isParenthesizedExpr) {
					this.toReferencedListDeep(node.arguments, isParenthesizedExpr)
				}
				parseTaggedTemplateExpression(base, startLoc, state) {
					const node = this.startNodeAt(startLoc)
					node.tag = base
					node.quasi = this.parseTemplate(true)
					if (state.optionalChainMember) {
						this.raise(Errors.OptionalChainingNoTemplate, startLoc)
					}
					return this.finishNode(node, 'TaggedTemplateExpression')
				}
				atPossibleAsyncArrow(base) {
					return (
						base.type === 'Identifier' &&
						base.name === 'async' &&
						this.state.lastTokEndLoc.index === base.end &&
						!this.canInsertSemicolon() &&
						base.end - base.start === 5 &&
						this.offsetToSourcePos(base.start) === this.state.potentialArrowAt
					)
				}
				finishCallExpression(node, optional) {
					if (node.callee.type === 'Import') {
						if (node.arguments.length === 0 || node.arguments.length > 2) {
							this.raise(Errors.ImportCallArity, node)
						} else {
							for (const arg of node.arguments) {
								if (arg.type === 'SpreadElement') {
									this.raise(Errors.ImportCallSpreadArgument, arg)
								}
							}
						}
					}
					return this.finishNode(
						node,
						optional ? 'OptionalCallExpression' : 'CallExpression',
					)
				}
				parseCallExpressionArguments(
					close,
					allowPlaceholder,
					nodeForExtra,
					refExpressionErrors,
				) {
					const elts = []
					let first = true
					const oldInFSharpPipelineDirectBody =
						this.state.inFSharpPipelineDirectBody
					this.state.inFSharpPipelineDirectBody = false
					while (!this.eat(close)) {
						if (first) {
							first = false
						} else {
							this.expect(12)
							if (this.match(close)) {
								if (nodeForExtra) {
									this.addTrailingCommaExtraToNode(nodeForExtra)
								}
								this.next()
								break
							}
						}
						elts.push(
							this.parseExprListItem(
								false,
								refExpressionErrors,
								allowPlaceholder,
							),
						)
					}
					this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody
					return elts
				}
				shouldParseAsyncArrow() {
					return this.match(19) && !this.canInsertSemicolon()
				}
				parseAsyncArrowFromCallExpression(node, call) {
					var _call$extra
					this.resetPreviousNodeTrailingComments(call)
					this.expect(19)
					this.parseArrowExpression(
						node,
						call.arguments,
						true,
						(_call$extra = call.extra) == null
							? void 0
							: _call$extra.trailingCommaLoc,
					)
					if (call.innerComments) {
						setInnerComments(node, call.innerComments)
					}
					if (call.callee.trailingComments) {
						setInnerComments(node, call.callee.trailingComments)
					}
					return node
				}
				parseNoCallExpr() {
					const startLoc = this.state.startLoc
					return this.parseSubscripts(this.parseExprAtom(), startLoc, true)
				}
				parseExprAtom(refExpressionErrors) {
					let node
					let decorators = null
					const { type } = this.state
					switch (type) {
						case 79:
							return this.parseSuper()
						case 83:
							node = this.startNode()
							this.next()
							if (this.match(16)) {
								return this.parseImportMetaProperty(node)
							}
							if (this.match(10)) {
								if (this.optionFlags & 512) {
									return this.parseImportCall(node)
								} else {
									return this.finishNode(node, 'Import')
								}
							} else {
								this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc)
								return this.finishNode(node, 'Import')
							}
						case 78:
							node = this.startNode()
							this.next()
							return this.finishNode(node, 'ThisExpression')
						case 90: {
							return this.parseDo(this.startNode(), false)
						}
						case 56:
						case 31: {
							this.readRegexp()
							return this.parseRegExpLiteral(this.state.value)
						}
						case 135:
							return this.parseNumericLiteral(this.state.value)
						case 136:
							return this.parseBigIntLiteral(this.state.value)
						case 134:
							return this.parseStringLiteral(this.state.value)
						case 84:
							return this.parseNullLiteral()
						case 85:
							return this.parseBooleanLiteral(true)
						case 86:
							return this.parseBooleanLiteral(false)
						case 10: {
							const canBeArrow =
								this.state.potentialArrowAt === this.state.start
							return this.parseParenAndDistinguishExpression(canBeArrow)
						}
						case 0: {
							return this.parseArrayLike(3, true, false, refExpressionErrors)
						}
						case 5: {
							return this.parseObjectLike(8, false, false, refExpressionErrors)
						}
						case 68:
							return this.parseFunctionOrFunctionSent()
						case 26:
							decorators = this.parseDecorators()
						case 80:
							return this.parseClass(
								this.maybeTakeDecorators(decorators, this.startNode()),
								false,
							)
						case 77:
							return this.parseNewOrNewTarget()
						case 25:
						case 24:
							return this.parseTemplate(false)
						case 15: {
							node = this.startNode()
							this.next()
							node.object = null
							const callee = (node.callee = this.parseNoCallExpr())
							if (callee.type === 'MemberExpression') {
								return this.finishNode(node, 'BindExpression')
							} else {
								throw this.raise(Errors.UnsupportedBind, callee)
							}
						}
						case 139: {
							this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {
								identifierName: this.state.value,
							})
							return this.parsePrivateName()
						}
						case 33: {
							return this.parseTopicReferenceThenEqualsSign(54, '%')
						}
						case 32: {
							return this.parseTopicReferenceThenEqualsSign(44, '^')
						}
						case 37:
						case 38: {
							return this.parseTopicReference('hack')
						}
						case 44:
						case 54:
						case 27: {
							const pipeProposal = this.getPluginOption(
								'pipelineOperator',
								'proposal',
							)
							if (pipeProposal) {
								return this.parseTopicReference(pipeProposal)
							}
							this.unexpected()
							break
						}
						case 47: {
							const lookaheadCh = this.input.codePointAt(this.nextTokenStart())
							if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
								this.expectOnePlugin(['jsx', 'flow', 'typescript'])
							} else {
								this.unexpected()
							}
							break
						}
						default:
							{
								if (type === 137) {
									return this.parseDecimalLiteral(this.state.value)
								} else if (type === 2 || type === 1) {
									return this.parseArrayLike(
										this.state.type === 2 ? 4 : 3,
										false,
										true,
									)
								} else if (type === 6 || type === 7) {
									return this.parseObjectLike(
										this.state.type === 6 ? 9 : 8,
										false,
										true,
									)
								}
							}
							if (tokenIsIdentifier(type)) {
								if (
									this.isContextual(127) &&
									this.lookaheadInLineCharCode() === 123
								) {
									return this.parseModuleExpression()
								}
								const canBeArrow =
									this.state.potentialArrowAt === this.state.start
								const containsEsc = this.state.containsEsc
								const id = this.parseIdentifier()
								if (
									!containsEsc &&
									id.name === 'async' &&
									!this.canInsertSemicolon()
								) {
									const { type } = this.state
									if (type === 68) {
										this.resetPreviousNodeTrailingComments(id)
										this.next()
										return this.parseAsyncFunctionExpression(
											this.startNodeAtNode(id),
										)
									} else if (tokenIsIdentifier(type)) {
										if (this.lookaheadCharCode() === 61) {
											return this.parseAsyncArrowUnaryFunction(
												this.startNodeAtNode(id),
											)
										} else {
											return id
										}
									} else if (type === 90) {
										this.resetPreviousNodeTrailingComments(id)
										return this.parseDo(this.startNodeAtNode(id), true)
									}
								}
								if (
									canBeArrow &&
									this.match(19) &&
									!this.canInsertSemicolon()
								) {
									this.next()
									return this.parseArrowExpression(
										this.startNodeAtNode(id),
										[id],
										false,
									)
								}
								return id
							} else {
								this.unexpected()
							}
					}
				}
				parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
					const pipeProposal = this.getPluginOption(
						'pipelineOperator',
						'proposal',
					)
					if (pipeProposal) {
						this.state.type = topicTokenType
						this.state.value = topicTokenValue
						this.state.pos--
						this.state.end--
						this.state.endLoc = createPositionWithColumnOffset(
							this.state.endLoc,
							-1,
						)
						return this.parseTopicReference(pipeProposal)
					} else {
						this.unexpected()
					}
				}
				parseTopicReference(pipeProposal) {
					const node = this.startNode()
					const startLoc = this.state.startLoc
					const tokenType = this.state.type
					this.next()
					return this.finishTopicReference(
						node,
						startLoc,
						pipeProposal,
						tokenType,
					)
				}
				finishTopicReference(node, startLoc, pipeProposal, tokenType) {
					if (
						this.testTopicReferenceConfiguration(
							pipeProposal,
							startLoc,
							tokenType,
						)
					) {
						if (pipeProposal === 'hack') {
							if (!this.topicReferenceIsAllowedInCurrentContext()) {
								this.raise(Errors.PipeTopicUnbound, startLoc)
							}
							this.registerTopicReference()
							return this.finishNode(node, 'TopicReference')
						} else {
							if (!this.topicReferenceIsAllowedInCurrentContext()) {
								this.raise(Errors.PrimaryTopicNotAllowed, startLoc)
							}
							this.registerTopicReference()
							return this.finishNode(node, 'PipelinePrimaryTopicReference')
						}
					} else {
						throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {
							token: tokenLabelName(tokenType),
						})
					}
				}
				testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
					switch (pipeProposal) {
						case 'hack': {
							return this.hasPlugin([
								'pipelineOperator',
								{
									topicToken: tokenLabelName(tokenType),
								},
							])
						}
						case 'smart':
							return tokenType === 27
						default:
							throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc)
					}
				}
				parseAsyncArrowUnaryFunction(node) {
					this.prodParam.enter(functionFlags(true, this.prodParam.hasYield))
					const params = [this.parseIdentifier()]
					this.prodParam.exit()
					if (this.hasPrecedingLineBreak()) {
						this.raise(
							Errors.LineTerminatorBeforeArrow,
							this.state.curPosition(),
						)
					}
					this.expect(19)
					return this.parseArrowExpression(node, params, true)
				}
				parseDo(node, isAsync) {
					this.expectPlugin('doExpressions')
					if (isAsync) {
						this.expectPlugin('asyncDoExpressions')
					}
					node.async = isAsync
					this.next()
					const oldLabels = this.state.labels
					this.state.labels = []
					if (isAsync) {
						this.prodParam.enter(2)
						node.body = this.parseBlock()
						this.prodParam.exit()
					} else {
						node.body = this.parseBlock()
					}
					this.state.labels = oldLabels
					return this.finishNode(node, 'DoExpression')
				}
				parseSuper() {
					const node = this.startNode()
					this.next()
					if (
						this.match(10) &&
						!this.scope.allowDirectSuper &&
						!(this.optionFlags & 16)
					) {
						this.raise(Errors.SuperNotAllowed, node)
					} else if (!this.scope.allowSuper && !(this.optionFlags & 16)) {
						this.raise(Errors.UnexpectedSuper, node)
					}
					if (!this.match(10) && !this.match(0) && !this.match(16)) {
						this.raise(Errors.UnsupportedSuper, node)
					}
					return this.finishNode(node, 'Super')
				}
				parsePrivateName() {
					const node = this.startNode()
					const id = this.startNodeAt(
						createPositionWithColumnOffset(this.state.startLoc, 1),
					)
					const name = this.state.value
					this.next()
					node.id = this.createIdentifier(id, name)
					return this.finishNode(node, 'PrivateName')
				}
				parseFunctionOrFunctionSent() {
					const node = this.startNode()
					this.next()
					if (this.prodParam.hasYield && this.match(16)) {
						const meta = this.createIdentifier(
							this.startNodeAtNode(node),
							'function',
						)
						this.next()
						if (this.match(103)) {
							this.expectPlugin('functionSent')
						} else if (!this.hasPlugin('functionSent')) {
							this.unexpected()
						}
						return this.parseMetaProperty(node, meta, 'sent')
					}
					return this.parseFunction(node)
				}
				parseMetaProperty(node, meta, propertyName) {
					node.meta = meta
					const containsEsc = this.state.containsEsc
					node.property = this.parseIdentifier(true)
					if (node.property.name !== propertyName || containsEsc) {
						this.raise(Errors.UnsupportedMetaProperty, node.property, {
							target: meta.name,
							onlyValidPropertyName: propertyName,
						})
					}
					return this.finishNode(node, 'MetaProperty')
				}
				parseImportMetaProperty(node) {
					const id = this.createIdentifier(this.startNodeAtNode(node), 'import')
					this.next()
					if (this.isContextual(101)) {
						if (!this.inModule) {
							this.raise(Errors.ImportMetaOutsideModule, id)
						}
						this.sawUnambiguousESM = true
					} else if (this.isContextual(105) || this.isContextual(97)) {
						const isSource = this.isContextual(105)
						this.expectPlugin(
							isSource ? 'sourcePhaseImports' : 'deferredImportEvaluation',
						)
						if (!(this.optionFlags & 512)) {
							throw this.raise(
								Errors.DynamicImportPhaseRequiresImportExpressions,
								this.state.startLoc,
								{
									phase: this.state.value,
								},
							)
						}
						this.next()
						node.phase = isSource ? 'source' : 'defer'
						return this.parseImportCall(node)
					}
					return this.parseMetaProperty(node, id, 'meta')
				}
				parseLiteralAtNode(value, type, node) {
					this.addExtra(node, 'rawValue', value)
					this.addExtra(
						node,
						'raw',
						this.input.slice(
							this.offsetToSourcePos(node.start),
							this.state.end,
						),
					)
					node.value = value
					this.next()
					return this.finishNode(node, type)
				}
				parseLiteral(value, type) {
					const node = this.startNode()
					return this.parseLiteralAtNode(value, type, node)
				}
				parseStringLiteral(value) {
					return this.parseLiteral(value, 'StringLiteral')
				}
				parseNumericLiteral(value) {
					return this.parseLiteral(value, 'NumericLiteral')
				}
				parseBigIntLiteral(value) {
					return this.parseLiteral(value, 'BigIntLiteral')
				}
				parseDecimalLiteral(value) {
					return this.parseLiteral(value, 'DecimalLiteral')
				}
				parseRegExpLiteral(value) {
					const node = this.startNode()
					this.addExtra(
						node,
						'raw',
						this.input.slice(
							this.offsetToSourcePos(node.start),
							this.state.end,
						),
					)
					node.pattern = value.pattern
					node.flags = value.flags
					this.next()
					return this.finishNode(node, 'RegExpLiteral')
				}
				parseBooleanLiteral(value) {
					const node = this.startNode()
					node.value = value
					this.next()
					return this.finishNode(node, 'BooleanLiteral')
				}
				parseNullLiteral() {
					const node = this.startNode()
					this.next()
					return this.finishNode(node, 'NullLiteral')
				}
				parseParenAndDistinguishExpression(canBeArrow) {
					const startLoc = this.state.startLoc
					let val
					this.next()
					this.expressionScope.enter(newArrowHeadScope())
					const oldMaybeInArrowParameters = this.state.maybeInArrowParameters
					const oldInFSharpPipelineDirectBody =
						this.state.inFSharpPipelineDirectBody
					this.state.maybeInArrowParameters = true
					this.state.inFSharpPipelineDirectBody = false
					const innerStartLoc = this.state.startLoc
					const exprList = []
					const refExpressionErrors = new ExpressionErrors()
					let first = true
					let spreadStartLoc
					let optionalCommaStartLoc
					while (!this.match(11)) {
						if (first) {
							first = false
						} else {
							this.expect(
								12,
								refExpressionErrors.optionalParametersLoc === null
									? null
									: refExpressionErrors.optionalParametersLoc,
							)
							if (this.match(11)) {
								optionalCommaStartLoc = this.state.startLoc
								break
							}
						}
						if (this.match(21)) {
							const spreadNodeStartLoc = this.state.startLoc
							spreadStartLoc = this.state.startLoc
							exprList.push(
								this.parseParenItem(
									this.parseRestBinding(),
									spreadNodeStartLoc,
								),
							)
							if (!this.checkCommaAfterRest(41)) {
								break
							}
						} else {
							exprList.push(
								this.parseMaybeAssignAllowIn(
									refExpressionErrors,
									this.parseParenItem,
								),
							)
						}
					}
					const innerEndLoc = this.state.lastTokEndLoc
					this.expect(11)
					this.state.maybeInArrowParameters = oldMaybeInArrowParameters
					this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody
					let arrowNode = this.startNodeAt(startLoc)
					if (
						canBeArrow &&
						this.shouldParseArrow(exprList) &&
						(arrowNode = this.parseArrow(arrowNode))
					) {
						this.checkDestructuringPrivate(refExpressionErrors)
						this.expressionScope.validateAsPattern()
						this.expressionScope.exit()
						this.parseArrowExpression(arrowNode, exprList, false)
						return arrowNode
					}
					this.expressionScope.exit()
					if (!exprList.length) {
						this.unexpected(this.state.lastTokStartLoc)
					}
					if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc)
					if (spreadStartLoc) this.unexpected(spreadStartLoc)
					this.checkExpressionErrors(refExpressionErrors, true)
					this.toReferencedListDeep(exprList, true)
					if (exprList.length > 1) {
						val = this.startNodeAt(innerStartLoc)
						val.expressions = exprList
						this.finishNode(val, 'SequenceExpression')
						this.resetEndLocation(val, innerEndLoc)
					} else {
						val = exprList[0]
					}
					return this.wrapParenthesis(startLoc, val)
				}
				wrapParenthesis(startLoc, expression) {
					if (!(this.optionFlags & 1024)) {
						this.addExtra(expression, 'parenthesized', true)
						this.addExtra(expression, 'parenStart', startLoc.index)
						this.takeSurroundingComments(
							expression,
							startLoc.index,
							this.state.lastTokEndLoc.index,
						)
						return expression
					}
					const parenExpression = this.startNodeAt(startLoc)
					parenExpression.expression = expression
					return this.finishNode(parenExpression, 'ParenthesizedExpression')
				}
				shouldParseArrow(params) {
					return !this.canInsertSemicolon()
				}
				parseArrow(node) {
					if (this.eat(19)) {
						return node
					}
				}
				parseParenItem(node, startLoc) {
					return node
				}
				parseNewOrNewTarget() {
					const node = this.startNode()
					this.next()
					if (this.match(16)) {
						const meta = this.createIdentifier(
							this.startNodeAtNode(node),
							'new',
						)
						this.next()
						const metaProp = this.parseMetaProperty(node, meta, 'target')
						if (
							!this.scope.inNonArrowFunction &&
							!this.scope.inClass &&
							!(this.optionFlags & 4)
						) {
							this.raise(Errors.UnexpectedNewTarget, metaProp)
						}
						return metaProp
					}
					return this.parseNew(node)
				}
				parseNew(node) {
					this.parseNewCallee(node)
					if (this.eat(10)) {
						const args = this.parseExprList(11)
						this.toReferencedList(args)
						node.arguments = args
					} else {
						node.arguments = []
					}
					return this.finishNode(node, 'NewExpression')
				}
				parseNewCallee(node) {
					const isImport = this.match(83)
					const callee = this.parseNoCallExpr()
					node.callee = callee
					if (
						isImport &&
						(callee.type === 'Import' || callee.type === 'ImportExpression')
					) {
						this.raise(Errors.ImportCallNotNewExpression, callee)
					}
				}
				parseTemplateElement(isTagged) {
					const { start, startLoc, end, value } = this.state
					const elemStart = start + 1
					const elem = this.startNodeAt(
						createPositionWithColumnOffset(startLoc, 1),
					)
					if (value === null) {
						if (!isTagged) {
							this.raise(
								Errors.InvalidEscapeSequenceTemplate,
								createPositionWithColumnOffset(
									this.state.firstInvalidTemplateEscapePos,
									1,
								),
							)
						}
					}
					const isTail = this.match(24)
					const endOffset = isTail ? -1 : -2
					const elemEnd = end + endOffset
					elem.value = {
						raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, '\n'),
						cooked: value === null ? null : value.slice(1, endOffset),
					}
					elem.tail = isTail
					this.next()
					const finishedNode = this.finishNode(elem, 'TemplateElement')
					this.resetEndLocation(
						finishedNode,
						createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset),
					)
					return finishedNode
				}
				parseTemplate(isTagged) {
					const node = this.startNode()
					let curElt = this.parseTemplateElement(isTagged)
					const quasis = [curElt]
					const substitutions = []
					while (!curElt.tail) {
						substitutions.push(this.parseTemplateSubstitution())
						this.readTemplateContinuation()
						quasis.push((curElt = this.parseTemplateElement(isTagged)))
					}
					node.expressions = substitutions
					node.quasis = quasis
					return this.finishNode(node, 'TemplateLiteral')
				}
				parseTemplateSubstitution() {
					return this.parseExpression()
				}
				parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
					if (isRecord) {
						this.expectPlugin('recordAndTuple')
					}
					const oldInFSharpPipelineDirectBody =
						this.state.inFSharpPipelineDirectBody
					this.state.inFSharpPipelineDirectBody = false
					let sawProto = false
					let first = true
					const node = this.startNode()
					node.properties = []
					this.next()
					while (!this.match(close)) {
						if (first) {
							first = false
						} else {
							this.expect(12)
							if (this.match(close)) {
								this.addTrailingCommaExtraToNode(node)
								break
							}
						}
						let prop
						if (isPattern) {
							prop = this.parseBindingProperty()
						} else {
							prop = this.parsePropertyDefinition(refExpressionErrors)
							sawProto = this.checkProto(
								prop,
								isRecord,
								sawProto,
								refExpressionErrors,
							)
						}
						if (
							isRecord &&
							!this.isObjectProperty(prop) &&
							prop.type !== 'SpreadElement'
						) {
							this.raise(Errors.InvalidRecordProperty, prop)
						}
						{
							if (prop.shorthand) {
								this.addExtra(prop, 'shorthand', true)
							}
						}
						node.properties.push(prop)
					}
					this.next()
					this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody
					let type = 'ObjectExpression'
					if (isPattern) {
						type = 'ObjectPattern'
					} else if (isRecord) {
						type = 'RecordExpression'
					}
					return this.finishNode(node, type)
				}
				addTrailingCommaExtraToNode(node) {
					this.addExtra(node, 'trailingComma', this.state.lastTokStartLoc.index)
					this.addExtra(
						node,
						'trailingCommaLoc',
						this.state.lastTokStartLoc,
						false,
					)
				}
				maybeAsyncOrAccessorProp(prop) {
					return (
						!prop.computed &&
						prop.key.type === 'Identifier' &&
						(this.isLiteralPropertyName() || this.match(0) || this.match(55))
					)
				}
				parsePropertyDefinition(refExpressionErrors) {
					let decorators = []
					if (this.match(26)) {
						if (this.hasPlugin('decorators')) {
							this.raise(
								Errors.UnsupportedPropertyDecorator,
								this.state.startLoc,
							)
						}
						while (this.match(26)) {
							decorators.push(this.parseDecorator())
						}
					}
					const prop = this.startNode()
					let isAsync = false
					let isAccessor = false
					let startLoc
					if (this.match(21)) {
						if (decorators.length) this.unexpected()
						return this.parseSpread()
					}
					if (decorators.length) {
						prop.decorators = decorators
						decorators = []
					}
					prop.method = false
					if (refExpressionErrors) {
						startLoc = this.state.startLoc
					}
					let isGenerator = this.eat(55)
					this.parsePropertyNamePrefixOperator(prop)
					const containsEsc = this.state.containsEsc
					this.parsePropertyName(prop, refExpressionErrors)
					if (
						!isGenerator &&
						!containsEsc &&
						this.maybeAsyncOrAccessorProp(prop)
					) {
						const { key } = prop
						const keyName = key.name
						if (keyName === 'async' && !this.hasPrecedingLineBreak()) {
							isAsync = true
							this.resetPreviousNodeTrailingComments(key)
							isGenerator = this.eat(55)
							this.parsePropertyName(prop)
						}
						if (keyName === 'get' || keyName === 'set') {
							isAccessor = true
							this.resetPreviousNodeTrailingComments(key)
							prop.kind = keyName
							if (this.match(55)) {
								isGenerator = true
								this.raise(
									Errors.AccessorIsGenerator,
									this.state.curPosition(),
									{
										kind: keyName,
									},
								)
								this.next()
							}
							this.parsePropertyName(prop)
						}
					}
					return this.parseObjPropValue(
						prop,
						startLoc,
						isGenerator,
						isAsync,
						false,
						isAccessor,
						refExpressionErrors,
					)
				}
				getGetterSetterExpectedParamCount(method) {
					return method.kind === 'get' ? 0 : 1
				}
				getObjectOrClassMethodParams(method) {
					return method.params
				}
				checkGetterSetterParams(method) {
					var _params
					const paramCount = this.getGetterSetterExpectedParamCount(method)
					const params = this.getObjectOrClassMethodParams(method)
					if (params.length !== paramCount) {
						this.raise(
							method.kind === 'get'
								? Errors.BadGetterArity
								: Errors.BadSetterArity,
							method,
						)
					}
					if (
						method.kind === 'set' &&
						((_params = params[params.length - 1]) == null
							? void 0
							: _params.type) === 'RestElement'
					) {
						this.raise(Errors.BadSetterRestParameter, method)
					}
				}
				parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
					if (isAccessor) {
						const finishedProp = this.parseMethod(
							prop,
							isGenerator,
							false,
							false,
							false,
							'ObjectMethod',
						)
						this.checkGetterSetterParams(finishedProp)
						return finishedProp
					}
					if (isAsync || isGenerator || this.match(10)) {
						if (isPattern) this.unexpected()
						prop.kind = 'method'
						prop.method = true
						return this.parseMethod(
							prop,
							isGenerator,
							isAsync,
							false,
							false,
							'ObjectMethod',
						)
					}
				}
				parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
					prop.shorthand = false
					if (this.eat(14)) {
						prop.value = isPattern
							? this.parseMaybeDefault(this.state.startLoc)
							: this.parseMaybeAssignAllowIn(refExpressionErrors)
						return this.finishObjectProperty(prop)
					}
					if (!prop.computed && prop.key.type === 'Identifier') {
						this.checkReservedWord(
							prop.key.name,
							prop.key.loc.start,
							true,
							false,
						)
						if (isPattern) {
							prop.value = this.parseMaybeDefault(
								startLoc,
								this.cloneIdentifier(prop.key),
							)
						} else if (this.match(29)) {
							const shorthandAssignLoc = this.state.startLoc
							if (refExpressionErrors != null) {
								if (refExpressionErrors.shorthandAssignLoc === null) {
									refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc
								}
							} else {
								this.raise(
									Errors.InvalidCoverInitializedName,
									shorthandAssignLoc,
								)
							}
							prop.value = this.parseMaybeDefault(
								startLoc,
								this.cloneIdentifier(prop.key),
							)
						} else {
							prop.value = this.cloneIdentifier(prop.key)
						}
						prop.shorthand = true
						return this.finishObjectProperty(prop)
					}
				}
				finishObjectProperty(node) {
					return this.finishNode(node, 'ObjectProperty')
				}
				parseObjPropValue(
					prop,
					startLoc,
					isGenerator,
					isAsync,
					isPattern,
					isAccessor,
					refExpressionErrors,
				) {
					const node =
						this.parseObjectMethod(
							prop,
							isGenerator,
							isAsync,
							isPattern,
							isAccessor,
						) ||
						this.parseObjectProperty(
							prop,
							startLoc,
							isPattern,
							refExpressionErrors,
						)
					if (!node) this.unexpected()
					return node
				}
				parsePropertyName(prop, refExpressionErrors) {
					if (this.eat(0)) {
						prop.computed = true
						prop.key = this.parseMaybeAssignAllowIn()
						this.expect(3)
					} else {
						const { type, value } = this.state
						let key
						if (tokenIsKeywordOrIdentifier(type)) {
							key = this.parseIdentifier(true)
						} else {
							switch (type) {
								case 135:
									key = this.parseNumericLiteral(value)
									break
								case 134:
									key = this.parseStringLiteral(value)
									break
								case 136:
									key = this.parseBigIntLiteral(value)
									break
								case 139: {
									const privateKeyLoc = this.state.startLoc
									if (refExpressionErrors != null) {
										if (refExpressionErrors.privateKeyLoc === null) {
											refExpressionErrors.privateKeyLoc = privateKeyLoc
										}
									} else {
										this.raise(Errors.UnexpectedPrivateField, privateKeyLoc)
									}
									key = this.parsePrivateName()
									break
								}
								default:
									if (type === 137) {
										key = this.parseDecimalLiteral(value)
										break
									}
									this.unexpected()
							}
						}
						prop.key = key
						if (type !== 139) {
							prop.computed = false
						}
					}
				}
				initFunction(node, isAsync) {
					node.id = null
					node.generator = false
					node.async = isAsync
				}
				parseMethod(
					node,
					isGenerator,
					isAsync,
					isConstructor,
					allowDirectSuper,
					type,
					inClassScope = false,
				) {
					this.initFunction(node, isAsync)
					node.generator = isGenerator
					this.scope.enter(
						2 | 16 | (inClassScope ? 64 : 0) | (allowDirectSuper ? 32 : 0),
					)
					this.prodParam.enter(functionFlags(isAsync, node.generator))
					this.parseFunctionParams(node, isConstructor)
					const finishedNode = this.parseFunctionBodyAndFinish(node, type, true)
					this.prodParam.exit()
					this.scope.exit()
					return finishedNode
				}
				parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
					if (isTuple) {
						this.expectPlugin('recordAndTuple')
					}
					const oldInFSharpPipelineDirectBody =
						this.state.inFSharpPipelineDirectBody
					this.state.inFSharpPipelineDirectBody = false
					const node = this.startNode()
					this.next()
					node.elements = this.parseExprList(
						close,
						!isTuple,
						refExpressionErrors,
						node,
					)
					this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody
					return this.finishNode(
						node,
						isTuple ? 'TupleExpression' : 'ArrayExpression',
					)
				}
				parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
					this.scope.enter(2 | 4)
					let flags = functionFlags(isAsync, false)
					if (!this.match(5) && this.prodParam.hasIn) {
						flags |= 8
					}
					this.prodParam.enter(flags)
					this.initFunction(node, isAsync)
					const oldMaybeInArrowParameters = this.state.maybeInArrowParameters
					if (params) {
						this.state.maybeInArrowParameters = true
						this.setArrowFunctionParameters(node, params, trailingCommaLoc)
					}
					this.state.maybeInArrowParameters = false
					this.parseFunctionBody(node, true)
					this.prodParam.exit()
					this.scope.exit()
					this.state.maybeInArrowParameters = oldMaybeInArrowParameters
					return this.finishNode(node, 'ArrowFunctionExpression')
				}
				setArrowFunctionParameters(node, params, trailingCommaLoc) {
					this.toAssignableList(params, trailingCommaLoc, false)
					node.params = params
				}
				parseFunctionBodyAndFinish(node, type, isMethod = false) {
					this.parseFunctionBody(node, false, isMethod)
					return this.finishNode(node, type)
				}
				parseFunctionBody(node, allowExpression, isMethod = false) {
					const isExpression = allowExpression && !this.match(5)
					this.expressionScope.enter(newExpressionScope())
					if (isExpression) {
						node.body = this.parseMaybeAssign()
						this.checkParams(node, false, allowExpression, false)
					} else {
						const oldStrict = this.state.strict
						const oldLabels = this.state.labels
						this.state.labels = []
						this.prodParam.enter(this.prodParam.currentFlags() | 4)
						node.body = this.parseBlock(
							true,
							false,
							(hasStrictModeDirective) => {
								const nonSimple = !this.isSimpleParamList(node.params)
								if (hasStrictModeDirective && nonSimple) {
									this.raise(
										Errors.IllegalLanguageModeDirective,
										(node.kind === 'method' || node.kind === 'constructor') &&
											!!node.key
											? node.key.loc.end
											: node,
									)
								}
								const strictModeChanged = !oldStrict && this.state.strict
								this.checkParams(
									node,
									!this.state.strict &&
										!allowExpression &&
										!isMethod &&
										!nonSimple,
									allowExpression,
									strictModeChanged,
								)
								if (this.state.strict && node.id) {
									this.checkIdentifier(node.id, 65, strictModeChanged)
								}
							},
						)
						this.prodParam.exit()
						this.state.labels = oldLabels
					}
					this.expressionScope.exit()
				}
				isSimpleParameter(node) {
					return node.type === 'Identifier'
				}
				isSimpleParamList(params) {
					for (let i = 0, len = params.length; i < len; i++) {
						if (!this.isSimpleParameter(params[i])) return false
					}
					return true
				}
				checkParams(
					node,
					allowDuplicates,
					isArrowFunction,
					strictModeChanged = true,
				) {
					const checkClashes = !allowDuplicates && new Set()
					const formalParameters = {
						type: 'FormalParameters',
					}
					for (const param of node.params) {
						this.checkLVal(
							param,
							formalParameters,
							5,
							checkClashes,
							strictModeChanged,
						)
					}
				}
				parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
					const elts = []
					let first = true
					while (!this.eat(close)) {
						if (first) {
							first = false
						} else {
							this.expect(12)
							if (this.match(close)) {
								if (nodeForExtra) {
									this.addTrailingCommaExtraToNode(nodeForExtra)
								}
								this.next()
								break
							}
						}
						elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors))
					}
					return elts
				}
				parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
					let elt
					if (this.match(12)) {
						if (!allowEmpty) {
							this.raise(Errors.UnexpectedToken, this.state.curPosition(), {
								unexpected: ',',
							})
						}
						elt = null
					} else if (this.match(21)) {
						const spreadNodeStartLoc = this.state.startLoc
						elt = this.parseParenItem(
							this.parseSpread(refExpressionErrors),
							spreadNodeStartLoc,
						)
					} else if (this.match(17)) {
						this.expectPlugin('partialApplication')
						if (!allowPlaceholder) {
							this.raise(
								Errors.UnexpectedArgumentPlaceholder,
								this.state.startLoc,
							)
						}
						const node = this.startNode()
						this.next()
						elt = this.finishNode(node, 'ArgumentPlaceholder')
					} else {
						elt = this.parseMaybeAssignAllowIn(
							refExpressionErrors,
							this.parseParenItem,
						)
					}
					return elt
				}
				parseIdentifier(liberal) {
					const node = this.startNode()
					const name = this.parseIdentifierName(liberal)
					return this.createIdentifier(node, name)
				}
				createIdentifier(node, name) {
					node.name = name
					node.loc.identifierName = name
					return this.finishNode(node, 'Identifier')
				}
				parseIdentifierName(liberal) {
					let name
					const { startLoc, type } = this.state
					if (tokenIsKeywordOrIdentifier(type)) {
						name = this.state.value
					} else {
						this.unexpected()
					}
					const tokenIsKeyword = tokenKeywordOrIdentifierIsKeyword(type)
					if (liberal) {
						if (tokenIsKeyword) {
							this.replaceToken(132)
						}
					} else {
						this.checkReservedWord(name, startLoc, tokenIsKeyword, false)
					}
					this.next()
					return name
				}
				checkReservedWord(word, startLoc, checkKeywords, isBinding) {
					if (word.length > 10) {
						return
					}
					if (!canBeReservedWord(word)) {
						return
					}
					if (checkKeywords && isKeyword(word)) {
						this.raise(Errors.UnexpectedKeyword, startLoc, {
							keyword: word,
						})
						return
					}
					const reservedTest = !this.state.strict
						? isReservedWord
						: isBinding
							? isStrictBindReservedWord
							: isStrictReservedWord
					if (reservedTest(word, this.inModule)) {
						this.raise(Errors.UnexpectedReservedWord, startLoc, {
							reservedWord: word,
						})
						return
					} else if (word === 'yield') {
						if (this.prodParam.hasYield) {
							this.raise(Errors.YieldBindingIdentifier, startLoc)
							return
						}
					} else if (word === 'await') {
						if (this.prodParam.hasAwait) {
							this.raise(Errors.AwaitBindingIdentifier, startLoc)
							return
						}
						if (this.scope.inStaticBlock) {
							this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc)
							return
						}
						this.expressionScope.recordAsyncArrowParametersError(startLoc)
					} else if (word === 'arguments') {
						if (this.scope.inClassAndNotInNonArrowFunction) {
							this.raise(Errors.ArgumentsInClass, startLoc)
							return
						}
					}
				}
				recordAwaitIfAllowed() {
					const isAwaitAllowed =
						this.prodParam.hasAwait ||
						(this.optionFlags & 1 && !this.scope.inFunction)
					if (isAwaitAllowed && !this.scope.inFunction) {
						this.state.hasTopLevelAwait = true
					}
					return isAwaitAllowed
				}
				parseAwait(startLoc) {
					const node = this.startNodeAt(startLoc)
					this.expressionScope.recordParameterInitializerError(
						Errors.AwaitExpressionFormalParameter,
						node,
					)
					if (this.eat(55)) {
						this.raise(Errors.ObsoleteAwaitStar, node)
					}
					if (!this.scope.inFunction && !(this.optionFlags & 1)) {
						if (this.isAmbiguousPrefixOrIdentifier()) {
							this.ambiguousScriptDifferentAst = true
						} else {
							this.sawUnambiguousESM = true
						}
					}
					if (!this.state.soloAwait) {
						node.argument = this.parseMaybeUnary(null, true)
					}
					return this.finishNode(node, 'AwaitExpression')
				}
				isAmbiguousPrefixOrIdentifier() {
					if (this.hasPrecedingLineBreak()) return true
					const { type } = this.state
					return (
						type === 53 ||
						type === 10 ||
						type === 0 ||
						tokenIsTemplate(type) ||
						(type === 102 && !this.state.containsEsc) ||
						type === 138 ||
						type === 56 ||
						(this.hasPlugin('v8intrinsic') && type === 54)
					)
				}
				parseYield(startLoc) {
					const node = this.startNodeAt(startLoc)
					this.expressionScope.recordParameterInitializerError(
						Errors.YieldInParameter,
						node,
					)
					let delegating = false
					let argument = null
					if (!this.hasPrecedingLineBreak()) {
						delegating = this.eat(55)
						switch (this.state.type) {
							case 13:
							case 140:
							case 8:
							case 11:
							case 3:
							case 9:
							case 14:
							case 12:
								if (!delegating) break
							default:
								argument = this.parseMaybeAssign()
						}
					}
					node.delegate = delegating
					node.argument = argument
					return this.finishNode(node, 'YieldExpression')
				}
				parseImportCall(node) {
					this.next()
					node.source = this.parseMaybeAssignAllowIn()
					node.options = null
					if (this.eat(12)) {
						if (!this.match(11)) {
							node.options = this.parseMaybeAssignAllowIn()
							if (this.eat(12) && !this.match(11)) {
								do {
									this.parseMaybeAssignAllowIn()
								} while (this.eat(12) && !this.match(11))
								this.raise(Errors.ImportCallArity, node)
							}
						}
					}
					this.expect(11)
					return this.finishNode(node, 'ImportExpression')
				}
				checkPipelineAtInfixOperator(left, leftStartLoc) {
					if (
						this.hasPlugin([
							'pipelineOperator',
							{
								proposal: 'smart',
							},
						])
					) {
						if (left.type === 'SequenceExpression') {
							this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc)
						}
					}
				}
				parseSmartPipelineBodyInStyle(childExpr, startLoc) {
					if (this.isSimpleReference(childExpr)) {
						const bodyNode = this.startNodeAt(startLoc)
						bodyNode.callee = childExpr
						return this.finishNode(bodyNode, 'PipelineBareFunction')
					} else {
						const bodyNode = this.startNodeAt(startLoc)
						this.checkSmartPipeTopicBodyEarlyErrors(startLoc)
						bodyNode.expression = childExpr
						return this.finishNode(bodyNode, 'PipelineTopicExpression')
					}
				}
				isSimpleReference(expression) {
					switch (expression.type) {
						case 'MemberExpression':
							return (
								!expression.computed &&
								this.isSimpleReference(expression.object)
							)
						case 'Identifier':
							return true
						default:
							return false
					}
				}
				checkSmartPipeTopicBodyEarlyErrors(startLoc) {
					if (this.match(19)) {
						throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc)
					}
					if (!this.topicReferenceWasUsedInCurrentContext()) {
						this.raise(Errors.PipelineTopicUnused, startLoc)
					}
				}
				withTopicBindingContext(callback) {
					const outerContextTopicState = this.state.topicContext
					this.state.topicContext = {
						maxNumOfResolvableTopics: 1,
						maxTopicIndex: null,
					}
					try {
						return callback()
					} finally {
						this.state.topicContext = outerContextTopicState
					}
				}
				withSmartMixTopicForbiddingContext(callback) {
					if (
						this.hasPlugin([
							'pipelineOperator',
							{
								proposal: 'smart',
							},
						])
					) {
						const outerContextTopicState = this.state.topicContext
						this.state.topicContext = {
							maxNumOfResolvableTopics: 0,
							maxTopicIndex: null,
						}
						try {
							return callback()
						} finally {
							this.state.topicContext = outerContextTopicState
						}
					} else {
						return callback()
					}
				}
				withSoloAwaitPermittingContext(callback) {
					const outerContextSoloAwaitState = this.state.soloAwait
					this.state.soloAwait = true
					try {
						return callback()
					} finally {
						this.state.soloAwait = outerContextSoloAwaitState
					}
				}
				allowInAnd(callback) {
					const flags = this.prodParam.currentFlags()
					const prodParamToSet = 8 & ~flags
					if (prodParamToSet) {
						this.prodParam.enter(flags | 8)
						try {
							return callback()
						} finally {
							this.prodParam.exit()
						}
					}
					return callback()
				}
				disallowInAnd(callback) {
					const flags = this.prodParam.currentFlags()
					const prodParamToClear = 8 & flags
					if (prodParamToClear) {
						this.prodParam.enter(flags & ~8)
						try {
							return callback()
						} finally {
							this.prodParam.exit()
						}
					}
					return callback()
				}
				registerTopicReference() {
					this.state.topicContext.maxTopicIndex = 0
				}
				topicReferenceIsAllowedInCurrentContext() {
					return this.state.topicContext.maxNumOfResolvableTopics >= 1
				}
				topicReferenceWasUsedInCurrentContext() {
					return (
						this.state.topicContext.maxTopicIndex != null &&
						this.state.topicContext.maxTopicIndex >= 0
					)
				}
				parseFSharpPipelineBody(prec) {
					const startLoc = this.state.startLoc
					this.state.potentialArrowAt = this.state.start
					const oldInFSharpPipelineDirectBody =
						this.state.inFSharpPipelineDirectBody
					this.state.inFSharpPipelineDirectBody = true
					const ret = this.parseExprOp(
						this.parseMaybeUnaryOrPrivate(),
						startLoc,
						prec,
					)
					this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody
					return ret
				}
				parseModuleExpression() {
					this.expectPlugin('moduleBlocks')
					const node = this.startNode()
					this.next()
					if (!this.match(5)) {
						this.unexpected(null, 5)
					}
					const program = this.startNodeAt(this.state.endLoc)
					this.next()
					const revertScopes = this.initializeScopes(true)
					this.enterInitialScopes()
					try {
						node.body = this.parseProgram(program, 8, 'module')
					} finally {
						revertScopes()
					}
					return this.finishNode(node, 'ModuleExpression')
				}
				parsePropertyNamePrefixOperator(prop) {}
			}
			const loopLabel = {
					kind: 1,
				},
				switchLabel = {
					kind: 2,
				}
			const loneSurrogate = /[\uD800-\uDFFF]/u
			const keywordRelationalOperator = /in(?:stanceof)?/y
			function babel7CompatTokens(tokens, input, startIndex) {
				for (let i = 0; i < tokens.length; i++) {
					const token = tokens[i]
					const { type } = token
					if (typeof type === 'number') {
						{
							if (type === 139) {
								const { loc, start, value, end } = token
								const hashEndPos = start + 1
								const hashEndLoc = createPositionWithColumnOffset(loc.start, 1)
								tokens.splice(
									i,
									1,
									new Token({
										type: getExportedToken(27),
										value: '#',
										start: start,
										end: hashEndPos,
										startLoc: loc.start,
										endLoc: hashEndLoc,
									}),
									new Token({
										type: getExportedToken(132),
										value: value,
										start: hashEndPos,
										end: end,
										startLoc: hashEndLoc,
										endLoc: loc.end,
									}),
								)
								i++
								continue
							}
							if (tokenIsTemplate(type)) {
								const { loc, start, value, end } = token
								const backquoteEnd = start + 1
								const backquoteEndLoc = createPositionWithColumnOffset(
									loc.start,
									1,
								)
								let startToken
								if (input.charCodeAt(start - startIndex) === 96) {
									startToken = new Token({
										type: getExportedToken(22),
										value: '`',
										start: start,
										end: backquoteEnd,
										startLoc: loc.start,
										endLoc: backquoteEndLoc,
									})
								} else {
									startToken = new Token({
										type: getExportedToken(8),
										value: '}',
										start: start,
										end: backquoteEnd,
										startLoc: loc.start,
										endLoc: backquoteEndLoc,
									})
								}
								let templateValue,
									templateElementEnd,
									templateElementEndLoc,
									endToken
								if (type === 24) {
									templateElementEnd = end - 1
									templateElementEndLoc = createPositionWithColumnOffset(
										loc.end,
										-1,
									)
									templateValue = value === null ? null : value.slice(1, -1)
									endToken = new Token({
										type: getExportedToken(22),
										value: '`',
										start: templateElementEnd,
										end: end,
										startLoc: templateElementEndLoc,
										endLoc: loc.end,
									})
								} else {
									templateElementEnd = end - 2
									templateElementEndLoc = createPositionWithColumnOffset(
										loc.end,
										-2,
									)
									templateValue = value === null ? null : value.slice(1, -2)
									endToken = new Token({
										type: getExportedToken(23),
										value: '${',
										start: templateElementEnd,
										end: end,
										startLoc: templateElementEndLoc,
										endLoc: loc.end,
									})
								}
								tokens.splice(
									i,
									1,
									startToken,
									new Token({
										type: getExportedToken(20),
										value: templateValue,
										start: backquoteEnd,
										end: templateElementEnd,
										startLoc: backquoteEndLoc,
										endLoc: templateElementEndLoc,
									}),
									endToken,
								)
								i += 2
								continue
							}
						}
						token.type = getExportedToken(type)
					}
				}
				return tokens
			}
			class StatementParser extends ExpressionParser {
				parseTopLevel(file, program) {
					file.program = this.parseProgram(program)
					file.comments = this.comments
					if (this.optionFlags & 256) {
						file.tokens = babel7CompatTokens(
							this.tokens,
							this.input,
							this.startIndex,
						)
					}
					return this.finishNode(file, 'File')
				}
				parseProgram(program, end = 140, sourceType = this.options.sourceType) {
					program.sourceType = sourceType
					program.interpreter = this.parseInterpreterDirective()
					this.parseBlockBody(program, true, true, end)
					if (this.inModule) {
						if (
							!(this.optionFlags & 64) &&
							this.scope.undefinedExports.size > 0
						) {
							for (const [localName, at] of Array.from(
								this.scope.undefinedExports,
							)) {
								this.raise(Errors.ModuleExportUndefined, at, {
									localName,
								})
							}
						}
						this.addExtra(program, 'topLevelAwait', this.state.hasTopLevelAwait)
					}
					let finishedProgram
					if (end === 140) {
						finishedProgram = this.finishNode(program, 'Program')
					} else {
						finishedProgram = this.finishNodeAt(
							program,
							'Program',
							createPositionWithColumnOffset(this.state.startLoc, -1),
						)
					}
					return finishedProgram
				}
				stmtToDirective(stmt) {
					const directive = this.castNodeTo(stmt, 'Directive')
					const directiveLiteral = this.castNodeTo(
						stmt.expression,
						'DirectiveLiteral',
					)
					const expressionValue = directiveLiteral.value
					const raw = this.input.slice(
						this.offsetToSourcePos(directiveLiteral.start),
						this.offsetToSourcePos(directiveLiteral.end),
					)
					const val = (directiveLiteral.value = raw.slice(1, -1))
					this.addExtra(directiveLiteral, 'raw', raw)
					this.addExtra(directiveLiteral, 'rawValue', val)
					this.addExtra(directiveLiteral, 'expressionValue', expressionValue)
					directive.value = directiveLiteral
					delete stmt.expression
					return directive
				}
				parseInterpreterDirective() {
					if (!this.match(28)) {
						return null
					}
					const node = this.startNode()
					node.value = this.state.value
					this.next()
					return this.finishNode(node, 'InterpreterDirective')
				}
				isLet() {
					if (!this.isContextual(100)) {
						return false
					}
					return this.hasFollowingBindingAtom()
				}
				chStartsBindingIdentifier(ch, pos) {
					if (isIdentifierStart(ch)) {
						keywordRelationalOperator.lastIndex = pos
						if (keywordRelationalOperator.test(this.input)) {
							const endCh = this.codePointAtPos(
								keywordRelationalOperator.lastIndex,
							)
							if (!isIdentifierChar(endCh) && endCh !== 92) {
								return false
							}
						}
						return true
					} else if (ch === 92) {
						return true
					} else {
						return false
					}
				}
				chStartsBindingPattern(ch) {
					return ch === 91 || ch === 123
				}
				hasFollowingBindingAtom() {
					const next = this.nextTokenStart()
					const nextCh = this.codePointAtPos(next)
					return (
						this.chStartsBindingPattern(nextCh) ||
						this.chStartsBindingIdentifier(nextCh, next)
					)
				}
				hasInLineFollowingBindingIdentifierOrBrace() {
					const next = this.nextTokenInLineStart()
					const nextCh = this.codePointAtPos(next)
					return nextCh === 123 || this.chStartsBindingIdentifier(nextCh, next)
				}
				allowsForUsing() {
					const { type, containsEsc, end } = this.lookahead()
					if (type === 102 && !containsEsc) {
						const nextCharAfterOf = this.lookaheadCharCodeSince(end)
						if (
							nextCharAfterOf !== 61 &&
							nextCharAfterOf !== 58 &&
							nextCharAfterOf !== 59
						) {
							return false
						}
					}
					if (tokenIsIdentifier(type) && !this.hasFollowingLineBreak()) {
						this.expectPlugin('explicitResourceManagement')
						return true
					}
					return false
				}
				startsAwaitUsing() {
					let next = this.nextTokenInLineStart()
					if (this.isUnparsedContextual(next, 'using')) {
						next = this.nextTokenInLineStartSince(next + 5)
						const nextCh = this.codePointAtPos(next)
						if (this.chStartsBindingIdentifier(nextCh, next)) {
							this.expectPlugin('explicitResourceManagement')
							return true
						}
					}
					return false
				}
				parseModuleItem() {
					return this.parseStatementLike(1 | 2 | 4 | 8)
				}
				parseStatementListItem() {
					return this.parseStatementLike(
						2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8),
					)
				}
				parseStatementOrSloppyAnnexBFunctionDeclaration(
					allowLabeledFunction = false,
				) {
					let flags = 0
					if (this.options.annexB && !this.state.strict) {
						flags |= 4
						if (allowLabeledFunction) {
							flags |= 8
						}
					}
					return this.parseStatementLike(flags)
				}
				parseStatement() {
					return this.parseStatementLike(0)
				}
				parseStatementLike(flags) {
					let decorators = null
					if (this.match(26)) {
						decorators = this.parseDecorators(true)
					}
					return this.parseStatementContent(flags, decorators)
				}
				parseStatementContent(flags, decorators) {
					const startType = this.state.type
					const node = this.startNode()
					const allowDeclaration = !!(flags & 2)
					const allowFunctionDeclaration = !!(flags & 4)
					const topLevel = flags & 1
					switch (startType) {
						case 60:
							return this.parseBreakContinueStatement(node, true)
						case 63:
							return this.parseBreakContinueStatement(node, false)
						case 64:
							return this.parseDebuggerStatement(node)
						case 90:
							return this.parseDoWhileStatement(node)
						case 91:
							return this.parseForStatement(node)
						case 68:
							if (this.lookaheadCharCode() === 46) break
							if (!allowFunctionDeclaration) {
								this.raise(
									this.state.strict
										? Errors.StrictFunction
										: this.options.annexB
											? Errors.SloppyFunctionAnnexB
											: Errors.SloppyFunction,
									this.state.startLoc,
								)
							}
							return this.parseFunctionStatement(
								node,
								false,
								!allowDeclaration && allowFunctionDeclaration,
							)
						case 80:
							if (!allowDeclaration) this.unexpected()
							return this.parseClass(
								this.maybeTakeDecorators(decorators, node),
								true,
							)
						case 69:
							return this.parseIfStatement(node)
						case 70:
							return this.parseReturnStatement(node)
						case 71:
							return this.parseSwitchStatement(node)
						case 72:
							return this.parseThrowStatement(node)
						case 73:
							return this.parseTryStatement(node)
						case 96:
							if (!this.state.containsEsc && this.startsAwaitUsing()) {
								if (!this.recordAwaitIfAllowed()) {
									this.raise(Errors.AwaitUsingNotInAsyncContext, node)
								} else if (!allowDeclaration) {
									this.raise(Errors.UnexpectedLexicalDeclaration, node)
								}
								this.next()
								return this.parseVarStatement(node, 'await using')
							}
							break
						case 107:
							if (
								this.state.containsEsc ||
								!this.hasInLineFollowingBindingIdentifierOrBrace()
							) {
								break
							}
							this.expectPlugin('explicitResourceManagement')
							if (!this.scope.inModule && this.scope.inTopLevel) {
								this.raise(
									Errors.UnexpectedUsingDeclaration,
									this.state.startLoc,
								)
							} else if (!allowDeclaration) {
								this.raise(
									Errors.UnexpectedLexicalDeclaration,
									this.state.startLoc,
								)
							}
							return this.parseVarStatement(node, 'using')
						case 100: {
							if (this.state.containsEsc) {
								break
							}
							const next = this.nextTokenStart()
							const nextCh = this.codePointAtPos(next)
							if (nextCh !== 91) {
								if (!allowDeclaration && this.hasFollowingLineBreak()) break
								if (
									!this.chStartsBindingIdentifier(nextCh, next) &&
									nextCh !== 123
								) {
									break
								}
							}
						}
						case 75: {
							if (!allowDeclaration) {
								this.raise(
									Errors.UnexpectedLexicalDeclaration,
									this.state.startLoc,
								)
							}
						}
						case 74: {
							const kind = this.state.value
							return this.parseVarStatement(node, kind)
						}
						case 92:
							return this.parseWhileStatement(node)
						case 76:
							return this.parseWithStatement(node)
						case 5:
							return this.parseBlock()
						case 13:
							return this.parseEmptyStatement(node)
						case 83: {
							const nextTokenCharCode = this.lookaheadCharCode()
							if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
								break
							}
						}
						case 82: {
							if (!(this.optionFlags & 8) && !topLevel) {
								this.raise(Errors.UnexpectedImportExport, this.state.startLoc)
							}
							this.next()
							let result
							if (startType === 83) {
								result = this.parseImport(node)
							} else {
								result = this.parseExport(node, decorators)
							}
							this.assertModuleNodeAllowed(result)
							return result
						}
						default: {
							if (this.isAsyncFunction()) {
								if (!allowDeclaration) {
									this.raise(
										Errors.AsyncFunctionInSingleStatementContext,
										this.state.startLoc,
									)
								}
								this.next()
								return this.parseFunctionStatement(
									node,
									true,
									!allowDeclaration && allowFunctionDeclaration,
								)
							}
						}
					}
					const maybeName = this.state.value
					const expr = this.parseExpression()
					if (
						tokenIsIdentifier(startType) &&
						expr.type === 'Identifier' &&
						this.eat(14)
					) {
						return this.parseLabeledStatement(node, maybeName, expr, flags)
					} else {
						return this.parseExpressionStatement(node, expr, decorators)
					}
				}
				assertModuleNodeAllowed(node) {
					if (!(this.optionFlags & 8) && !this.inModule) {
						this.raise(Errors.ImportOutsideModule, node)
					}
				}
				decoratorsEnabledBeforeExport() {
					if (this.hasPlugin('decorators-legacy')) return true
					return (
						this.hasPlugin('decorators') &&
						this.getPluginOption('decorators', 'decoratorsBeforeExport') !==
							false
					)
				}
				maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
					if (maybeDecorators) {
						var _classNode$decorators
						if (
							(_classNode$decorators = classNode.decorators) != null &&
							_classNode$decorators.length
						) {
							if (
								typeof this.getPluginOption(
									'decorators',
									'decoratorsBeforeExport',
								) !== 'boolean'
							) {
								this.raise(
									Errors.DecoratorsBeforeAfterExport,
									classNode.decorators[0],
								)
							}
							classNode.decorators.unshift(...maybeDecorators)
						} else {
							classNode.decorators = maybeDecorators
						}
						this.resetStartLocationFromNode(classNode, maybeDecorators[0])
						if (exportNode)
							this.resetStartLocationFromNode(exportNode, classNode)
					}
					return classNode
				}
				canHaveLeadingDecorator() {
					return this.match(80)
				}
				parseDecorators(allowExport) {
					const decorators = []
					do {
						decorators.push(this.parseDecorator())
					} while (this.match(26))
					if (this.match(82)) {
						if (!allowExport) {
							this.unexpected()
						}
						if (!this.decoratorsEnabledBeforeExport()) {
							this.raise(Errors.DecoratorExportClass, this.state.startLoc)
						}
					} else if (!this.canHaveLeadingDecorator()) {
						throw this.raise(
							Errors.UnexpectedLeadingDecorator,
							this.state.startLoc,
						)
					}
					return decorators
				}
				parseDecorator() {
					this.expectOnePlugin(['decorators', 'decorators-legacy'])
					const node = this.startNode()
					this.next()
					if (this.hasPlugin('decorators')) {
						const startLoc = this.state.startLoc
						let expr
						if (this.match(10)) {
							const startLoc = this.state.startLoc
							this.next()
							expr = this.parseExpression()
							this.expect(11)
							expr = this.wrapParenthesis(startLoc, expr)
							const paramsStartLoc = this.state.startLoc
							node.expression = this.parseMaybeDecoratorArguments(
								expr,
								startLoc,
							)
							if (
								this.getPluginOption('decorators', 'allowCallParenthesized') ===
									false &&
								node.expression !== expr
							) {
								this.raise(
									Errors.DecoratorArgumentsOutsideParentheses,
									paramsStartLoc,
								)
							}
						} else {
							expr = this.parseIdentifier(false)
							while (this.eat(16)) {
								const node = this.startNodeAt(startLoc)
								node.object = expr
								if (this.match(139)) {
									this.classScope.usePrivateName(
										this.state.value,
										this.state.startLoc,
									)
									node.property = this.parsePrivateName()
								} else {
									node.property = this.parseIdentifier(true)
								}
								node.computed = false
								expr = this.finishNode(node, 'MemberExpression')
							}
							node.expression = this.parseMaybeDecoratorArguments(
								expr,
								startLoc,
							)
						}
					} else {
						node.expression = this.parseExprSubscripts()
					}
					return this.finishNode(node, 'Decorator')
				}
				parseMaybeDecoratorArguments(expr, startLoc) {
					if (this.eat(10)) {
						const node = this.startNodeAt(startLoc)
						node.callee = expr
						node.arguments = this.parseCallExpressionArguments(11)
						this.toReferencedList(node.arguments)
						return this.finishNode(node, 'CallExpression')
					}
					return expr
				}
				parseBreakContinueStatement(node, isBreak) {
					this.next()
					if (this.isLineTerminator()) {
						node.label = null
					} else {
						node.label = this.parseIdentifier()
						this.semicolon()
					}
					this.verifyBreakContinue(node, isBreak)
					return this.finishNode(
						node,
						isBreak ? 'BreakStatement' : 'ContinueStatement',
					)
				}
				verifyBreakContinue(node, isBreak) {
					let i
					for (i = 0; i < this.state.labels.length; ++i) {
						const lab = this.state.labels[i]
						if (node.label == null || lab.name === node.label.name) {
							if (lab.kind != null && (isBreak || lab.kind === 1)) {
								break
							}
							if (node.label && isBreak) break
						}
					}
					if (i === this.state.labels.length) {
						const type = isBreak ? 'BreakStatement' : 'ContinueStatement'
						this.raise(Errors.IllegalBreakContinue, node, {
							type,
						})
					}
				}
				parseDebuggerStatement(node) {
					this.next()
					this.semicolon()
					return this.finishNode(node, 'DebuggerStatement')
				}
				parseHeaderExpression() {
					this.expect(10)
					const val = this.parseExpression()
					this.expect(11)
					return val
				}
				parseDoWhileStatement(node) {
					this.next()
					this.state.labels.push(loopLabel)
					node.body = this.withSmartMixTopicForbiddingContext(() =>
						this.parseStatement(),
					)
					this.state.labels.pop()
					this.expect(92)
					node.test = this.parseHeaderExpression()
					this.eat(13)
					return this.finishNode(node, 'DoWhileStatement')
				}
				parseForStatement(node) {
					this.next()
					this.state.labels.push(loopLabel)
					let awaitAt = null
					if (this.isContextual(96) && this.recordAwaitIfAllowed()) {
						awaitAt = this.state.startLoc
						this.next()
					}
					this.scope.enter(0)
					this.expect(10)
					if (this.match(13)) {
						if (awaitAt !== null) {
							this.unexpected(awaitAt)
						}
						return this.parseFor(node, null)
					}
					const startsWithLet = this.isContextual(100)
					{
						const startsWithAwaitUsing =
							this.isContextual(96) && this.startsAwaitUsing()
						const starsWithUsingDeclaration =
							startsWithAwaitUsing ||
							(this.isContextual(107) && this.allowsForUsing())
						const isLetOrUsing =
							(startsWithLet && this.hasFollowingBindingAtom()) ||
							starsWithUsingDeclaration
						if (this.match(74) || this.match(75) || isLetOrUsing) {
							const initNode = this.startNode()
							let kind
							if (startsWithAwaitUsing) {
								kind = 'await using'
								if (!this.recordAwaitIfAllowed()) {
									this.raise(
										Errors.AwaitUsingNotInAsyncContext,
										this.state.startLoc,
									)
								}
								this.next()
							} else {
								kind = this.state.value
							}
							this.next()
							this.parseVar(initNode, true, kind)
							const init = this.finishNode(initNode, 'VariableDeclaration')
							const isForIn = this.match(58)
							if (isForIn && starsWithUsingDeclaration) {
								this.raise(Errors.ForInUsing, init)
							}
							if (
								(isForIn || this.isContextual(102)) &&
								init.declarations.length === 1
							) {
								return this.parseForIn(node, init, awaitAt)
							}
							if (awaitAt !== null) {
								this.unexpected(awaitAt)
							}
							return this.parseFor(node, init)
						}
					}
					const startsWithAsync = this.isContextual(95)
					const refExpressionErrors = new ExpressionErrors()
					const init = this.parseExpression(true, refExpressionErrors)
					const isForOf = this.isContextual(102)
					if (isForOf) {
						if (startsWithLet) {
							this.raise(Errors.ForOfLet, init)
						}
						if (
							awaitAt === null &&
							startsWithAsync &&
							init.type === 'Identifier'
						) {
							this.raise(Errors.ForOfAsync, init)
						}
					}
					if (isForOf || this.match(58)) {
						this.checkDestructuringPrivate(refExpressionErrors)
						this.toAssignable(init, true)
						const type = isForOf ? 'ForOfStatement' : 'ForInStatement'
						this.checkLVal(init, {
							type,
						})
						return this.parseForIn(node, init, awaitAt)
					} else {
						this.checkExpressionErrors(refExpressionErrors, true)
					}
					if (awaitAt !== null) {
						this.unexpected(awaitAt)
					}
					return this.parseFor(node, init)
				}
				parseFunctionStatement(node, isAsync, isHangingDeclaration) {
					this.next()
					return this.parseFunction(
						node,
						1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0),
					)
				}
				parseIfStatement(node) {
					this.next()
					node.test = this.parseHeaderExpression()
					node.consequent =
						this.parseStatementOrSloppyAnnexBFunctionDeclaration()
					node.alternate = this.eat(66)
						? this.parseStatementOrSloppyAnnexBFunctionDeclaration()
						: null
					return this.finishNode(node, 'IfStatement')
				}
				parseReturnStatement(node) {
					if (!this.prodParam.hasReturn && !(this.optionFlags & 2)) {
						this.raise(Errors.IllegalReturn, this.state.startLoc)
					}
					this.next()
					if (this.isLineTerminator()) {
						node.argument = null
					} else {
						node.argument = this.parseExpression()
						this.semicolon()
					}
					return this.finishNode(node, 'ReturnStatement')
				}
				parseSwitchStatement(node) {
					this.next()
					node.discriminant = this.parseHeaderExpression()
					const cases = (node.cases = [])
					this.expect(5)
					this.state.labels.push(switchLabel)
					this.scope.enter(0)
					let cur
					for (let sawDefault; !this.match(8); ) {
						if (this.match(61) || this.match(65)) {
							const isCase = this.match(61)
							if (cur) this.finishNode(cur, 'SwitchCase')
							cases.push((cur = this.startNode()))
							cur.consequent = []
							this.next()
							if (isCase) {
								cur.test = this.parseExpression()
							} else {
								if (sawDefault) {
									this.raise(
										Errors.MultipleDefaultsInSwitch,
										this.state.lastTokStartLoc,
									)
								}
								sawDefault = true
								cur.test = null
							}
							this.expect(14)
						} else {
							if (cur) {
								cur.consequent.push(this.parseStatementListItem())
							} else {
								this.unexpected()
							}
						}
					}
					this.scope.exit()
					if (cur) this.finishNode(cur, 'SwitchCase')
					this.next()
					this.state.labels.pop()
					return this.finishNode(node, 'SwitchStatement')
				}
				parseThrowStatement(node) {
					this.next()
					if (this.hasPrecedingLineBreak()) {
						this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc)
					}
					node.argument = this.parseExpression()
					this.semicolon()
					return this.finishNode(node, 'ThrowStatement')
				}
				parseCatchClauseParam() {
					const param = this.parseBindingAtom()
					this.scope.enter(
						this.options.annexB && param.type === 'Identifier' ? 8 : 0,
					)
					this.checkLVal(
						param,
						{
							type: 'CatchClause',
						},
						9,
					)
					return param
				}
				parseTryStatement(node) {
					this.next()
					node.block = this.parseBlock()
					node.handler = null
					if (this.match(62)) {
						const clause = this.startNode()
						this.next()
						if (this.match(10)) {
							this.expect(10)
							clause.param = this.parseCatchClauseParam()
							this.expect(11)
						} else {
							clause.param = null
							this.scope.enter(0)
						}
						clause.body = this.withSmartMixTopicForbiddingContext(() =>
							this.parseBlock(false, false),
						)
						this.scope.exit()
						node.handler = this.finishNode(clause, 'CatchClause')
					}
					node.finalizer = this.eat(67) ? this.parseBlock() : null
					if (!node.handler && !node.finalizer) {
						this.raise(Errors.NoCatchOrFinally, node)
					}
					return this.finishNode(node, 'TryStatement')
				}
				parseVarStatement(node, kind, allowMissingInitializer = false) {
					this.next()
					this.parseVar(node, false, kind, allowMissingInitializer)
					this.semicolon()
					return this.finishNode(node, 'VariableDeclaration')
				}
				parseWhileStatement(node) {
					this.next()
					node.test = this.parseHeaderExpression()
					this.state.labels.push(loopLabel)
					node.body = this.withSmartMixTopicForbiddingContext(() =>
						this.parseStatement(),
					)
					this.state.labels.pop()
					return this.finishNode(node, 'WhileStatement')
				}
				parseWithStatement(node) {
					if (this.state.strict) {
						this.raise(Errors.StrictWith, this.state.startLoc)
					}
					this.next()
					node.object = this.parseHeaderExpression()
					node.body = this.withSmartMixTopicForbiddingContext(() =>
						this.parseStatement(),
					)
					return this.finishNode(node, 'WithStatement')
				}
				parseEmptyStatement(node) {
					this.next()
					return this.finishNode(node, 'EmptyStatement')
				}
				parseLabeledStatement(node, maybeName, expr, flags) {
					for (const label of this.state.labels) {
						if (label.name === maybeName) {
							this.raise(Errors.LabelRedeclaration, expr, {
								labelName: maybeName,
							})
						}
					}
					const kind = tokenIsLoop(this.state.type)
						? 1
						: this.match(71)
							? 2
							: null
					for (let i = this.state.labels.length - 1; i >= 0; i--) {
						const label = this.state.labels[i]
						if (label.statementStart === node.start) {
							label.statementStart = this.sourceToOffsetPos(this.state.start)
							label.kind = kind
						} else {
							break
						}
					}
					this.state.labels.push({
						name: maybeName,
						kind: kind,
						statementStart: this.sourceToOffsetPos(this.state.start),
					})
					node.body =
						flags & 8
							? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true)
							: this.parseStatement()
					this.state.labels.pop()
					node.label = expr
					return this.finishNode(node, 'LabeledStatement')
				}
				parseExpressionStatement(node, expr, decorators) {
					node.expression = expr
					this.semicolon()
					return this.finishNode(node, 'ExpressionStatement')
				}
				parseBlock(
					allowDirectives = false,
					createNewLexicalScope = true,
					afterBlockParse,
				) {
					const node = this.startNode()
					if (allowDirectives) {
						this.state.strictErrors.clear()
					}
					this.expect(5)
					if (createNewLexicalScope) {
						this.scope.enter(0)
					}
					this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse)
					if (createNewLexicalScope) {
						this.scope.exit()
					}
					return this.finishNode(node, 'BlockStatement')
				}
				isValidDirective(stmt) {
					return (
						stmt.type === 'ExpressionStatement' &&
						stmt.expression.type === 'StringLiteral' &&
						!stmt.expression.extra.parenthesized
					)
				}
				parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
					const body = (node.body = [])
					const directives = (node.directives = [])
					this.parseBlockOrModuleBlockBody(
						body,
						allowDirectives ? directives : undefined,
						topLevel,
						end,
						afterBlockParse,
					)
				}
				parseBlockOrModuleBlockBody(
					body,
					directives,
					topLevel,
					end,
					afterBlockParse,
				) {
					const oldStrict = this.state.strict
					let hasStrictModeDirective = false
					let parsedNonDirective = false
					while (!this.match(end)) {
						const stmt = topLevel
							? this.parseModuleItem()
							: this.parseStatementListItem()
						if (directives && !parsedNonDirective) {
							if (this.isValidDirective(stmt)) {
								const directive = this.stmtToDirective(stmt)
								directives.push(directive)
								if (
									!hasStrictModeDirective &&
									directive.value.value === 'use strict'
								) {
									hasStrictModeDirective = true
									this.setStrict(true)
								}
								continue
							}
							parsedNonDirective = true
							this.state.strictErrors.clear()
						}
						body.push(stmt)
					}
					afterBlockParse == null ||
						afterBlockParse.call(this, hasStrictModeDirective)
					if (!oldStrict) {
						this.setStrict(false)
					}
					this.next()
				}
				parseFor(node, init) {
					node.init = init
					this.semicolon(false)
					node.test = this.match(13) ? null : this.parseExpression()
					this.semicolon(false)
					node.update = this.match(11) ? null : this.parseExpression()
					this.expect(11)
					node.body = this.withSmartMixTopicForbiddingContext(() =>
						this.parseStatement(),
					)
					this.scope.exit()
					this.state.labels.pop()
					return this.finishNode(node, 'ForStatement')
				}
				parseForIn(node, init, awaitAt) {
					const isForIn = this.match(58)
					this.next()
					if (isForIn) {
						if (awaitAt !== null) this.unexpected(awaitAt)
					} else {
						node.await = awaitAt !== null
					}
					if (
						init.type === 'VariableDeclaration' &&
						init.declarations[0].init != null &&
						(!isForIn ||
							!this.options.annexB ||
							this.state.strict ||
							init.kind !== 'var' ||
							init.declarations[0].id.type !== 'Identifier')
					) {
						this.raise(Errors.ForInOfLoopInitializer, init, {
							type: isForIn ? 'ForInStatement' : 'ForOfStatement',
						})
					}
					if (init.type === 'AssignmentPattern') {
						this.raise(Errors.InvalidLhs, init, {
							ancestor: {
								type: 'ForStatement',
							},
						})
					}
					node.left = init
					node.right = isForIn
						? this.parseExpression()
						: this.parseMaybeAssignAllowIn()
					this.expect(11)
					node.body = this.withSmartMixTopicForbiddingContext(() =>
						this.parseStatement(),
					)
					this.scope.exit()
					this.state.labels.pop()
					return this.finishNode(
						node,
						isForIn ? 'ForInStatement' : 'ForOfStatement',
					)
				}
				parseVar(node, isFor, kind, allowMissingInitializer = false) {
					const declarations = (node.declarations = [])
					node.kind = kind
					for (;;) {
						const decl = this.startNode()
						this.parseVarId(decl, kind)
						decl.init = !this.eat(29)
							? null
							: isFor
								? this.parseMaybeAssignDisallowIn()
								: this.parseMaybeAssignAllowIn()
						if (decl.init === null && !allowMissingInitializer) {
							if (
								decl.id.type !== 'Identifier' &&
								!(isFor && (this.match(58) || this.isContextual(102)))
							) {
								this.raise(
									Errors.DeclarationMissingInitializer,
									this.state.lastTokEndLoc,
									{
										kind: 'destructuring',
									},
								)
							} else if (
								(kind === 'const' ||
									kind === 'using' ||
									kind === 'await using') &&
								!(this.match(58) || this.isContextual(102))
							) {
								this.raise(
									Errors.DeclarationMissingInitializer,
									this.state.lastTokEndLoc,
									{
										kind,
									},
								)
							}
						}
						declarations.push(this.finishNode(decl, 'VariableDeclarator'))
						if (!this.eat(12)) break
					}
					return node
				}
				parseVarId(decl, kind) {
					const id = this.parseBindingAtom()
					if (kind === 'using' || kind === 'await using') {
						if (id.type === 'ArrayPattern' || id.type === 'ObjectPattern') {
							this.raise(Errors.UsingDeclarationHasBindingPattern, id.loc.start)
						}
					}
					this.checkLVal(
						id,
						{
							type: 'VariableDeclarator',
						},
						kind === 'var' ? 5 : 8201,
					)
					decl.id = id
				}
				parseAsyncFunctionExpression(node) {
					return this.parseFunction(node, 8)
				}
				parseFunction(node, flags = 0) {
					const hangingDeclaration = flags & 2
					const isDeclaration = !!(flags & 1)
					const requireId = isDeclaration && !(flags & 4)
					const isAsync = !!(flags & 8)
					this.initFunction(node, isAsync)
					if (this.match(55)) {
						if (hangingDeclaration) {
							this.raise(
								Errors.GeneratorInSingleStatementContext,
								this.state.startLoc,
							)
						}
						this.next()
						node.generator = true
					}
					if (isDeclaration) {
						node.id = this.parseFunctionId(requireId)
					}
					const oldMaybeInArrowParameters = this.state.maybeInArrowParameters
					this.state.maybeInArrowParameters = false
					this.scope.enter(2)
					this.prodParam.enter(functionFlags(isAsync, node.generator))
					if (!isDeclaration) {
						node.id = this.parseFunctionId()
					}
					this.parseFunctionParams(node, false)
					this.withSmartMixTopicForbiddingContext(() => {
						this.parseFunctionBodyAndFinish(
							node,
							isDeclaration ? 'FunctionDeclaration' : 'FunctionExpression',
						)
					})
					this.prodParam.exit()
					this.scope.exit()
					if (isDeclaration && !hangingDeclaration) {
						this.registerFunctionStatementId(node)
					}
					this.state.maybeInArrowParameters = oldMaybeInArrowParameters
					return node
				}
				parseFunctionId(requireId) {
					return requireId || tokenIsIdentifier(this.state.type)
						? this.parseIdentifier()
						: null
				}
				parseFunctionParams(node, isConstructor) {
					this.expect(10)
					this.expressionScope.enter(newParameterDeclarationScope())
					node.params = this.parseBindingList(
						11,
						41,
						2 | (isConstructor ? 4 : 0),
					)
					this.expressionScope.exit()
				}
				registerFunctionStatementId(node) {
					if (!node.id) return
					this.scope.declareName(
						node.id.name,
						!this.options.annexB ||
							this.state.strict ||
							node.generator ||
							node.async
							? this.scope.treatFunctionsAsVar
								? 5
								: 8201
							: 17,
						node.id.loc.start,
					)
				}
				parseClass(node, isStatement, optionalId) {
					this.next()
					const oldStrict = this.state.strict
					this.state.strict = true
					this.parseClassId(node, isStatement, optionalId)
					this.parseClassSuper(node)
					node.body = this.parseClassBody(!!node.superClass, oldStrict)
					return this.finishNode(
						node,
						isStatement ? 'ClassDeclaration' : 'ClassExpression',
					)
				}
				isClassProperty() {
					return this.match(29) || this.match(13) || this.match(8)
				}
				isClassMethod() {
					return this.match(10)
				}
				nameIsConstructor(key) {
					return (
						(key.type === 'Identifier' && key.name === 'constructor') ||
						(key.type === 'StringLiteral' && key.value === 'constructor')
					)
				}
				isNonstaticConstructor(method) {
					return (
						!method.computed &&
						!method.static &&
						this.nameIsConstructor(method.key)
					)
				}
				parseClassBody(hadSuperClass, oldStrict) {
					this.classScope.enter()
					const state = {
						hadConstructor: false,
						hadSuperClass,
					}
					let decorators = []
					const classBody = this.startNode()
					classBody.body = []
					this.expect(5)
					this.withSmartMixTopicForbiddingContext(() => {
						while (!this.match(8)) {
							if (this.eat(13)) {
								if (decorators.length > 0) {
									throw this.raise(
										Errors.DecoratorSemicolon,
										this.state.lastTokEndLoc,
									)
								}
								continue
							}
							if (this.match(26)) {
								decorators.push(this.parseDecorator())
								continue
							}
							const member = this.startNode()
							if (decorators.length) {
								member.decorators = decorators
								this.resetStartLocationFromNode(member, decorators[0])
								decorators = []
							}
							this.parseClassMember(classBody, member, state)
							if (
								member.kind === 'constructor' &&
								member.decorators &&
								member.decorators.length > 0
							) {
								this.raise(Errors.DecoratorConstructor, member)
							}
						}
					})
					this.state.strict = oldStrict
					this.next()
					if (decorators.length) {
						throw this.raise(Errors.TrailingDecorator, this.state.startLoc)
					}
					this.classScope.exit()
					return this.finishNode(classBody, 'ClassBody')
				}
				parseClassMemberFromModifier(classBody, member) {
					const key = this.parseIdentifier(true)
					if (this.isClassMethod()) {
						const method = member
						method.kind = 'method'
						method.computed = false
						method.key = key
						method.static = false
						this.pushClassMethod(classBody, method, false, false, false, false)
						return true
					} else if (this.isClassProperty()) {
						const prop = member
						prop.computed = false
						prop.key = key
						prop.static = false
						classBody.body.push(this.parseClassProperty(prop))
						return true
					}
					this.resetPreviousNodeTrailingComments(key)
					return false
				}
				parseClassMember(classBody, member, state) {
					const isStatic = this.isContextual(106)
					if (isStatic) {
						if (this.parseClassMemberFromModifier(classBody, member)) {
							return
						}
						if (this.eat(5)) {
							this.parseClassStaticBlock(classBody, member)
							return
						}
					}
					this.parseClassMemberWithIsStatic(classBody, member, state, isStatic)
				}
				parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
					const publicMethod = member
					const privateMethod = member
					const publicProp = member
					const privateProp = member
					const accessorProp = member
					const method = publicMethod
					const publicMember = publicMethod
					member.static = isStatic
					this.parsePropertyNamePrefixOperator(member)
					if (this.eat(55)) {
						method.kind = 'method'
						const isPrivateName = this.match(139)
						this.parseClassElementName(method)
						if (isPrivateName) {
							this.pushClassPrivateMethod(classBody, privateMethod, true, false)
							return
						}
						if (this.isNonstaticConstructor(publicMethod)) {
							this.raise(Errors.ConstructorIsGenerator, publicMethod.key)
						}
						this.pushClassMethod(
							classBody,
							publicMethod,
							true,
							false,
							false,
							false,
						)
						return
					}
					const isContextual =
						!this.state.containsEsc && tokenIsIdentifier(this.state.type)
					const key = this.parseClassElementName(member)
					const maybeContextualKw = isContextual ? key.name : null
					const isPrivate = this.isPrivateName(key)
					const maybeQuestionTokenStartLoc = this.state.startLoc
					this.parsePostMemberNameModifiers(publicMember)
					if (this.isClassMethod()) {
						method.kind = 'method'
						if (isPrivate) {
							this.pushClassPrivateMethod(
								classBody,
								privateMethod,
								false,
								false,
							)
							return
						}
						const isConstructor = this.isNonstaticConstructor(publicMethod)
						let allowsDirectSuper = false
						if (isConstructor) {
							publicMethod.kind = 'constructor'
							if (state.hadConstructor && !this.hasPlugin('typescript')) {
								this.raise(Errors.DuplicateConstructor, key)
							}
							if (
								isConstructor &&
								this.hasPlugin('typescript') &&
								member.override
							) {
								this.raise(Errors.OverrideOnConstructor, key)
							}
							state.hadConstructor = true
							allowsDirectSuper = state.hadSuperClass
						}
						this.pushClassMethod(
							classBody,
							publicMethod,
							false,
							false,
							isConstructor,
							allowsDirectSuper,
						)
					} else if (this.isClassProperty()) {
						if (isPrivate) {
							this.pushClassPrivateProperty(classBody, privateProp)
						} else {
							this.pushClassProperty(classBody, publicProp)
						}
					} else if (
						maybeContextualKw === 'async' &&
						!this.isLineTerminator()
					) {
						this.resetPreviousNodeTrailingComments(key)
						const isGenerator = this.eat(55)
						if (publicMember.optional) {
							this.unexpected(maybeQuestionTokenStartLoc)
						}
						method.kind = 'method'
						const isPrivate = this.match(139)
						this.parseClassElementName(method)
						this.parsePostMemberNameModifiers(publicMember)
						if (isPrivate) {
							this.pushClassPrivateMethod(
								classBody,
								privateMethod,
								isGenerator,
								true,
							)
						} else {
							if (this.isNonstaticConstructor(publicMethod)) {
								this.raise(Errors.ConstructorIsAsync, publicMethod.key)
							}
							this.pushClassMethod(
								classBody,
								publicMethod,
								isGenerator,
								true,
								false,
								false,
							)
						}
					} else if (
						(maybeContextualKw === 'get' || maybeContextualKw === 'set') &&
						!(this.match(55) && this.isLineTerminator())
					) {
						this.resetPreviousNodeTrailingComments(key)
						method.kind = maybeContextualKw
						const isPrivate = this.match(139)
						this.parseClassElementName(publicMethod)
						if (isPrivate) {
							this.pushClassPrivateMethod(
								classBody,
								privateMethod,
								false,
								false,
							)
						} else {
							if (this.isNonstaticConstructor(publicMethod)) {
								this.raise(Errors.ConstructorIsAccessor, publicMethod.key)
							}
							this.pushClassMethod(
								classBody,
								publicMethod,
								false,
								false,
								false,
								false,
							)
						}
						this.checkGetterSetterParams(publicMethod)
					} else if (
						maybeContextualKw === 'accessor' &&
						!this.isLineTerminator()
					) {
						this.expectPlugin('decoratorAutoAccessors')
						this.resetPreviousNodeTrailingComments(key)
						const isPrivate = this.match(139)
						this.parseClassElementName(publicProp)
						this.pushClassAccessorProperty(classBody, accessorProp, isPrivate)
					} else if (this.isLineTerminator()) {
						if (isPrivate) {
							this.pushClassPrivateProperty(classBody, privateProp)
						} else {
							this.pushClassProperty(classBody, publicProp)
						}
					} else {
						this.unexpected()
					}
				}
				parseClassElementName(member) {
					const { type, value } = this.state
					if (
						(type === 132 || type === 134) &&
						member.static &&
						value === 'prototype'
					) {
						this.raise(Errors.StaticPrototype, this.state.startLoc)
					}
					if (type === 139) {
						if (value === 'constructor') {
							this.raise(
								Errors.ConstructorClassPrivateField,
								this.state.startLoc,
							)
						}
						const key = this.parsePrivateName()
						member.key = key
						return key
					}
					this.parsePropertyName(member)
					return member.key
				}
				parseClassStaticBlock(classBody, member) {
					var _member$decorators
					this.scope.enter(64 | 128 | 16)
					const oldLabels = this.state.labels
					this.state.labels = []
					this.prodParam.enter(0)
					const body = (member.body = [])
					this.parseBlockOrModuleBlockBody(body, undefined, false, 8)
					this.prodParam.exit()
					this.scope.exit()
					this.state.labels = oldLabels
					classBody.body.push(this.finishNode(member, 'StaticBlock'))
					if (
						(_member$decorators = member.decorators) != null &&
						_member$decorators.length
					) {
						this.raise(Errors.DecoratorStaticBlock, member)
					}
				}
				pushClassProperty(classBody, prop) {
					if (!prop.computed && this.nameIsConstructor(prop.key)) {
						this.raise(Errors.ConstructorClassField, prop.key)
					}
					classBody.body.push(this.parseClassProperty(prop))
				}
				pushClassPrivateProperty(classBody, prop) {
					const node = this.parseClassPrivateProperty(prop)
					classBody.body.push(node)
					this.classScope.declarePrivateName(
						this.getPrivateNameSV(node.key),
						0,
						node.key.loc.start,
					)
				}
				pushClassAccessorProperty(classBody, prop, isPrivate) {
					if (
						!isPrivate &&
						!prop.computed &&
						this.nameIsConstructor(prop.key)
					) {
						this.raise(Errors.ConstructorClassField, prop.key)
					}
					const node = this.parseClassAccessorProperty(prop)
					classBody.body.push(node)
					if (isPrivate) {
						this.classScope.declarePrivateName(
							this.getPrivateNameSV(node.key),
							0,
							node.key.loc.start,
						)
					}
				}
				pushClassMethod(
					classBody,
					method,
					isGenerator,
					isAsync,
					isConstructor,
					allowsDirectSuper,
				) {
					classBody.body.push(
						this.parseMethod(
							method,
							isGenerator,
							isAsync,
							isConstructor,
							allowsDirectSuper,
							'ClassMethod',
							true,
						),
					)
				}
				pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
					const node = this.parseMethod(
						method,
						isGenerator,
						isAsync,
						false,
						false,
						'ClassPrivateMethod',
						true,
					)
					classBody.body.push(node)
					const kind =
						node.kind === 'get'
							? node.static
								? 6
								: 2
							: node.kind === 'set'
								? node.static
									? 5
									: 1
								: 0
					this.declareClassPrivateMethodInScope(node, kind)
				}
				declareClassPrivateMethodInScope(node, kind) {
					this.classScope.declarePrivateName(
						this.getPrivateNameSV(node.key),
						kind,
						node.key.loc.start,
					)
				}
				parsePostMemberNameModifiers(methodOrProp) {}
				parseClassPrivateProperty(node) {
					this.parseInitializer(node)
					this.semicolon()
					return this.finishNode(node, 'ClassPrivateProperty')
				}
				parseClassProperty(node) {
					this.parseInitializer(node)
					this.semicolon()
					return this.finishNode(node, 'ClassProperty')
				}
				parseClassAccessorProperty(node) {
					this.parseInitializer(node)
					this.semicolon()
					return this.finishNode(node, 'ClassAccessorProperty')
				}
				parseInitializer(node) {
					this.scope.enter(64 | 16)
					this.expressionScope.enter(newExpressionScope())
					this.prodParam.enter(0)
					node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null
					this.expressionScope.exit()
					this.prodParam.exit()
					this.scope.exit()
				}
				parseClassId(node, isStatement, optionalId, bindingType = 8331) {
					if (tokenIsIdentifier(this.state.type)) {
						node.id = this.parseIdentifier()
						if (isStatement) {
							this.declareNameFromIdentifier(node.id, bindingType)
						}
					} else {
						if (optionalId || !isStatement) {
							node.id = null
						} else {
							throw this.raise(Errors.MissingClassName, this.state.startLoc)
						}
					}
				}
				parseClassSuper(node) {
					node.superClass = this.eat(81) ? this.parseExprSubscripts() : null
				}
				parseExport(node, decorators) {
					const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true)
					const hasDefault = this.maybeParseExportDefaultSpecifier(
						node,
						maybeDefaultIdentifier,
					)
					const parseAfterDefault = !hasDefault || this.eat(12)
					const hasStar = parseAfterDefault && this.eatExportStar(node)
					const hasNamespace =
						hasStar && this.maybeParseExportNamespaceSpecifier(node)
					const parseAfterNamespace =
						parseAfterDefault && (!hasNamespace || this.eat(12))
					const isFromRequired = hasDefault || hasStar
					if (hasStar && !hasNamespace) {
						if (hasDefault) this.unexpected()
						if (decorators) {
							throw this.raise(Errors.UnsupportedDecoratorExport, node)
						}
						this.parseExportFrom(node, true)
						this.sawUnambiguousESM = true
						return this.finishNode(node, 'ExportAllDeclaration')
					}
					const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node)
					if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {
						this.unexpected(null, 5)
					}
					if (hasNamespace && parseAfterNamespace) {
						this.unexpected(null, 98)
					}
					let hasDeclaration
					if (isFromRequired || hasSpecifiers) {
						hasDeclaration = false
						if (decorators) {
							throw this.raise(Errors.UnsupportedDecoratorExport, node)
						}
						this.parseExportFrom(node, isFromRequired)
					} else {
						hasDeclaration = this.maybeParseExportDeclaration(node)
					}
					if (isFromRequired || hasSpecifiers || hasDeclaration) {
						var _node2$declaration
						const node2 = node
						this.checkExport(node2, true, false, !!node2.source)
						if (
							((_node2$declaration = node2.declaration) == null
								? void 0
								: _node2$declaration.type) === 'ClassDeclaration'
						) {
							this.maybeTakeDecorators(decorators, node2.declaration, node2)
						} else if (decorators) {
							throw this.raise(Errors.UnsupportedDecoratorExport, node)
						}
						this.sawUnambiguousESM = true
						return this.finishNode(node2, 'ExportNamedDeclaration')
					}
					if (this.eat(65)) {
						const node2 = node
						const decl = this.parseExportDefaultExpression()
						node2.declaration = decl
						if (decl.type === 'ClassDeclaration') {
							this.maybeTakeDecorators(decorators, decl, node2)
						} else if (decorators) {
							throw this.raise(Errors.UnsupportedDecoratorExport, node)
						}
						this.checkExport(node2, true, true)
						this.sawUnambiguousESM = true
						return this.finishNode(node2, 'ExportDefaultDeclaration')
					}
					this.unexpected(null, 5)
				}
				eatExportStar(node) {
					return this.eat(55)
				}
				maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
					if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {
						this.expectPlugin(
							'exportDefaultFrom',
							maybeDefaultIdentifier == null
								? void 0
								: maybeDefaultIdentifier.loc.start,
						)
						const id = maybeDefaultIdentifier || this.parseIdentifier(true)
						const specifier = this.startNodeAtNode(id)
						specifier.exported = id
						node.specifiers = [
							this.finishNode(specifier, 'ExportDefaultSpecifier'),
						]
						return true
					}
					return false
				}
				maybeParseExportNamespaceSpecifier(node) {
					if (this.isContextual(93)) {
						var _ref, _ref$specifiers
						;(_ref$specifiers = (_ref = node).specifiers) != null
							? _ref$specifiers
							: (_ref.specifiers = [])
						const specifier = this.startNodeAt(this.state.lastTokStartLoc)
						this.next()
						specifier.exported = this.parseModuleExportName()
						node.specifiers.push(
							this.finishNode(specifier, 'ExportNamespaceSpecifier'),
						)
						return true
					}
					return false
				}
				maybeParseExportNamedSpecifiers(node) {
					if (this.match(5)) {
						const node2 = node
						if (!node2.specifiers) node2.specifiers = []
						const isTypeExport = node2.exportKind === 'type'
						node2.specifiers.push(...this.parseExportSpecifiers(isTypeExport))
						node2.source = null
						if (this.hasPlugin('importAssertions')) {
							node2.assertions = []
						} else {
							node2.attributes = []
						}
						node2.declaration = null
						return true
					}
					return false
				}
				maybeParseExportDeclaration(node) {
					if (this.shouldParseExportDeclaration()) {
						node.specifiers = []
						node.source = null
						if (this.hasPlugin('importAssertions')) {
							node.assertions = []
						} else {
							node.attributes = []
						}
						node.declaration = this.parseExportDeclaration(node)
						return true
					}
					return false
				}
				isAsyncFunction() {
					if (!this.isContextual(95)) return false
					const next = this.nextTokenInLineStart()
					return this.isUnparsedContextual(next, 'function')
				}
				parseExportDefaultExpression() {
					const expr = this.startNode()
					if (this.match(68)) {
						this.next()
						return this.parseFunction(expr, 1 | 4)
					} else if (this.isAsyncFunction()) {
						this.next()
						this.next()
						return this.parseFunction(expr, 1 | 4 | 8)
					}
					if (this.match(80)) {
						return this.parseClass(expr, true, true)
					}
					if (this.match(26)) {
						if (
							this.hasPlugin('decorators') &&
							this.getPluginOption('decorators', 'decoratorsBeforeExport') ===
								true
						) {
							this.raise(Errors.DecoratorBeforeExport, this.state.startLoc)
						}
						return this.parseClass(
							this.maybeTakeDecorators(
								this.parseDecorators(false),
								this.startNode(),
							),
							true,
							true,
						)
					}
					if (this.match(75) || this.match(74) || this.isLet()) {
						throw this.raise(
							Errors.UnsupportedDefaultExport,
							this.state.startLoc,
						)
					}
					const res = this.parseMaybeAssignAllowIn()
					this.semicolon()
					return res
				}
				parseExportDeclaration(node) {
					if (this.match(80)) {
						const node = this.parseClass(this.startNode(), true, false)
						return node
					}
					return this.parseStatementListItem()
				}
				isExportDefaultSpecifier() {
					const { type } = this.state
					if (tokenIsIdentifier(type)) {
						if ((type === 95 && !this.state.containsEsc) || type === 100) {
							return false
						}
						if ((type === 130 || type === 129) && !this.state.containsEsc) {
							const { type: nextType } = this.lookahead()
							if (
								(tokenIsIdentifier(nextType) && nextType !== 98) ||
								nextType === 5
							) {
								this.expectOnePlugin(['flow', 'typescript'])
								return false
							}
						}
					} else if (!this.match(65)) {
						return false
					}
					const next = this.nextTokenStart()
					const hasFrom = this.isUnparsedContextual(next, 'from')
					if (
						this.input.charCodeAt(next) === 44 ||
						(tokenIsIdentifier(this.state.type) && hasFrom)
					) {
						return true
					}
					if (this.match(65) && hasFrom) {
						const nextAfterFrom = this.input.charCodeAt(
							this.nextTokenStartSince(next + 4),
						)
						return nextAfterFrom === 34 || nextAfterFrom === 39
					}
					return false
				}
				parseExportFrom(node, expect) {
					if (this.eatContextual(98)) {
						node.source = this.parseImportSource()
						this.checkExport(node)
						this.maybeParseImportAttributes(node)
						this.checkJSONModuleImport(node)
					} else if (expect) {
						this.unexpected()
					}
					this.semicolon()
				}
				shouldParseExportDeclaration() {
					const { type } = this.state
					if (type === 26) {
						this.expectOnePlugin(['decorators', 'decorators-legacy'])
						if (this.hasPlugin('decorators')) {
							if (
								this.getPluginOption('decorators', 'decoratorsBeforeExport') ===
								true
							) {
								this.raise(Errors.DecoratorBeforeExport, this.state.startLoc)
							}
							return true
						}
					}
					if (this.isContextual(107)) {
						this.raise(Errors.UsingDeclarationExport, this.state.startLoc)
						return true
					}
					if (this.isContextual(96) && this.startsAwaitUsing()) {
						this.raise(Errors.UsingDeclarationExport, this.state.startLoc)
						return true
					}
					return (
						type === 74 ||
						type === 75 ||
						type === 68 ||
						type === 80 ||
						this.isLet() ||
						this.isAsyncFunction()
					)
				}
				checkExport(node, checkNames, isDefault, isFrom) {
					if (checkNames) {
						var _node$specifiers
						if (isDefault) {
							this.checkDuplicateExports(node, 'default')
							if (this.hasPlugin('exportDefaultFrom')) {
								var _declaration$extra
								const declaration = node.declaration
								if (
									declaration.type === 'Identifier' &&
									declaration.name === 'from' &&
									declaration.end - declaration.start === 4 &&
									!(
										(_declaration$extra = declaration.extra) != null &&
										_declaration$extra.parenthesized
									)
								) {
									this.raise(Errors.ExportDefaultFromAsIdentifier, declaration)
								}
							}
						} else if (
							(_node$specifiers = node.specifiers) != null &&
							_node$specifiers.length
						) {
							for (const specifier of node.specifiers) {
								const { exported } = specifier
								const exportName =
									exported.type === 'Identifier'
										? exported.name
										: exported.value
								this.checkDuplicateExports(specifier, exportName)
								if (!isFrom && specifier.local) {
									const { local } = specifier
									if (local.type !== 'Identifier') {
										this.raise(Errors.ExportBindingIsString, specifier, {
											localName: local.value,
											exportName,
										})
									} else {
										this.checkReservedWord(
											local.name,
											local.loc.start,
											true,
											false,
										)
										this.scope.checkLocalExport(local)
									}
								}
							}
						} else if (node.declaration) {
							const decl = node.declaration
							if (
								decl.type === 'FunctionDeclaration' ||
								decl.type === 'ClassDeclaration'
							) {
								const { id } = decl
								if (!id) throw new Error('Assertion failure')
								this.checkDuplicateExports(node, id.name)
							} else if (decl.type === 'VariableDeclaration') {
								for (const declaration of decl.declarations) {
									this.checkDeclaration(declaration.id)
								}
							}
						}
					}
				}
				checkDeclaration(node) {
					if (node.type === 'Identifier') {
						this.checkDuplicateExports(node, node.name)
					} else if (node.type === 'ObjectPattern') {
						for (const prop of node.properties) {
							this.checkDeclaration(prop)
						}
					} else if (node.type === 'ArrayPattern') {
						for (const elem of node.elements) {
							if (elem) {
								this.checkDeclaration(elem)
							}
						}
					} else if (node.type === 'ObjectProperty') {
						this.checkDeclaration(node.value)
					} else if (node.type === 'RestElement') {
						this.checkDeclaration(node.argument)
					} else if (node.type === 'AssignmentPattern') {
						this.checkDeclaration(node.left)
					}
				}
				checkDuplicateExports(node, exportName) {
					if (this.exportedIdentifiers.has(exportName)) {
						if (exportName === 'default') {
							this.raise(Errors.DuplicateDefaultExport, node)
						} else {
							this.raise(Errors.DuplicateExport, node, {
								exportName,
							})
						}
					}
					this.exportedIdentifiers.add(exportName)
				}
				parseExportSpecifiers(isInTypeExport) {
					const nodes = []
					let first = true
					this.expect(5)
					while (!this.eat(8)) {
						if (first) {
							first = false
						} else {
							this.expect(12)
							if (this.eat(8)) break
						}
						const isMaybeTypeOnly = this.isContextual(130)
						const isString = this.match(134)
						const node = this.startNode()
						node.local = this.parseModuleExportName()
						nodes.push(
							this.parseExportSpecifier(
								node,
								isString,
								isInTypeExport,
								isMaybeTypeOnly,
							),
						)
					}
					return nodes
				}
				parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
					if (this.eatContextual(93)) {
						node.exported = this.parseModuleExportName()
					} else if (isString) {
						node.exported = this.cloneStringLiteral(node.local)
					} else if (!node.exported) {
						node.exported = this.cloneIdentifier(node.local)
					}
					return this.finishNode(node, 'ExportSpecifier')
				}
				parseModuleExportName() {
					if (this.match(134)) {
						const result = this.parseStringLiteral(this.state.value)
						const surrogate = loneSurrogate.exec(result.value)
						if (surrogate) {
							this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {
								surrogateCharCode: surrogate[0].charCodeAt(0),
							})
						}
						return result
					}
					return this.parseIdentifier(true)
				}
				isJSONModuleImport(node) {
					if (node.assertions != null) {
						return node.assertions.some(({ key, value }) => {
							return (
								value.value === 'json' &&
								(key.type === 'Identifier'
									? key.name === 'type'
									: key.value === 'type')
							)
						})
					}
					return false
				}
				checkImportReflection(node) {
					const { specifiers } = node
					const singleBindingType =
						specifiers.length === 1 ? specifiers[0].type : null
					if (node.phase === 'source') {
						if (singleBindingType !== 'ImportDefaultSpecifier') {
							this.raise(
								Errors.SourcePhaseImportRequiresDefault,
								specifiers[0].loc.start,
							)
						}
					} else if (node.phase === 'defer') {
						if (singleBindingType !== 'ImportNamespaceSpecifier') {
							this.raise(
								Errors.DeferImportRequiresNamespace,
								specifiers[0].loc.start,
							)
						}
					} else if (node.module) {
						var _node$assertions
						if (singleBindingType !== 'ImportDefaultSpecifier') {
							this.raise(
								Errors.ImportReflectionNotBinding,
								specifiers[0].loc.start,
							)
						}
						if (
							((_node$assertions = node.assertions) == null
								? void 0
								: _node$assertions.length) > 0
						) {
							this.raise(
								Errors.ImportReflectionHasAssertion,
								specifiers[0].loc.start,
							)
						}
					}
				}
				checkJSONModuleImport(node) {
					if (
						this.isJSONModuleImport(node) &&
						node.type !== 'ExportAllDeclaration'
					) {
						const { specifiers } = node
						if (specifiers != null) {
							const nonDefaultNamedSpecifier = specifiers.find((specifier) => {
								let imported
								if (specifier.type === 'ExportSpecifier') {
									imported = specifier.local
								} else if (specifier.type === 'ImportSpecifier') {
									imported = specifier.imported
								}
								if (imported !== undefined) {
									return imported.type === 'Identifier'
										? imported.name !== 'default'
										: imported.value !== 'default'
								}
							})
							if (nonDefaultNamedSpecifier !== undefined) {
								this.raise(
									Errors.ImportJSONBindingNotDefault,
									nonDefaultNamedSpecifier.loc.start,
								)
							}
						}
					}
				}
				isPotentialImportPhase(isExport) {
					if (isExport) return false
					return (
						this.isContextual(105) ||
						this.isContextual(97) ||
						this.isContextual(127)
					)
				}
				applyImportPhase(node, isExport, phase, loc) {
					if (isExport) {
						return
					}
					if (phase === 'module') {
						this.expectPlugin('importReflection', loc)
						node.module = true
					} else if (this.hasPlugin('importReflection')) {
						node.module = false
					}
					if (phase === 'source') {
						this.expectPlugin('sourcePhaseImports', loc)
						node.phase = 'source'
					} else if (phase === 'defer') {
						this.expectPlugin('deferredImportEvaluation', loc)
						node.phase = 'defer'
					} else if (this.hasPlugin('sourcePhaseImports')) {
						node.phase = null
					}
				}
				parseMaybeImportPhase(node, isExport) {
					if (!this.isPotentialImportPhase(isExport)) {
						this.applyImportPhase(node, isExport, null)
						return null
					}
					const phaseIdentifier = this.parseIdentifier(true)
					const { type } = this.state
					const isImportPhase = tokenIsKeywordOrIdentifier(type)
						? type !== 98 || this.lookaheadCharCode() === 102
						: type !== 12
					if (isImportPhase) {
						this.resetPreviousIdentifierLeadingComments(phaseIdentifier)
						this.applyImportPhase(
							node,
							isExport,
							phaseIdentifier.name,
							phaseIdentifier.loc.start,
						)
						return null
					} else {
						this.applyImportPhase(node, isExport, null)
						return phaseIdentifier
					}
				}
				isPrecedingIdImportPhase(phase) {
					const { type } = this.state
					return tokenIsIdentifier(type)
						? type !== 98 || this.lookaheadCharCode() === 102
						: type !== 12
				}
				parseImport(node) {
					if (this.match(134)) {
						return this.parseImportSourceAndAttributes(node)
					}
					return this.parseImportSpecifiersAndAfter(
						node,
						this.parseMaybeImportPhase(node, false),
					)
				}
				parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {
					node.specifiers = []
					const hasDefault = this.maybeParseDefaultImportSpecifier(
						node,
						maybeDefaultIdentifier,
					)
					const parseNext = !hasDefault || this.eat(12)
					const hasStar = parseNext && this.maybeParseStarImportSpecifier(node)
					if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node)
					this.expectContextual(98)
					return this.parseImportSourceAndAttributes(node)
				}
				parseImportSourceAndAttributes(node) {
					var _node$specifiers2
					;(_node$specifiers2 = node.specifiers) != null
						? _node$specifiers2
						: (node.specifiers = [])
					node.source = this.parseImportSource()
					this.maybeParseImportAttributes(node)
					this.checkImportReflection(node)
					this.checkJSONModuleImport(node)
					this.semicolon()
					this.sawUnambiguousESM = true
					return this.finishNode(node, 'ImportDeclaration')
				}
				parseImportSource() {
					if (!this.match(134)) this.unexpected()
					return this.parseExprAtom()
				}
				parseImportSpecifierLocal(node, specifier, type) {
					specifier.local = this.parseIdentifier()
					node.specifiers.push(this.finishImportSpecifier(specifier, type))
				}
				finishImportSpecifier(specifier, type, bindingType = 8201) {
					this.checkLVal(
						specifier.local,
						{
							type,
						},
						bindingType,
					)
					return this.finishNode(specifier, type)
				}
				parseImportAttributes() {
					this.expect(5)
					const attrs = []
					const attrNames = new Set()
					do {
						if (this.match(8)) {
							break
						}
						const node = this.startNode()
						const keyName = this.state.value
						if (attrNames.has(keyName)) {
							this.raise(
								Errors.ModuleAttributesWithDuplicateKeys,
								this.state.startLoc,
								{
									key: keyName,
								},
							)
						}
						attrNames.add(keyName)
						if (this.match(134)) {
							node.key = this.parseStringLiteral(keyName)
						} else {
							node.key = this.parseIdentifier(true)
						}
						this.expect(14)
						if (!this.match(134)) {
							throw this.raise(
								Errors.ModuleAttributeInvalidValue,
								this.state.startLoc,
							)
						}
						node.value = this.parseStringLiteral(this.state.value)
						attrs.push(this.finishNode(node, 'ImportAttribute'))
					} while (this.eat(12))
					this.expect(8)
					return attrs
				}
				parseModuleAttributes() {
					const attrs = []
					const attributes = new Set()
					do {
						const node = this.startNode()
						node.key = this.parseIdentifier(true)
						if (node.key.name !== 'type') {
							this.raise(Errors.ModuleAttributeDifferentFromType, node.key)
						}
						if (attributes.has(node.key.name)) {
							this.raise(Errors.ModuleAttributesWithDuplicateKeys, node.key, {
								key: node.key.name,
							})
						}
						attributes.add(node.key.name)
						this.expect(14)
						if (!this.match(134)) {
							throw this.raise(
								Errors.ModuleAttributeInvalidValue,
								this.state.startLoc,
							)
						}
						node.value = this.parseStringLiteral(this.state.value)
						attrs.push(this.finishNode(node, 'ImportAttribute'))
					} while (this.eat(12))
					return attrs
				}
				maybeParseImportAttributes(node) {
					let attributes
					{
						var useWith = false
					}
					if (this.match(76)) {
						if (
							this.hasPrecedingLineBreak() &&
							this.lookaheadCharCode() === 40
						) {
							return
						}
						this.next()
						if (this.hasPlugin('moduleAttributes')) {
							attributes = this.parseModuleAttributes()
							this.addExtra(node, 'deprecatedWithLegacySyntax', true)
						} else {
							attributes = this.parseImportAttributes()
						}
						{
							useWith = true
						}
					} else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
						if (
							!this.hasPlugin('deprecatedImportAssert') &&
							!this.hasPlugin('importAssertions')
						) {
							this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc)
						}
						if (!this.hasPlugin('importAssertions')) {
							this.addExtra(node, 'deprecatedAssertSyntax', true)
						}
						this.next()
						attributes = this.parseImportAttributes()
					} else {
						attributes = []
					}
					if (!useWith && this.hasPlugin('importAssertions')) {
						node.assertions = attributes
					} else {
						node.attributes = attributes
					}
				}
				maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {
					if (maybeDefaultIdentifier) {
						const specifier = this.startNodeAtNode(maybeDefaultIdentifier)
						specifier.local = maybeDefaultIdentifier
						node.specifiers.push(
							this.finishImportSpecifier(specifier, 'ImportDefaultSpecifier'),
						)
						return true
					} else if (tokenIsKeywordOrIdentifier(this.state.type)) {
						this.parseImportSpecifierLocal(
							node,
							this.startNode(),
							'ImportDefaultSpecifier',
						)
						return true
					}
					return false
				}
				maybeParseStarImportSpecifier(node) {
					if (this.match(55)) {
						const specifier = this.startNode()
						this.next()
						this.expectContextual(93)
						this.parseImportSpecifierLocal(
							node,
							specifier,
							'ImportNamespaceSpecifier',
						)
						return true
					}
					return false
				}
				parseNamedImportSpecifiers(node) {
					let first = true
					this.expect(5)
					while (!this.eat(8)) {
						if (first) {
							first = false
						} else {
							if (this.eat(14)) {
								throw this.raise(
									Errors.DestructureNamedImport,
									this.state.startLoc,
								)
							}
							this.expect(12)
							if (this.eat(8)) break
						}
						const specifier = this.startNode()
						const importedIsString = this.match(134)
						const isMaybeTypeOnly = this.isContextual(130)
						specifier.imported = this.parseModuleExportName()
						const importSpecifier = this.parseImportSpecifier(
							specifier,
							importedIsString,
							node.importKind === 'type' || node.importKind === 'typeof',
							isMaybeTypeOnly,
							undefined,
						)
						node.specifiers.push(importSpecifier)
					}
				}
				parseImportSpecifier(
					specifier,
					importedIsString,
					isInTypeOnlyImport,
					isMaybeTypeOnly,
					bindingType,
				) {
					if (this.eatContextual(93)) {
						specifier.local = this.parseIdentifier()
					} else {
						const { imported } = specifier
						if (importedIsString) {
							throw this.raise(Errors.ImportBindingIsString, specifier, {
								importName: imported.value,
							})
						}
						this.checkReservedWord(
							imported.name,
							specifier.loc.start,
							true,
							true,
						)
						if (!specifier.local) {
							specifier.local = this.cloneIdentifier(imported)
						}
					}
					return this.finishImportSpecifier(
						specifier,
						'ImportSpecifier',
						bindingType,
					)
				}
				isThisParam(param) {
					return param.type === 'Identifier' && param.name === 'this'
				}
			}
			class Parser extends StatementParser {
				constructor(options, input, pluginsMap) {
					options = getOptions(options)
					super(options, input)
					this.options = options
					this.initializeScopes()
					this.plugins = pluginsMap
					this.filename = options.sourceFilename
					this.startIndex = options.startIndex
					let optionFlags = 0
					if (options.allowAwaitOutsideFunction) {
						optionFlags |= 1
					}
					if (options.allowReturnOutsideFunction) {
						optionFlags |= 2
					}
					if (options.allowImportExportEverywhere) {
						optionFlags |= 8
					}
					if (options.allowSuperOutsideMethod) {
						optionFlags |= 16
					}
					if (options.allowUndeclaredExports) {
						optionFlags |= 64
					}
					if (options.allowNewTargetOutsideFunction) {
						optionFlags |= 4
					}
					if (options.allowYieldOutsideFunction) {
						optionFlags |= 32
					}
					if (options.ranges) {
						optionFlags |= 128
					}
					if (options.tokens) {
						optionFlags |= 256
					}
					if (options.createImportExpressions) {
						optionFlags |= 512
					}
					if (options.createParenthesizedExpressions) {
						optionFlags |= 1024
					}
					if (options.errorRecovery) {
						optionFlags |= 2048
					}
					if (options.attachComment) {
						optionFlags |= 4096
					}
					if (options.annexB) {
						optionFlags |= 8192
					}
					this.optionFlags = optionFlags
				}
				getScopeHandler() {
					return ScopeHandler
				}
				parse() {
					this.enterInitialScopes()
					const file = this.startNode()
					const program = this.startNode()
					this.nextToken()
					file.errors = null
					this.parseTopLevel(file, program)
					file.errors = this.state.errors
					file.comments.length = this.state.commentsLen
					return file
				}
			}
			function parse(input, options) {
				var _options
				if (
					((_options = options) == null ? void 0 : _options.sourceType) ===
					'unambiguous'
				) {
					options = Object.assign({}, options)
					try {
						options.sourceType = 'module'
						const parser = getParser(options, input)
						const ast = parser.parse()
						if (parser.sawUnambiguousESM) {
							return ast
						}
						if (parser.ambiguousScriptDifferentAst) {
							try {
								options.sourceType = 'script'
								return getParser(options, input).parse()
							} catch (_unused) {}
						} else {
							ast.program.sourceType = 'script'
						}
						return ast
					} catch (moduleError) {
						try {
							options.sourceType = 'script'
							return getParser(options, input).parse()
						} catch (_unused2) {}
						throw moduleError
					}
				} else {
					return getParser(options, input).parse()
				}
			}
			function parseExpression(input, options) {
				const parser = getParser(options, input)
				if (parser.options.strictMode) {
					parser.state.strict = true
				}
				return parser.getExpression()
			}
			function generateExportedTokenTypes(internalTokenTypes) {
				const tokenTypes = {}
				for (const typeName of Object.keys(internalTokenTypes)) {
					tokenTypes[typeName] = getExportedToken(internalTokenTypes[typeName])
				}
				return tokenTypes
			}
			const tokTypes = generateExportedTokenTypes(tt)
			function getParser(options, input) {
				let cls = Parser
				const pluginsMap = new Map()
				if (options != null && options.plugins) {
					for (const plugin of options.plugins) {
						let name, opts
						if (typeof plugin === 'string') {
							name = plugin
						} else {
							;[name, opts] = plugin
						}
						if (!pluginsMap.has(name)) {
							pluginsMap.set(name, opts || {})
						}
					}
					validatePlugins(pluginsMap)
					cls = getParserClass(pluginsMap)
				}
				return new cls(options, input, pluginsMap)
			}
			const parserClassCache = new Map()
			function getParserClass(pluginsMap) {
				const pluginList = []
				for (const name of mixinPluginNames) {
					if (pluginsMap.has(name)) {
						pluginList.push(name)
					}
				}
				const key = pluginList.join('|')
				let cls = parserClassCache.get(key)
				if (!cls) {
					cls = Parser
					for (const plugin of pluginList) {
						cls = mixinPlugins[plugin](cls)
					}
					parserClassCache.set(key, cls)
				}
				return cls
			}
			exports.parse = parse
			exports.parseExpression = parseExpression
			exports.tokTypes = tokTypes
			//# sourceMappingURL=index.js.map

			/***/
		},

		/***/ 32519: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			Object.defineProperty(exports, 'convertFunctionParams', {
				enumerable: true,
				get: function () {
					return _params.default
				},
			})
			exports['default'] = void 0
			var _helperPluginUtils = __nccwpck_require__(30484)
			var _params = __nccwpck_require__(61893)
			var _rest = __nccwpck_require__(36061)
			var _default = (exports['default'] = (0, _helperPluginUtils.declare)(
				(api, options) => {
					var _api$assumption, _api$assumption2
					api.assertVersion(7)
					const ignoreFunctionLength =
						(_api$assumption = api.assumption('ignoreFunctionLength')) != null
							? _api$assumption
							: options.loose
					const noNewArrows =
						(_api$assumption2 = api.assumption('noNewArrows')) != null
							? _api$assumption2
							: true
					return {
						name: 'transform-parameters',
						visitor: {
							Function(path) {
								if (
									path.isArrowFunctionExpression() &&
									path
										.get('params')
										.some(
											(param) =>
												param.isRestElement() || param.isAssignmentPattern(),
										)
								) {
									path.arrowFunctionToExpression({
										allowInsertArrowWithRest: false,
										noNewArrows,
									})
									if (!path.isFunctionExpression()) return
								}
								const convertedRest = (0, _rest.default)(path)
								const convertedParams = (0, _params.default)(
									path,
									ignoreFunctionLength,
								)
								if (convertedRest || convertedParams) {
									path.scope.crawl()
								}
							},
						},
					}
				},
			))

			//# sourceMappingURL=index.js.map

			/***/
		},

		/***/ 61893: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = convertFunctionParams
			var _core = __nccwpck_require__(85414)
			var _shadowUtils = __nccwpck_require__(92399)
			const buildDefaultParam = _core.template.statement(`
  let VARIABLE_NAME =
    arguments.length > ARGUMENT_KEY && arguments[ARGUMENT_KEY] !== undefined ?
      arguments[ARGUMENT_KEY]
    :
      DEFAULT_VALUE;
`)
			const buildLooseDefaultParam = _core.template.statement(`
  if (ASSIGNMENT_IDENTIFIER === UNDEFINED) {
    ASSIGNMENT_IDENTIFIER = DEFAULT_VALUE;
  }
`)
			const buildLooseDestructuredDefaultParam = _core.template.statement(`
  let ASSIGNMENT_IDENTIFIER = PARAMETER_NAME === UNDEFINED ? DEFAULT_VALUE : PARAMETER_NAME ;
`)
			const buildSafeArgumentsAccess = _core.template.statement(`
  let $0 = arguments.length > $1 ? arguments[$1] : undefined;
`)
			function convertFunctionParams(
				path,
				ignoreFunctionLength,
				shouldTransformParam,
				replaceRestElement,
			) {
				const params = path.get('params')
				const isSimpleParameterList = params.every((param) =>
					param.isIdentifier(),
				)
				if (isSimpleParameterList) return false
				const { node, scope } = path
				const body = []
				const shadowedParams = new Set()
				for (const param of params) {
					;(0, _shadowUtils.collectShadowedParamsNames)(
						param,
						scope,
						shadowedParams,
					)
				}
				const state = {
					needsOuterBinding: false,
					scope,
				}
				if (shadowedParams.size === 0) {
					for (const param of params) {
						if (!param.isIdentifier())
							param.traverse(_shadowUtils.iifeVisitor, state)
						if (state.needsOuterBinding) break
					}
				}
				let firstOptionalIndex = null
				for (let i = 0; i < params.length; i++) {
					const param = params[i]
					if (shouldTransformParam && !shouldTransformParam(i)) {
						continue
					}
					const transformedRestNodes = []
					if (replaceRestElement) {
						replaceRestElement(path, param, transformedRestNodes)
					}
					const paramIsAssignmentPattern = param.isAssignmentPattern()
					if (
						paramIsAssignmentPattern &&
						(ignoreFunctionLength ||
							_core.types.isMethod(node, {
								kind: 'set',
							}))
					) {
						const left = param.get('left')
						const right = param.get('right')
						const undefinedNode = scope.buildUndefinedNode()
						if (left.isIdentifier()) {
							body.push(
								buildLooseDefaultParam({
									ASSIGNMENT_IDENTIFIER: _core.types.cloneNode(left.node),
									DEFAULT_VALUE: right.node,
									UNDEFINED: undefinedNode,
								}),
							)
							param.replaceWith(left.node)
						} else if (left.isObjectPattern() || left.isArrayPattern()) {
							const paramName = scope.generateUidIdentifier()
							body.push(
								buildLooseDestructuredDefaultParam({
									ASSIGNMENT_IDENTIFIER: left.node,
									DEFAULT_VALUE: right.node,
									PARAMETER_NAME: _core.types.cloneNode(paramName),
									UNDEFINED: undefinedNode,
								}),
							)
							param.replaceWith(paramName)
						}
					} else if (paramIsAssignmentPattern) {
						if (firstOptionalIndex === null) firstOptionalIndex = i
						const left = param.get('left')
						const right = param.get('right')
						const defNode = buildDefaultParam({
							VARIABLE_NAME: left.node,
							DEFAULT_VALUE: right.node,
							ARGUMENT_KEY: _core.types.numericLiteral(i),
						})
						body.push(defNode)
					} else if (firstOptionalIndex !== null) {
						const defNode = buildSafeArgumentsAccess([
							param.node,
							_core.types.numericLiteral(i),
						])
						body.push(defNode)
					} else if (param.isObjectPattern() || param.isArrayPattern()) {
						const uid = path.scope.generateUidIdentifier('ref')
						uid.typeAnnotation = param.node.typeAnnotation
						const defNode = _core.types.variableDeclaration('let', [
							_core.types.variableDeclarator(param.node, uid),
						])
						body.push(defNode)
						param.replaceWith(_core.types.cloneNode(uid))
					}
					if (transformedRestNodes) {
						for (const transformedNode of transformedRestNodes) {
							body.push(transformedNode)
						}
					}
				}
				if (firstOptionalIndex !== null) {
					node.params = node.params.slice(0, firstOptionalIndex)
				}
				path.ensureBlock()
				const path2 = path
				const { async, generator } = node
				if (generator || state.needsOuterBinding || shadowedParams.size > 0) {
					body.push(
						(0, _shadowUtils.buildScopeIIFE)(shadowedParams, path2.node.body),
					)
					path.set('body', _core.types.blockStatement(body))
					const bodyPath = path2.get('body.body')
					const arrowPath = bodyPath[bodyPath.length - 1].get('argument.callee')
					arrowPath.arrowFunctionToExpression()
					arrowPath.node.generator = generator
					arrowPath.node.async = async
					node.generator = false
					node.async = false
					if (async) {
						path2.node.body = _core.template.statement.ast`{
        try {
          ${path2.node.body.body}
        } catch (e) {
          return Promise.reject(e);
        }
      }`
					}
				} else {
					path2.get('body').unshiftContainer('body', body)
				}
				return true
			}

			//# sourceMappingURL=params.js.map

			/***/
		},

		/***/ 36061: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = convertFunctionRest
			var _core = __nccwpck_require__(85414)
			var _shadowUtils = __nccwpck_require__(92399)
			const buildRest = _core.template.statement(`
  for (var LEN = ARGUMENTS.length,
           ARRAY = new Array(ARRAY_LEN),
           KEY = START;
       KEY < LEN;
       KEY++) {
    ARRAY[ARRAY_KEY] = ARGUMENTS[KEY];
  }
`)
			const restIndex = _core.template.expression(`
  (INDEX < OFFSET || ARGUMENTS.length <= INDEX) ? undefined : ARGUMENTS[INDEX]
`)
			const restIndexImpure = _core.template.expression(`
  REF = INDEX, (REF < OFFSET || ARGUMENTS.length <= REF) ? undefined : ARGUMENTS[REF]
`)
			const restLength = _core.template.expression(`
  ARGUMENTS.length <= OFFSET ? 0 : ARGUMENTS.length - OFFSET
`)
			function referencesRest(path, state) {
				if (path.node.name === state.name) {
					return path.scope.bindingIdentifierEquals(
						state.name,
						state.outerBinding,
					)
				}
				return false
			}
			const memberExpressionOptimisationVisitor = {
				Scope(path, state) {
					if (
						!path.scope.bindingIdentifierEquals(state.name, state.outerBinding)
					) {
						path.skip()
					}
				},
				Flow(path) {
					if (path.isTypeCastExpression()) return
					path.skip()
				},
				Function(path, state) {
					const oldNoOptimise = state.noOptimise
					state.noOptimise = true
					path.traverse(memberExpressionOptimisationVisitor, state)
					state.noOptimise = oldNoOptimise
					path.skip()
				},
				ReferencedIdentifier(path, state) {
					const { node } = path
					if (node.name === 'arguments') {
						state.deopted = true
					}
					if (!referencesRest(path, state)) return
					if (state.noOptimise) {
						state.deopted = true
					} else {
						const { parentPath } = path
						if (
							parentPath.listKey === 'params' &&
							parentPath.key < state.offset
						) {
							return
						}
						if (
							parentPath.isMemberExpression({
								object: node,
							})
						) {
							const grandparentPath = parentPath.parentPath
							const argsOptEligible =
								!state.deopted &&
								!(
									(grandparentPath.isAssignmentExpression() &&
										parentPath.node === grandparentPath.node.left) ||
									grandparentPath.isLVal() ||
									grandparentPath.isForXStatement() ||
									grandparentPath.isUpdateExpression() ||
									grandparentPath.isUnaryExpression({
										operator: 'delete',
									}) ||
									((grandparentPath.isCallExpression() ||
										grandparentPath.isNewExpression()) &&
										parentPath.node === grandparentPath.node.callee)
								)
							if (argsOptEligible) {
								if (parentPath.node.computed) {
									if (parentPath.get('property').isBaseType('number')) {
										state.candidates.push({
											cause: 'indexGetter',
											path,
										})
										return
									}
								} else if (parentPath.node.property.name === 'length') {
									state.candidates.push({
										cause: 'lengthGetter',
										path,
									})
									return
								}
							}
						}
						if (state.offset === 0 && parentPath.isSpreadElement()) {
							const call = parentPath.parentPath
							if (call.isCallExpression() && call.node.arguments.length === 1) {
								state.candidates.push({
									cause: 'argSpread',
									path,
								})
								return
							}
						}
						state.references.push(path)
					}
				},
				BindingIdentifier(path, state) {
					if (referencesRest(path, state)) {
						state.deopted = true
					}
				},
			}
			function getParamsCount(node) {
				let count = node.params.length
				if (
					count > 0 &&
					_core.types.isIdentifier(node.params[0], {
						name: 'this',
					})
				) {
					count -= 1
				}
				return count
			}
			function hasRest(node) {
				const length = node.params.length
				return length > 0 && _core.types.isRestElement(node.params[length - 1])
			}
			function optimiseIndexGetter(path, argsId, offset) {
				const offsetLiteral = _core.types.numericLiteral(offset)
				let index
				const parent = path.parent
				if (_core.types.isNumericLiteral(parent.property)) {
					index = _core.types.numericLiteral(parent.property.value + offset)
				} else if (offset === 0) {
					index = parent.property
				} else {
					index = _core.types.binaryExpression(
						'+',
						parent.property,
						_core.types.cloneNode(offsetLiteral),
					)
				}
				const { scope, parentPath } = path
				if (!scope.isPure(index)) {
					const temp = scope.generateUidIdentifierBasedOnNode(index)
					scope.push({
						id: temp,
						kind: 'var',
					})
					parentPath.replaceWith(
						restIndexImpure({
							ARGUMENTS: argsId,
							OFFSET: offsetLiteral,
							INDEX: index,
							REF: _core.types.cloneNode(temp),
						}),
					)
				} else {
					parentPath.replaceWith(
						restIndex({
							ARGUMENTS: argsId,
							OFFSET: offsetLiteral,
							INDEX: index,
						}),
					)
					const replacedParentPath = parentPath
					const offsetTestPath = replacedParentPath.get('test')
					const valRes = offsetTestPath.get('left').evaluate()
					if (valRes.confident) {
						if (valRes.value === true) {
							replacedParentPath.replaceWith(scope.buildUndefinedNode())
						} else {
							offsetTestPath.replaceWith(offsetTestPath.get('right'))
						}
					}
				}
			}
			function optimiseLengthGetter(path, argsId, offset) {
				if (offset) {
					path.parentPath.replaceWith(
						restLength({
							ARGUMENTS: argsId,
							OFFSET: _core.types.numericLiteral(offset),
						}),
					)
				} else {
					path.replaceWith(argsId)
				}
			}
			function convertFunctionRest(path) {
				const { node, scope } = path
				if (!hasRest(node)) return false
				const restPath = path.get(`params.${node.params.length - 1}.argument`)
				if (!restPath.isIdentifier()) {
					const shadowedParams = new Set()
					;(0, _shadowUtils.collectShadowedParamsNames)(
						restPath,
						path.scope,
						shadowedParams,
					)
					let needsIIFE = shadowedParams.size > 0
					if (!needsIIFE) {
						const state = {
							needsOuterBinding: false,
							scope,
						}
						restPath.traverse(_shadowUtils.iifeVisitor, state)
						needsIIFE = state.needsOuterBinding
					}
					if (needsIIFE) {
						path.ensureBlock()
						path.set(
							'body',
							_core.types.blockStatement([
								(0, _shadowUtils.buildScopeIIFE)(
									shadowedParams,
									path.node.body,
								),
							]),
						)
					}
				}
				let rest = restPath.node
				node.params.pop()
				if (_core.types.isPattern(rest)) {
					const pattern = rest
					rest = scope.generateUidIdentifier('ref')
					const declar = _core.types.variableDeclaration('let', [
						_core.types.variableDeclarator(pattern, rest),
					])
					path.ensureBlock()
					node.body.body.unshift(declar)
				} else if (rest.name === 'arguments') {
					scope.rename(rest.name)
				}
				const argsId = _core.types.identifier('arguments')
				const paramsCount = getParamsCount(node)
				const state = {
					references: [],
					offset: paramsCount,
					argumentsNode: argsId,
					outerBinding: scope.getBindingIdentifier(rest.name),
					candidates: [],
					name: rest.name,
					deopted: false,
				}
				path.traverse(memberExpressionOptimisationVisitor, state)
				if (!state.deopted && !state.references.length) {
					for (const { path, cause } of state.candidates) {
						const clonedArgsId = _core.types.cloneNode(argsId)
						switch (cause) {
							case 'indexGetter':
								optimiseIndexGetter(path, clonedArgsId, state.offset)
								break
							case 'lengthGetter':
								optimiseLengthGetter(path, clonedArgsId, state.offset)
								break
							default:
								path.replaceWith(clonedArgsId)
						}
					}
					return true
				}
				state.references.push(...state.candidates.map(({ path }) => path))
				const start = _core.types.numericLiteral(paramsCount)
				const key = scope.generateUidIdentifier('key')
				const len = scope.generateUidIdentifier('len')
				let arrKey, arrLen
				if (paramsCount) {
					arrKey = _core.types.binaryExpression(
						'-',
						_core.types.cloneNode(key),
						_core.types.cloneNode(start),
					)
					arrLen = _core.types.conditionalExpression(
						_core.types.binaryExpression(
							'>',
							_core.types.cloneNode(len),
							_core.types.cloneNode(start),
						),
						_core.types.binaryExpression(
							'-',
							_core.types.cloneNode(len),
							_core.types.cloneNode(start),
						),
						_core.types.numericLiteral(0),
					)
				} else {
					arrKey = _core.types.identifier(key.name)
					arrLen = _core.types.identifier(len.name)
				}
				const loop = buildRest({
					ARGUMENTS: argsId,
					ARRAY_KEY: arrKey,
					ARRAY_LEN: arrLen,
					START: start,
					ARRAY: rest,
					KEY: key,
					LEN: len,
				})
				if (state.deopted) {
					node.body.body.unshift(loop)
				} else {
					let target = path
						.getEarliestCommonAncestorFrom(state.references)
						.getStatementParent()
					target.findParent((path) => {
						if (path.isLoop()) {
							target = path
						} else {
							return path.isFunction()
						}
					})
					target.insertBefore(loop)
				}
				return true
			}

			//# sourceMappingURL=rest.js.map

			/***/
		},

		/***/ 92399: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.buildScopeIIFE = buildScopeIIFE
			exports.collectShadowedParamsNames = collectShadowedParamsNames
			exports.iifeVisitor = void 0
			var _core = __nccwpck_require__(85414)
			const iifeVisitor = (exports.iifeVisitor = {
				'ReferencedIdentifier|BindingIdentifier'(path, state) {
					const { scope, node } = path
					const { name } = node
					if (
						name === 'eval' ||
						(scope.getBinding(name) === state.scope.parent.getBinding(name) &&
							state.scope.hasOwnBinding(name))
					) {
						state.needsOuterBinding = true
						path.stop()
					}
				},
				'TypeAnnotation|TSTypeAnnotation|TypeParameterDeclaration|TSTypeParameterDeclaration':
					(path) => path.skip(),
			})
			function collectShadowedParamsNames(
				param,
				functionScope,
				shadowedParams,
			) {
				for (const name of Object.keys(param.getBindingIdentifiers())) {
					var _functionScope$bindin
					const constantViolations =
						(_functionScope$bindin = functionScope.bindings[name]) == null
							? void 0
							: _functionScope$bindin.constantViolations
					if (constantViolations) {
						for (const redeclarator of constantViolations) {
							const node = redeclarator.node
							switch (node.type) {
								case 'VariableDeclarator': {
									if (node.init === null) {
										const declaration = redeclarator.parentPath
										if (
											!declaration.parentPath.isFor() ||
											declaration.parentPath.get('body') === declaration
										) {
											redeclarator.remove()
											break
										}
									}
									shadowedParams.add(name)
									break
								}
								case 'FunctionDeclaration':
									shadowedParams.add(name)
									break
							}
						}
					}
				}
			}
			function buildScopeIIFE(shadowedParams, body) {
				const args = []
				const params = []
				for (const name of shadowedParams) {
					args.push(_core.types.identifier(name))
					params.push(_core.types.identifier(name))
				}
				return _core.types.returnStatement(
					_core.types.callExpression(
						_core.types.arrowFunctionExpression(params, body),
						args,
					),
				)
			}

			//# sourceMappingURL=shadow-utils.js.map

			/***/
		},

		/***/ 30484: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.declare = declare
			exports.declarePreset = void 0
			const apiPolyfills = {
				assertVersion: (api) => (range) => {
					throwVersionError(range, api.version)
				},
			}
			{
				Object.assign(apiPolyfills, {
					targets: () => () => {
						return {}
					},
					assumption: () => () => {
						return undefined
					},
					addExternalDependency: () => () => {},
				})
			}
			function declare(builder) {
				return (api, options, dirname) => {
					let clonedApi
					for (const name of Object.keys(apiPolyfills)) {
						if (api[name]) continue
						clonedApi != null ? clonedApi : (clonedApi = copyApiObject(api))
						clonedApi[name] = apiPolyfills[name](clonedApi)
					}
					return builder(
						clonedApi != null ? clonedApi : api,
						options || {},
						dirname,
					)
				}
			}
			const declarePreset = (exports.declarePreset = declare)
			function copyApiObject(api) {
				let proto = null
				if (typeof api.version === 'string' && /^7\./.test(api.version)) {
					proto = Object.getPrototypeOf(api)
					if (
						proto &&
						(!hasOwnProperty.call(proto, 'version') ||
							!hasOwnProperty.call(proto, 'transform') ||
							!hasOwnProperty.call(proto, 'template') ||
							!hasOwnProperty.call(proto, 'types'))
					) {
						proto = null
					}
				}
				return Object.assign({}, proto, api)
			}
			function throwVersionError(range, version) {
				if (typeof range === 'number') {
					if (!Number.isInteger(range)) {
						throw new Error('Expected string or integer value.')
					}
					range = `^${range}.0.0-0`
				}
				if (typeof range !== 'string') {
					throw new Error('Expected string or integer value.')
				}
				const limit = Error.stackTraceLimit
				if (typeof limit === 'number' && limit < 25) {
					Error.stackTraceLimit = 25
				}
				let err
				if (version.slice(0, 2) === '7.') {
					err = new Error(
						`Requires Babel "^7.0.0-beta.41", but was loaded with "${version}". ` +
							`You'll need to update your @babel/core version.`,
					)
				} else {
					err = new Error(
						`Requires Babel "${range}", but was loaded with "${version}". ` +
							`If you are sure you have a compatible version of @babel/core, ` +
							`it is likely that something in your build process is loading the ` +
							`wrong version. Inspect the stack trace of this error to look for ` +
							`the first entry that doesn't mention "@babel/core" or "babel-core" ` +
							`to see what is calling Babel.`,
					)
				}
				if (typeof limit === 'number') {
					Error.stackTraceLimit = limit
				}
				throw Object.assign(err, {
					code: 'BABEL_VERSION_UNSUPPORTED',
					version,
					range,
				})
			}

			//# sourceMappingURL=index.js.map

			/***/
		},

		/***/ 66631: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = createTemplateBuilder
			var _options = __nccwpck_require__(97886)
			var _string = __nccwpck_require__(1231)
			var _literal = __nccwpck_require__(98083)
			const NO_PLACEHOLDER = (0, _options.validate)({
				placeholderPattern: false,
			})
			function createTemplateBuilder(formatter, defaultOpts) {
				const templateFnCache = new WeakMap()
				const templateAstCache = new WeakMap()
				const cachedOpts = defaultOpts || (0, _options.validate)(null)
				return Object.assign(
					(tpl, ...args) => {
						if (typeof tpl === 'string') {
							if (args.length > 1) throw new Error('Unexpected extra params.')
							return extendedTrace(
								(0, _string.default)(
									formatter,
									tpl,
									(0, _options.merge)(
										cachedOpts,
										(0, _options.validate)(args[0]),
									),
								),
							)
						} else if (Array.isArray(tpl)) {
							let builder = templateFnCache.get(tpl)
							if (!builder) {
								builder = (0, _literal.default)(formatter, tpl, cachedOpts)
								templateFnCache.set(tpl, builder)
							}
							return extendedTrace(builder(args))
						} else if (typeof tpl === 'object' && tpl) {
							if (args.length > 0) throw new Error('Unexpected extra params.')
							return createTemplateBuilder(
								formatter,
								(0, _options.merge)(cachedOpts, (0, _options.validate)(tpl)),
							)
						}
						throw new Error(`Unexpected template param ${typeof tpl}`)
					},
					{
						ast: (tpl, ...args) => {
							if (typeof tpl === 'string') {
								if (args.length > 1) throw new Error('Unexpected extra params.')
								return (0, _string.default)(
									formatter,
									tpl,
									(0, _options.merge)(
										(0, _options.merge)(
											cachedOpts,
											(0, _options.validate)(args[0]),
										),
										NO_PLACEHOLDER,
									),
								)()
							} else if (Array.isArray(tpl)) {
								let builder = templateAstCache.get(tpl)
								if (!builder) {
									builder = (0, _literal.default)(
										formatter,
										tpl,
										(0, _options.merge)(cachedOpts, NO_PLACEHOLDER),
									)
									templateAstCache.set(tpl, builder)
								}
								return builder(args)()
							}
							throw new Error(`Unexpected template param ${typeof tpl}`)
						},
					},
				)
			}
			function extendedTrace(fn) {
				let rootStack = ''
				try {
					throw new Error()
				} catch (error) {
					if (error.stack) {
						rootStack = error.stack.split('\n').slice(3).join('\n')
					}
				}
				return (arg) => {
					try {
						return fn(arg)
					} catch (err) {
						err.stack += `\n    =============\n${rootStack}`
						throw err
					}
				}
			}

			//# sourceMappingURL=builder.js.map

			/***/
		},

		/***/ 53637: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.statements =
				exports.statement =
				exports.smart =
				exports.program =
				exports.expression =
					void 0
			var _t = __nccwpck_require__(16535)
			const { assertExpressionStatement } = _t
			function makeStatementFormatter(fn) {
				return {
					code: (str) => `/* @babel/template */;\n${str}`,
					validate: () => {},
					unwrap: (ast) => {
						return fn(ast.program.body.slice(1))
					},
				}
			}
			const smart = (exports.smart = makeStatementFormatter((body) => {
				if (body.length > 1) {
					return body
				} else {
					return body[0]
				}
			}))
			const statements = (exports.statements = makeStatementFormatter(
				(body) => body,
			))
			const statement = (exports.statement = makeStatementFormatter((body) => {
				if (body.length === 0) {
					throw new Error('Found nothing to return.')
				}
				if (body.length > 1) {
					throw new Error('Found multiple statements but wanted one')
				}
				return body[0]
			}))
			const expression = (exports.expression = {
				code: (str) => `(\n${str}\n)`,
				validate: (ast) => {
					if (ast.program.body.length > 1) {
						throw new Error('Found multiple statements but wanted one')
					}
					if (expression.unwrap(ast).start === 0) {
						throw new Error('Parse result included parens.')
					}
				},
				unwrap: ({ program }) => {
					const [stmt] = program.body
					assertExpressionStatement(stmt)
					return stmt.expression
				},
			})
			const program = (exports.program = {
				code: (str) => str,
				validate: () => {},
				unwrap: (ast) => ast.program,
			})

			//# sourceMappingURL=formatters.js.map

			/***/
		},

		/***/ 19648: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.statements =
				exports.statement =
				exports.smart =
				exports.program =
				exports.expression =
				exports['default'] =
					void 0
			var formatters = __nccwpck_require__(53637)
			var _builder = __nccwpck_require__(66631)
			const smart = (exports.smart = (0, _builder.default)(formatters.smart))
			const statement = (exports.statement = (0, _builder.default)(
				formatters.statement,
			))
			const statements = (exports.statements = (0, _builder.default)(
				formatters.statements,
			))
			const expression = (exports.expression = (0, _builder.default)(
				formatters.expression,
			))
			const program = (exports.program = (0, _builder.default)(
				formatters.program,
			))
			var _default = (exports['default'] = Object.assign(
				smart.bind(undefined),
				{
					smart,
					statement,
					statements,
					expression,
					program,
					ast: smart.ast,
				},
			))

			//# sourceMappingURL=index.js.map

			/***/
		},

		/***/ 98083: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = literalTemplate
			var _options = __nccwpck_require__(97886)
			var _parse = __nccwpck_require__(73539)
			var _populate = __nccwpck_require__(18624)
			function literalTemplate(formatter, tpl, opts) {
				const { metadata, names } = buildLiteralData(formatter, tpl, opts)
				return (arg) => {
					const defaultReplacements = {}
					arg.forEach((replacement, i) => {
						defaultReplacements[names[i]] = replacement
					})
					return (arg) => {
						const replacements = (0, _options.normalizeReplacements)(arg)
						if (replacements) {
							Object.keys(replacements).forEach((key) => {
								if (hasOwnProperty.call(defaultReplacements, key)) {
									throw new Error('Unexpected replacement overlap.')
								}
							})
						}
						return formatter.unwrap(
							(0, _populate.default)(
								metadata,
								replacements
									? Object.assign(replacements, defaultReplacements)
									: defaultReplacements,
							),
						)
					}
				}
			}
			function buildLiteralData(formatter, tpl, opts) {
				let prefix = 'BABEL_TPL$'
				const raw = tpl.join('')
				do {
					prefix = '$$' + prefix
				} while (raw.includes(prefix))
				const { names, code } = buildTemplateCode(tpl, prefix)
				const metadata = (0, _parse.default)(formatter, formatter.code(code), {
					parser: opts.parser,
					placeholderWhitelist: new Set(
						names.concat(
							opts.placeholderWhitelist
								? Array.from(opts.placeholderWhitelist)
								: [],
						),
					),
					placeholderPattern: opts.placeholderPattern,
					preserveComments: opts.preserveComments,
					syntacticPlaceholders: opts.syntacticPlaceholders,
				})
				return {
					metadata,
					names,
				}
			}
			function buildTemplateCode(tpl, prefix) {
				const names = []
				let code = tpl[0]
				for (let i = 1; i < tpl.length; i++) {
					const value = `${prefix}${i - 1}`
					names.push(value)
					code += value + tpl[i]
				}
				return {
					names,
					code,
				}
			}

			//# sourceMappingURL=literal.js.map

			/***/
		},

		/***/ 97886: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.merge = merge
			exports.normalizeReplacements = normalizeReplacements
			exports.validate = validate
			const _excluded = [
				'placeholderWhitelist',
				'placeholderPattern',
				'preserveComments',
				'syntacticPlaceholders',
			]
			function _objectWithoutPropertiesLoose(r, e) {
				if (null == r) return {}
				var t = {}
				for (var n in r)
					if ({}.hasOwnProperty.call(r, n)) {
						if (-1 !== e.indexOf(n)) continue
						t[n] = r[n]
					}
				return t
			}
			function merge(a, b) {
				const {
					placeholderWhitelist = a.placeholderWhitelist,
					placeholderPattern = a.placeholderPattern,
					preserveComments = a.preserveComments,
					syntacticPlaceholders = a.syntacticPlaceholders,
				} = b
				return {
					parser: Object.assign({}, a.parser, b.parser),
					placeholderWhitelist,
					placeholderPattern,
					preserveComments,
					syntacticPlaceholders,
				}
			}
			function validate(opts) {
				if (opts != null && typeof opts !== 'object') {
					throw new Error('Unknown template options.')
				}
				const _ref = opts || {},
					{
						placeholderWhitelist,
						placeholderPattern,
						preserveComments,
						syntacticPlaceholders,
					} = _ref,
					parser = _objectWithoutPropertiesLoose(_ref, _excluded)
				if (
					placeholderWhitelist != null &&
					!(placeholderWhitelist instanceof Set)
				) {
					throw new Error(
						"'.placeholderWhitelist' must be a Set, null, or undefined",
					)
				}
				if (
					placeholderPattern != null &&
					!(placeholderPattern instanceof RegExp) &&
					placeholderPattern !== false
				) {
					throw new Error(
						"'.placeholderPattern' must be a RegExp, false, null, or undefined",
					)
				}
				if (preserveComments != null && typeof preserveComments !== 'boolean') {
					throw new Error(
						"'.preserveComments' must be a boolean, null, or undefined",
					)
				}
				if (
					syntacticPlaceholders != null &&
					typeof syntacticPlaceholders !== 'boolean'
				) {
					throw new Error(
						"'.syntacticPlaceholders' must be a boolean, null, or undefined",
					)
				}
				if (
					syntacticPlaceholders === true &&
					(placeholderWhitelist != null || placeholderPattern != null)
				) {
					throw new Error(
						"'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" +
							" with '.syntacticPlaceholders: true'",
					)
				}
				return {
					parser,
					placeholderWhitelist: placeholderWhitelist || undefined,
					placeholderPattern:
						placeholderPattern == null ? undefined : placeholderPattern,
					preserveComments:
						preserveComments == null ? undefined : preserveComments,
					syntacticPlaceholders:
						syntacticPlaceholders == null ? undefined : syntacticPlaceholders,
				}
			}
			function normalizeReplacements(replacements) {
				if (Array.isArray(replacements)) {
					return replacements.reduce((acc, replacement, i) => {
						acc['$' + i] = replacement
						return acc
					}, {})
				} else if (typeof replacements === 'object' || replacements == null) {
					return replacements || undefined
				}
				throw new Error(
					'Template replacements must be an array, object, null, or undefined',
				)
			}

			//# sourceMappingURL=options.js.map

			/***/
		},

		/***/ 73539: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = parseAndBuildMetadata
			var _t = __nccwpck_require__(16535)
			var _parser = __nccwpck_require__(5429)
			var _codeFrame = __nccwpck_require__(90147)
			const {
				isCallExpression,
				isExpressionStatement,
				isFunction,
				isIdentifier,
				isJSXIdentifier,
				isNewExpression,
				isPlaceholder,
				isStatement,
				isStringLiteral,
				removePropertiesDeep,
				traverse,
			} = _t
			const PATTERN = /^[_$A-Z0-9]+$/
			function parseAndBuildMetadata(formatter, code, opts) {
				const {
					placeholderWhitelist,
					placeholderPattern,
					preserveComments,
					syntacticPlaceholders,
				} = opts
				const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders)
				removePropertiesDeep(ast, {
					preserveComments,
				})
				formatter.validate(ast)
				const state = {
					syntactic: {
						placeholders: [],
						placeholderNames: new Set(),
					},
					legacy: {
						placeholders: [],
						placeholderNames: new Set(),
					},
					placeholderWhitelist,
					placeholderPattern,
					syntacticPlaceholders,
				}
				traverse(ast, placeholderVisitorHandler, state)
				return Object.assign(
					{
						ast,
					},
					state.syntactic.placeholders.length ? state.syntactic : state.legacy,
				)
			}
			function placeholderVisitorHandler(node, ancestors, state) {
				var _state$placeholderWhi
				let name
				let hasSyntacticPlaceholders = state.syntactic.placeholders.length > 0
				if (isPlaceholder(node)) {
					if (state.syntacticPlaceholders === false) {
						throw new Error(
							"%%foo%%-style placeholders can't be used when " +
								"'.syntacticPlaceholders' is false.",
						)
					}
					name = node.name.name
					hasSyntacticPlaceholders = true
				} else if (hasSyntacticPlaceholders || state.syntacticPlaceholders) {
					return
				} else if (isIdentifier(node) || isJSXIdentifier(node)) {
					name = node.name
				} else if (isStringLiteral(node)) {
					name = node.value
				} else {
					return
				}
				if (
					hasSyntacticPlaceholders &&
					(state.placeholderPattern != null ||
						state.placeholderWhitelist != null)
				) {
					throw new Error(
						"'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" +
							" with '.syntacticPlaceholders: true'",
					)
				}
				if (
					!hasSyntacticPlaceholders &&
					(state.placeholderPattern === false ||
						!(state.placeholderPattern || PATTERN).test(name)) &&
					!(
						(_state$placeholderWhi = state.placeholderWhitelist) != null &&
						_state$placeholderWhi.has(name)
					)
				) {
					return
				}
				ancestors = ancestors.slice()
				const { node: parent, key } = ancestors[ancestors.length - 1]
				let type
				if (
					isStringLiteral(node) ||
					isPlaceholder(node, {
						expectedNode: 'StringLiteral',
					})
				) {
					type = 'string'
				} else if (
					(isNewExpression(parent) && key === 'arguments') ||
					(isCallExpression(parent) && key === 'arguments') ||
					(isFunction(parent) && key === 'params')
				) {
					type = 'param'
				} else if (isExpressionStatement(parent) && !isPlaceholder(node)) {
					type = 'statement'
					ancestors = ancestors.slice(0, -1)
				} else if (isStatement(node) && isPlaceholder(node)) {
					type = 'statement'
				} else {
					type = 'other'
				}
				const { placeholders, placeholderNames } = !hasSyntacticPlaceholders
					? state.legacy
					: state.syntactic
				placeholders.push({
					name,
					type,
					resolve: (ast) => resolveAncestors(ast, ancestors),
					isDuplicate: placeholderNames.has(name),
				})
				placeholderNames.add(name)
			}
			function resolveAncestors(ast, ancestors) {
				let parent = ast
				for (let i = 0; i < ancestors.length - 1; i++) {
					const { key, index } = ancestors[i]
					if (index === undefined) {
						parent = parent[key]
					} else {
						parent = parent[key][index]
					}
				}
				const { key, index } = ancestors[ancestors.length - 1]
				return {
					parent,
					key,
					index,
				}
			}
			function parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {
				const plugins = (parserOpts.plugins || []).slice()
				if (syntacticPlaceholders !== false) {
					plugins.push('placeholders')
				}
				parserOpts = Object.assign(
					{
						allowAwaitOutsideFunction: true,
						allowReturnOutsideFunction: true,
						allowNewTargetOutsideFunction: true,
						allowSuperOutsideMethod: true,
						allowYieldOutsideFunction: true,
						sourceType: 'module',
					},
					parserOpts,
					{
						plugins,
					},
				)
				try {
					return (0, _parser.parse)(code, parserOpts)
				} catch (err) {
					const loc = err.loc
					if (loc) {
						err.message +=
							'\n' +
							(0, _codeFrame.codeFrameColumns)(code, {
								start: loc,
							})
						err.code = 'BABEL_TEMPLATE_PARSE_ERROR'
					}
					throw err
				}
			}

			//# sourceMappingURL=parse.js.map

			/***/
		},

		/***/ 18624: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = populatePlaceholders
			var _t = __nccwpck_require__(16535)
			const {
				blockStatement,
				cloneNode,
				emptyStatement,
				expressionStatement,
				identifier,
				isStatement,
				isStringLiteral,
				stringLiteral,
				validate,
			} = _t
			function populatePlaceholders(metadata, replacements) {
				const ast = cloneNode(metadata.ast)
				if (replacements) {
					metadata.placeholders.forEach((placeholder) => {
						if (!hasOwnProperty.call(replacements, placeholder.name)) {
							const placeholderName = placeholder.name
							throw new Error(`Error: No substitution given for "${placeholderName}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}
            - { placeholderPattern: /^${placeholderName}$/ }`)
						}
					})
					Object.keys(replacements).forEach((key) => {
						if (!metadata.placeholderNames.has(key)) {
							throw new Error(`Unknown substitution "${key}" given`)
						}
					})
				}
				metadata.placeholders
					.slice()
					.reverse()
					.forEach((placeholder) => {
						try {
							var _ref
							applyReplacement(
								placeholder,
								ast,
								(_ref = replacements && replacements[placeholder.name]) != null
									? _ref
									: null,
							)
						} catch (e) {
							e.message = `@babel/template placeholder "${placeholder.name}": ${e.message}`
							throw e
						}
					})
				return ast
			}
			function applyReplacement(placeholder, ast, replacement) {
				if (placeholder.isDuplicate) {
					if (Array.isArray(replacement)) {
						replacement = replacement.map((node) => cloneNode(node))
					} else if (typeof replacement === 'object') {
						replacement = cloneNode(replacement)
					}
				}
				const { parent, key, index } = placeholder.resolve(ast)
				if (placeholder.type === 'string') {
					if (typeof replacement === 'string') {
						replacement = stringLiteral(replacement)
					}
					if (!replacement || !isStringLiteral(replacement)) {
						throw new Error('Expected string substitution')
					}
				} else if (placeholder.type === 'statement') {
					if (index === undefined) {
						if (!replacement) {
							replacement = emptyStatement()
						} else if (Array.isArray(replacement)) {
							replacement = blockStatement(replacement)
						} else if (typeof replacement === 'string') {
							replacement = expressionStatement(identifier(replacement))
						} else if (!isStatement(replacement)) {
							replacement = expressionStatement(replacement)
						}
					} else {
						if (replacement && !Array.isArray(replacement)) {
							if (typeof replacement === 'string') {
								replacement = identifier(replacement)
							}
							if (!isStatement(replacement)) {
								replacement = expressionStatement(replacement)
							}
						}
					}
				} else if (placeholder.type === 'param') {
					if (typeof replacement === 'string') {
						replacement = identifier(replacement)
					}
					if (index === undefined) throw new Error('Assertion failure.')
				} else {
					if (typeof replacement === 'string') {
						replacement = identifier(replacement)
					}
					if (Array.isArray(replacement)) {
						throw new Error('Cannot replace single expression with an array.')
					}
				}
				function set(parent, key, value) {
					const node = parent[key]
					parent[key] = value
					if (node.type === 'Identifier' || node.type === 'Placeholder') {
						if (node.typeAnnotation) {
							value.typeAnnotation = node.typeAnnotation
						}
						if (node.optional) {
							value.optional = node.optional
						}
						if (node.decorators) {
							value.decorators = node.decorators
						}
					}
				}
				if (index === undefined) {
					validate(parent, key, replacement)
					set(parent, key, replacement)
				} else {
					const items = parent[key].slice()
					if (
						placeholder.type === 'statement' ||
						placeholder.type === 'param'
					) {
						if (replacement == null) {
							items.splice(index, 1)
						} else if (Array.isArray(replacement)) {
							items.splice(index, 1, ...replacement)
						} else {
							set(items, index, replacement)
						}
					} else {
						set(items, index, replacement)
					}
					validate(parent, key, items)
					parent[key] = items
				}
			}

			//# sourceMappingURL=populate.js.map

			/***/
		},

		/***/ 1231: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = stringTemplate
			var _options = __nccwpck_require__(97886)
			var _parse = __nccwpck_require__(73539)
			var _populate = __nccwpck_require__(18624)
			function stringTemplate(formatter, code, opts) {
				code = formatter.code(code)
				let metadata
				return (arg) => {
					const replacements = (0, _options.normalizeReplacements)(arg)
					if (!metadata) metadata = (0, _parse.default)(formatter, code, opts)
					return formatter.unwrap(
						(0, _populate.default)(metadata, replacements),
					)
				}
			}

			//# sourceMappingURL=string.js.map

			/***/
		},

		/***/ 6730: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.clear = clear
			exports.clearPath = clearPath
			exports.clearScope = clearScope
			exports.getCachedPaths = getCachedPaths
			exports.getOrCreateCachedPaths = getOrCreateCachedPaths
			exports.scope = exports.path = void 0
			let pathsCache = (exports.path = new WeakMap())
			let scope = (exports.scope = new WeakMap())
			function clear() {
				clearPath()
				clearScope()
			}
			function clearPath() {
				exports.path = pathsCache = new WeakMap()
			}
			function clearScope() {
				exports.scope = scope = new WeakMap()
			}
			function getCachedPaths(path) {
				const { parent, parentPath } = path
				return pathsCache.get(parent)
			}
			function getOrCreateCachedPaths(node, parentPath) {
				let paths = pathsCache.get(node)
				if (!paths) pathsCache.set(node, (paths = new Map()))
				return paths
			}

			//# sourceMappingURL=cache.js.map

			/***/
		},

		/***/ 49767: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = void 0
			var _index = __nccwpck_require__(91806)
			var _t = __nccwpck_require__(16535)
			var _context = __nccwpck_require__(74105)
			const { VISITOR_KEYS } = _t
			class TraversalContext {
				constructor(scope, opts, state, parentPath) {
					this.queue = null
					this.priorityQueue = null
					this.parentPath = parentPath
					this.scope = scope
					this.state = state
					this.opts = opts
				}
				shouldVisit(node) {
					const opts = this.opts
					if (opts.enter || opts.exit) return true
					if (opts[node.type]) return true
					const keys = VISITOR_KEYS[node.type]
					if (!(keys != null && keys.length)) return false
					for (const key of keys) {
						if (node[key]) {
							return true
						}
					}
					return false
				}
				create(node, container, key, listKey) {
					return _index.default.get({
						parentPath: this.parentPath,
						parent: node,
						container,
						key: key,
						listKey,
					})
				}
				maybeQueue(path, notPriority) {
					if (this.queue) {
						if (notPriority) {
							this.queue.push(path)
						} else {
							this.priorityQueue.push(path)
						}
					}
				}
				visitMultiple(container, parent, listKey) {
					if (container.length === 0) return false
					const queue = []
					for (let key = 0; key < container.length; key++) {
						const node = container[key]
						if (node && this.shouldVisit(node)) {
							queue.push(this.create(parent, container, key, listKey))
						}
					}
					return this.visitQueue(queue)
				}
				visitSingle(node, key) {
					if (this.shouldVisit(node[key])) {
						return this.visitQueue([this.create(node, node, key)])
					} else {
						return false
					}
				}
				visitQueue(queue) {
					this.queue = queue
					this.priorityQueue = []
					const visited = new WeakSet()
					let stop = false
					let visitIndex = 0
					for (; visitIndex < queue.length; ) {
						const path = queue[visitIndex]
						visitIndex++
						_context.resync.call(path)
						if (
							path.contexts.length === 0 ||
							path.contexts[path.contexts.length - 1] !== this
						) {
							_context.pushContext.call(path, this)
						}
						if (path.key === null) continue
						const { node } = path
						if (visited.has(node)) continue
						if (node) visited.add(node)
						if (path.visit()) {
							stop = true
							break
						}
						if (this.priorityQueue.length) {
							stop = this.visitQueue(this.priorityQueue)
							this.priorityQueue = []
							this.queue = queue
							if (stop) break
						}
					}
					for (let i = 0; i < visitIndex; i++) {
						_context.popContext.call(queue[i])
					}
					this.queue = null
					return stop
				}
				visit(node, key) {
					const nodes = node[key]
					if (!nodes) return false
					if (Array.isArray(nodes)) {
						return this.visitMultiple(nodes, node, key)
					} else {
						return this.visitSingle(node, key)
					}
				}
			}
			exports['default'] = TraversalContext

			//# sourceMappingURL=context.js.map

			/***/
		},

		/***/ 18327: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = void 0
			class Hub {
				getCode() {}
				getScope() {}
				addHelper() {
					throw new Error('Helpers are not supported by the default hub.')
				}
				buildError(node, msg, Error = TypeError) {
					return new Error(msg)
				}
			}
			exports['default'] = Hub

			//# sourceMappingURL=hub.js.map

			/***/
		},

		/***/ 50148: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			Object.defineProperty(exports, 'Hub', {
				enumerable: true,
				get: function () {
					return _hub.default
				},
			})
			Object.defineProperty(exports, 'NodePath', {
				enumerable: true,
				get: function () {
					return _index.default
				},
			})
			Object.defineProperty(exports, 'Scope', {
				enumerable: true,
				get: function () {
					return _index2.default
				},
			})
			exports.visitors = exports['default'] = void 0
			__nccwpck_require__(74105)
			var visitors = __nccwpck_require__(38133)
			exports.visitors = visitors
			var _t = __nccwpck_require__(16535)
			var cache = __nccwpck_require__(6730)
			var _traverseNode = __nccwpck_require__(95469)
			var _index = __nccwpck_require__(91806)
			var _index2 = __nccwpck_require__(18171)
			var _hub = __nccwpck_require__(18327)
			const { VISITOR_KEYS, removeProperties, traverseFast } = _t
			function traverse(
				parent,
				opts = {},
				scope,
				state,
				parentPath,
				visitSelf,
			) {
				if (!parent) return
				if (!opts.noScope && !scope) {
					if (parent.type !== 'Program' && parent.type !== 'File') {
						throw new Error(
							'You must pass a scope and parentPath unless traversing a Program/File. ' +
								`Instead of that you tried to traverse a ${parent.type} node without ` +
								'passing scope and parentPath.',
						)
					}
				}
				if (!parentPath && visitSelf) {
					throw new Error(
						'visitSelf can only be used when providing a NodePath.',
					)
				}
				if (!VISITOR_KEYS[parent.type]) {
					return
				}
				visitors.explode(opts)
				;(0, _traverseNode.traverseNode)(
					parent,
					opts,
					scope,
					state,
					parentPath,
					null,
					visitSelf,
				)
			}
			var _default = (exports['default'] = traverse)
			traverse.visitors = visitors
			traverse.verify = visitors.verify
			traverse.explode = visitors.explode
			traverse.cheap = function (node, enter) {
				traverseFast(node, enter)
				return
			}
			traverse.node = function (node, opts, scope, state, path, skipKeys) {
				;(0, _traverseNode.traverseNode)(
					node,
					opts,
					scope,
					state,
					path,
					skipKeys,
				)
			}
			traverse.clearNode = function (node, opts) {
				removeProperties(node, opts)
			}
			traverse.removeProperties = function (tree, opts) {
				traverseFast(tree, traverse.clearNode, opts)
				return tree
			}
			traverse.hasType = function (tree, type, denylistTypes) {
				if (denylistTypes != null && denylistTypes.includes(tree.type))
					return false
				if (tree.type === type) return true
				return traverseFast(tree, function (node) {
					if (denylistTypes != null && denylistTypes.includes(node.type)) {
						return traverseFast.skip
					}
					if (node.type === type) {
						return traverseFast.stop
					}
				})
			}
			traverse.cache = cache

			//# sourceMappingURL=index.js.map

			/***/
		},

		/***/ 63405: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.find = find
			exports.findParent = findParent
			exports.getAncestry = getAncestry
			exports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom
			exports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom
			exports.getFunctionParent = getFunctionParent
			exports.getStatementParent = getStatementParent
			exports.inType = inType
			exports.isAncestor = isAncestor
			exports.isDescendant = isDescendant
			var _t = __nccwpck_require__(16535)
			const { VISITOR_KEYS } = _t
			function findParent(callback) {
				let path = this
				while ((path = path.parentPath)) {
					if (callback(path)) return path
				}
				return null
			}
			function find(callback) {
				let path = this
				do {
					if (callback(path)) return path
				} while ((path = path.parentPath))
				return null
			}
			function getFunctionParent() {
				return this.findParent((p) => p.isFunction())
			}
			function getStatementParent() {
				let path = this
				do {
					if (
						!path.parentPath ||
						(Array.isArray(path.container) && path.isStatement())
					) {
						break
					} else {
						path = path.parentPath
					}
				} while (path)
				if (path && (path.isProgram() || path.isFile())) {
					throw new Error(
						"File/Program node, we can't possibly find a statement parent to this",
					)
				}
				return path
			}
			function getEarliestCommonAncestorFrom(paths) {
				return this.getDeepestCommonAncestorFrom(
					paths,
					function (deepest, i, ancestries) {
						let earliest
						const keys = VISITOR_KEYS[deepest.type]
						for (const ancestry of ancestries) {
							const path = ancestry[i + 1]
							if (!earliest) {
								earliest = path
								continue
							}
							if (path.listKey && earliest.listKey === path.listKey) {
								if (path.key < earliest.key) {
									earliest = path
									continue
								}
							}
							const earliestKeyIndex = keys.indexOf(earliest.parentKey)
							const currentKeyIndex = keys.indexOf(path.parentKey)
							if (earliestKeyIndex > currentKeyIndex) {
								earliest = path
							}
						}
						return earliest
					},
				)
			}
			function getDeepestCommonAncestorFrom(paths, filter) {
				if (!paths.length) {
					return this
				}
				if (paths.length === 1) {
					return paths[0]
				}
				let minDepth = Infinity
				let lastCommonIndex, lastCommon
				const ancestries = paths.map((path) => {
					const ancestry = []
					do {
						ancestry.unshift(path)
					} while ((path = path.parentPath) && path !== this)
					if (ancestry.length < minDepth) {
						minDepth = ancestry.length
					}
					return ancestry
				})
				const first = ancestries[0]
				depthLoop: for (let i = 0; i < minDepth; i++) {
					const shouldMatch = first[i]
					for (const ancestry of ancestries) {
						if (ancestry[i] !== shouldMatch) {
							break depthLoop
						}
					}
					lastCommonIndex = i
					lastCommon = shouldMatch
				}
				if (lastCommon) {
					if (filter) {
						return filter(lastCommon, lastCommonIndex, ancestries)
					} else {
						return lastCommon
					}
				} else {
					throw new Error("Couldn't find intersection")
				}
			}
			function getAncestry() {
				let path = this
				const paths = []
				do {
					paths.push(path)
				} while ((path = path.parentPath))
				return paths
			}
			function isAncestor(maybeDescendant) {
				return maybeDescendant.isDescendant(this)
			}
			function isDescendant(maybeAncestor) {
				return !!this.findParent((parent) => parent === maybeAncestor)
			}
			function inType(...candidateTypes) {
				let path = this
				while (path) {
					if (candidateTypes.includes(path.node.type)) return true
					path = path.parentPath
				}
				return false
			}

			//# sourceMappingURL=ancestry.js.map

			/***/
		},

		/***/ 17794: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.addComment = addComment
			exports.addComments = addComments
			exports.shareCommentsWithSiblings = shareCommentsWithSiblings
			var _t = __nccwpck_require__(16535)
			const { addComment: _addComment, addComments: _addComments } = _t
			function shareCommentsWithSiblings() {
				if (typeof this.key === 'string') return
				const node = this.node
				if (!node) return
				const trailing = node.trailingComments
				const leading = node.leadingComments
				if (!trailing && !leading) return
				const prev = this.getSibling(this.key - 1)
				const next = this.getSibling(this.key + 1)
				const hasPrev = Boolean(prev.node)
				const hasNext = Boolean(next.node)
				if (hasPrev) {
					if (leading) {
						prev.addComments(
							'trailing',
							removeIfExisting(leading, prev.node.trailingComments),
						)
					}
					if (trailing && !hasNext) prev.addComments('trailing', trailing)
				}
				if (hasNext) {
					if (trailing) {
						next.addComments(
							'leading',
							removeIfExisting(trailing, next.node.leadingComments),
						)
					}
					if (leading && !hasPrev) next.addComments('leading', leading)
				}
			}
			function removeIfExisting(list, toRemove) {
				if (!(toRemove != null && toRemove.length)) return list
				const set = new Set(toRemove)
				return list.filter((el) => {
					return !set.has(el)
				})
			}
			function addComment(type, content, line) {
				_addComment(this.node, type, content, line)
			}
			function addComments(type, comments) {
				_addComments(this.node, type, comments)
			}

			//# sourceMappingURL=comments.js.map

			/***/
		},

		/***/ 74105: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports._call = _call
			exports._getQueueContexts = _getQueueContexts
			exports._resyncKey = _resyncKey
			exports._resyncList = _resyncList
			exports._resyncParent = _resyncParent
			exports._resyncRemoved = _resyncRemoved
			exports.call = call
			exports.isDenylisted = isDenylisted
			exports.popContext = popContext
			exports.pushContext = pushContext
			exports.requeue = requeue
			exports.requeueComputedKeyAndDecorators = requeueComputedKeyAndDecorators
			exports.resync = resync
			exports.setContext = setContext
			exports.setKey = setKey
			exports.setScope = setScope
			exports.setup = setup
			exports.skip = skip
			exports.skipKey = skipKey
			exports.stop = stop
			exports.visit = visit
			var _traverseNode = __nccwpck_require__(95469)
			var _index = __nccwpck_require__(91806)
			var _removal = __nccwpck_require__(23562)
			var t = __nccwpck_require__(16535)
			function call(key) {
				const opts = this.opts
				this.debug(key)
				if (this.node) {
					if (_call.call(this, opts[key])) return true
				}
				if (this.node) {
					var _opts$this$node$type
					return _call.call(
						this,
						(_opts$this$node$type = opts[this.node.type]) == null
							? void 0
							: _opts$this$node$type[key],
					)
				}
				return false
			}
			function _call(fns) {
				if (!fns) return false
				for (const fn of fns) {
					if (!fn) continue
					const node = this.node
					if (!node) return true
					const ret = fn.call(this.state, this, this.state)
					if (
						ret &&
						typeof ret === 'object' &&
						typeof ret.then === 'function'
					) {
						throw new Error(
							`You appear to be using a plugin with an async traversal visitor, ` +
								`which your current version of Babel does not support. ` +
								`If you're using a published plugin, you may need to upgrade ` +
								`your @babel/core version.`,
						)
					}
					if (ret) {
						throw new Error(`Unexpected return value from visitor method ${fn}`)
					}
					if (this.node !== node) return true
					if (this._traverseFlags > 0) return true
				}
				return false
			}
			function isDenylisted() {
				var _this$opts$denylist
				const denylist =
					(_this$opts$denylist = this.opts.denylist) != null
						? _this$opts$denylist
						: this.opts.blacklist
				return denylist == null ? void 0 : denylist.includes(this.node.type)
			}
			{
				exports.isBlacklisted = isDenylisted
			}
			function restoreContext(path, context) {
				if (path.context !== context) {
					path.context = context
					path.state = context.state
					path.opts = context.opts
				}
			}
			function visit() {
				var _this$opts$shouldSkip, _this$opts
				if (!this.node) {
					return false
				}
				if (this.isDenylisted()) {
					return false
				}
				if (
					(_this$opts$shouldSkip = (_this$opts = this.opts).shouldSkip) !=
						null &&
					_this$opts$shouldSkip.call(_this$opts, this)
				) {
					return false
				}
				const currentContext = this.context
				if (this.shouldSkip || call.call(this, 'enter')) {
					this.debug('Skip...')
					return this.shouldStop
				}
				restoreContext(this, currentContext)
				this.debug('Recursing into...')
				this.shouldStop = (0, _traverseNode.traverseNode)(
					this.node,
					this.opts,
					this.scope,
					this.state,
					this,
					this.skipKeys,
				)
				restoreContext(this, currentContext)
				call.call(this, 'exit')
				return this.shouldStop
			}
			function skip() {
				this.shouldSkip = true
			}
			function skipKey(key) {
				if (this.skipKeys == null) {
					this.skipKeys = {}
				}
				this.skipKeys[key] = true
			}
			function stop() {
				this._traverseFlags |= _index.SHOULD_SKIP | _index.SHOULD_STOP
			}
			function setScope() {
				var _this$opts2, _this$scope
				if ((_this$opts2 = this.opts) != null && _this$opts2.noScope) return
				let path = this.parentPath
				if (
					((this.key === 'key' || this.listKey === 'decorators') &&
						path.isMethod()) ||
					(this.key === 'discriminant' && path.isSwitchStatement())
				) {
					path = path.parentPath
				}
				let target
				while (path && !target) {
					var _path$opts
					if ((_path$opts = path.opts) != null && _path$opts.noScope) return
					target = path.scope
					path = path.parentPath
				}
				this.scope = this.getScope(target)
				;(_this$scope = this.scope) == null || _this$scope.init()
			}
			function setContext(context) {
				if (this.skipKeys != null) {
					this.skipKeys = {}
				}
				this._traverseFlags = 0
				if (context) {
					this.context = context
					this.state = context.state
					this.opts = context.opts
				}
				setScope.call(this)
				return this
			}
			function resync() {
				if (this.removed) return
				_resyncParent.call(this)
				_resyncList.call(this)
				_resyncKey.call(this)
			}
			function _resyncParent() {
				if (this.parentPath) {
					this.parent = this.parentPath.node
				}
			}
			function _resyncKey() {
				if (!this.container) return
				if (this.node === this.container[this.key]) {
					return
				}
				if (Array.isArray(this.container)) {
					for (let i = 0; i < this.container.length; i++) {
						if (this.container[i] === this.node) {
							setKey.call(this, i)
							return
						}
					}
				} else {
					for (const key of Object.keys(this.container)) {
						if (this.container[key] === this.node) {
							setKey.call(this, key)
							return
						}
					}
				}
				this.key = null
			}
			function _resyncList() {
				if (!this.parent || !this.inList) return
				const newContainer = this.parent[this.listKey]
				if (this.container === newContainer) return
				this.container = newContainer || null
			}
			function _resyncRemoved() {
				if (
					this.key == null ||
					!this.container ||
					this.container[this.key] !== this.node
				) {
					_removal._markRemoved.call(this)
				}
			}
			function popContext() {
				this.contexts.pop()
				if (this.contexts.length > 0) {
					this.setContext(this.contexts[this.contexts.length - 1])
				} else {
					this.setContext(undefined)
				}
			}
			function pushContext(context) {
				this.contexts.push(context)
				this.setContext(context)
			}
			function setup(parentPath, container, listKey, key) {
				this.listKey = listKey
				this.container = container
				this.parentPath = parentPath || this.parentPath
				setKey.call(this, key)
			}
			function setKey(key) {
				var _this$node
				this.key = key
				this.node = this.container[this.key]
				this.type = (_this$node = this.node) == null ? void 0 : _this$node.type
			}
			function requeue(pathToQueue = this) {
				if (pathToQueue.removed) return
				const contexts = this.contexts
				for (const context of contexts) {
					context.maybeQueue(pathToQueue)
				}
			}
			function requeueComputedKeyAndDecorators() {
				const { context, node } = this
				if (!t.isPrivate(node) && node.computed) {
					context.maybeQueue(this.get('key'))
				}
				if (node.decorators) {
					for (const decorator of this.get('decorators')) {
						context.maybeQueue(decorator)
					}
				}
			}
			function _getQueueContexts() {
				let path = this
				let contexts = this.contexts
				while (!contexts.length) {
					path = path.parentPath
					if (!path) break
					contexts = path.contexts
				}
				return contexts
			}

			//# sourceMappingURL=context.js.map

			/***/
		},

		/***/ 26900: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.arrowFunctionToExpression = arrowFunctionToExpression
			exports.ensureBlock = ensureBlock
			exports.ensureFunctionName = ensureFunctionName
			exports.splitExportDeclaration = splitExportDeclaration
			exports.toComputedKey = toComputedKey
			exports.unwrapFunctionEnvironment = unwrapFunctionEnvironment
			var _t = __nccwpck_require__(16535)
			var _template = __nccwpck_require__(19648)
			var _visitors = __nccwpck_require__(38133)
			var _context = __nccwpck_require__(74105)
			const {
				arrowFunctionExpression,
				assignmentExpression,
				binaryExpression,
				blockStatement,
				callExpression,
				conditionalExpression,
				expressionStatement,
				identifier,
				isIdentifier,
				jsxIdentifier,
				logicalExpression,
				LOGICAL_OPERATORS,
				memberExpression,
				metaProperty,
				numericLiteral,
				objectExpression,
				restElement,
				returnStatement,
				sequenceExpression,
				spreadElement,
				stringLiteral,
				super: _super,
				thisExpression,
				toExpression,
				unaryExpression,
				toBindingIdentifierName,
				isFunction,
				isAssignmentPattern,
				isRestElement,
				getFunctionName,
				cloneNode,
				variableDeclaration,
				variableDeclarator,
				exportNamedDeclaration,
				exportSpecifier,
				inherits,
			} = _t
			function toComputedKey() {
				let key
				if (this.isMemberExpression()) {
					key = this.node.property
				} else if (this.isProperty() || this.isMethod()) {
					key = this.node.key
				} else {
					throw new ReferenceError('todo')
				}
				if (!this.node.computed) {
					if (isIdentifier(key)) key = stringLiteral(key.name)
				}
				return key
			}
			function ensureBlock() {
				const body = this.get('body')
				const bodyNode = body.node
				if (Array.isArray(body)) {
					throw new Error("Can't convert array path to a block statement")
				}
				if (!bodyNode) {
					throw new Error("Can't convert node without a body")
				}
				if (body.isBlockStatement()) {
					return bodyNode
				}
				const statements = []
				let stringPath = 'body'
				let key
				let listKey
				if (body.isStatement()) {
					listKey = 'body'
					key = 0
					statements.push(body.node)
				} else {
					stringPath += '.body.0'
					if (this.isFunction()) {
						key = 'argument'
						statements.push(returnStatement(body.node))
					} else {
						key = 'expression'
						statements.push(expressionStatement(body.node))
					}
				}
				this.node.body = blockStatement(statements)
				const parentPath = this.get(stringPath)
				_context.setup.call(
					body,
					parentPath,
					listKey ? parentPath.node[listKey] : parentPath.node,
					listKey,
					key,
				)
				return this.node
			}
			{
				exports.arrowFunctionToShadowed = function () {
					if (!this.isArrowFunctionExpression()) return
					this.arrowFunctionToExpression()
				}
			}
			function unwrapFunctionEnvironment() {
				if (
					!this.isArrowFunctionExpression() &&
					!this.isFunctionExpression() &&
					!this.isFunctionDeclaration()
				) {
					throw this.buildCodeFrameError(
						'Can only unwrap the environment of a function.',
					)
				}
				hoistFunctionEnvironment(this)
			}
			function setType(path, type) {
				path.node.type = type
			}
			function arrowFunctionToExpression({
				allowInsertArrow = true,
				allowInsertArrowWithRest = allowInsertArrow,
				noNewArrows = !((_arguments$) =>
					(_arguments$ = arguments[0]) == null
						? void 0
						: _arguments$.specCompliant)(),
			} = {}) {
				if (!this.isArrowFunctionExpression()) {
					throw this.buildCodeFrameError(
						'Cannot convert non-arrow function to a function expression.',
					)
				}
				let self = this
				if (!noNewArrows) {
					var _self$ensureFunctionN
					self =
						(_self$ensureFunctionN = self.ensureFunctionName(false)) != null
							? _self$ensureFunctionN
							: self
				}
				const { thisBinding, fnPath: fn } = hoistFunctionEnvironment(
					self,
					noNewArrows,
					allowInsertArrow,
					allowInsertArrowWithRest,
				)
				fn.ensureBlock()
				setType(fn, 'FunctionExpression')
				if (!noNewArrows) {
					const checkBinding = thisBinding
						? null
						: fn.scope.generateUidIdentifier('arrowCheckId')
					if (checkBinding) {
						fn.parentPath.scope.push({
							id: checkBinding,
							init: objectExpression([]),
						})
					}
					fn.get('body').unshiftContainer(
						'body',
						expressionStatement(
							callExpression(this.hub.addHelper('newArrowCheck'), [
								thisExpression(),
								checkBinding
									? identifier(checkBinding.name)
									: identifier(thisBinding),
							]),
						),
					)
					fn.replaceWith(
						callExpression(memberExpression(fn.node, identifier('bind')), [
							checkBinding ? identifier(checkBinding.name) : thisExpression(),
						]),
					)
					return fn.get('callee.object')
				}
				return fn
			}
			const getSuperCallsVisitor = (0, _visitors.environmentVisitor)({
				CallExpression(child, { allSuperCalls }) {
					if (!child.get('callee').isSuper()) return
					allSuperCalls.push(child)
				},
			})
			function hoistFunctionEnvironment(
				fnPath,
				noNewArrows = true,
				allowInsertArrow = true,
				allowInsertArrowWithRest = true,
			) {
				let arrowParent
				let thisEnvFn = fnPath.findParent((p) => {
					if (p.isArrowFunctionExpression()) {
						arrowParent != null ? arrowParent : (arrowParent = p)
						return false
					}
					return (
						p.isFunction() ||
						p.isProgram() ||
						p.isClassProperty({
							static: false,
						}) ||
						p.isClassPrivateProperty({
							static: false,
						})
					)
				})
				const inConstructor = thisEnvFn.isClassMethod({
					kind: 'constructor',
				})
				if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {
					if (arrowParent) {
						thisEnvFn = arrowParent
					} else if (allowInsertArrow) {
						fnPath.replaceWith(
							callExpression(
								arrowFunctionExpression([], toExpression(fnPath.node)),
								[],
							),
						)
						thisEnvFn = fnPath.get('callee')
						fnPath = thisEnvFn.get('body')
					} else {
						throw fnPath.buildCodeFrameError(
							'Unable to transform arrow inside class property',
						)
					}
				}
				const {
					thisPaths,
					argumentsPaths,
					newTargetPaths,
					superProps,
					superCalls,
				} = getScopeInformation(fnPath)
				if (inConstructor && superCalls.length > 0) {
					if (!allowInsertArrow) {
						throw superCalls[0].buildCodeFrameError(
							"When using '@babel/plugin-transform-arrow-functions', " +
								"it's not possible to compile `super()` in an arrow function without compiling classes.\n" +
								"Please add '@babel/plugin-transform-classes' to your Babel configuration.",
						)
					}
					if (!allowInsertArrowWithRest) {
						throw superCalls[0].buildCodeFrameError(
							"When using '@babel/plugin-transform-parameters', " +
								"it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\n" +
								"Please add '@babel/plugin-transform-classes' to your Babel configuration.",
						)
					}
					const allSuperCalls = []
					thisEnvFn.traverse(getSuperCallsVisitor, {
						allSuperCalls,
					})
					const superBinding = getSuperBinding(thisEnvFn)
					allSuperCalls.forEach((superCall) => {
						const callee = identifier(superBinding)
						callee.loc = superCall.node.callee.loc
						superCall.get('callee').replaceWith(callee)
					})
				}
				if (argumentsPaths.length > 0) {
					const argumentsBinding = getBinding(thisEnvFn, 'arguments', () => {
						const args = () => identifier('arguments')
						if (thisEnvFn.scope.path.isProgram()) {
							return conditionalExpression(
								binaryExpression(
									'===',
									unaryExpression('typeof', args()),
									stringLiteral('undefined'),
								),
								thisEnvFn.scope.buildUndefinedNode(),
								args(),
							)
						} else {
							return args()
						}
					})
					argumentsPaths.forEach((argumentsChild) => {
						const argsRef = identifier(argumentsBinding)
						argsRef.loc = argumentsChild.node.loc
						argumentsChild.replaceWith(argsRef)
					})
				}
				if (newTargetPaths.length > 0) {
					const newTargetBinding = getBinding(thisEnvFn, 'newtarget', () =>
						metaProperty(identifier('new'), identifier('target')),
					)
					newTargetPaths.forEach((targetChild) => {
						const targetRef = identifier(newTargetBinding)
						targetRef.loc = targetChild.node.loc
						targetChild.replaceWith(targetRef)
					})
				}
				if (superProps.length > 0) {
					if (!allowInsertArrow) {
						throw superProps[0].buildCodeFrameError(
							"When using '@babel/plugin-transform-arrow-functions', " +
								"it's not possible to compile `super.prop` in an arrow function without compiling classes.\n" +
								"Please add '@babel/plugin-transform-classes' to your Babel configuration.",
						)
					}
					const flatSuperProps = superProps.reduce(
						(acc, superProp) => acc.concat(standardizeSuperProperty(superProp)),
						[],
					)
					flatSuperProps.forEach((superProp) => {
						const key = superProp.node.computed
							? ''
							: superProp.get('property').node.name
						const superParentPath = superProp.parentPath
						const isAssignment = superParentPath.isAssignmentExpression({
							left: superProp.node,
						})
						const isCall = superParentPath.isCallExpression({
							callee: superProp.node,
						})
						const isTaggedTemplate = superParentPath.isTaggedTemplateExpression(
							{
								tag: superProp.node,
							},
						)
						const superBinding = getSuperPropBinding(
							thisEnvFn,
							isAssignment,
							key,
						)
						const args = []
						if (superProp.node.computed) {
							args.push(superProp.get('property').node)
						}
						if (isAssignment) {
							const value = superParentPath.node.right
							args.push(value)
						}
						const call = callExpression(identifier(superBinding), args)
						if (isCall) {
							superParentPath.unshiftContainer('arguments', thisExpression())
							superProp.replaceWith(memberExpression(call, identifier('call')))
							thisPaths.push(superParentPath.get('arguments.0'))
						} else if (isAssignment) {
							superParentPath.replaceWith(call)
						} else if (isTaggedTemplate) {
							superProp.replaceWith(
								callExpression(
									memberExpression(call, identifier('bind'), false),
									[thisExpression()],
								),
							)
							thisPaths.push(superProp.get('arguments.0'))
						} else {
							superProp.replaceWith(call)
						}
					})
				}
				let thisBinding
				if (thisPaths.length > 0 || !noNewArrows) {
					thisBinding = getThisBinding(thisEnvFn, inConstructor)
					if (noNewArrows || (inConstructor && hasSuperClass(thisEnvFn))) {
						thisPaths.forEach((thisChild) => {
							const thisRef = thisChild.isJSX()
								? jsxIdentifier(thisBinding)
								: identifier(thisBinding)
							thisRef.loc = thisChild.node.loc
							thisChild.replaceWith(thisRef)
						})
						if (!noNewArrows) thisBinding = null
					}
				}
				return {
					thisBinding,
					fnPath,
				}
			}
			function isLogicalOp(op) {
				return LOGICAL_OPERATORS.includes(op)
			}
			function standardizeSuperProperty(superProp) {
				if (
					superProp.parentPath.isAssignmentExpression() &&
					superProp.parentPath.node.operator !== '='
				) {
					const assignmentPath = superProp.parentPath
					const op = assignmentPath.node.operator.slice(0, -1)
					const value = assignmentPath.node.right
					const isLogicalAssignment = isLogicalOp(op)
					if (superProp.node.computed) {
						const tmp = superProp.scope.generateDeclaredUidIdentifier('tmp')
						const object = superProp.node.object
						const property = superProp.node.property
						assignmentPath
							.get('left')
							.replaceWith(
								memberExpression(
									object,
									assignmentExpression('=', tmp, property),
									true,
								),
							)
						assignmentPath
							.get('right')
							.replaceWith(
								rightExpression(
									isLogicalAssignment ? '=' : op,
									memberExpression(object, identifier(tmp.name), true),
									value,
								),
							)
					} else {
						const object = superProp.node.object
						const property = superProp.node.property
						assignmentPath
							.get('left')
							.replaceWith(memberExpression(object, property))
						assignmentPath
							.get('right')
							.replaceWith(
								rightExpression(
									isLogicalAssignment ? '=' : op,
									memberExpression(object, identifier(property.name)),
									value,
								),
							)
					}
					if (isLogicalAssignment) {
						assignmentPath.replaceWith(
							logicalExpression(
								op,
								assignmentPath.node.left,
								assignmentPath.node.right,
							),
						)
					} else {
						assignmentPath.node.operator = '='
					}
					return [
						assignmentPath.get('left'),
						assignmentPath.get('right').get('left'),
					]
				} else if (superProp.parentPath.isUpdateExpression()) {
					const updateExpr = superProp.parentPath
					const tmp = superProp.scope.generateDeclaredUidIdentifier('tmp')
					const computedKey = superProp.node.computed
						? superProp.scope.generateDeclaredUidIdentifier('prop')
						: null
					const parts = [
						assignmentExpression(
							'=',
							tmp,
							memberExpression(
								superProp.node.object,
								computedKey
									? assignmentExpression(
											'=',
											computedKey,
											superProp.node.property,
										)
									: superProp.node.property,
								superProp.node.computed,
							),
						),
						assignmentExpression(
							'=',
							memberExpression(
								superProp.node.object,
								computedKey
									? identifier(computedKey.name)
									: superProp.node.property,
								superProp.node.computed,
							),
							binaryExpression(
								superProp.parentPath.node.operator[0],
								identifier(tmp.name),
								numericLiteral(1),
							),
						),
					]
					if (!superProp.parentPath.node.prefix) {
						parts.push(identifier(tmp.name))
					}
					updateExpr.replaceWith(sequenceExpression(parts))
					const left = updateExpr.get('expressions.0.right')
					const right = updateExpr.get('expressions.1.left')
					return [left, right]
				}
				return [superProp]
				function rightExpression(op, left, right) {
					if (op === '=') {
						return assignmentExpression('=', left, right)
					} else {
						return binaryExpression(op, left, right)
					}
				}
			}
			function hasSuperClass(thisEnvFn) {
				return (
					thisEnvFn.isClassMethod() &&
					!!thisEnvFn.parentPath.parentPath.node.superClass
				)
			}
			const assignSuperThisVisitor = (0, _visitors.environmentVisitor)({
				CallExpression(child, { supers, thisBinding }) {
					if (!child.get('callee').isSuper()) return
					if (supers.has(child.node)) return
					supers.add(child.node)
					child.replaceWithMultiple([
						child.node,
						assignmentExpression(
							'=',
							identifier(thisBinding),
							identifier('this'),
						),
					])
				},
			})
			function getThisBinding(thisEnvFn, inConstructor) {
				return getBinding(thisEnvFn, 'this', (thisBinding) => {
					if (!inConstructor || !hasSuperClass(thisEnvFn))
						return thisExpression()
					thisEnvFn.traverse(assignSuperThisVisitor, {
						supers: new WeakSet(),
						thisBinding,
					})
				})
			}
			function getSuperBinding(thisEnvFn) {
				return getBinding(thisEnvFn, 'supercall', () => {
					const argsBinding = thisEnvFn.scope.generateUidIdentifier('args')
					return arrowFunctionExpression(
						[restElement(argsBinding)],
						callExpression(_super(), [
							spreadElement(identifier(argsBinding.name)),
						]),
					)
				})
			}
			function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
				const op = isAssignment ? 'set' : 'get'
				return getBinding(
					thisEnvFn,
					`superprop_${op}:${propName || ''}`,
					() => {
						const argsList = []
						let fnBody
						if (propName) {
							fnBody = memberExpression(_super(), identifier(propName))
						} else {
							const method = thisEnvFn.scope.generateUidIdentifier('prop')
							argsList.unshift(method)
							fnBody = memberExpression(_super(), identifier(method.name), true)
						}
						if (isAssignment) {
							const valueIdent = thisEnvFn.scope.generateUidIdentifier('value')
							argsList.push(valueIdent)
							fnBody = assignmentExpression(
								'=',
								fnBody,
								identifier(valueIdent.name),
							)
						}
						return arrowFunctionExpression(argsList, fnBody)
					},
				)
			}
			function getBinding(thisEnvFn, key, init) {
				const cacheKey = 'binding:' + key
				let data = thisEnvFn.getData(cacheKey)
				if (!data) {
					const id = thisEnvFn.scope.generateUidIdentifier(key)
					data = id.name
					thisEnvFn.setData(cacheKey, data)
					thisEnvFn.scope.push({
						id: id,
						init: init(data),
					})
				}
				return data
			}
			const getScopeInformationVisitor = (0, _visitors.environmentVisitor)({
				ThisExpression(child, { thisPaths }) {
					thisPaths.push(child)
				},
				JSXIdentifier(child, { thisPaths }) {
					if (child.node.name !== 'this') return
					if (
						!child.parentPath.isJSXMemberExpression({
							object: child.node,
						}) &&
						!child.parentPath.isJSXOpeningElement({
							name: child.node,
						})
					) {
						return
					}
					thisPaths.push(child)
				},
				CallExpression(child, { superCalls }) {
					if (child.get('callee').isSuper()) superCalls.push(child)
				},
				MemberExpression(child, { superProps }) {
					if (child.get('object').isSuper()) superProps.push(child)
				},
				Identifier(child, { argumentsPaths }) {
					if (
						!child.isReferencedIdentifier({
							name: 'arguments',
						})
					)
						return
					let curr = child.scope
					do {
						if (curr.hasOwnBinding('arguments')) {
							curr.rename('arguments')
							return
						}
						if (
							curr.path.isFunction() &&
							!curr.path.isArrowFunctionExpression()
						) {
							break
						}
					} while ((curr = curr.parent))
					argumentsPaths.push(child)
				},
				MetaProperty(child, { newTargetPaths }) {
					if (
						!child.get('meta').isIdentifier({
							name: 'new',
						})
					)
						return
					if (
						!child.get('property').isIdentifier({
							name: 'target',
						})
					)
						return
					newTargetPaths.push(child)
				},
			})
			function getScopeInformation(fnPath) {
				const thisPaths = []
				const argumentsPaths = []
				const newTargetPaths = []
				const superProps = []
				const superCalls = []
				fnPath.traverse(getScopeInformationVisitor, {
					thisPaths,
					argumentsPaths,
					newTargetPaths,
					superProps,
					superCalls,
				})
				return {
					thisPaths,
					argumentsPaths,
					newTargetPaths,
					superProps,
					superCalls,
				}
			}
			function splitExportDeclaration() {
				if (!this.isExportDeclaration() || this.isExportAllDeclaration()) {
					throw new Error(
						'Only default and named export declarations can be split.',
					)
				}
				if (
					this.isExportNamedDeclaration() &&
					this.get('specifiers').length > 0
				) {
					throw new Error("It doesn't make sense to split exported specifiers.")
				}
				const declaration = this.get('declaration')
				if (this.isExportDefaultDeclaration()) {
					const standaloneDeclaration =
						declaration.isFunctionDeclaration() ||
						declaration.isClassDeclaration()
					const exportExpr =
						declaration.isFunctionExpression() ||
						declaration.isClassExpression()
					const scope = declaration.isScope()
						? declaration.scope.parent
						: declaration.scope
					let id = declaration.node.id
					let needBindingRegistration = false
					if (!id) {
						needBindingRegistration = true
						id = scope.generateUidIdentifier('default')
						if (standaloneDeclaration || exportExpr) {
							declaration.node.id = cloneNode(id)
						}
					} else if (exportExpr && scope.hasBinding(id.name)) {
						needBindingRegistration = true
						id = scope.generateUidIdentifier(id.name)
					}
					const updatedDeclaration = standaloneDeclaration
						? declaration.node
						: variableDeclaration('var', [
								variableDeclarator(cloneNode(id), declaration.node),
							])
					const updatedExportDeclaration = exportNamedDeclaration(null, [
						exportSpecifier(cloneNode(id), identifier('default')),
					])
					this.insertAfter(updatedExportDeclaration)
					this.replaceWith(updatedDeclaration)
					if (needBindingRegistration) {
						scope.registerDeclaration(this)
					}
					return this
				} else if (this.get('specifiers').length > 0) {
					throw new Error("It doesn't make sense to split exported specifiers.")
				}
				const bindingIdentifiers = declaration.getOuterBindingIdentifiers()
				const specifiers = Object.keys(bindingIdentifiers).map((name) => {
					return exportSpecifier(identifier(name), identifier(name))
				})
				const aliasDeclar = exportNamedDeclaration(null, specifiers)
				this.insertAfter(aliasDeclar)
				this.replaceWith(declaration.node)
				return this
			}
			const refersOuterBindingVisitor = {
				'ReferencedIdentifier|BindingIdentifier'(path, state) {
					if (path.node.name !== state.name) return
					state.needsRename = true
					path.stop()
				},
				Scope(path, state) {
					if (path.scope.hasOwnBinding(state.name)) {
						path.skip()
					}
				},
			}
			function ensureFunctionName(supportUnicodeId) {
				if (this.node.id) return this
				const res = getFunctionName(this.node, this.parent)
				if (res == null) return this
				let { name } = res
				if (!supportUnicodeId && /[\uD800-\uDFFF]/.test(name)) {
					return null
				}
				if (name.startsWith('get ') || name.startsWith('set ')) {
					return null
				}
				name = toBindingIdentifierName(name.replace(/[/ ]/g, '_'))
				const id = identifier(name)
				inherits(id, res.originalNode)
				const state = {
					needsRename: false,
					name,
				}
				const { scope } = this
				const binding = scope.getOwnBinding(name)
				if (binding) {
					if (binding.kind === 'param') {
						state.needsRename = true
					} else {
					}
				} else if (scope.parent.hasBinding(name) || scope.hasGlobal(name)) {
					this.traverse(refersOuterBindingVisitor, state)
				}
				if (!state.needsRename) {
					this.node.id = id
					scope.getProgramParent().references[id.name] = true
					return this
				}
				if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {
					scope.rename(id.name)
					this.node.id = id
					scope.getProgramParent().references[id.name] = true
					return this
				}
				if (!isFunction(this.node)) return null
				const key = scope.generateUidIdentifier(id.name)
				const params = []
				for (let i = 0, len = getFunctionArity(this.node); i < len; i++) {
					params.push(scope.generateUidIdentifier('x'))
				}
				const call = _template.default.expression.ast`
    (function (${key}) {
      function ${id}(${params}) {
        return ${cloneNode(key)}.apply(this, arguments);
      }

      ${cloneNode(id)}.toString = function () {
        return ${cloneNode(key)}.toString();
      }

      return ${cloneNode(id)};
    })(${toExpression(this.node)})
  `
				return this.replaceWith(call)[0].get('arguments.0')
			}
			function getFunctionArity(node) {
				const count = node.params.findIndex(
					(param) => isAssignmentPattern(param) || isRestElement(param),
				)
				return count === -1 ? node.params.length : count
			}

			//# sourceMappingURL=conversion.js.map

			/***/
		},

		/***/ 20398: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.evaluate = evaluate
			exports.evaluateTruthy = evaluateTruthy
			const VALID_OBJECT_CALLEES = ['Number', 'String', 'Math']
			const VALID_IDENTIFIER_CALLEES = [
				'isFinite',
				'isNaN',
				'parseFloat',
				'parseInt',
				'decodeURI',
				'decodeURIComponent',
				'encodeURI',
				'encodeURIComponent',
				null,
				null,
			]
			const INVALID_METHODS = ['random']
			function isValidObjectCallee(val) {
				return VALID_OBJECT_CALLEES.includes(val)
			}
			function isValidIdentifierCallee(val) {
				return VALID_IDENTIFIER_CALLEES.includes(val)
			}
			function isInvalidMethod(val) {
				return INVALID_METHODS.includes(val)
			}
			function evaluateTruthy() {
				const res = this.evaluate()
				if (res.confident) return !!res.value
			}
			function deopt(path, state) {
				if (!state.confident) return
				state.deoptPath = path
				state.confident = false
			}
			const Globals = new Map([
				['undefined', undefined],
				['Infinity', Infinity],
				['NaN', NaN],
			])
			function evaluateCached(path, state) {
				const { node } = path
				const { seen } = state
				if (seen.has(node)) {
					const existing = seen.get(node)
					if (existing.resolved) {
						return existing.value
					} else {
						deopt(path, state)
						return
					}
				} else {
					const item = {
						resolved: false,
					}
					seen.set(node, item)
					const val = _evaluate(path, state)
					if (state.confident) {
						item.resolved = true
						item.value = val
					}
					return val
				}
			}
			function _evaluate(path, state) {
				if (!state.confident) return
				if (path.isSequenceExpression()) {
					const exprs = path.get('expressions')
					return evaluateCached(exprs[exprs.length - 1], state)
				}
				if (
					path.isStringLiteral() ||
					path.isNumericLiteral() ||
					path.isBooleanLiteral()
				) {
					return path.node.value
				}
				if (path.isNullLiteral()) {
					return null
				}
				if (path.isTemplateLiteral()) {
					return evaluateQuasis(path, path.node.quasis, state)
				}
				if (
					path.isTaggedTemplateExpression() &&
					path.get('tag').isMemberExpression()
				) {
					const object = path.get('tag.object')
					const {
						node: { name },
					} = object
					const property = path.get('tag.property')
					if (
						object.isIdentifier() &&
						name === 'String' &&
						!path.scope.getBinding(name) &&
						property.isIdentifier() &&
						property.node.name === 'raw'
					) {
						return evaluateQuasis(path, path.node.quasi.quasis, state, true)
					}
				}
				if (path.isConditionalExpression()) {
					const testResult = evaluateCached(path.get('test'), state)
					if (!state.confident) return
					if (testResult) {
						return evaluateCached(path.get('consequent'), state)
					} else {
						return evaluateCached(path.get('alternate'), state)
					}
				}
				if (path.isExpressionWrapper()) {
					return evaluateCached(path.get('expression'), state)
				}
				if (
					path.isMemberExpression() &&
					!path.parentPath.isCallExpression({
						callee: path.node,
					})
				) {
					const property = path.get('property')
					const object = path.get('object')
					if (object.isLiteral()) {
						const value = object.node.value
						const type = typeof value
						let key = null
						if (path.node.computed) {
							key = evaluateCached(property, state)
							if (!state.confident) return
						} else if (property.isIdentifier()) {
							key = property.node.name
						}
						if (
							(type === 'number' || type === 'string') &&
							key != null &&
							(typeof key === 'number' || typeof key === 'string')
						) {
							return value[key]
						}
					}
				}
				if (path.isReferencedIdentifier()) {
					const binding = path.scope.getBinding(path.node.name)
					if (binding) {
						if (
							binding.constantViolations.length > 0 ||
							path.node.start < binding.path.node.end
						) {
							deopt(binding.path, state)
							return
						}
						const bindingPathScope = binding.path.scope
						if (binding.kind === 'var' && bindingPathScope !== binding.scope) {
							let hasUnsafeBlock =
								!bindingPathScope.path.parentPath.isBlockStatement()
							for (
								let scope = bindingPathScope.parent;
								scope;
								scope = scope.parent
							) {
								var _scope$path$parentPat
								if (scope === path.scope) {
									if (hasUnsafeBlock) {
										deopt(binding.path, state)
										return
									}
									break
								}
								if (
									(_scope$path$parentPat = scope.path.parentPath) != null &&
									_scope$path$parentPat.isBlockStatement()
								) {
									hasUnsafeBlock = true
								}
							}
						}
						if (binding.hasValue) {
							return binding.value
						}
					}
					const name = path.node.name
					if (Globals.has(name)) {
						if (!binding) {
							return Globals.get(name)
						}
						deopt(binding.path, state)
						return
					}
					const resolved = path.resolve()
					if (resolved === path) {
						deopt(path, state)
						return
					}
					const value = evaluateCached(resolved, state)
					if (
						typeof value === 'object' &&
						value !== null &&
						binding.references > 1
					) {
						deopt(resolved, state)
						return
					}
					return value
				}
				if (
					path.isUnaryExpression({
						prefix: true,
					})
				) {
					if (path.node.operator === 'void') {
						return undefined
					}
					const argument = path.get('argument')
					if (
						path.node.operator === 'typeof' &&
						(argument.isFunction() || argument.isClass())
					) {
						return 'function'
					}
					const arg = evaluateCached(argument, state)
					if (!state.confident) return
					switch (path.node.operator) {
						case '!':
							return !arg
						case '+':
							return +arg
						case '-':
							return -arg
						case '~':
							return ~arg
						case 'typeof':
							return typeof arg
					}
				}
				if (path.isArrayExpression()) {
					const arr = []
					const elems = path.get('elements')
					for (const elem of elems) {
						const elemValue = elem.evaluate()
						if (elemValue.confident) {
							arr.push(elemValue.value)
						} else {
							deopt(elemValue.deopt, state)
							return
						}
					}
					return arr
				}
				if (path.isObjectExpression()) {
					const obj = {}
					const props = path.get('properties')
					for (const prop of props) {
						if (prop.isObjectMethod() || prop.isSpreadElement()) {
							deopt(prop, state)
							return
						}
						const keyPath = prop.get('key')
						let key
						if (prop.node.computed) {
							key = keyPath.evaluate()
							if (!key.confident) {
								deopt(key.deopt, state)
								return
							}
							key = key.value
						} else if (keyPath.isIdentifier()) {
							key = keyPath.node.name
						} else {
							key = keyPath.node.value
						}
						const valuePath = prop.get('value')
						let value = valuePath.evaluate()
						if (!value.confident) {
							deopt(value.deopt, state)
							return
						}
						value = value.value
						obj[key] = value
					}
					return obj
				}
				if (path.isLogicalExpression()) {
					const wasConfident = state.confident
					const left = evaluateCached(path.get('left'), state)
					const leftConfident = state.confident
					state.confident = wasConfident
					const right = evaluateCached(path.get('right'), state)
					const rightConfident = state.confident
					switch (path.node.operator) {
						case '||':
							state.confident = leftConfident && (!!left || rightConfident)
							if (!state.confident) return
							return left || right
						case '&&':
							state.confident = leftConfident && (!left || rightConfident)
							if (!state.confident) return
							return left && right
						case '??':
							state.confident =
								leftConfident && (left != null || rightConfident)
							if (!state.confident) return
							return left != null ? left : right
					}
				}
				if (path.isBinaryExpression()) {
					const left = evaluateCached(path.get('left'), state)
					if (!state.confident) return
					const right = evaluateCached(path.get('right'), state)
					if (!state.confident) return
					switch (path.node.operator) {
						case '-':
							return left - right
						case '+':
							return left + right
						case '/':
							return left / right
						case '*':
							return left * right
						case '%':
							return left % right
						case '**':
							return Math.pow(left, right)
						case '<':
							return left < right
						case '>':
							return left > right
						case '<=':
							return left <= right
						case '>=':
							return left >= right
						case '==':
							return left == right
						case '!=':
							return left != right
						case '===':
							return left === right
						case '!==':
							return left !== right
						case '|':
							return left | right
						case '&':
							return left & right
						case '^':
							return left ^ right
						case '<<':
							return left << right
						case '>>':
							return left >> right
						case '>>>':
							return left >>> right
					}
				}
				if (path.isCallExpression()) {
					const callee = path.get('callee')
					let context
					let func
					if (
						callee.isIdentifier() &&
						!path.scope.getBinding(callee.node.name) &&
						(isValidObjectCallee(callee.node.name) ||
							isValidIdentifierCallee(callee.node.name))
					) {
						func = global[callee.node.name]
					}
					if (callee.isMemberExpression()) {
						const object = callee.get('object')
						const property = callee.get('property')
						if (
							object.isIdentifier() &&
							property.isIdentifier() &&
							isValidObjectCallee(object.node.name) &&
							!isInvalidMethod(property.node.name)
						) {
							context = global[object.node.name]
							const key = property.node.name
							if (hasOwnProperty.call(context, key)) {
								func = context[key]
							}
						}
						if (object.isLiteral() && property.isIdentifier()) {
							const type = typeof object.node.value
							if (type === 'string' || type === 'number') {
								context = object.node.value
								func = context[property.node.name]
							}
						}
					}
					if (func) {
						const args = path
							.get('arguments')
							.map((arg) => evaluateCached(arg, state))
						if (!state.confident) return
						return func.apply(context, args)
					}
				}
				deopt(path, state)
			}
			function evaluateQuasis(path, quasis, state, raw = false) {
				let str = ''
				let i = 0
				const exprs = path.isTemplateLiteral()
					? path.get('expressions')
					: path.get('quasi.expressions')
				for (const elem of quasis) {
					if (!state.confident) break
					str += raw ? elem.value.raw : elem.value.cooked
					const expr = exprs[i++]
					if (expr) str += String(evaluateCached(expr, state))
				}
				if (!state.confident) return
				return str
			}
			function evaluate() {
				const state = {
					confident: true,
					deoptPath: null,
					seen: new Map(),
				}
				let value = evaluateCached(this, state)
				if (!state.confident) value = undefined
				return {
					confident: state.confident,
					deopt: state.deoptPath,
					value: value,
				}
			}

			//# sourceMappingURL=evaluation.js.map

			/***/
		},

		/***/ 47588: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports._getKey = _getKey
			exports._getPattern = _getPattern
			exports.get = get
			exports.getAllNextSiblings = getAllNextSiblings
			exports.getAllPrevSiblings = getAllPrevSiblings
			exports.getAssignmentIdentifiers = getAssignmentIdentifiers
			exports.getBindingIdentifierPaths = getBindingIdentifierPaths
			exports.getBindingIdentifiers = getBindingIdentifiers
			exports.getCompletionRecords = getCompletionRecords
			exports.getNextSibling = getNextSibling
			exports.getOpposite = getOpposite
			exports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths
			exports.getOuterBindingIdentifiers = getOuterBindingIdentifiers
			exports.getPrevSibling = getPrevSibling
			exports.getSibling = getSibling
			var _index = __nccwpck_require__(91806)
			var _t = __nccwpck_require__(16535)
			const {
				getAssignmentIdentifiers: _getAssignmentIdentifiers,
				getBindingIdentifiers: _getBindingIdentifiers,
				getOuterBindingIdentifiers: _getOuterBindingIdentifiers,
				numericLiteral,
				unaryExpression,
			} = _t
			const NORMAL_COMPLETION = 0
			const BREAK_COMPLETION = 1
			function NormalCompletion(path) {
				return {
					type: NORMAL_COMPLETION,
					path,
				}
			}
			function BreakCompletion(path) {
				return {
					type: BREAK_COMPLETION,
					path,
				}
			}
			function getOpposite() {
				if (this.key === 'left') {
					return this.getSibling('right')
				} else if (this.key === 'right') {
					return this.getSibling('left')
				}
				return null
			}
			function addCompletionRecords(path, records, context) {
				if (path) {
					records.push(..._getCompletionRecords(path, context))
				}
				return records
			}
			function completionRecordForSwitch(cases, records, context) {
				let lastNormalCompletions = []
				for (let i = 0; i < cases.length; i++) {
					const casePath = cases[i]
					const caseCompletions = _getCompletionRecords(casePath, context)
					const normalCompletions = []
					const breakCompletions = []
					for (const c of caseCompletions) {
						if (c.type === NORMAL_COMPLETION) {
							normalCompletions.push(c)
						}
						if (c.type === BREAK_COMPLETION) {
							breakCompletions.push(c)
						}
					}
					if (normalCompletions.length) {
						lastNormalCompletions = normalCompletions
					}
					records.push(...breakCompletions)
				}
				records.push(...lastNormalCompletions)
				return records
			}
			function normalCompletionToBreak(completions) {
				completions.forEach((c) => {
					c.type = BREAK_COMPLETION
				})
			}
			function replaceBreakStatementInBreakCompletion(completions, reachable) {
				completions.forEach((c) => {
					if (
						c.path.isBreakStatement({
							label: null,
						})
					) {
						if (reachable) {
							c.path.replaceWith(unaryExpression('void', numericLiteral(0)))
						} else {
							c.path.remove()
						}
					}
				})
			}
			function getStatementListCompletion(paths, context) {
				const completions = []
				if (context.canHaveBreak) {
					let lastNormalCompletions = []
					for (let i = 0; i < paths.length; i++) {
						const path = paths[i]
						const newContext = Object.assign({}, context, {
							inCaseClause: false,
						})
						if (
							path.isBlockStatement() &&
							(context.inCaseClause || context.shouldPopulateBreak)
						) {
							newContext.shouldPopulateBreak = true
						} else {
							newContext.shouldPopulateBreak = false
						}
						const statementCompletions = _getCompletionRecords(path, newContext)
						if (
							statementCompletions.length > 0 &&
							statementCompletions.every((c) => c.type === BREAK_COMPLETION)
						) {
							if (
								lastNormalCompletions.length > 0 &&
								statementCompletions.every((c) =>
									c.path.isBreakStatement({
										label: null,
									}),
								)
							) {
								normalCompletionToBreak(lastNormalCompletions)
								completions.push(...lastNormalCompletions)
								if (lastNormalCompletions.some((c) => c.path.isDeclaration())) {
									completions.push(...statementCompletions)
									if (!context.shouldPreserveBreak) {
										replaceBreakStatementInBreakCompletion(
											statementCompletions,
											true,
										)
									}
								}
								if (!context.shouldPreserveBreak) {
									replaceBreakStatementInBreakCompletion(
										statementCompletions,
										false,
									)
								}
							} else {
								completions.push(...statementCompletions)
								if (
									!context.shouldPopulateBreak &&
									!context.shouldPreserveBreak
								) {
									replaceBreakStatementInBreakCompletion(
										statementCompletions,
										true,
									)
								}
							}
							break
						}
						if (i === paths.length - 1) {
							completions.push(...statementCompletions)
						} else {
							lastNormalCompletions = []
							for (let i = 0; i < statementCompletions.length; i++) {
								const c = statementCompletions[i]
								if (c.type === BREAK_COMPLETION) {
									completions.push(c)
								}
								if (c.type === NORMAL_COMPLETION) {
									lastNormalCompletions.push(c)
								}
							}
						}
					}
				} else if (paths.length) {
					for (let i = paths.length - 1; i >= 0; i--) {
						const pathCompletions = _getCompletionRecords(paths[i], context)
						if (
							pathCompletions.length > 1 ||
							(pathCompletions.length === 1 &&
								!pathCompletions[0].path.isVariableDeclaration() &&
								!pathCompletions[0].path.isEmptyStatement())
						) {
							completions.push(...pathCompletions)
							break
						}
					}
				}
				return completions
			}
			function _getCompletionRecords(path, context) {
				let records = []
				if (path.isIfStatement()) {
					records = addCompletionRecords(
						path.get('consequent'),
						records,
						context,
					)
					records = addCompletionRecords(
						path.get('alternate'),
						records,
						context,
					)
				} else if (
					path.isDoExpression() ||
					path.isFor() ||
					path.isWhile() ||
					path.isLabeledStatement()
				) {
					return addCompletionRecords(path.get('body'), records, context)
				} else if (path.isProgram() || path.isBlockStatement()) {
					return getStatementListCompletion(path.get('body'), context)
				} else if (path.isFunction()) {
					return _getCompletionRecords(path.get('body'), context)
				} else if (path.isTryStatement()) {
					records = addCompletionRecords(path.get('block'), records, context)
					records = addCompletionRecords(path.get('handler'), records, context)
				} else if (path.isCatchClause()) {
					return addCompletionRecords(path.get('body'), records, context)
				} else if (path.isSwitchStatement()) {
					return completionRecordForSwitch(path.get('cases'), records, context)
				} else if (path.isSwitchCase()) {
					return getStatementListCompletion(path.get('consequent'), {
						canHaveBreak: true,
						shouldPopulateBreak: false,
						inCaseClause: true,
						shouldPreserveBreak: context.shouldPreserveBreak,
					})
				} else if (path.isBreakStatement()) {
					records.push(BreakCompletion(path))
				} else {
					records.push(NormalCompletion(path))
				}
				return records
			}
			function getCompletionRecords(shouldPreserveBreak = false) {
				const records = _getCompletionRecords(this, {
					canHaveBreak: false,
					shouldPopulateBreak: false,
					inCaseClause: false,
					shouldPreserveBreak,
				})
				return records.map((r) => r.path)
			}
			function getSibling(key) {
				return _index.default
					.get({
						parentPath: this.parentPath,
						parent: this.parent,
						container: this.container,
						listKey: this.listKey,
						key: key,
					})
					.setContext(this.context)
			}
			function getPrevSibling() {
				return this.getSibling(this.key - 1)
			}
			function getNextSibling() {
				return this.getSibling(this.key + 1)
			}
			function getAllNextSiblings() {
				let _key = this.key
				let sibling = this.getSibling(++_key)
				const siblings = []
				while (sibling.node) {
					siblings.push(sibling)
					sibling = this.getSibling(++_key)
				}
				return siblings
			}
			function getAllPrevSiblings() {
				let _key = this.key
				let sibling = this.getSibling(--_key)
				const siblings = []
				while (sibling.node) {
					siblings.push(sibling)
					sibling = this.getSibling(--_key)
				}
				return siblings
			}
			function get(key, context = true) {
				if (context === true) context = this.context
				const parts = key.split('.')
				if (parts.length === 1) {
					return _getKey.call(this, key, context)
				} else {
					return _getPattern.call(this, parts, context)
				}
			}
			function _getKey(key, context) {
				const node = this.node
				const container = node[key]
				if (Array.isArray(container)) {
					return container.map((_, i) => {
						return _index.default
							.get({
								listKey: key,
								parentPath: this,
								parent: node,
								container: container,
								key: i,
							})
							.setContext(context)
					})
				} else {
					return _index.default
						.get({
							parentPath: this,
							parent: node,
							container: node,
							key: key,
						})
						.setContext(context)
				}
			}
			function _getPattern(parts, context) {
				let path = this
				for (const part of parts) {
					if (part === '.') {
						path = path.parentPath
					} else {
						if (Array.isArray(path)) {
							path = path[part]
						} else {
							path = path.get(part, context)
						}
					}
				}
				return path
			}
			function getAssignmentIdentifiers() {
				return _getAssignmentIdentifiers(this.node)
			}
			function getBindingIdentifiers(duplicates) {
				return _getBindingIdentifiers(this.node, duplicates)
			}
			function getOuterBindingIdentifiers(duplicates) {
				return _getOuterBindingIdentifiers(this.node, duplicates)
			}
			function getBindingIdentifierPaths(
				duplicates = false,
				outerOnly = false,
			) {
				const path = this
				const search = [path]
				const ids = Object.create(null)
				while (search.length) {
					const id = search.shift()
					if (!id) continue
					if (!id.node) continue
					const keys = _getBindingIdentifiers.keys[id.node.type]
					if (id.isIdentifier()) {
						if (duplicates) {
							const _ids = (ids[id.node.name] = ids[id.node.name] || [])
							_ids.push(id)
						} else {
							ids[id.node.name] = id
						}
						continue
					}
					if (id.isExportDeclaration()) {
						const declaration = id.get('declaration')
						if (declaration.isDeclaration()) {
							search.push(declaration)
						}
						continue
					}
					if (outerOnly) {
						if (id.isFunctionDeclaration()) {
							search.push(id.get('id'))
							continue
						}
						if (id.isFunctionExpression()) {
							continue
						}
					}
					if (keys) {
						for (let i = 0; i < keys.length; i++) {
							const key = keys[i]
							const child = id.get(key)
							if (Array.isArray(child)) {
								search.push(...child)
							} else if (child.node) {
								search.push(child)
							}
						}
					}
				}
				return ids
			}
			function getOuterBindingIdentifierPaths(duplicates = false) {
				return this.getBindingIdentifierPaths(duplicates, true)
			}

			//# sourceMappingURL=family.js.map

			/***/
		},

		/***/ 91806: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] =
				exports.SHOULD_STOP =
				exports.SHOULD_SKIP =
				exports.REMOVED =
					void 0
			var virtualTypes = __nccwpck_require__(74425)
			var _debug = __nccwpck_require__(2830)
			var _index = __nccwpck_require__(50148)
			var _index2 = __nccwpck_require__(18171)
			var _t = __nccwpck_require__(16535)
			var t = _t
			var cache = __nccwpck_require__(6730)
			var _generator = __nccwpck_require__(12123)
			var NodePath_ancestry = __nccwpck_require__(63405)
			var NodePath_inference = __nccwpck_require__(98882)
			var NodePath_replacement = __nccwpck_require__(76178)
			var NodePath_evaluation = __nccwpck_require__(20398)
			var NodePath_conversion = __nccwpck_require__(26900)
			var NodePath_introspection = __nccwpck_require__(7009)
			var _context = __nccwpck_require__(74105)
			var NodePath_context = _context
			var NodePath_removal = __nccwpck_require__(23562)
			var NodePath_modification = __nccwpck_require__(20184)
			var NodePath_family = __nccwpck_require__(47588)
			var NodePath_comments = __nccwpck_require__(17794)
			var NodePath_virtual_types_validator = __nccwpck_require__(66582)
			const { validate } = _t
			const debug = _debug('babel')
			const REMOVED = (exports.REMOVED = 1 << 0)
			const SHOULD_STOP = (exports.SHOULD_STOP = 1 << 1)
			const SHOULD_SKIP = (exports.SHOULD_SKIP = 1 << 2)
			const NodePath_Final = (exports['default'] = class NodePath {
				constructor(hub, parent) {
					this.contexts = []
					this.state = null
					this.opts = null
					this._traverseFlags = 0
					this.skipKeys = null
					this.parentPath = null
					this.container = null
					this.listKey = null
					this.key = null
					this.node = null
					this.type = null
					this._store = null
					this.parent = parent
					this.hub = hub
					this.data = null
					this.context = null
					this.scope = null
				}
				get removed() {
					return (this._traverseFlags & 1) > 0
				}
				set removed(v) {
					if (v) this._traverseFlags |= 1
					else this._traverseFlags &= -2
				}
				get shouldStop() {
					return (this._traverseFlags & 2) > 0
				}
				set shouldStop(v) {
					if (v) this._traverseFlags |= 2
					else this._traverseFlags &= -3
				}
				get shouldSkip() {
					return (this._traverseFlags & 4) > 0
				}
				set shouldSkip(v) {
					if (v) this._traverseFlags |= 4
					else this._traverseFlags &= -5
				}
				static get({ hub, parentPath, parent, container, listKey, key }) {
					if (!hub && parentPath) {
						hub = parentPath.hub
					}
					if (!parent) {
						throw new Error('To get a node path the parent needs to exist')
					}
					const targetNode = container[key]
					const paths = cache.getOrCreateCachedPaths(parent, parentPath)
					let path = paths.get(targetNode)
					if (!path) {
						path = new NodePath(hub, parent)
						if (targetNode) paths.set(targetNode, path)
					}
					_context.setup.call(path, parentPath, container, listKey, key)
					return path
				}
				getScope(scope) {
					return this.isScope() ? new _index2.default(this) : scope
				}
				setData(key, val) {
					if (this.data == null) {
						this.data = Object.create(null)
					}
					return (this.data[key] = val)
				}
				getData(key, def) {
					if (this.data == null) {
						this.data = Object.create(null)
					}
					let val = this.data[key]
					if (val === undefined && def !== undefined) val = this.data[key] = def
					return val
				}
				hasNode() {
					return this.node != null
				}
				buildCodeFrameError(msg, Error = SyntaxError) {
					return this.hub.buildError(this.node, msg, Error)
				}
				traverse(visitor, state) {
					;(0, _index.default)(this.node, visitor, this.scope, state, this)
				}
				set(key, node) {
					validate(this.node, key, node)
					this.node[key] = node
				}
				getPathLocation() {
					const parts = []
					let path = this
					do {
						let key = path.key
						if (path.inList) key = `${path.listKey}[${key}]`
						parts.unshift(key)
					} while ((path = path.parentPath))
					return parts.join('.')
				}
				debug(message) {
					if (!debug.enabled) return
					debug(`${this.getPathLocation()} ${this.type}: ${message}`)
				}
				toString() {
					return (0, _generator.default)(this.node).code
				}
				get inList() {
					return !!this.listKey
				}
				set inList(inList) {
					if (!inList) {
						this.listKey = null
					}
				}
				get parentKey() {
					return this.listKey || this.key
				}
			})
			const methods = {
				findParent: NodePath_ancestry.findParent,
				find: NodePath_ancestry.find,
				getFunctionParent: NodePath_ancestry.getFunctionParent,
				getStatementParent: NodePath_ancestry.getStatementParent,
				getEarliestCommonAncestorFrom:
					NodePath_ancestry.getEarliestCommonAncestorFrom,
				getDeepestCommonAncestorFrom:
					NodePath_ancestry.getDeepestCommonAncestorFrom,
				getAncestry: NodePath_ancestry.getAncestry,
				isAncestor: NodePath_ancestry.isAncestor,
				isDescendant: NodePath_ancestry.isDescendant,
				inType: NodePath_ancestry.inType,
				getTypeAnnotation: NodePath_inference.getTypeAnnotation,
				isBaseType: NodePath_inference.isBaseType,
				couldBeBaseType: NodePath_inference.couldBeBaseType,
				baseTypeStrictlyMatches: NodePath_inference.baseTypeStrictlyMatches,
				isGenericType: NodePath_inference.isGenericType,
				replaceWithMultiple: NodePath_replacement.replaceWithMultiple,
				replaceWithSourceString: NodePath_replacement.replaceWithSourceString,
				replaceWith: NodePath_replacement.replaceWith,
				replaceExpressionWithStatements:
					NodePath_replacement.replaceExpressionWithStatements,
				replaceInline: NodePath_replacement.replaceInline,
				evaluateTruthy: NodePath_evaluation.evaluateTruthy,
				evaluate: NodePath_evaluation.evaluate,
				toComputedKey: NodePath_conversion.toComputedKey,
				ensureBlock: NodePath_conversion.ensureBlock,
				unwrapFunctionEnvironment:
					NodePath_conversion.unwrapFunctionEnvironment,
				arrowFunctionToExpression:
					NodePath_conversion.arrowFunctionToExpression,
				splitExportDeclaration: NodePath_conversion.splitExportDeclaration,
				ensureFunctionName: NodePath_conversion.ensureFunctionName,
				matchesPattern: NodePath_introspection.matchesPattern,
				isStatic: NodePath_introspection.isStatic,
				isNodeType: NodePath_introspection.isNodeType,
				canHaveVariableDeclarationOrExpression:
					NodePath_introspection.canHaveVariableDeclarationOrExpression,
				canSwapBetweenExpressionAndStatement:
					NodePath_introspection.canSwapBetweenExpressionAndStatement,
				isCompletionRecord: NodePath_introspection.isCompletionRecord,
				isStatementOrBlock: NodePath_introspection.isStatementOrBlock,
				referencesImport: NodePath_introspection.referencesImport,
				getSource: NodePath_introspection.getSource,
				willIMaybeExecuteBefore: NodePath_introspection.willIMaybeExecuteBefore,
				_guessExecutionStatusRelativeTo:
					NodePath_introspection._guessExecutionStatusRelativeTo,
				resolve: NodePath_introspection.resolve,
				isConstantExpression: NodePath_introspection.isConstantExpression,
				isInStrictMode: NodePath_introspection.isInStrictMode,
				isDenylisted: NodePath_context.isDenylisted,
				visit: NodePath_context.visit,
				skip: NodePath_context.skip,
				skipKey: NodePath_context.skipKey,
				stop: NodePath_context.stop,
				setContext: NodePath_context.setContext,
				requeue: NodePath_context.requeue,
				requeueComputedKeyAndDecorators:
					NodePath_context.requeueComputedKeyAndDecorators,
				remove: NodePath_removal.remove,
				insertBefore: NodePath_modification.insertBefore,
				insertAfter: NodePath_modification.insertAfter,
				unshiftContainer: NodePath_modification.unshiftContainer,
				pushContainer: NodePath_modification.pushContainer,
				getOpposite: NodePath_family.getOpposite,
				getCompletionRecords: NodePath_family.getCompletionRecords,
				getSibling: NodePath_family.getSibling,
				getPrevSibling: NodePath_family.getPrevSibling,
				getNextSibling: NodePath_family.getNextSibling,
				getAllNextSiblings: NodePath_family.getAllNextSiblings,
				getAllPrevSiblings: NodePath_family.getAllPrevSiblings,
				get: NodePath_family.get,
				getAssignmentIdentifiers: NodePath_family.getAssignmentIdentifiers,
				getBindingIdentifiers: NodePath_family.getBindingIdentifiers,
				getOuterBindingIdentifiers: NodePath_family.getOuterBindingIdentifiers,
				getBindingIdentifierPaths: NodePath_family.getBindingIdentifierPaths,
				getOuterBindingIdentifierPaths:
					NodePath_family.getOuterBindingIdentifierPaths,
				shareCommentsWithSiblings: NodePath_comments.shareCommentsWithSiblings,
				addComment: NodePath_comments.addComment,
				addComments: NodePath_comments.addComments,
			}
			Object.assign(NodePath_Final.prototype, methods)
			{
				NodePath_Final.prototype.arrowFunctionToShadowed =
					NodePath_conversion[String('arrowFunctionToShadowed')]
				Object.assign(NodePath_Final.prototype, {
					has: NodePath_introspection[String('has')],
					is: NodePath_introspection[String('is')],
					isnt: NodePath_introspection[String('isnt')],
					equals: NodePath_introspection[String('equals')],
					hoist: NodePath_modification[String('hoist')],
					updateSiblingKeys: NodePath_modification.updateSiblingKeys,
					call: NodePath_context.call,
					isBlacklisted: NodePath_context[String('isBlacklisted')],
					setScope: NodePath_context.setScope,
					resync: NodePath_context.resync,
					popContext: NodePath_context.popContext,
					pushContext: NodePath_context.pushContext,
					setup: NodePath_context.setup,
					setKey: NodePath_context.setKey,
				})
			}
			{
				NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions =
					NodePath_introspection._guessExecutionStatusRelativeTo
				NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions =
					NodePath_introspection._guessExecutionStatusRelativeTo
				Object.assign(NodePath_Final.prototype, {
					_getTypeAnnotation: NodePath_inference._getTypeAnnotation,
					_replaceWith: NodePath_replacement._replaceWith,
					_resolve: NodePath_introspection._resolve,
					_call: NodePath_context._call,
					_resyncParent: NodePath_context._resyncParent,
					_resyncKey: NodePath_context._resyncKey,
					_resyncList: NodePath_context._resyncList,
					_resyncRemoved: NodePath_context._resyncRemoved,
					_getQueueContexts: NodePath_context._getQueueContexts,
					_removeFromScope: NodePath_removal._removeFromScope,
					_callRemovalHooks: NodePath_removal._callRemovalHooks,
					_remove: NodePath_removal._remove,
					_markRemoved: NodePath_removal._markRemoved,
					_assertUnremoved: NodePath_removal._assertUnremoved,
					_containerInsert: NodePath_modification._containerInsert,
					_containerInsertBefore: NodePath_modification._containerInsertBefore,
					_containerInsertAfter: NodePath_modification._containerInsertAfter,
					_verifyNodeList: NodePath_modification._verifyNodeList,
					_getKey: NodePath_family._getKey,
					_getPattern: NodePath_family._getPattern,
				})
			}
			for (const type of t.TYPES) {
				const typeKey = `is${type}`
				const fn = t[typeKey]
				NodePath_Final.prototype[typeKey] = function (opts) {
					return fn(this.node, opts)
				}
				NodePath_Final.prototype[`assert${type}`] = function (opts) {
					if (!fn(this.node, opts)) {
						throw new TypeError(`Expected node path of type ${type}`)
					}
				}
			}
			Object.assign(NodePath_Final.prototype, NodePath_virtual_types_validator)
			for (const type of Object.keys(virtualTypes)) {
				if (type[0] === '_') continue
				if (!t.TYPES.includes(type)) t.TYPES.push(type)
			}

			//# sourceMappingURL=index.js.map

			/***/
		},

		/***/ 98882: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports._getTypeAnnotation = _getTypeAnnotation
			exports.baseTypeStrictlyMatches = baseTypeStrictlyMatches
			exports.couldBeBaseType = couldBeBaseType
			exports.getTypeAnnotation = getTypeAnnotation
			exports.isBaseType = isBaseType
			exports.isGenericType = isGenericType
			var inferers = __nccwpck_require__(87116)
			var _t = __nccwpck_require__(16535)
			const {
				anyTypeAnnotation,
				isAnyTypeAnnotation,
				isArrayTypeAnnotation,
				isBooleanTypeAnnotation,
				isEmptyTypeAnnotation,
				isFlowBaseAnnotation,
				isGenericTypeAnnotation,
				isIdentifier,
				isMixedTypeAnnotation,
				isNumberTypeAnnotation,
				isStringTypeAnnotation,
				isTSArrayType,
				isTSTypeAnnotation,
				isTSTypeReference,
				isTupleTypeAnnotation,
				isTypeAnnotation,
				isUnionTypeAnnotation,
				isVoidTypeAnnotation,
				stringTypeAnnotation,
				voidTypeAnnotation,
			} = _t
			function getTypeAnnotation() {
				let type = this.getData('typeAnnotation')
				if (type != null) {
					return type
				}
				type = _getTypeAnnotation.call(this) || anyTypeAnnotation()
				if (isTypeAnnotation(type) || isTSTypeAnnotation(type)) {
					type = type.typeAnnotation
				}
				this.setData('typeAnnotation', type)
				return type
			}
			const typeAnnotationInferringNodes = new WeakSet()
			function _getTypeAnnotation() {
				const node = this.node
				if (!node) {
					if (this.key === 'init' && this.parentPath.isVariableDeclarator()) {
						const declar = this.parentPath.parentPath
						const declarParent = declar.parentPath
						if (declar.key === 'left' && declarParent.isForInStatement()) {
							return stringTypeAnnotation()
						}
						if (declar.key === 'left' && declarParent.isForOfStatement()) {
							return anyTypeAnnotation()
						}
						return voidTypeAnnotation()
					} else {
						return
					}
				}
				if (node.typeAnnotation) {
					return node.typeAnnotation
				}
				if (typeAnnotationInferringNodes.has(node)) {
					return
				}
				typeAnnotationInferringNodes.add(node)
				try {
					var _inferer
					let inferer = inferers[node.type]
					if (inferer) {
						return inferer.call(this, node)
					}
					inferer = inferers[this.parentPath.type]
					if ((_inferer = inferer) != null && _inferer.validParent) {
						return this.parentPath.getTypeAnnotation()
					}
				} finally {
					typeAnnotationInferringNodes.delete(node)
				}
			}
			function isBaseType(baseName, soft) {
				return _isBaseType(baseName, this.getTypeAnnotation(), soft)
			}
			function _isBaseType(baseName, type, soft) {
				if (baseName === 'string') {
					return isStringTypeAnnotation(type)
				} else if (baseName === 'number') {
					return isNumberTypeAnnotation(type)
				} else if (baseName === 'boolean') {
					return isBooleanTypeAnnotation(type)
				} else if (baseName === 'any') {
					return isAnyTypeAnnotation(type)
				} else if (baseName === 'mixed') {
					return isMixedTypeAnnotation(type)
				} else if (baseName === 'empty') {
					return isEmptyTypeAnnotation(type)
				} else if (baseName === 'void') {
					return isVoidTypeAnnotation(type)
				} else {
					if (soft) {
						return false
					} else {
						throw new Error(`Unknown base type ${baseName}`)
					}
				}
			}
			function couldBeBaseType(name) {
				const type = this.getTypeAnnotation()
				if (isAnyTypeAnnotation(type)) return true
				if (isUnionTypeAnnotation(type)) {
					for (const type2 of type.types) {
						if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {
							return true
						}
					}
					return false
				} else {
					return _isBaseType(name, type, true)
				}
			}
			function baseTypeStrictlyMatches(rightArg) {
				const left = this.getTypeAnnotation()
				const right = rightArg.getTypeAnnotation()
				if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {
					return right.type === left.type
				}
				return false
			}
			function isGenericType(genericName) {
				const type = this.getTypeAnnotation()
				if (genericName === 'Array') {
					if (
						isTSArrayType(type) ||
						isArrayTypeAnnotation(type) ||
						isTupleTypeAnnotation(type)
					) {
						return true
					}
				}
				return (
					(isGenericTypeAnnotation(type) &&
						isIdentifier(type.id, {
							name: genericName,
						})) ||
					(isTSTypeReference(type) &&
						isIdentifier(type.typeName, {
							name: genericName,
						}))
				)
			}

			//# sourceMappingURL=index.js.map

			/***/
		},

		/***/ 77081: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = _default
			var _t = __nccwpck_require__(16535)
			var _util = __nccwpck_require__(97964)
			const {
				BOOLEAN_NUMBER_BINARY_OPERATORS,
				createTypeAnnotationBasedOnTypeof,
				numberTypeAnnotation,
				voidTypeAnnotation,
			} = _t
			function _default(node) {
				if (!this.isReferenced()) return
				const binding = this.scope.getBinding(node.name)
				if (binding) {
					if (binding.identifier.typeAnnotation) {
						return binding.identifier.typeAnnotation
					} else {
						return getTypeAnnotationBindingConstantViolations(
							binding,
							this,
							node.name,
						)
					}
				}
				if (node.name === 'undefined') {
					return voidTypeAnnotation()
				} else if (node.name === 'NaN' || node.name === 'Infinity') {
					return numberTypeAnnotation()
				} else if (node.name === 'arguments') {
				}
			}
			function getTypeAnnotationBindingConstantViolations(binding, path, name) {
				const types = []
				const functionConstantViolations = []
				let constantViolations = getConstantViolationsBefore(
					binding,
					path,
					functionConstantViolations,
				)
				const testType = getConditionalAnnotation(binding, path, name)
				if (testType) {
					const testConstantViolations = getConstantViolationsBefore(
						binding,
						testType.ifStatement,
					)
					constantViolations = constantViolations.filter(
						(path) => !testConstantViolations.includes(path),
					)
					types.push(testType.typeAnnotation)
				}
				if (constantViolations.length) {
					constantViolations.push(...functionConstantViolations)
					for (const violation of constantViolations) {
						types.push(violation.getTypeAnnotation())
					}
				}
				if (!types.length) {
					return
				}
				return (0, _util.createUnionType)(types)
			}
			function getConstantViolationsBefore(binding, path, functions) {
				const violations = binding.constantViolations.slice()
				violations.unshift(binding.path)
				return violations.filter((violation) => {
					violation = violation.resolve()
					const status = violation._guessExecutionStatusRelativeTo(path)
					if (functions && status === 'unknown') functions.push(violation)
					return status === 'before'
				})
			}
			function inferAnnotationFromBinaryExpression(name, path) {
				const operator = path.node.operator
				const right = path.get('right').resolve()
				const left = path.get('left').resolve()
				let target
				if (
					left.isIdentifier({
						name,
					})
				) {
					target = right
				} else if (
					right.isIdentifier({
						name,
					})
				) {
					target = left
				}
				if (target) {
					if (operator === '===') {
						return target.getTypeAnnotation()
					}
					if (BOOLEAN_NUMBER_BINARY_OPERATORS.includes(operator)) {
						return numberTypeAnnotation()
					}
					return
				}
				if (operator !== '===' && operator !== '==') return
				let typeofPath
				let typePath
				if (
					left.isUnaryExpression({
						operator: 'typeof',
					})
				) {
					typeofPath = left
					typePath = right
				} else if (
					right.isUnaryExpression({
						operator: 'typeof',
					})
				) {
					typeofPath = right
					typePath = left
				}
				if (!typeofPath) return
				if (
					!typeofPath.get('argument').isIdentifier({
						name,
					})
				)
					return
				typePath = typePath.resolve()
				if (!typePath.isLiteral()) return
				const typeValue = typePath.node.value
				if (typeof typeValue !== 'string') return
				return createTypeAnnotationBasedOnTypeof(typeValue)
			}
			function getParentConditionalPath(binding, path, name) {
				let parentPath
				while ((parentPath = path.parentPath)) {
					if (
						parentPath.isIfStatement() ||
						parentPath.isConditionalExpression()
					) {
						if (path.key === 'test') {
							return
						}
						return parentPath
					}
					if (parentPath.isFunction()) {
						if (parentPath.parentPath.scope.getBinding(name) !== binding) return
					}
					path = parentPath
				}
			}
			function getConditionalAnnotation(binding, path, name) {
				const ifStatement = getParentConditionalPath(binding, path, name)
				if (!ifStatement) return
				const test = ifStatement.get('test')
				const paths = [test]
				const types = []
				for (let i = 0; i < paths.length; i++) {
					const path = paths[i]
					if (path.isLogicalExpression()) {
						if (path.node.operator === '&&') {
							paths.push(path.get('left'))
							paths.push(path.get('right'))
						}
					} else if (path.isBinaryExpression()) {
						const type = inferAnnotationFromBinaryExpression(name, path)
						if (type) types.push(type)
					}
				}
				if (types.length) {
					return {
						typeAnnotation: (0, _util.createUnionType)(types),
						ifStatement,
					}
				}
				return getConditionalAnnotation(binding, ifStatement, name)
			}

			//# sourceMappingURL=inferer-reference.js.map

			/***/
		},

		/***/ 87116: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.ArrayExpression = ArrayExpression
			exports.AssignmentExpression = AssignmentExpression
			exports.BinaryExpression = BinaryExpression
			exports.BooleanLiteral = BooleanLiteral
			exports.CallExpression = CallExpression
			exports.ConditionalExpression = ConditionalExpression
			exports.ClassDeclaration =
				exports.ClassExpression =
				exports.FunctionDeclaration =
				exports.ArrowFunctionExpression =
				exports.FunctionExpression =
					Func
			Object.defineProperty(exports, 'Identifier', {
				enumerable: true,
				get: function () {
					return _infererReference.default
				},
			})
			exports.LogicalExpression = LogicalExpression
			exports.NewExpression = NewExpression
			exports.NullLiteral = NullLiteral
			exports.NumericLiteral = NumericLiteral
			exports.ObjectExpression = ObjectExpression
			exports.ParenthesizedExpression = ParenthesizedExpression
			exports.RegExpLiteral = RegExpLiteral
			exports.RestElement = RestElement
			exports.SequenceExpression = SequenceExpression
			exports.StringLiteral = StringLiteral
			exports.TSAsExpression = TSAsExpression
			exports.TSNonNullExpression = TSNonNullExpression
			exports.TaggedTemplateExpression = TaggedTemplateExpression
			exports.TemplateLiteral = TemplateLiteral
			exports.TypeCastExpression = TypeCastExpression
			exports.UnaryExpression = UnaryExpression
			exports.UpdateExpression = UpdateExpression
			exports.VariableDeclarator = VariableDeclarator
			var _t = __nccwpck_require__(16535)
			var _infererReference = __nccwpck_require__(77081)
			var _util = __nccwpck_require__(97964)
			const {
				BOOLEAN_BINARY_OPERATORS,
				BOOLEAN_UNARY_OPERATORS,
				NUMBER_BINARY_OPERATORS,
				NUMBER_UNARY_OPERATORS,
				STRING_UNARY_OPERATORS,
				anyTypeAnnotation,
				arrayTypeAnnotation,
				booleanTypeAnnotation,
				buildMatchMemberExpression,
				genericTypeAnnotation,
				identifier,
				nullLiteralTypeAnnotation,
				numberTypeAnnotation,
				stringTypeAnnotation,
				tupleTypeAnnotation,
				unionTypeAnnotation,
				voidTypeAnnotation,
				isIdentifier,
			} = _t
			function VariableDeclarator() {
				if (!this.get('id').isIdentifier()) return
				return this.get('init').getTypeAnnotation()
			}
			function TypeCastExpression(node) {
				return node.typeAnnotation
			}
			TypeCastExpression.validParent = true
			function TSAsExpression(node) {
				return node.typeAnnotation
			}
			TSAsExpression.validParent = true
			function TSNonNullExpression() {
				return this.get('expression').getTypeAnnotation()
			}
			function NewExpression(node) {
				if (node.callee.type === 'Identifier') {
					return genericTypeAnnotation(node.callee)
				}
			}
			function TemplateLiteral() {
				return stringTypeAnnotation()
			}
			function UnaryExpression(node) {
				const operator = node.operator
				if (operator === 'void') {
					return voidTypeAnnotation()
				} else if (NUMBER_UNARY_OPERATORS.includes(operator)) {
					return numberTypeAnnotation()
				} else if (STRING_UNARY_OPERATORS.includes(operator)) {
					return stringTypeAnnotation()
				} else if (BOOLEAN_UNARY_OPERATORS.includes(operator)) {
					return booleanTypeAnnotation()
				}
			}
			function BinaryExpression(node) {
				const operator = node.operator
				if (NUMBER_BINARY_OPERATORS.includes(operator)) {
					return numberTypeAnnotation()
				} else if (BOOLEAN_BINARY_OPERATORS.includes(operator)) {
					return booleanTypeAnnotation()
				} else if (operator === '+') {
					const right = this.get('right')
					const left = this.get('left')
					if (left.isBaseType('number') && right.isBaseType('number')) {
						return numberTypeAnnotation()
					} else if (left.isBaseType('string') || right.isBaseType('string')) {
						return stringTypeAnnotation()
					}
					return unionTypeAnnotation([
						stringTypeAnnotation(),
						numberTypeAnnotation(),
					])
				}
			}
			function LogicalExpression() {
				const argumentTypes = [
					this.get('left').getTypeAnnotation(),
					this.get('right').getTypeAnnotation(),
				]
				return (0, _util.createUnionType)(argumentTypes)
			}
			function ConditionalExpression() {
				const argumentTypes = [
					this.get('consequent').getTypeAnnotation(),
					this.get('alternate').getTypeAnnotation(),
				]
				return (0, _util.createUnionType)(argumentTypes)
			}
			function SequenceExpression() {
				return this.get('expressions').pop().getTypeAnnotation()
			}
			function ParenthesizedExpression() {
				return this.get('expression').getTypeAnnotation()
			}
			function AssignmentExpression() {
				return this.get('right').getTypeAnnotation()
			}
			function UpdateExpression(node) {
				const operator = node.operator
				if (operator === '++' || operator === '--') {
					return numberTypeAnnotation()
				}
			}
			function StringLiteral() {
				return stringTypeAnnotation()
			}
			function NumericLiteral() {
				return numberTypeAnnotation()
			}
			function BooleanLiteral() {
				return booleanTypeAnnotation()
			}
			function NullLiteral() {
				return nullLiteralTypeAnnotation()
			}
			function RegExpLiteral() {
				return genericTypeAnnotation(identifier('RegExp'))
			}
			function ObjectExpression() {
				return genericTypeAnnotation(identifier('Object'))
			}
			function ArrayExpression() {
				return genericTypeAnnotation(identifier('Array'))
			}
			function RestElement() {
				return ArrayExpression()
			}
			RestElement.validParent = true
			function Func() {
				return genericTypeAnnotation(identifier('Function'))
			}
			const isArrayFrom = buildMatchMemberExpression('Array.from')
			const isObjectKeys = buildMatchMemberExpression('Object.keys')
			const isObjectValues = buildMatchMemberExpression('Object.values')
			const isObjectEntries = buildMatchMemberExpression('Object.entries')
			function CallExpression() {
				const { callee } = this.node
				if (isObjectKeys(callee)) {
					return arrayTypeAnnotation(stringTypeAnnotation())
				} else if (
					isArrayFrom(callee) ||
					isObjectValues(callee) ||
					isIdentifier(callee, {
						name: 'Array',
					})
				) {
					return arrayTypeAnnotation(anyTypeAnnotation())
				} else if (isObjectEntries(callee)) {
					return arrayTypeAnnotation(
						tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]),
					)
				}
				return resolveCall(this.get('callee'))
			}
			function TaggedTemplateExpression() {
				return resolveCall(this.get('tag'))
			}
			function resolveCall(callee) {
				callee = callee.resolve()
				if (callee.isFunction()) {
					const { node } = callee
					if (node.async) {
						if (node.generator) {
							return genericTypeAnnotation(identifier('AsyncIterator'))
						} else {
							return genericTypeAnnotation(identifier('Promise'))
						}
					} else {
						if (node.generator) {
							return genericTypeAnnotation(identifier('Iterator'))
						} else if (callee.node.returnType) {
							return callee.node.returnType
						} else {
						}
					}
				}
			}

			//# sourceMappingURL=inferers.js.map

			/***/
		},

		/***/ 97964: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.createUnionType = createUnionType
			var _t = __nccwpck_require__(16535)
			const {
				createFlowUnionType,
				createTSUnionType,
				createUnionTypeAnnotation,
				isFlowType,
				isTSType,
			} = _t
			function createUnionType(types) {
				{
					if (types.every((v) => isFlowType(v))) {
						if (createFlowUnionType) {
							return createFlowUnionType(types)
						}
						return createUnionTypeAnnotation(types)
					} else if (types.every((v) => isTSType(v))) {
						if (createTSUnionType) {
							return createTSUnionType(types)
						}
					}
				}
			}

			//# sourceMappingURL=util.js.map

			/***/
		},

		/***/ 7009: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo
			exports._resolve = _resolve
			exports.canHaveVariableDeclarationOrExpression =
				canHaveVariableDeclarationOrExpression
			exports.canSwapBetweenExpressionAndStatement =
				canSwapBetweenExpressionAndStatement
			exports.getSource = getSource
			exports.isCompletionRecord = isCompletionRecord
			exports.isConstantExpression = isConstantExpression
			exports.isInStrictMode = isInStrictMode
			exports.isNodeType = isNodeType
			exports.isStatementOrBlock = isStatementOrBlock
			exports.isStatic = isStatic
			exports.matchesPattern = matchesPattern
			exports.referencesImport = referencesImport
			exports.resolve = resolve
			exports.willIMaybeExecuteBefore = willIMaybeExecuteBefore
			var _t = __nccwpck_require__(16535)
			const {
				STATEMENT_OR_BLOCK_KEYS,
				VISITOR_KEYS,
				isBlockStatement,
				isExpression,
				isIdentifier,
				isLiteral,
				isStringLiteral,
				isType,
				matchesPattern: _matchesPattern,
			} = _t
			function matchesPattern(pattern, allowPartial) {
				return _matchesPattern(this.node, pattern, allowPartial)
			}
			{
				exports.has = function has(key) {
					var _this$node
					const val =
						(_this$node = this.node) == null ? void 0 : _this$node[key]
					if (val && Array.isArray(val)) {
						return !!val.length
					} else {
						return !!val
					}
				}
			}
			function isStatic() {
				return this.scope.isStatic(this.node)
			}
			{
				exports.is = exports.has
				exports.isnt = function isnt(key) {
					return !this.has(key)
				}
				exports.equals = function equals(key, value) {
					return this.node[key] === value
				}
			}
			function isNodeType(type) {
				return isType(this.type, type)
			}
			function canHaveVariableDeclarationOrExpression() {
				return (
					(this.key === 'init' || this.key === 'left') &&
					this.parentPath.isFor()
				)
			}
			function canSwapBetweenExpressionAndStatement(replacement) {
				if (
					this.key !== 'body' ||
					!this.parentPath.isArrowFunctionExpression()
				) {
					return false
				}
				if (this.isExpression()) {
					return isBlockStatement(replacement)
				} else if (this.isBlockStatement()) {
					return isExpression(replacement)
				}
				return false
			}
			function isCompletionRecord(allowInsideFunction) {
				let path = this
				let first = true
				do {
					const { type, container } = path
					if (!first && (path.isFunction() || type === 'StaticBlock')) {
						return !!allowInsideFunction
					}
					first = false
					if (Array.isArray(container) && path.key !== container.length - 1) {
						return false
					}
				} while (
					(path = path.parentPath) &&
					!path.isProgram() &&
					!path.isDoExpression()
				)
				return true
			}
			function isStatementOrBlock() {
				if (
					this.parentPath.isLabeledStatement() ||
					isBlockStatement(this.container)
				) {
					return false
				} else {
					return STATEMENT_OR_BLOCK_KEYS.includes(this.key)
				}
			}
			function referencesImport(moduleSource, importName) {
				if (!this.isReferencedIdentifier()) {
					if (
						(this.isJSXMemberExpression() &&
							this.node.property.name === importName) ||
						((this.isMemberExpression() || this.isOptionalMemberExpression()) &&
							(this.node.computed
								? isStringLiteral(this.node.property, {
										value: importName,
									})
								: this.node.property.name === importName))
					) {
						const object = this.get('object')
						return (
							object.isReferencedIdentifier() &&
							object.referencesImport(moduleSource, '*')
						)
					}
					return false
				}
				const binding = this.scope.getBinding(this.node.name)
				if (!binding || binding.kind !== 'module') return false
				const path = binding.path
				const parent = path.parentPath
				if (!parent.isImportDeclaration()) return false
				if (parent.node.source.value === moduleSource) {
					if (!importName) return true
				} else {
					return false
				}
				if (path.isImportDefaultSpecifier() && importName === 'default') {
					return true
				}
				if (path.isImportNamespaceSpecifier() && importName === '*') {
					return true
				}
				if (
					path.isImportSpecifier() &&
					isIdentifier(path.node.imported, {
						name: importName,
					})
				) {
					return true
				}
				return false
			}
			function getSource() {
				const node = this.node
				if (node.end) {
					const code = this.hub.getCode()
					if (code) return code.slice(node.start, node.end)
				}
				return ''
			}
			function willIMaybeExecuteBefore(target) {
				return this._guessExecutionStatusRelativeTo(target) !== 'after'
			}
			function getOuterFunction(path) {
				return path.isProgram()
					? path
					: (
							path.parentPath.scope.getFunctionParent() ||
							path.parentPath.scope.getProgramParent()
						).path
			}
			function isExecutionUncertain(type, key) {
				switch (type) {
					case 'LogicalExpression':
						return key === 'right'
					case 'ConditionalExpression':
					case 'IfStatement':
						return key === 'consequent' || key === 'alternate'
					case 'WhileStatement':
					case 'DoWhileStatement':
					case 'ForInStatement':
					case 'ForOfStatement':
						return key === 'body'
					case 'ForStatement':
						return key === 'body' || key === 'update'
					case 'SwitchStatement':
						return key === 'cases'
					case 'TryStatement':
						return key === 'handler'
					case 'AssignmentPattern':
						return key === 'right'
					case 'OptionalMemberExpression':
						return key === 'property'
					case 'OptionalCallExpression':
						return key === 'arguments'
					default:
						return false
				}
			}
			function isExecutionUncertainInList(paths, maxIndex) {
				for (let i = 0; i < maxIndex; i++) {
					const path = paths[i]
					if (isExecutionUncertain(path.parent.type, path.parentKey)) {
						return true
					}
				}
				return false
			}
			const SYMBOL_CHECKING = Symbol()
			function _guessExecutionStatusRelativeTo(target) {
				return _guessExecutionStatusRelativeToCached(this, target, new Map())
			}
			function _guessExecutionStatusRelativeToCached(base, target, cache) {
				const funcParent = {
					this: getOuterFunction(base),
					target: getOuterFunction(target),
				}
				if (funcParent.target.node !== funcParent.this.node) {
					return _guessExecutionStatusRelativeToDifferentFunctionsCached(
						base,
						funcParent.target,
						cache,
					)
				}
				const paths = {
					target: target.getAncestry(),
					this: base.getAncestry(),
				}
				if (paths.target.includes(base)) return 'after'
				if (paths.this.includes(target)) return 'before'
				let commonPath
				const commonIndex = {
					target: 0,
					this: 0,
				}
				while (!commonPath && commonIndex.this < paths.this.length) {
					const path = paths.this[commonIndex.this]
					commonIndex.target = paths.target.indexOf(path)
					if (commonIndex.target >= 0) {
						commonPath = path
					} else {
						commonIndex.this++
					}
				}
				if (!commonPath) {
					throw new Error(
						'Internal Babel error - The two compared nodes' +
							" don't appear to belong to the same program.",
					)
				}
				if (
					isExecutionUncertainInList(paths.this, commonIndex.this - 1) ||
					isExecutionUncertainInList(paths.target, commonIndex.target - 1)
				) {
					return 'unknown'
				}
				const divergence = {
					this: paths.this[commonIndex.this - 1],
					target: paths.target[commonIndex.target - 1],
				}
				if (
					divergence.target.listKey &&
					divergence.this.listKey &&
					divergence.target.container === divergence.this.container
				) {
					return divergence.target.key > divergence.this.key
						? 'before'
						: 'after'
				}
				const keys = VISITOR_KEYS[commonPath.type]
				const keyPosition = {
					this: keys.indexOf(divergence.this.parentKey),
					target: keys.indexOf(divergence.target.parentKey),
				}
				return keyPosition.target > keyPosition.this ? 'before' : 'after'
			}
			function _guessExecutionStatusRelativeToDifferentFunctionsInternal(
				base,
				target,
				cache,
			) {
				if (!target.isFunctionDeclaration()) {
					if (
						_guessExecutionStatusRelativeToCached(base, target, cache) ===
						'before'
					) {
						return 'before'
					}
					return 'unknown'
				} else if (target.parentPath.isExportDeclaration()) {
					return 'unknown'
				}
				const binding = target.scope.getBinding(target.node.id.name)
				if (!binding.references) return 'before'
				const referencePaths = binding.referencePaths
				let allStatus
				for (const path of referencePaths) {
					const childOfFunction = !!path.find(
						(path) => path.node === target.node,
					)
					if (childOfFunction) continue
					if (path.key !== 'callee' || !path.parentPath.isCallExpression()) {
						return 'unknown'
					}
					const status = _guessExecutionStatusRelativeToCached(
						base,
						path,
						cache,
					)
					if (allStatus && allStatus !== status) {
						return 'unknown'
					} else {
						allStatus = status
					}
				}
				return allStatus
			}
			function _guessExecutionStatusRelativeToDifferentFunctionsCached(
				base,
				target,
				cache,
			) {
				let nodeMap = cache.get(base.node)
				let cached
				if (!nodeMap) {
					cache.set(base.node, (nodeMap = new Map()))
				} else if ((cached = nodeMap.get(target.node))) {
					if (cached === SYMBOL_CHECKING) {
						return 'unknown'
					}
					return cached
				}
				nodeMap.set(target.node, SYMBOL_CHECKING)
				const result =
					_guessExecutionStatusRelativeToDifferentFunctionsInternal(
						base,
						target,
						cache,
					)
				nodeMap.set(target.node, result)
				return result
			}
			function resolve(dangerous, resolved) {
				return _resolve.call(this, dangerous, resolved) || this
			}
			function _resolve(dangerous, resolved) {
				var _resolved
				if ((_resolved = resolved) != null && _resolved.includes(this)) return
				resolved = resolved || []
				resolved.push(this)
				if (this.isVariableDeclarator()) {
					if (this.get('id').isIdentifier()) {
						return this.get('init').resolve(dangerous, resolved)
					} else {
					}
				} else if (this.isReferencedIdentifier()) {
					const binding = this.scope.getBinding(this.node.name)
					if (!binding) return
					if (!binding.constant) return
					if (binding.kind === 'module') return
					if (binding.path !== this) {
						const ret = binding.path.resolve(dangerous, resolved)
						if (this.find((parent) => parent.node === ret.node)) return
						return ret
					}
				} else if (this.isTypeCastExpression()) {
					return this.get('expression').resolve(dangerous, resolved)
				} else if (dangerous && this.isMemberExpression()) {
					const targetKey = this.toComputedKey()
					if (!isLiteral(targetKey)) return
					const targetName = targetKey.value
					const target = this.get('object').resolve(dangerous, resolved)
					if (target.isObjectExpression()) {
						const props = target.get('properties')
						for (const prop of props) {
							if (!prop.isProperty()) continue
							const key = prop.get('key')
							let match =
								prop.isnt('computed') &&
								key.isIdentifier({
									name: targetName,
								})
							match =
								match ||
								key.isLiteral({
									value: targetName,
								})
							if (match) return prop.get('value').resolve(dangerous, resolved)
						}
					} else if (target.isArrayExpression() && !isNaN(+targetName)) {
						const elems = target.get('elements')
						const elem = elems[targetName]
						if (elem) return elem.resolve(dangerous, resolved)
					}
				}
			}
			function isConstantExpression() {
				if (this.isIdentifier()) {
					const binding = this.scope.getBinding(this.node.name)
					if (!binding) return false
					return binding.constant
				}
				if (this.isLiteral()) {
					if (this.isRegExpLiteral()) {
						return false
					}
					if (this.isTemplateLiteral()) {
						return this.get('expressions').every((expression) =>
							expression.isConstantExpression(),
						)
					}
					return true
				}
				if (this.isUnaryExpression()) {
					if (this.node.operator !== 'void') {
						return false
					}
					return this.get('argument').isConstantExpression()
				}
				if (this.isBinaryExpression()) {
					const { operator } = this.node
					return (
						operator !== 'in' &&
						operator !== 'instanceof' &&
						this.get('left').isConstantExpression() &&
						this.get('right').isConstantExpression()
					)
				}
				if (this.isMemberExpression()) {
					return (
						!this.node.computed &&
						this.get('object').isIdentifier({
							name: 'Symbol',
						}) &&
						!this.scope.hasBinding('Symbol', {
							noGlobals: true,
						})
					)
				}
				if (this.isCallExpression()) {
					return (
						this.node.arguments.length === 1 &&
						this.get('callee').matchesPattern('Symbol.for') &&
						!this.scope.hasBinding('Symbol', {
							noGlobals: true,
						}) &&
						this.get('arguments')[0].isStringLiteral()
					)
				}
				return false
			}
			function isInStrictMode() {
				const start = this.isProgram() ? this : this.parentPath
				const strictParent = start.find((path) => {
					if (
						path.isProgram({
							sourceType: 'module',
						})
					)
						return true
					if (path.isClass()) return true
					if (
						path.isArrowFunctionExpression() &&
						!path.get('body').isBlockStatement()
					) {
						return false
					}
					let body
					if (path.isFunction()) {
						body = path.node.body
					} else if (path.isProgram()) {
						body = path.node
					} else {
						return false
					}
					for (const directive of body.directives) {
						if (directive.value.value === 'use strict') {
							return true
						}
					}
				})
				return !!strictParent
			}

			//# sourceMappingURL=introspection.js.map

			/***/
		},

		/***/ 95250: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = void 0
			var _t = __nccwpck_require__(16535)
			var _t2 = _t
			const { react } = _t
			const {
				cloneNode,
				jsxExpressionContainer,
				variableDeclaration,
				variableDeclarator,
			} = _t2
			const referenceVisitor = {
				ReferencedIdentifier(path, state) {
					if (
						path.isJSXIdentifier() &&
						react.isCompatTag(path.node.name) &&
						!path.parentPath.isJSXMemberExpression()
					) {
						return
					}
					if (path.node.name === 'this') {
						let scope = path.scope
						do {
							if (
								scope.path.isFunction() &&
								!scope.path.isArrowFunctionExpression()
							) {
								break
							}
						} while ((scope = scope.parent))
						if (scope) state.breakOnScopePaths.push(scope.path)
					}
					const binding = path.scope.getBinding(path.node.name)
					if (!binding) return
					for (const violation of binding.constantViolations) {
						if (violation.scope !== binding.path.scope) {
							state.mutableBinding = true
							path.stop()
							return
						}
					}
					if (binding !== state.scope.getBinding(path.node.name)) return
					state.bindings[path.node.name] = binding
				},
			}
			class PathHoister {
				constructor(path, scope) {
					this.breakOnScopePaths = void 0
					this.bindings = void 0
					this.mutableBinding = void 0
					this.scopes = void 0
					this.scope = void 0
					this.path = void 0
					this.attachAfter = void 0
					this.breakOnScopePaths = []
					this.bindings = {}
					this.mutableBinding = false
					this.scopes = []
					this.scope = scope
					this.path = path
					this.attachAfter = false
				}
				isCompatibleScope(scope) {
					for (const key of Object.keys(this.bindings)) {
						const binding = this.bindings[key]
						if (!scope.bindingIdentifierEquals(key, binding.identifier)) {
							return false
						}
					}
					return true
				}
				getCompatibleScopes() {
					let scope = this.path.scope
					do {
						if (this.isCompatibleScope(scope)) {
							this.scopes.push(scope)
						} else {
							break
						}
						if (this.breakOnScopePaths.includes(scope.path)) {
							break
						}
					} while ((scope = scope.parent))
				}
				getAttachmentPath() {
					let path = this._getAttachmentPath()
					if (!path) return
					let targetScope = path.scope
					if (targetScope.path === path) {
						targetScope = path.scope.parent
					}
					if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
						for (const name of Object.keys(this.bindings)) {
							if (!targetScope.hasOwnBinding(name)) continue
							const binding = this.bindings[name]
							if (
								binding.kind === 'param' ||
								binding.path.parentKey === 'params'
							) {
								continue
							}
							const bindingParentPath = this.getAttachmentParentForPath(
								binding.path,
							)
							if (bindingParentPath.key >= path.key) {
								this.attachAfter = true
								path = binding.path
								for (const violationPath of binding.constantViolations) {
									if (
										this.getAttachmentParentForPath(violationPath).key >
										path.key
									) {
										path = violationPath
									}
								}
							}
						}
					}
					return path
				}
				_getAttachmentPath() {
					const scopes = this.scopes
					const scope = scopes.pop()
					if (!scope) return
					if (scope.path.isFunction()) {
						if (this.hasOwnParamBindings(scope)) {
							if (this.scope === scope) return
							const bodies = scope.path.get('body').get('body')
							for (let i = 0; i < bodies.length; i++) {
								if (bodies[i].node._blockHoist) continue
								return bodies[i]
							}
						} else {
							return this.getNextScopeAttachmentParent()
						}
					} else if (scope.path.isProgram()) {
						return this.getNextScopeAttachmentParent()
					}
				}
				getNextScopeAttachmentParent() {
					const scope = this.scopes.pop()
					if (scope) return this.getAttachmentParentForPath(scope.path)
				}
				getAttachmentParentForPath(path) {
					do {
						if (
							!path.parentPath ||
							(Array.isArray(path.container) && path.isStatement())
						) {
							return path
						}
					} while ((path = path.parentPath))
				}
				hasOwnParamBindings(scope) {
					for (const name of Object.keys(this.bindings)) {
						if (!scope.hasOwnBinding(name)) continue
						const binding = this.bindings[name]
						if (binding.kind === 'param' && binding.constant) return true
					}
					return false
				}
				run() {
					this.path.traverse(referenceVisitor, this)
					if (this.mutableBinding) return
					this.getCompatibleScopes()
					const attachTo = this.getAttachmentPath()
					if (!attachTo) return
					if (attachTo.getFunctionParent() === this.path.getFunctionParent())
						return
					let uid = attachTo.scope.generateUidIdentifier('ref')
					const declarator = variableDeclarator(uid, this.path.node)
					const insertFn = this.attachAfter ? 'insertAfter' : 'insertBefore'
					const [attached] = attachTo[insertFn]([
						attachTo.isVariableDeclarator()
							? declarator
							: variableDeclaration('var', [declarator]),
					])
					const parent = this.path.parentPath
					if (
						parent.isJSXElement() &&
						this.path.container === parent.node.children
					) {
						uid = jsxExpressionContainer(uid)
					}
					this.path.replaceWith(cloneNode(uid))
					return attachTo.isVariableDeclarator()
						? attached.get('init')
						: attached.get('declarations.0.init')
				}
			}
			exports['default'] = PathHoister

			//# sourceMappingURL=hoister.js.map

			/***/
		},

		/***/ 60547: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.hooks = void 0
			const hooks = (exports.hooks = [
				function (self, parent) {
					const removeParent =
						(self.key === 'test' &&
							(parent.isWhile() || parent.isSwitchCase())) ||
						(self.key === 'declaration' && parent.isExportDeclaration()) ||
						(self.key === 'body' && parent.isLabeledStatement()) ||
						(self.listKey === 'declarations' &&
							parent.isVariableDeclaration() &&
							parent.node.declarations.length === 1) ||
						(self.key === 'expression' && parent.isExpressionStatement())
					if (removeParent) {
						parent.remove()
						return true
					}
				},
				function (self, parent) {
					if (
						parent.isSequenceExpression() &&
						parent.node.expressions.length === 1
					) {
						parent.replaceWith(parent.node.expressions[0])
						return true
					}
				},
				function (self, parent) {
					if (parent.isBinary()) {
						if (self.key === 'left') {
							parent.replaceWith(parent.node.right)
						} else {
							parent.replaceWith(parent.node.left)
						}
						return true
					}
				},
				function (self, parent) {
					if (
						(parent.isIfStatement() && self.key === 'consequent') ||
						(self.key === 'body' &&
							(parent.isLoop() || parent.isArrowFunctionExpression()))
					) {
						self.replaceWith({
							type: 'BlockStatement',
							body: [],
						})
						return true
					}
				},
			])

			//# sourceMappingURL=removal-hooks.js.map

			/***/
		},

		/***/ 66582: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.isBindingIdentifier = isBindingIdentifier
			exports.isBlockScoped = isBlockScoped
			exports.isExpression = isExpression
			exports.isFlow = isFlow
			exports.isForAwaitStatement = isForAwaitStatement
			exports.isGenerated = isGenerated
			exports.isPure = isPure
			exports.isReferenced = isReferenced
			exports.isReferencedIdentifier = isReferencedIdentifier
			exports.isReferencedMemberExpression = isReferencedMemberExpression
			exports.isRestProperty = isRestProperty
			exports.isScope = isScope
			exports.isSpreadProperty = isSpreadProperty
			exports.isStatement = isStatement
			exports.isUser = isUser
			exports.isVar = isVar
			var _t = __nccwpck_require__(16535)
			const {
				isBinding,
				isBlockScoped: nodeIsBlockScoped,
				isExportDeclaration,
				isExpression: nodeIsExpression,
				isFlow: nodeIsFlow,
				isForStatement,
				isForXStatement,
				isIdentifier,
				isImportDeclaration,
				isImportSpecifier,
				isJSXIdentifier,
				isJSXMemberExpression,
				isMemberExpression,
				isRestElement: nodeIsRestElement,
				isReferenced: nodeIsReferenced,
				isScope: nodeIsScope,
				isStatement: nodeIsStatement,
				isVar: nodeIsVar,
				isVariableDeclaration,
				react,
				isForOfStatement,
			} = _t
			const { isCompatTag } = react
			function isReferencedIdentifier(opts) {
				const { node, parent } = this
				if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {
					if (isJSXIdentifier(node, opts)) {
						if (isCompatTag(node.name)) return false
					} else {
						return false
					}
				}
				return nodeIsReferenced(node, parent, this.parentPath.parent)
			}
			function isReferencedMemberExpression() {
				const { node, parent } = this
				return isMemberExpression(node) && nodeIsReferenced(node, parent)
			}
			function isBindingIdentifier() {
				const { node, parent } = this
				const grandparent = this.parentPath.parent
				return isIdentifier(node) && isBinding(node, parent, grandparent)
			}
			function isStatement() {
				const { node, parent } = this
				if (nodeIsStatement(node)) {
					if (isVariableDeclaration(node)) {
						if (
							isForXStatement(parent, {
								left: node,
							})
						)
							return false
						if (
							isForStatement(parent, {
								init: node,
							})
						)
							return false
					}
					return true
				} else {
					return false
				}
			}
			function isExpression() {
				if (this.isIdentifier()) {
					return this.isReferencedIdentifier()
				} else {
					return nodeIsExpression(this.node)
				}
			}
			function isScope() {
				return nodeIsScope(this.node, this.parent)
			}
			function isReferenced() {
				return nodeIsReferenced(this.node, this.parent)
			}
			function isBlockScoped() {
				return nodeIsBlockScoped(this.node)
			}
			function isVar() {
				return nodeIsVar(this.node)
			}
			function isUser() {
				return this.node && !!this.node.loc
			}
			function isGenerated() {
				return !this.isUser()
			}
			function isPure(constantsOnly) {
				return this.scope.isPure(this.node, constantsOnly)
			}
			function isFlow() {
				const { node } = this
				if (nodeIsFlow(node)) {
					return true
				} else if (isImportDeclaration(node)) {
					return node.importKind === 'type' || node.importKind === 'typeof'
				} else if (isExportDeclaration(node)) {
					return node.exportKind === 'type'
				} else if (isImportSpecifier(node)) {
					return node.importKind === 'type' || node.importKind === 'typeof'
				} else {
					return false
				}
			}
			function isRestProperty() {
				var _this$parentPath
				return (
					nodeIsRestElement(this.node) &&
					((_this$parentPath = this.parentPath) == null
						? void 0
						: _this$parentPath.isObjectPattern())
				)
			}
			function isSpreadProperty() {
				var _this$parentPath2
				return (
					nodeIsRestElement(this.node) &&
					((_this$parentPath2 = this.parentPath) == null
						? void 0
						: _this$parentPath2.isObjectExpression())
				)
			}
			function isForAwaitStatement() {
				return isForOfStatement(this.node, {
					await: true,
				})
			}
			{
				exports.isExistentialTypeParam = function isExistentialTypeParam() {
					throw new Error(
						'`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.',
					)
				}
				exports.isNumericLiteralTypeAnnotation =
					function isNumericLiteralTypeAnnotation() {
						throw new Error(
							'`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.',
						)
					}
			}

			//# sourceMappingURL=virtual-types-validator.js.map

			/***/
		},

		/***/ 74425: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.Var =
				exports.User =
				exports.Statement =
				exports.SpreadProperty =
				exports.Scope =
				exports.RestProperty =
				exports.ReferencedMemberExpression =
				exports.ReferencedIdentifier =
				exports.Referenced =
				exports.Pure =
				exports.NumericLiteralTypeAnnotation =
				exports.Generated =
				exports.ForAwaitStatement =
				exports.Flow =
				exports.Expression =
				exports.ExistentialTypeParam =
				exports.BlockScoped =
				exports.BindingIdentifier =
					void 0
			const ReferencedIdentifier = (exports.ReferencedIdentifier = [
				'Identifier',
				'JSXIdentifier',
			])
			const ReferencedMemberExpression = (exports.ReferencedMemberExpression = [
				'MemberExpression',
			])
			const BindingIdentifier = (exports.BindingIdentifier = ['Identifier'])
			const Statement = (exports.Statement = ['Statement'])
			const Expression = (exports.Expression = ['Expression'])
			const Scope = (exports.Scope = ['Scopable', 'Pattern'])
			const Referenced = (exports.Referenced = null)
			const BlockScoped = (exports.BlockScoped = null)
			const Var = (exports.Var = ['VariableDeclaration'])
			const User = (exports.User = null)
			const Generated = (exports.Generated = null)
			const Pure = (exports.Pure = null)
			const Flow = (exports.Flow = [
				'Flow',
				'ImportDeclaration',
				'ExportDeclaration',
				'ImportSpecifier',
			])
			const RestProperty = (exports.RestProperty = ['RestElement'])
			const SpreadProperty = (exports.SpreadProperty = ['RestElement'])
			const ExistentialTypeParam = (exports.ExistentialTypeParam = [
				'ExistsTypeAnnotation',
			])
			const NumericLiteralTypeAnnotation =
				(exports.NumericLiteralTypeAnnotation = ['NumberLiteralTypeAnnotation'])
			const ForAwaitStatement = (exports.ForAwaitStatement = ['ForOfStatement'])

			//# sourceMappingURL=virtual-types.js.map

			/***/
		},

		/***/ 20184: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports._containerInsert = _containerInsert
			exports._containerInsertAfter = _containerInsertAfter
			exports._containerInsertBefore = _containerInsertBefore
			exports._verifyNodeList = _verifyNodeList
			exports.insertAfter = insertAfter
			exports.insertBefore = insertBefore
			exports.pushContainer = pushContainer
			exports.unshiftContainer = unshiftContainer
			exports.updateSiblingKeys = updateSiblingKeys
			var _cache = __nccwpck_require__(6730)
			var _index = __nccwpck_require__(91806)
			var _context = __nccwpck_require__(74105)
			var _removal = __nccwpck_require__(23562)
			var _t = __nccwpck_require__(16535)
			var _hoister = __nccwpck_require__(95250)
			const {
				arrowFunctionExpression,
				assertExpression,
				assignmentExpression,
				blockStatement,
				callExpression,
				cloneNode,
				expressionStatement,
				isAssignmentExpression,
				isCallExpression,
				isExportNamedDeclaration,
				isExpression,
				isIdentifier,
				isSequenceExpression,
				isSuper,
				thisExpression,
			} = _t
			function insertBefore(nodes_) {
				_removal._assertUnremoved.call(this)
				const nodes = _verifyNodeList.call(this, nodes_)
				const { parentPath, parent } = this
				if (
					parentPath.isExpressionStatement() ||
					parentPath.isLabeledStatement() ||
					isExportNamedDeclaration(parent) ||
					(parentPath.isExportDefaultDeclaration() && this.isDeclaration())
				) {
					return parentPath.insertBefore(nodes)
				} else if (
					(this.isNodeType('Expression') && !this.isJSXElement()) ||
					(parentPath.isForStatement() && this.key === 'init')
				) {
					if (this.node) nodes.push(this.node)
					return this.replaceExpressionWithStatements(nodes)
				} else if (Array.isArray(this.container)) {
					return _containerInsertBefore.call(this, nodes)
				} else if (this.isStatementOrBlock()) {
					const node = this.node
					const shouldInsertCurrentNode =
						node && (!this.isExpressionStatement() || node.expression != null)
					this.replaceWith(
						blockStatement(shouldInsertCurrentNode ? [node] : []),
					)
					return this.unshiftContainer('body', nodes)
				} else {
					throw new Error(
						"We don't know what to do with this node type. " +
							"We were previously a Statement but we can't fit in here?",
					)
				}
			}
			function _containerInsert(from, nodes) {
				updateSiblingKeys.call(this, from, nodes.length)
				const paths = []
				this.container.splice(from, 0, ...nodes)
				for (let i = 0; i < nodes.length; i++) {
					var _this$context
					const to = from + i
					const path = this.getSibling(to)
					paths.push(path)
					if ((_this$context = this.context) != null && _this$context.queue) {
						_context.pushContext.call(path, this.context)
					}
				}
				const contexts = _context._getQueueContexts.call(this)
				for (const path of paths) {
					_context.setScope.call(path)
					path.debug('Inserted.')
					for (const context of contexts) {
						context.maybeQueue(path, true)
					}
				}
				return paths
			}
			function _containerInsertBefore(nodes) {
				return _containerInsert.call(this, this.key, nodes)
			}
			function _containerInsertAfter(nodes) {
				return _containerInsert.call(this, this.key + 1, nodes)
			}
			const last = (arr) => arr[arr.length - 1]
			function isHiddenInSequenceExpression(path) {
				return (
					isSequenceExpression(path.parent) &&
					(last(path.parent.expressions) !== path.node ||
						isHiddenInSequenceExpression(path.parentPath))
				)
			}
			function isAlmostConstantAssignment(node, scope) {
				if (!isAssignmentExpression(node) || !isIdentifier(node.left)) {
					return false
				}
				const blockScope = scope.getBlockParent()
				return (
					blockScope.hasOwnBinding(node.left.name) &&
					blockScope.getOwnBinding(node.left.name).constantViolations.length <=
						1
				)
			}
			function insertAfter(nodes_) {
				_removal._assertUnremoved.call(this)
				if (this.isSequenceExpression()) {
					return last(this.get('expressions')).insertAfter(nodes_)
				}
				const nodes = _verifyNodeList.call(this, nodes_)
				const { parentPath, parent } = this
				if (
					parentPath.isExpressionStatement() ||
					parentPath.isLabeledStatement() ||
					isExportNamedDeclaration(parent) ||
					(parentPath.isExportDefaultDeclaration() && this.isDeclaration())
				) {
					return parentPath.insertAfter(
						nodes.map((node) => {
							return isExpression(node) ? expressionStatement(node) : node
						}),
					)
				} else if (
					(this.isNodeType('Expression') &&
						!this.isJSXElement() &&
						!parentPath.isJSXElement()) ||
					(parentPath.isForStatement() && this.key === 'init')
				) {
					const self = this
					if (self.node) {
						const node = self.node
						let { scope } = this
						if (scope.path.isPattern()) {
							assertExpression(node)
							self.replaceWith(
								callExpression(arrowFunctionExpression([], node), []),
							)
							self.get('callee.body').insertAfter(nodes)
							return [self]
						}
						if (isHiddenInSequenceExpression(self)) {
							nodes.unshift(node)
						} else if (isCallExpression(node) && isSuper(node.callee)) {
							nodes.unshift(node)
							nodes.push(thisExpression())
						} else if (isAlmostConstantAssignment(node, scope)) {
							nodes.unshift(node)
							nodes.push(cloneNode(node.left))
						} else if (scope.isPure(node, true)) {
							nodes.push(node)
						} else {
							if (
								parentPath.isMethod({
									computed: true,
									key: node,
								})
							) {
								scope = scope.parent
							}
							const temp = scope.generateDeclaredUidIdentifier()
							nodes.unshift(
								expressionStatement(
									assignmentExpression('=', cloneNode(temp), node),
								),
							)
							nodes.push(expressionStatement(cloneNode(temp)))
						}
					}
					return this.replaceExpressionWithStatements(nodes)
				} else if (Array.isArray(this.container)) {
					return _containerInsertAfter.call(this, nodes)
				} else if (this.isStatementOrBlock()) {
					const node = this.node
					const shouldInsertCurrentNode =
						node && (!this.isExpressionStatement() || node.expression != null)
					this.replaceWith(
						blockStatement(shouldInsertCurrentNode ? [node] : []),
					)
					return this.pushContainer('body', nodes)
				} else {
					throw new Error(
						"We don't know what to do with this node type. " +
							"We were previously a Statement but we can't fit in here?",
					)
				}
			}
			function updateSiblingKeys(fromIndex, incrementBy) {
				if (!this.parent) return
				const paths = (0, _cache.getCachedPaths)(this)
				if (!paths) return
				for (const [, path] of paths) {
					if (
						typeof path.key === 'number' &&
						path.container === this.container &&
						path.key >= fromIndex
					) {
						path.key += incrementBy
					}
				}
			}
			function _verifyNodeList(nodes) {
				if (!nodes) {
					return []
				}
				if (!Array.isArray(nodes)) {
					nodes = [nodes]
				}
				for (let i = 0; i < nodes.length; i++) {
					const node = nodes[i]
					let msg
					if (!node) {
						msg = 'has falsy node'
					} else if (typeof node !== 'object') {
						msg = 'contains a non-object node'
					} else if (!node.type) {
						msg = 'without a type'
					} else if (node instanceof _index.default) {
						msg = 'has a NodePath when it expected a raw object'
					}
					if (msg) {
						const type = Array.isArray(node) ? 'array' : typeof node
						throw new Error(
							`Node list ${msg} with the index of ${i} and type of ${type}`,
						)
					}
				}
				return nodes
			}
			function unshiftContainer(listKey, nodes) {
				_removal._assertUnremoved.call(this)
				nodes = _verifyNodeList.call(this, nodes)
				const path = _index.default
					.get({
						parentPath: this,
						parent: this.node,
						container: this.node[listKey],
						listKey,
						key: 0,
					})
					.setContext(this.context)
				return _containerInsertBefore.call(path, nodes)
			}
			function pushContainer(listKey, nodes) {
				_removal._assertUnremoved.call(this)
				const verifiedNodes = _verifyNodeList.call(this, nodes)
				const container = this.node[listKey]
				const path = _index.default
					.get({
						parentPath: this,
						parent: this.node,
						container: container,
						listKey,
						key: container.length,
					})
					.setContext(this.context)
				return path.replaceWithMultiple(verifiedNodes)
			}
			{
				exports.hoist = function hoist(scope = this.scope) {
					const hoister = new _hoister.default(this, scope)
					return hoister.run()
				}
			}

			//# sourceMappingURL=modification.js.map

			/***/
		},

		/***/ 23562: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports._assertUnremoved = _assertUnremoved
			exports._callRemovalHooks = _callRemovalHooks
			exports._markRemoved = _markRemoved
			exports._remove = _remove
			exports._removeFromScope = _removeFromScope
			exports.remove = remove
			var _removalHooks = __nccwpck_require__(60547)
			var _cache = __nccwpck_require__(6730)
			var _replacement = __nccwpck_require__(76178)
			var _index = __nccwpck_require__(91806)
			var _t = __nccwpck_require__(16535)
			var _modification = __nccwpck_require__(20184)
			var _context = __nccwpck_require__(74105)
			const { getBindingIdentifiers } = _t
			function remove() {
				var _this$opts
				_assertUnremoved.call(this)
				_context.resync.call(this)
				if (_callRemovalHooks.call(this)) {
					_markRemoved.call(this)
					return
				}
				if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {
					_removeFromScope.call(this)
				}
				this.shareCommentsWithSiblings()
				_remove.call(this)
				_markRemoved.call(this)
			}
			function _removeFromScope() {
				const bindings = getBindingIdentifiers(this.node, false, false, true)
				Object.keys(bindings).forEach((name) => this.scope.removeBinding(name))
			}
			function _callRemovalHooks() {
				if (this.parentPath) {
					for (const fn of _removalHooks.hooks) {
						if (fn(this, this.parentPath)) return true
					}
				}
			}
			function _remove() {
				if (Array.isArray(this.container)) {
					this.container.splice(this.key, 1)
					_modification.updateSiblingKeys.call(this, this.key, -1)
				} else {
					_replacement._replaceWith.call(this, null)
				}
			}
			function _markRemoved() {
				this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED
				if (this.parent) {
					var _getCachedPaths
					;(_getCachedPaths = (0, _cache.getCachedPaths)(this)) == null ||
						_getCachedPaths.delete(this.node)
				}
				this.node = null
			}
			function _assertUnremoved() {
				if (this.removed) {
					throw this.buildCodeFrameError(
						'NodePath has been removed so is read-only.',
					)
				}
			}

			//# sourceMappingURL=removal.js.map

			/***/
		},

		/***/ 76178: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports._replaceWith = _replaceWith
			exports.replaceExpressionWithStatements = replaceExpressionWithStatements
			exports.replaceInline = replaceInline
			exports.replaceWith = replaceWith
			exports.replaceWithMultiple = replaceWithMultiple
			exports.replaceWithSourceString = replaceWithSourceString
			var _codeFrame = __nccwpck_require__(90147)
			var _index = __nccwpck_require__(50148)
			var _index2 = __nccwpck_require__(91806)
			var _cache = __nccwpck_require__(6730)
			var _modification = __nccwpck_require__(20184)
			var _parser = __nccwpck_require__(5429)
			var _t = __nccwpck_require__(16535)
			var _context = __nccwpck_require__(74105)
			const {
				FUNCTION_TYPES,
				arrowFunctionExpression,
				assignmentExpression,
				awaitExpression,
				blockStatement,
				buildUndefinedNode,
				callExpression,
				cloneNode,
				conditionalExpression,
				expressionStatement,
				getBindingIdentifiers,
				identifier,
				inheritLeadingComments,
				inheritTrailingComments,
				inheritsComments,
				isBlockStatement,
				isEmptyStatement,
				isExpression,
				isExpressionStatement,
				isIfStatement,
				isProgram,
				isStatement,
				isVariableDeclaration,
				removeComments,
				returnStatement,
				sequenceExpression,
				validate,
				yieldExpression,
			} = _t
			function replaceWithMultiple(nodes) {
				var _getCachedPaths
				_context.resync.call(this)
				nodes = _modification._verifyNodeList.call(this, nodes)
				inheritLeadingComments(nodes[0], this.node)
				inheritTrailingComments(nodes[nodes.length - 1], this.node)
				;(_getCachedPaths = (0, _cache.getCachedPaths)(this)) == null ||
					_getCachedPaths.delete(this.node)
				this.node = this.container[this.key] = null
				const paths = this.insertAfter(nodes)
				if (this.node) {
					this.requeue()
				} else {
					this.remove()
				}
				return paths
			}
			function replaceWithSourceString(replacement) {
				_context.resync.call(this)
				let ast
				try {
					replacement = `(${replacement})`
					ast = (0, _parser.parse)(replacement)
				} catch (err) {
					const loc = err.loc
					if (loc) {
						err.message +=
							' - make sure this is an expression.\n' +
							(0, _codeFrame.codeFrameColumns)(replacement, {
								start: {
									line: loc.line,
									column: loc.column + 1,
								},
							})
						err.code = 'BABEL_REPLACE_SOURCE_ERROR'
					}
					throw err
				}
				const expressionAST = ast.program.body[0].expression
				_index.default.removeProperties(expressionAST)
				return this.replaceWith(expressionAST)
			}
			function replaceWith(replacementPath) {
				_context.resync.call(this)
				if (this.removed) {
					throw new Error(
						"You can't replace this node, we've already removed it",
					)
				}
				let replacement =
					replacementPath instanceof _index2.default
						? replacementPath.node
						: replacementPath
				if (!replacement) {
					throw new Error(
						'You passed `path.replaceWith()` a falsy node, use `path.remove()` instead',
					)
				}
				if (this.node === replacement) {
					return [this]
				}
				if (this.isProgram() && !isProgram(replacement)) {
					throw new Error(
						'You can only replace a Program root node with another Program node',
					)
				}
				if (Array.isArray(replacement)) {
					throw new Error(
						"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`",
					)
				}
				if (typeof replacement === 'string') {
					throw new Error(
						"Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`",
					)
				}
				let nodePath = ''
				if (this.isNodeType('Statement') && isExpression(replacement)) {
					if (
						!this.canHaveVariableDeclarationOrExpression() &&
						!this.canSwapBetweenExpressionAndStatement(replacement) &&
						!this.parentPath.isExportDefaultDeclaration()
					) {
						replacement = expressionStatement(replacement)
						nodePath = 'expression'
					}
				}
				if (this.isNodeType('Expression') && isStatement(replacement)) {
					if (
						!this.canHaveVariableDeclarationOrExpression() &&
						!this.canSwapBetweenExpressionAndStatement(replacement)
					) {
						return this.replaceExpressionWithStatements([replacement])
					}
				}
				const oldNode = this.node
				if (oldNode) {
					inheritsComments(replacement, oldNode)
					removeComments(oldNode)
				}
				_replaceWith.call(this, replacement)
				this.type = replacement.type
				_context.setScope.call(this)
				this.requeue()
				return [nodePath ? this.get(nodePath) : this]
			}
			function _replaceWith(node) {
				var _getCachedPaths2
				if (!this.container) {
					throw new ReferenceError('Container is falsy')
				}
				if (this.inList) {
					validate(this.parent, this.key, [node])
				} else {
					validate(this.parent, this.key, node)
				}
				this.debug(`Replace with ${node == null ? void 0 : node.type}`)
				;(_getCachedPaths2 = (0, _cache.getCachedPaths)(this)) == null ||
					_getCachedPaths2.set(node, this).delete(this.node)
				this.node = this.container[this.key] = node
			}
			function replaceExpressionWithStatements(nodes) {
				_context.resync.call(this)
				const declars = []
				const nodesAsSingleExpression = gatherSequenceExpressions(
					nodes,
					declars,
				)
				if (nodesAsSingleExpression) {
					for (const id of declars)
						this.scope.push({
							id,
						})
					return this.replaceWith(nodesAsSingleExpression)[0].get('expressions')
				}
				const functionParent = this.getFunctionParent()
				const isParentAsync =
					functionParent == null ? void 0 : functionParent.node.async
				const isParentGenerator =
					functionParent == null ? void 0 : functionParent.node.generator
				const container = arrowFunctionExpression([], blockStatement(nodes))
				this.replaceWith(callExpression(container, []))
				const callee = this.get('callee')
				callee.get('body').scope.hoistVariables((id) =>
					this.scope.push({
						id,
					}),
				)
				const completionRecords = callee.getCompletionRecords()
				for (const path of completionRecords) {
					if (!path.isExpressionStatement()) continue
					const loop = path.findParent((path) => path.isLoop())
					if (loop) {
						let uid = loop.getData('expressionReplacementReturnUid')
						if (!uid) {
							uid = callee.scope.generateDeclaredUidIdentifier('ret')
							callee
								.get('body')
								.pushContainer('body', returnStatement(cloneNode(uid)))
							loop.setData('expressionReplacementReturnUid', uid)
						} else {
							uid = identifier(uid.name)
						}
						path
							.get('expression')
							.replaceWith(
								assignmentExpression('=', cloneNode(uid), path.node.expression),
							)
					} else {
						path.replaceWith(returnStatement(path.node.expression))
					}
				}
				callee.arrowFunctionToExpression()
				const newCallee = callee
				const needToAwaitFunction =
					isParentAsync &&
					_index.default.hasType(
						this.get('callee.body').node,
						'AwaitExpression',
						FUNCTION_TYPES,
					)
				const needToYieldFunction =
					isParentGenerator &&
					_index.default.hasType(
						this.get('callee.body').node,
						'YieldExpression',
						FUNCTION_TYPES,
					)
				if (needToAwaitFunction) {
					newCallee.set('async', true)
					if (!needToYieldFunction) {
						this.replaceWith(awaitExpression(this.node))
					}
				}
				if (needToYieldFunction) {
					newCallee.set('generator', true)
					this.replaceWith(yieldExpression(this.node, true))
				}
				return newCallee.get('body.body')
			}
			function gatherSequenceExpressions(nodes, declars) {
				const exprs = []
				let ensureLastUndefined = true
				for (const node of nodes) {
					if (!isEmptyStatement(node)) {
						ensureLastUndefined = false
					}
					if (isExpression(node)) {
						exprs.push(node)
					} else if (isExpressionStatement(node)) {
						exprs.push(node.expression)
					} else if (isVariableDeclaration(node)) {
						if (node.kind !== 'var') return
						for (const declar of node.declarations) {
							const bindings = getBindingIdentifiers(declar)
							for (const key of Object.keys(bindings)) {
								declars.push(cloneNode(bindings[key]))
							}
							if (declar.init) {
								exprs.push(assignmentExpression('=', declar.id, declar.init))
							}
						}
						ensureLastUndefined = true
					} else if (isIfStatement(node)) {
						const consequent = node.consequent
							? gatherSequenceExpressions([node.consequent], declars)
							: buildUndefinedNode()
						const alternate = node.alternate
							? gatherSequenceExpressions([node.alternate], declars)
							: buildUndefinedNode()
						if (!consequent || !alternate) return
						exprs.push(conditionalExpression(node.test, consequent, alternate))
					} else if (isBlockStatement(node)) {
						const body = gatherSequenceExpressions(node.body, declars)
						if (!body) return
						exprs.push(body)
					} else if (isEmptyStatement(node)) {
						if (nodes.indexOf(node) === 0) {
							ensureLastUndefined = true
						}
					} else {
						return
					}
				}
				if (ensureLastUndefined) exprs.push(buildUndefinedNode())
				if (exprs.length === 1) {
					return exprs[0]
				} else {
					return sequenceExpression(exprs)
				}
			}
			function replaceInline(nodes) {
				_context.resync.call(this)
				if (Array.isArray(nodes)) {
					if (Array.isArray(this.container)) {
						nodes = _modification._verifyNodeList.call(this, nodes)
						const paths = _modification._containerInsertAfter.call(this, nodes)
						this.remove()
						return paths
					} else {
						return this.replaceWithMultiple(nodes)
					}
				} else {
					return this.replaceWith(nodes)
				}
			}

			//# sourceMappingURL=replacement.js.map

			/***/
		},

		/***/ 42058: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = void 0
			class Binding {
				constructor({ identifier, scope, path, kind }) {
					this.identifier = void 0
					this.scope = void 0
					this.path = void 0
					this.kind = void 0
					this.constantViolations = []
					this.constant = true
					this.referencePaths = []
					this.referenced = false
					this.references = 0
					this.identifier = identifier
					this.scope = scope
					this.path = path
					this.kind = kind
					if ((kind === 'var' || kind === 'hoisted') && isInitInLoop(path)) {
						this.reassign(path)
					}
					this.clearValue()
				}
				deoptValue() {
					this.clearValue()
					this.hasDeoptedValue = true
				}
				setValue(value) {
					if (this.hasDeoptedValue) return
					this.hasValue = true
					this.value = value
				}
				clearValue() {
					this.hasDeoptedValue = false
					this.hasValue = false
					this.value = null
				}
				reassign(path) {
					this.constant = false
					if (this.constantViolations.includes(path)) {
						return
					}
					this.constantViolations.push(path)
				}
				reference(path) {
					if (this.referencePaths.includes(path)) {
						return
					}
					this.referenced = true
					this.references++
					this.referencePaths.push(path)
				}
				dereference() {
					this.references--
					this.referenced = !!this.references
				}
			}
			exports['default'] = Binding
			function isInitInLoop(path) {
				const isFunctionDeclarationOrHasInit =
					!path.isVariableDeclarator() || path.node.init
				for (
					let { parentPath, key } = path;
					parentPath;
					{ parentPath, key } = parentPath
				) {
					if (parentPath.isFunctionParent()) return false
					if (
						(key === 'left' && parentPath.isForXStatement()) ||
						(isFunctionDeclarationOrHasInit &&
							key === 'body' &&
							parentPath.isLoop())
					) {
						return true
					}
				}
				return false
			}

			//# sourceMappingURL=binding.js.map

			/***/
		},

		/***/ 18171: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = void 0
			var _renamer = __nccwpck_require__(99391)
			var _index = __nccwpck_require__(50148)
			var _binding = __nccwpck_require__(42058)
			var _globals = __nccwpck_require__(21384)
			var _t = __nccwpck_require__(16535)
			var t = _t
			var _cache = __nccwpck_require__(6730)
			const {
				assignmentExpression,
				callExpression,
				cloneNode,
				getBindingIdentifiers,
				identifier,
				isArrayExpression,
				isBinary,
				isCallExpression,
				isClass,
				isClassBody,
				isClassDeclaration,
				isExportAllDeclaration,
				isExportDefaultDeclaration,
				isExportNamedDeclaration,
				isFunctionDeclaration,
				isIdentifier,
				isImportDeclaration,
				isLiteral,
				isMemberExpression,
				isMethod,
				isModuleSpecifier,
				isNullLiteral,
				isObjectExpression,
				isProperty,
				isPureish,
				isRegExpLiteral,
				isSuper,
				isTaggedTemplateExpression,
				isTemplateLiteral,
				isThisExpression,
				isUnaryExpression,
				isVariableDeclaration,
				expressionStatement,
				matchesPattern,
				memberExpression,
				numericLiteral,
				toIdentifier,
				variableDeclaration,
				variableDeclarator,
				isRecordExpression,
				isTupleExpression,
				isObjectProperty,
				isTopicReference,
				isMetaProperty,
				isPrivateName,
				isExportDeclaration,
				buildUndefinedNode,
				sequenceExpression,
			} = _t
			function gatherNodeParts(node, parts) {
				switch (node == null ? void 0 : node.type) {
					default:
						if (isImportDeclaration(node) || isExportDeclaration(node)) {
							var _node$specifiers
							if (
								(isExportAllDeclaration(node) ||
									isExportNamedDeclaration(node) ||
									isImportDeclaration(node)) &&
								node.source
							) {
								gatherNodeParts(node.source, parts)
							} else if (
								(isExportNamedDeclaration(node) || isImportDeclaration(node)) &&
								(_node$specifiers = node.specifiers) != null &&
								_node$specifiers.length
							) {
								for (const e of node.specifiers) gatherNodeParts(e, parts)
							} else if (
								(isExportDefaultDeclaration(node) ||
									isExportNamedDeclaration(node)) &&
								node.declaration
							) {
								gatherNodeParts(node.declaration, parts)
							}
						} else if (isModuleSpecifier(node)) {
							gatherNodeParts(node.local, parts)
						} else if (
							isLiteral(node) &&
							!isNullLiteral(node) &&
							!isRegExpLiteral(node) &&
							!isTemplateLiteral(node)
						) {
							parts.push(node.value)
						}
						break
					case 'MemberExpression':
					case 'OptionalMemberExpression':
					case 'JSXMemberExpression':
						gatherNodeParts(node.object, parts)
						gatherNodeParts(node.property, parts)
						break
					case 'Identifier':
					case 'JSXIdentifier':
						parts.push(node.name)
						break
					case 'CallExpression':
					case 'OptionalCallExpression':
					case 'NewExpression':
						gatherNodeParts(node.callee, parts)
						break
					case 'ObjectExpression':
					case 'ObjectPattern':
						for (const e of node.properties) {
							gatherNodeParts(e, parts)
						}
						break
					case 'SpreadElement':
					case 'RestElement':
						gatherNodeParts(node.argument, parts)
						break
					case 'ObjectProperty':
					case 'ObjectMethod':
					case 'ClassProperty':
					case 'ClassMethod':
					case 'ClassPrivateProperty':
					case 'ClassPrivateMethod':
						gatherNodeParts(node.key, parts)
						break
					case 'ThisExpression':
						parts.push('this')
						break
					case 'Super':
						parts.push('super')
						break
					case 'Import':
						parts.push('import')
						break
					case 'DoExpression':
						parts.push('do')
						break
					case 'YieldExpression':
						parts.push('yield')
						gatherNodeParts(node.argument, parts)
						break
					case 'AwaitExpression':
						parts.push('await')
						gatherNodeParts(node.argument, parts)
						break
					case 'AssignmentExpression':
						gatherNodeParts(node.left, parts)
						break
					case 'VariableDeclarator':
						gatherNodeParts(node.id, parts)
						break
					case 'FunctionExpression':
					case 'FunctionDeclaration':
					case 'ClassExpression':
					case 'ClassDeclaration':
						gatherNodeParts(node.id, parts)
						break
					case 'PrivateName':
						gatherNodeParts(node.id, parts)
						break
					case 'ParenthesizedExpression':
						gatherNodeParts(node.expression, parts)
						break
					case 'UnaryExpression':
					case 'UpdateExpression':
						gatherNodeParts(node.argument, parts)
						break
					case 'MetaProperty':
						gatherNodeParts(node.meta, parts)
						gatherNodeParts(node.property, parts)
						break
					case 'JSXElement':
						gatherNodeParts(node.openingElement, parts)
						break
					case 'JSXOpeningElement':
						gatherNodeParts(node.name, parts)
						break
					case 'JSXFragment':
						gatherNodeParts(node.openingFragment, parts)
						break
					case 'JSXOpeningFragment':
						parts.push('Fragment')
						break
					case 'JSXNamespacedName':
						gatherNodeParts(node.namespace, parts)
						gatherNodeParts(node.name, parts)
						break
				}
			}
			function resetScope(scope) {
				scope.references = Object.create(null)
				scope.bindings = Object.create(null)
				scope.globals = Object.create(null)
				scope.uids = Object.create(null)
			}
			{
				var NOT_LOCAL_BINDING = Symbol.for(
					'should not be considered a local binding',
				)
			}
			const collectorVisitor = {
				ForStatement(path) {
					const declar = path.get('init')
					if (declar.isVar()) {
						const { scope } = path
						const parentScope =
							scope.getFunctionParent() || scope.getProgramParent()
						parentScope.registerBinding('var', declar)
					}
				},
				Declaration(path) {
					if (path.isBlockScoped()) return
					if (path.isImportDeclaration()) return
					if (path.isExportDeclaration()) return
					const parent =
						path.scope.getFunctionParent() || path.scope.getProgramParent()
					parent.registerDeclaration(path)
				},
				ImportDeclaration(path) {
					const parent = path.scope.getBlockParent()
					parent.registerDeclaration(path)
				},
				TSImportEqualsDeclaration(path) {
					const parent = path.scope.getBlockParent()
					parent.registerDeclaration(path)
				},
				ReferencedIdentifier(path, state) {
					if (
						t.isTSQualifiedName(path.parent) &&
						path.parent.right === path.node
					) {
						return
					}
					if (path.parentPath.isTSImportEqualsDeclaration()) return
					state.references.push(path)
				},
				ForXStatement(path, state) {
					const left = path.get('left')
					if (left.isPattern() || left.isIdentifier()) {
						state.constantViolations.push(path)
					} else if (left.isVar()) {
						const { scope } = path
						const parentScope =
							scope.getFunctionParent() || scope.getProgramParent()
						parentScope.registerBinding('var', left)
					}
				},
				ExportDeclaration: {
					exit(path) {
						const { node, scope } = path
						if (isExportAllDeclaration(node)) return
						const declar = node.declaration
						if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {
							const id = declar.id
							if (!id) return
							const binding = scope.getBinding(id.name)
							binding == null || binding.reference(path)
						} else if (isVariableDeclaration(declar)) {
							for (const decl of declar.declarations) {
								for (const name of Object.keys(getBindingIdentifiers(decl))) {
									const binding = scope.getBinding(name)
									binding == null || binding.reference(path)
								}
							}
						}
					},
				},
				LabeledStatement(path) {
					path.scope.getBlockParent().registerDeclaration(path)
				},
				AssignmentExpression(path, state) {
					state.assignments.push(path)
				},
				UpdateExpression(path, state) {
					state.constantViolations.push(path)
				},
				UnaryExpression(path, state) {
					if (path.node.operator === 'delete') {
						state.constantViolations.push(path)
					}
				},
				BlockScoped(path) {
					let scope = path.scope
					if (scope.path === path) scope = scope.parent
					const parent = scope.getBlockParent()
					parent.registerDeclaration(path)
					if (path.isClassDeclaration() && path.node.id) {
						const id = path.node.id
						const name = id.name
						path.scope.bindings[name] = path.scope.parent.getBinding(name)
					}
				},
				CatchClause(path) {
					path.scope.registerBinding('let', path)
				},
				Function(path) {
					const params = path.get('params')
					for (const param of params) {
						path.scope.registerBinding('param', param)
					}
					if (
						path.isFunctionExpression() &&
						path.node.id &&
						!path.node.id[NOT_LOCAL_BINDING]
					) {
						path.scope.registerBinding('local', path.get('id'), path)
					}
				},
				ClassExpression(path) {
					if (path.node.id && !path.node.id[NOT_LOCAL_BINDING]) {
						path.scope.registerBinding('local', path.get('id'), path)
					}
				},
				TSTypeAnnotation(path) {
					path.skip()
				},
			}
			let scopeVisitor
			let uid = 0
			class Scope {
				constructor(path) {
					this.uid = void 0
					this.path = void 0
					this.block = void 0
					this.inited = void 0
					this.labels = void 0
					this.bindings = void 0
					this.references = void 0
					this.globals = void 0
					this.uids = void 0
					this.data = void 0
					this.crawling = void 0
					const { node } = path
					const cached = _cache.scope.get(node)
					if ((cached == null ? void 0 : cached.path) === path) {
						return cached
					}
					_cache.scope.set(node, this)
					this.uid = uid++
					this.block = node
					this.path = path
					this.labels = new Map()
					this.inited = false
				}
				get parent() {
					var _parent
					let parent,
						path = this.path
					do {
						var _path
						const shouldSkip =
							path.key === 'key' || path.listKey === 'decorators'
						path = path.parentPath
						if (shouldSkip && path.isMethod()) path = path.parentPath
						if ((_path = path) != null && _path.isScope()) parent = path
					} while (path && !parent)
					return (_parent = parent) == null ? void 0 : _parent.scope
				}
				generateDeclaredUidIdentifier(name) {
					const id = this.generateUidIdentifier(name)
					this.push({
						id,
					})
					return cloneNode(id)
				}
				generateUidIdentifier(name) {
					return identifier(this.generateUid(name))
				}
				generateUid(name = 'temp') {
					name = toIdentifier(name).replace(/^_+/, '').replace(/\d+$/g, '')
					let uid
					let i = 0
					do {
						uid = `_${name}`
						if (i >= 11) uid += i - 1
						else if (i >= 9) uid += i - 9
						else if (i >= 1) uid += i + 1
						i++
					} while (
						this.hasLabel(uid) ||
						this.hasBinding(uid) ||
						this.hasGlobal(uid) ||
						this.hasReference(uid)
					)
					const program = this.getProgramParent()
					program.references[uid] = true
					program.uids[uid] = true
					return uid
				}
				generateUidBasedOnNode(node, defaultName) {
					const parts = []
					gatherNodeParts(node, parts)
					let id = parts.join('$')
					id = id.replace(/^_/, '') || defaultName || 'ref'
					return this.generateUid(id.slice(0, 20))
				}
				generateUidIdentifierBasedOnNode(node, defaultName) {
					return identifier(this.generateUidBasedOnNode(node, defaultName))
				}
				isStatic(node) {
					if (
						isThisExpression(node) ||
						isSuper(node) ||
						isTopicReference(node)
					) {
						return true
					}
					if (isIdentifier(node)) {
						const binding = this.getBinding(node.name)
						if (binding) {
							return binding.constant
						} else {
							return this.hasBinding(node.name)
						}
					}
					return false
				}
				maybeGenerateMemoised(node, dontPush) {
					if (this.isStatic(node)) {
						return null
					} else {
						const id = this.generateUidIdentifierBasedOnNode(node)
						if (!dontPush) {
							this.push({
								id,
							})
							return cloneNode(id)
						}
						return id
					}
				}
				checkBlockScopedCollisions(local, kind, name, id) {
					if (kind === 'param') return
					if (local.kind === 'local') return
					const duplicate =
						kind === 'let' ||
						local.kind === 'let' ||
						local.kind === 'const' ||
						local.kind === 'module' ||
						(local.kind === 'param' && kind === 'const')
					if (duplicate) {
						throw this.path.hub.buildError(
							id,
							`Duplicate declaration "${name}"`,
							TypeError,
						)
					}
				}
				rename(oldName, newName) {
					const binding = this.getBinding(oldName)
					if (binding) {
						newName || (newName = this.generateUidIdentifier(oldName).name)
						const renamer = new _renamer.default(binding, oldName, newName)
						{
							renamer.rename(arguments[2])
						}
					}
				}
				dump() {
					const sep = '-'.repeat(60)
					console.log(sep)
					let scope = this
					do {
						console.log('#', scope.block.type)
						for (const name of Object.keys(scope.bindings)) {
							const binding = scope.bindings[name]
							console.log(' -', name, {
								constant: binding.constant,
								references: binding.references,
								violations: binding.constantViolations.length,
								kind: binding.kind,
							})
						}
					} while ((scope = scope.parent))
					console.log(sep)
				}
				hasLabel(name) {
					return !!this.getLabel(name)
				}
				getLabel(name) {
					return this.labels.get(name)
				}
				registerLabel(path) {
					this.labels.set(path.node.label.name, path)
				}
				registerDeclaration(path) {
					if (path.isLabeledStatement()) {
						this.registerLabel(path)
					} else if (path.isFunctionDeclaration()) {
						this.registerBinding('hoisted', path.get('id'), path)
					} else if (path.isVariableDeclaration()) {
						const declarations = path.get('declarations')
						const { kind } = path.node
						for (const declar of declarations) {
							this.registerBinding(
								kind === 'using' || kind === 'await using' ? 'const' : kind,
								declar,
							)
						}
					} else if (path.isClassDeclaration()) {
						if (path.node.declare) return
						this.registerBinding('let', path)
					} else if (path.isImportDeclaration()) {
						const isTypeDeclaration =
							path.node.importKind === 'type' ||
							path.node.importKind === 'typeof'
						const specifiers = path.get('specifiers')
						for (const specifier of specifiers) {
							const isTypeSpecifier =
								isTypeDeclaration ||
								(specifier.isImportSpecifier() &&
									(specifier.node.importKind === 'type' ||
										specifier.node.importKind === 'typeof'))
							this.registerBinding(
								isTypeSpecifier ? 'unknown' : 'module',
								specifier,
							)
						}
					} else if (path.isExportDeclaration()) {
						const declar = path.get('declaration')
						if (
							declar.isClassDeclaration() ||
							declar.isFunctionDeclaration() ||
							declar.isVariableDeclaration()
						) {
							this.registerDeclaration(declar)
						}
					} else {
						this.registerBinding('unknown', path)
					}
				}
				buildUndefinedNode() {
					return buildUndefinedNode()
				}
				registerConstantViolation(path) {
					const ids = path.getAssignmentIdentifiers()
					for (const name of Object.keys(ids)) {
						var _this$getBinding
						;(_this$getBinding = this.getBinding(name)) == null ||
							_this$getBinding.reassign(path)
					}
				}
				registerBinding(kind, path, bindingPath = path) {
					if (!kind) throw new ReferenceError('no `kind`')
					if (path.isVariableDeclaration()) {
						const declarators = path.get('declarations')
						for (const declar of declarators) {
							this.registerBinding(kind, declar)
						}
						return
					}
					const parent = this.getProgramParent()
					const ids = path.getOuterBindingIdentifiers(true)
					for (const name of Object.keys(ids)) {
						parent.references[name] = true
						for (const id of ids[name]) {
							const local = this.getOwnBinding(name)
							if (local) {
								if (local.identifier === id) continue
								this.checkBlockScopedCollisions(local, kind, name, id)
							}
							if (local) {
								local.reassign(bindingPath)
							} else {
								this.bindings[name] = new _binding.default({
									identifier: id,
									scope: this,
									path: bindingPath,
									kind: kind,
								})
							}
						}
					}
				}
				addGlobal(node) {
					this.globals[node.name] = node
				}
				hasUid(name) {
					let scope = this
					do {
						if (scope.uids[name]) return true
					} while ((scope = scope.parent))
					return false
				}
				hasGlobal(name) {
					let scope = this
					do {
						if (scope.globals[name]) return true
					} while ((scope = scope.parent))
					return false
				}
				hasReference(name) {
					return !!this.getProgramParent().references[name]
				}
				isPure(node, constantsOnly) {
					if (isIdentifier(node)) {
						const binding = this.getBinding(node.name)
						if (!binding) return false
						if (constantsOnly) return binding.constant
						return true
					} else if (
						isThisExpression(node) ||
						isMetaProperty(node) ||
						isTopicReference(node) ||
						isPrivateName(node)
					) {
						return true
					} else if (isClass(node)) {
						var _node$decorators
						if (
							node.superClass &&
							!this.isPure(node.superClass, constantsOnly)
						) {
							return false
						}
						if (
							((_node$decorators = node.decorators) == null
								? void 0
								: _node$decorators.length) > 0
						) {
							return false
						}
						return this.isPure(node.body, constantsOnly)
					} else if (isClassBody(node)) {
						for (const method of node.body) {
							if (!this.isPure(method, constantsOnly)) return false
						}
						return true
					} else if (isBinary(node)) {
						return (
							this.isPure(node.left, constantsOnly) &&
							this.isPure(node.right, constantsOnly)
						)
					} else if (isArrayExpression(node) || isTupleExpression(node)) {
						for (const elem of node.elements) {
							if (elem !== null && !this.isPure(elem, constantsOnly))
								return false
						}
						return true
					} else if (isObjectExpression(node) || isRecordExpression(node)) {
						for (const prop of node.properties) {
							if (!this.isPure(prop, constantsOnly)) return false
						}
						return true
					} else if (isMethod(node)) {
						var _node$decorators2
						if (node.computed && !this.isPure(node.key, constantsOnly))
							return false
						if (
							((_node$decorators2 = node.decorators) == null
								? void 0
								: _node$decorators2.length) > 0
						) {
							return false
						}
						return true
					} else if (isProperty(node)) {
						var _node$decorators3
						if (node.computed && !this.isPure(node.key, constantsOnly))
							return false
						if (
							((_node$decorators3 = node.decorators) == null
								? void 0
								: _node$decorators3.length) > 0
						) {
							return false
						}
						if (isObjectProperty(node) || node.static) {
							if (
								node.value !== null &&
								!this.isPure(node.value, constantsOnly)
							) {
								return false
							}
						}
						return true
					} else if (isUnaryExpression(node)) {
						return this.isPure(node.argument, constantsOnly)
					} else if (isTemplateLiteral(node)) {
						for (const expression of node.expressions) {
							if (!this.isPure(expression, constantsOnly)) return false
						}
						return true
					} else if (isTaggedTemplateExpression(node)) {
						return (
							matchesPattern(node.tag, 'String.raw') &&
							!this.hasBinding('String', {
								noGlobals: true,
							}) &&
							this.isPure(node.quasi, constantsOnly)
						)
					} else if (isMemberExpression(node)) {
						return (
							!node.computed &&
							isIdentifier(node.object) &&
							node.object.name === 'Symbol' &&
							isIdentifier(node.property) &&
							node.property.name !== 'for' &&
							!this.hasBinding('Symbol', {
								noGlobals: true,
							})
						)
					} else if (isCallExpression(node)) {
						return (
							matchesPattern(node.callee, 'Symbol.for') &&
							!this.hasBinding('Symbol', {
								noGlobals: true,
							}) &&
							node.arguments.length === 1 &&
							t.isStringLiteral(node.arguments[0])
						)
					} else {
						return isPureish(node)
					}
				}
				setData(key, val) {
					return (this.data[key] = val)
				}
				getData(key) {
					let scope = this
					do {
						const data = scope.data[key]
						if (data != null) return data
					} while ((scope = scope.parent))
				}
				removeData(key) {
					let scope = this
					do {
						const data = scope.data[key]
						if (data != null) scope.data[key] = null
					} while ((scope = scope.parent))
				}
				init() {
					if (!this.inited) {
						this.inited = true
						this.crawl()
					}
				}
				crawl() {
					const path = this.path
					resetScope(this)
					this.data = Object.create(null)
					let scope = this
					do {
						if (scope.crawling) return
						if (scope.path.isProgram()) {
							break
						}
					} while ((scope = scope.parent))
					const programParent = scope
					const state = {
						references: [],
						constantViolations: [],
						assignments: [],
					}
					this.crawling = true
					scopeVisitor ||
						(scopeVisitor = _index.default.visitors.merge([
							{
								Scope(path) {
									resetScope(path.scope)
								},
							},
							collectorVisitor,
						]))
					if (path.type !== 'Program') {
						for (const visit of scopeVisitor.enter) {
							visit.call(state, path, state)
						}
						const typeVisitors = scopeVisitor[path.type]
						if (typeVisitors) {
							for (const visit of typeVisitors.enter) {
								visit.call(state, path, state)
							}
						}
					}
					path.traverse(scopeVisitor, state)
					this.crawling = false
					for (const path of state.assignments) {
						const ids = path.getAssignmentIdentifiers()
						for (const name of Object.keys(ids)) {
							if (path.scope.getBinding(name)) continue
							programParent.addGlobal(ids[name])
						}
						path.scope.registerConstantViolation(path)
					}
					for (const ref of state.references) {
						const binding = ref.scope.getBinding(ref.node.name)
						if (binding) {
							binding.reference(ref)
						} else {
							programParent.addGlobal(ref.node)
						}
					}
					for (const path of state.constantViolations) {
						path.scope.registerConstantViolation(path)
					}
				}
				push(opts) {
					let path = this.path
					if (path.isPattern()) {
						path = this.getPatternParent().path
					} else if (!path.isBlockStatement() && !path.isProgram()) {
						path = this.getBlockParent().path
					}
					if (path.isSwitchStatement()) {
						path = (this.getFunctionParent() || this.getProgramParent()).path
					}
					const { init, unique, kind = 'var', id } = opts
					if (
						!init &&
						!unique &&
						(kind === 'var' || kind === 'let') &&
						path.isFunction() &&
						!path.node.name &&
						isCallExpression(path.parent, {
							callee: path.node,
						}) &&
						path.parent.arguments.length <= path.node.params.length &&
						isIdentifier(id)
					) {
						path.pushContainer('params', id)
						path.scope.registerBinding(
							'param',
							path.get('params')[path.node.params.length - 1],
						)
						return
					}
					if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
						path.ensureBlock()
						path = path.get('body')
					}
					const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist
					const dataKey = `declaration:${kind}:${blockHoist}`
					let declarPath = !unique && path.getData(dataKey)
					if (!declarPath) {
						const declar = variableDeclaration(kind, [])
						declar._blockHoist = blockHoist
						;[declarPath] = path.unshiftContainer('body', [declar])
						if (!unique) path.setData(dataKey, declarPath)
					}
					const declarator = variableDeclarator(id, init)
					const len = declarPath.node.declarations.push(declarator)
					path.scope.registerBinding(
						kind,
						declarPath.get('declarations')[len - 1],
					)
				}
				getProgramParent() {
					let scope = this
					do {
						if (scope.path.isProgram()) {
							return scope
						}
					} while ((scope = scope.parent))
					throw new Error("Couldn't find a Program")
				}
				getFunctionParent() {
					let scope = this
					do {
						if (scope.path.isFunctionParent()) {
							return scope
						}
					} while ((scope = scope.parent))
					return null
				}
				getBlockParent() {
					let scope = this
					do {
						if (scope.path.isBlockParent()) {
							return scope
						}
					} while ((scope = scope.parent))
					throw new Error(
						"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...",
					)
				}
				getPatternParent() {
					let scope = this
					do {
						if (!scope.path.isPattern()) {
							return scope.getBlockParent()
						}
					} while ((scope = scope.parent.parent))
					throw new Error(
						"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...",
					)
				}
				getAllBindings() {
					const ids = Object.create(null)
					let scope = this
					do {
						for (const key of Object.keys(scope.bindings)) {
							if (key in ids === false) {
								ids[key] = scope.bindings[key]
							}
						}
						scope = scope.parent
					} while (scope)
					return ids
				}
				bindingIdentifierEquals(name, node) {
					return this.getBindingIdentifier(name) === node
				}
				getBinding(name) {
					let scope = this
					let previousPath
					do {
						const binding = scope.getOwnBinding(name)
						if (binding) {
							var _previousPath
							if (
								(_previousPath = previousPath) != null &&
								_previousPath.isPattern() &&
								binding.kind !== 'param' &&
								binding.kind !== 'local'
							) {
							} else {
								return binding
							}
						} else if (
							!binding &&
							name === 'arguments' &&
							scope.path.isFunction() &&
							!scope.path.isArrowFunctionExpression()
						) {
							break
						}
						previousPath = scope.path
					} while ((scope = scope.parent))
				}
				getOwnBinding(name) {
					return this.bindings[name]
				}
				getBindingIdentifier(name) {
					var _this$getBinding2
					return (_this$getBinding2 = this.getBinding(name)) == null
						? void 0
						: _this$getBinding2.identifier
				}
				getOwnBindingIdentifier(name) {
					const binding = this.bindings[name]
					return binding == null ? void 0 : binding.identifier
				}
				hasOwnBinding(name) {
					return !!this.getOwnBinding(name)
				}
				hasBinding(name, opts) {
					if (!name) return false
					let noGlobals
					let noUids
					let upToScope
					if (typeof opts === 'object') {
						noGlobals = opts.noGlobals
						noUids = opts.noUids
						upToScope = opts.upToScope
					} else if (typeof opts === 'boolean') {
						noGlobals = opts
					}
					let scope = this
					do {
						if (upToScope === scope) {
							break
						}
						if (scope.hasOwnBinding(name)) {
							return true
						}
					} while ((scope = scope.parent))
					if (!noUids && this.hasUid(name)) return true
					if (!noGlobals && Scope.globals.includes(name)) return true
					if (!noGlobals && Scope.contextVariables.includes(name)) return true
					return false
				}
				parentHasBinding(name, opts) {
					var _this$parent
					return (_this$parent = this.parent) == null
						? void 0
						: _this$parent.hasBinding(name, opts)
				}
				moveBindingTo(name, scope) {
					const info = this.getBinding(name)
					if (info) {
						info.scope.removeOwnBinding(name)
						info.scope = scope
						scope.bindings[name] = info
					}
				}
				removeOwnBinding(name) {
					delete this.bindings[name]
				}
				removeBinding(name) {
					var _this$getBinding3
					;(_this$getBinding3 = this.getBinding(name)) == null ||
						_this$getBinding3.scope.removeOwnBinding(name)
					let scope = this
					do {
						if (scope.uids[name]) {
							scope.uids[name] = false
						}
					} while ((scope = scope.parent))
				}
				hoistVariables(
					emit = (id) =>
						this.push({
							id,
						}),
				) {
					this.crawl()
					const seen = new Set()
					for (const name of Object.keys(this.bindings)) {
						const binding = this.bindings[name]
						if (!binding) continue
						const { path } = binding
						if (!path.isVariableDeclarator()) continue
						const { parent, parentPath } = path
						if (parent.kind !== 'var' || seen.has(parent)) continue
						seen.add(path.parent)
						let firstId
						const init = []
						for (const decl of parent.declarations) {
							firstId != null ? firstId : (firstId = decl.id)
							if (decl.init) {
								init.push(assignmentExpression('=', decl.id, decl.init))
							}
							const ids = Object.keys(
								getBindingIdentifiers(decl, false, true, true),
							)
							for (const name of ids) {
								emit(identifier(name), decl.init != null)
							}
						}
						if (
							parentPath.parentPath.isFor({
								left: parent,
							})
						) {
							parentPath.replaceWith(firstId)
						} else if (init.length === 0) {
							parentPath.remove()
						} else {
							const expr =
								init.length === 1 ? init[0] : sequenceExpression(init)
							if (
								parentPath.parentPath.isForStatement({
									init: parent,
								})
							) {
								parentPath.replaceWith(expr)
							} else {
								parentPath.replaceWith(expressionStatement(expr))
							}
						}
					}
				}
			}
			exports['default'] = Scope
			Scope.globals = Object.keys(_globals.builtin)
			Scope.contextVariables = ['arguments', 'undefined', 'Infinity', 'NaN']
			{
				Scope.prototype._renameFromMap = function _renameFromMap(
					map,
					oldName,
					newName,
					value,
				) {
					if (map[oldName]) {
						map[newName] = value
						map[oldName] = null
					}
				}
				Scope.prototype.traverse = function (node, opts, state) {
					;(0, _index.default)(node, opts, this, state, this.path)
				}
				Scope.prototype._generateUid = function _generateUid(name, i) {
					let id = name
					if (i > 1) id += i
					return `_${id}`
				}
				Scope.prototype.toArray = function toArray(
					node,
					i,
					arrayLikeIsIterable,
				) {
					if (isIdentifier(node)) {
						const binding = this.getBinding(node.name)
						if (
							binding != null &&
							binding.constant &&
							binding.path.isGenericType('Array')
						) {
							return node
						}
					}
					if (isArrayExpression(node)) {
						return node
					}
					if (
						isIdentifier(node, {
							name: 'arguments',
						})
					) {
						return callExpression(
							memberExpression(
								memberExpression(
									memberExpression(
										identifier('Array'),
										identifier('prototype'),
									),
									identifier('slice'),
								),
								identifier('call'),
							),
							[node],
						)
					}
					let helperName
					const args = [node]
					if (i === true) {
						helperName = 'toConsumableArray'
					} else if (typeof i === 'number') {
						args.push(numericLiteral(i))
						helperName = 'slicedToArray'
					} else {
						helperName = 'toArray'
					}
					if (arrayLikeIsIterable) {
						args.unshift(this.path.hub.addHelper(helperName))
						helperName = 'maybeArrayLike'
					}
					return callExpression(this.path.hub.addHelper(helperName), args)
				}
				Scope.prototype.getAllBindingsOfKind = function getAllBindingsOfKind(
					...kinds
				) {
					const ids = Object.create(null)
					for (const kind of kinds) {
						let scope = this
						do {
							for (const name of Object.keys(scope.bindings)) {
								const binding = scope.bindings[name]
								if (binding.kind === kind) ids[name] = binding
							}
							scope = scope.parent
						} while (scope)
					}
					return ids
				}
				Object.defineProperties(Scope.prototype, {
					parentBlock: {
						configurable: true,
						enumerable: true,
						get() {
							return this.path.parent
						},
					},
					hub: {
						configurable: true,
						enumerable: true,
						get() {
							return this.path.hub
						},
					},
				})
			}

			//# sourceMappingURL=index.js.map

			/***/
		},

		/***/ 99391: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = void 0
			var t = __nccwpck_require__(16535)
			var _t = t
			var _traverseNode = __nccwpck_require__(95469)
			var _visitors = __nccwpck_require__(38133)
			var _context = __nccwpck_require__(74105)
			const { getAssignmentIdentifiers } = _t
			const renameVisitor = {
				ReferencedIdentifier({ node }, state) {
					if (node.name === state.oldName) {
						node.name = state.newName
					}
				},
				Scope(path, state) {
					if (
						!path.scope.bindingIdentifierEquals(
							state.oldName,
							state.binding.identifier,
						)
					) {
						path.skip()
						if (path.isMethod()) {
							if (!path.requeueComputedKeyAndDecorators) {
								_context.requeueComputedKeyAndDecorators.call(path)
							} else {
								path.requeueComputedKeyAndDecorators()
							}
						}
					}
				},
				ObjectProperty({ node, scope }, state) {
					const { name } = node.key
					if (
						node.shorthand &&
						(name === state.oldName || name === state.newName) &&
						scope.getBindingIdentifier(name) === state.binding.identifier
					) {
						node.shorthand = false
						{
							var _node$extra
							if ((_node$extra = node.extra) != null && _node$extra.shorthand)
								node.extra.shorthand = false
						}
					}
				},
				'AssignmentExpression|Declaration|VariableDeclarator'(path, state) {
					if (path.isVariableDeclaration()) return
					const ids = path.isAssignmentExpression()
						? getAssignmentIdentifiers(path.node)
						: path.getOuterBindingIdentifiers()
					for (const name in ids) {
						if (name === state.oldName) ids[name].name = state.newName
					}
				},
			}
			class Renamer {
				constructor(binding, oldName, newName) {
					this.newName = newName
					this.oldName = oldName
					this.binding = binding
				}
				maybeConvertFromExportDeclaration(parentDeclar) {
					const maybeExportDeclar = parentDeclar.parentPath
					if (!maybeExportDeclar.isExportDeclaration()) {
						return
					}
					if (maybeExportDeclar.isExportDefaultDeclaration()) {
						const { declaration } = maybeExportDeclar.node
						if (t.isDeclaration(declaration) && !declaration.id) {
							return
						}
					}
					if (maybeExportDeclar.isExportAllDeclaration()) {
						return
					}
					maybeExportDeclar.splitExportDeclaration()
				}
				maybeConvertFromClassFunctionDeclaration(path) {
					return path
				}
				maybeConvertFromClassFunctionExpression(path) {
					return path
				}
				rename() {
					const { binding, oldName, newName } = this
					const { scope, path } = binding
					const parentDeclar = path.find(
						(path) =>
							path.isDeclaration() ||
							path.isFunctionExpression() ||
							path.isClassExpression(),
					)
					if (parentDeclar) {
						const bindingIds = parentDeclar.getOuterBindingIdentifiers()
						if (bindingIds[oldName] === binding.identifier) {
							this.maybeConvertFromExportDeclaration(parentDeclar)
						}
					}
					const blockToTraverse = arguments[0] || scope.block
					const skipKeys = {
						discriminant: true,
					}
					if (t.isMethod(blockToTraverse)) {
						if (blockToTraverse.computed) {
							skipKeys.key = true
						}
						if (!t.isObjectMethod(blockToTraverse)) {
							skipKeys.decorators = true
						}
					}
					;(0, _traverseNode.traverseNode)(
						blockToTraverse,
						(0, _visitors.explode)(renameVisitor),
						scope,
						this,
						scope.path,
						skipKeys,
					)
					if (!arguments[0]) {
						scope.removeOwnBinding(oldName)
						scope.bindings[newName] = binding
						this.binding.identifier.name = newName
					}
					if (parentDeclar) {
						this.maybeConvertFromClassFunctionDeclaration(path)
						this.maybeConvertFromClassFunctionExpression(path)
					}
				}
			}
			exports['default'] = Renamer

			//# sourceMappingURL=renamer.js.map

			/***/
		},

		/***/ 95469: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.traverseNode = traverseNode
			var _context = __nccwpck_require__(49767)
			var _index = __nccwpck_require__(91806)
			var _t = __nccwpck_require__(16535)
			var _context2 = __nccwpck_require__(74105)
			const { VISITOR_KEYS } = _t
			function _visitPaths(ctx, paths) {
				ctx.queue = paths
				ctx.priorityQueue = []
				const visited = new Set()
				let stop = false
				let visitIndex = 0
				for (; visitIndex < paths.length; ) {
					const path = paths[visitIndex]
					visitIndex++
					_context2.resync.call(path)
					if (
						path.contexts.length === 0 ||
						path.contexts[path.contexts.length - 1] !== ctx
					) {
						_context2.pushContext.call(path, ctx)
					}
					if (path.key === null) continue
					const { node } = path
					if (visited.has(node)) continue
					if (node) visited.add(node)
					if (_visit(ctx, path)) {
						stop = true
						break
					}
					if (ctx.priorityQueue.length) {
						stop = _visitPaths(ctx, ctx.priorityQueue)
						ctx.priorityQueue = []
						ctx.queue = paths
						if (stop) break
					}
				}
				for (let i = 0; i < visitIndex; i++) {
					_context2.popContext.call(paths[i])
				}
				ctx.queue = null
				return stop
			}
			function _visit(ctx, path) {
				var _opts$denylist
				const node = path.node
				if (!node) {
					return false
				}
				const opts = ctx.opts
				const denylist =
					(_opts$denylist = opts.denylist) != null
						? _opts$denylist
						: opts.blacklist
				if (denylist != null && denylist.includes(node.type)) {
					return false
				}
				if (opts.shouldSkip != null && opts.shouldSkip(path)) {
					return false
				}
				if (path.shouldSkip) return path.shouldStop
				if (_context2._call.call(path, opts.enter)) return path.shouldStop
				if (path.node) {
					var _opts$node$type
					if (
						_context2._call.call(
							path,
							(_opts$node$type = opts[node.type]) == null
								? void 0
								: _opts$node$type.enter,
						)
					)
						return path.shouldStop
				}
				path.shouldStop = _traverse(
					path.node,
					opts,
					path.scope,
					ctx.state,
					path,
					path.skipKeys,
				)
				if (path.node) {
					if (_context2._call.call(path, opts.exit)) return true
				}
				if (path.node) {
					var _opts$node$type2
					_context2._call.call(
						path,
						(_opts$node$type2 = opts[node.type]) == null
							? void 0
							: _opts$node$type2.exit,
					)
				}
				return path.shouldStop
			}
			function _traverse(node, opts, scope, state, path, skipKeys, visitSelf) {
				const keys = VISITOR_KEYS[node.type]
				if (!(keys != null && keys.length)) return false
				const ctx = new _context.default(scope, opts, state, path)
				if (visitSelf) {
					if (skipKeys != null && skipKeys[path.parentKey]) return false
					return _visitPaths(ctx, [path])
				}
				for (const key of keys) {
					if (skipKeys != null && skipKeys[key]) continue
					const prop = node[key]
					if (!prop) continue
					if (Array.isArray(prop)) {
						if (!prop.length) continue
						const paths = []
						for (let i = 0; i < prop.length; i++) {
							const childPath = _index.default.get({
								parentPath: path,
								parent: node,
								container: prop,
								key: i,
								listKey: key,
							})
							paths.push(childPath)
						}
						if (_visitPaths(ctx, paths)) return true
					} else {
						if (
							_visitPaths(ctx, [
								_index.default.get({
									parentPath: path,
									parent: node,
									container: node,
									key,
									listKey: null,
								}),
							])
						) {
							return true
						}
					}
				}
				return false
			}
			function traverseNode(
				node,
				opts,
				scope,
				state,
				path,
				skipKeys,
				visitSelf,
			) {
				const keys = VISITOR_KEYS[node.type]
				if (!keys) return false
				const context = new _context.default(scope, opts, state, path)
				if (visitSelf) {
					if (skipKeys != null && skipKeys[path.parentKey]) return false
					return context.visitQueue([path])
				}
				for (const key of keys) {
					if (skipKeys != null && skipKeys[key]) continue
					if (context.visit(node, key)) {
						return true
					}
				}
				return false
			}

			//# sourceMappingURL=traverse-node.js.map

			/***/
		},

		/***/ 38133: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.environmentVisitor = environmentVisitor
			exports.explode = explode$1
			exports.isExplodedVisitor = isExplodedVisitor
			exports.merge = merge
			exports.verify = verify$1
			var virtualTypes = __nccwpck_require__(74425)
			var virtualTypesValidators = __nccwpck_require__(66582)
			var _t = __nccwpck_require__(16535)
			var _context = __nccwpck_require__(74105)
			const {
				DEPRECATED_KEYS,
				DEPRECATED_ALIASES,
				FLIPPED_ALIAS_KEYS,
				TYPES,
				__internal__deprecationWarning: deprecationWarning,
			} = _t
			function isVirtualType(type) {
				return type in virtualTypes
			}
			function isExplodedVisitor(visitor) {
				return visitor == null ? void 0 : visitor._exploded
			}
			function explode$1(visitor) {
				if (isExplodedVisitor(visitor)) return visitor
				visitor._exploded = true
				for (const nodeType of Object.keys(visitor)) {
					if (shouldIgnoreKey(nodeType)) continue
					const parts = nodeType.split('|')
					if (parts.length === 1) continue
					const fns = visitor[nodeType]
					delete visitor[nodeType]
					for (const part of parts) {
						visitor[part] = fns
					}
				}
				verify$1(visitor)
				delete visitor.__esModule
				ensureEntranceObjects(visitor)
				ensureCallbackArrays(visitor)
				for (const nodeType of Object.keys(visitor)) {
					if (shouldIgnoreKey(nodeType)) continue
					if (!isVirtualType(nodeType)) continue
					const fns = visitor[nodeType]
					for (const type of Object.keys(fns)) {
						fns[type] = wrapCheck(nodeType, fns[type])
					}
					delete visitor[nodeType]
					const types = virtualTypes[nodeType]
					if (types !== null) {
						for (const type of types) {
							if (visitor[type]) {
								mergePair(visitor[type], fns)
							} else {
								visitor[type] = fns
							}
						}
					} else {
						mergePair(visitor, fns)
					}
				}
				for (const nodeType of Object.keys(visitor)) {
					if (shouldIgnoreKey(nodeType)) continue
					let aliases = FLIPPED_ALIAS_KEYS[nodeType]
					if (nodeType in DEPRECATED_KEYS) {
						const deprecatedKey = DEPRECATED_KEYS[nodeType]
						deprecationWarning(nodeType, deprecatedKey, 'Visitor ')
						aliases = [deprecatedKey]
					} else if (nodeType in DEPRECATED_ALIASES) {
						const deprecatedAlias = DEPRECATED_ALIASES[nodeType]
						deprecationWarning(nodeType, deprecatedAlias, 'Visitor ')
						aliases = FLIPPED_ALIAS_KEYS[deprecatedAlias]
					}
					if (!aliases) continue
					const fns = visitor[nodeType]
					delete visitor[nodeType]
					for (const alias of aliases) {
						const existing = visitor[alias]
						if (existing) {
							mergePair(existing, fns)
						} else {
							visitor[alias] = Object.assign({}, fns)
						}
					}
				}
				for (const nodeType of Object.keys(visitor)) {
					if (shouldIgnoreKey(nodeType)) continue
					ensureCallbackArrays(visitor[nodeType])
				}
				return visitor
			}
			function verify$1(visitor) {
				if (visitor._verified) return
				if (typeof visitor === 'function') {
					throw new Error(
						'You passed `traverse()` a function when it expected a visitor object, ' +
							"are you sure you didn't mean `{ enter: Function }`?",
					)
				}
				for (const nodeType of Object.keys(visitor)) {
					if (nodeType === 'enter' || nodeType === 'exit') {
						validateVisitorMethods(nodeType, visitor[nodeType])
					}
					if (shouldIgnoreKey(nodeType)) continue
					if (!TYPES.includes(nodeType)) {
						throw new Error(
							`You gave us a visitor for the node type ${nodeType} but it's not a valid type in @babel/traverse ${'7.27.1'}`,
						)
					}
					const visitors = visitor[nodeType]
					if (typeof visitors === 'object') {
						for (const visitorKey of Object.keys(visitors)) {
							if (visitorKey === 'enter' || visitorKey === 'exit') {
								validateVisitorMethods(
									`${nodeType}.${visitorKey}`,
									visitors[visitorKey],
								)
							} else {
								throw new Error(
									'You passed `traverse()` a visitor object with the property ' +
										`${nodeType} that has the invalid property ${visitorKey}`,
								)
							}
						}
					}
				}
				visitor._verified = true
			}
			function validateVisitorMethods(path, val) {
				const fns = [].concat(val)
				for (const fn of fns) {
					if (typeof fn !== 'function') {
						throw new TypeError(
							`Non-function found defined in ${path} with type ${typeof fn}`,
						)
					}
				}
			}
			function merge(visitors, states = [], wrapper) {
				const mergedVisitor = {
					_verified: true,
					_exploded: true,
				}
				{
					Object.defineProperty(mergedVisitor, '_exploded', {
						enumerable: false,
					})
					Object.defineProperty(mergedVisitor, '_verified', {
						enumerable: false,
					})
				}
				for (let i = 0; i < visitors.length; i++) {
					const visitor = explode$1(visitors[i])
					const state = states[i]
					let topVisitor = visitor
					if (state || wrapper) {
						topVisitor = wrapWithStateOrWrapper(topVisitor, state, wrapper)
					}
					mergePair(mergedVisitor, topVisitor)
					for (const key of Object.keys(visitor)) {
						if (shouldIgnoreKey(key)) continue
						let typeVisitor = visitor[key]
						if (state || wrapper) {
							typeVisitor = wrapWithStateOrWrapper(typeVisitor, state, wrapper)
						}
						const nodeVisitor = mergedVisitor[key] || (mergedVisitor[key] = {})
						mergePair(nodeVisitor, typeVisitor)
					}
				}
				return mergedVisitor
			}
			function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
				const newVisitor = {}
				for (const phase of ['enter', 'exit']) {
					let fns = oldVisitor[phase]
					if (!Array.isArray(fns)) continue
					fns = fns.map(function (fn) {
						let newFn = fn
						if (state) {
							newFn = function (path) {
								fn.call(state, path, state)
							}
						}
						if (wrapper) {
							newFn = wrapper(state == null ? void 0 : state.key, phase, newFn)
						}
						if (newFn !== fn) {
							newFn.toString = () => fn.toString()
						}
						return newFn
					})
					newVisitor[phase] = fns
				}
				return newVisitor
			}
			function ensureEntranceObjects(obj) {
				for (const key of Object.keys(obj)) {
					if (shouldIgnoreKey(key)) continue
					const fns = obj[key]
					if (typeof fns === 'function') {
						obj[key] = {
							enter: fns,
						}
					}
				}
			}
			function ensureCallbackArrays(obj) {
				if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter]
				if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit]
			}
			function wrapCheck(nodeType, fn) {
				const fnKey = `is${nodeType}`
				const validator = virtualTypesValidators[fnKey]
				const newFn = function (path) {
					if (validator.call(path)) {
						return fn.apply(this, arguments)
					}
				}
				newFn.toString = () => fn.toString()
				return newFn
			}
			function shouldIgnoreKey(key) {
				if (key[0] === '_') return true
				if (key === 'enter' || key === 'exit' || key === 'shouldSkip')
					return true
				if (key === 'denylist' || key === 'noScope' || key === 'skipKeys') {
					return true
				}
				{
					if (key === 'blacklist') {
						return true
					}
				}
				return false
			}
			function mergePair(dest, src) {
				for (const phase of ['enter', 'exit']) {
					if (!src[phase]) continue
					dest[phase] = [].concat(dest[phase] || [], src[phase])
				}
			}
			const _environmentVisitor = {
				FunctionParent(path) {
					if (path.isArrowFunctionExpression()) return
					path.skip()
					if (path.isMethod()) {
						if (!path.requeueComputedKeyAndDecorators) {
							_context.requeueComputedKeyAndDecorators.call(path)
						} else {
							path.requeueComputedKeyAndDecorators()
						}
					}
				},
				Property(path) {
					if (path.isObjectProperty()) return
					path.skip()
					if (!path.requeueComputedKeyAndDecorators) {
						_context.requeueComputedKeyAndDecorators.call(path)
					} else {
						path.requeueComputedKeyAndDecorators()
					}
				},
			}
			function environmentVisitor(visitor) {
				return merge([_environmentVisitor, visitor])
			}

			//# sourceMappingURL=visitors.js.map

			/***/
		},

		/***/ 41737: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = assertNode
			var _isNode = __nccwpck_require__(84503)
			function assertNode(node) {
				if (!(0, _isNode.default)(node)) {
					var _node$type
					const type =
						(_node$type = node == null ? void 0 : node.type) != null
							? _node$type
							: JSON.stringify(node)
					throw new TypeError(`Not a valid node of type "${type}"`)
				}
			}

			//# sourceMappingURL=assertNode.js.map

			/***/
		},

		/***/ 98345: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.assertAccessor = assertAccessor
			exports.assertAnyTypeAnnotation = assertAnyTypeAnnotation
			exports.assertArgumentPlaceholder = assertArgumentPlaceholder
			exports.assertArrayExpression = assertArrayExpression
			exports.assertArrayPattern = assertArrayPattern
			exports.assertArrayTypeAnnotation = assertArrayTypeAnnotation
			exports.assertArrowFunctionExpression = assertArrowFunctionExpression
			exports.assertAssignmentExpression = assertAssignmentExpression
			exports.assertAssignmentPattern = assertAssignmentPattern
			exports.assertAwaitExpression = assertAwaitExpression
			exports.assertBigIntLiteral = assertBigIntLiteral
			exports.assertBinary = assertBinary
			exports.assertBinaryExpression = assertBinaryExpression
			exports.assertBindExpression = assertBindExpression
			exports.assertBlock = assertBlock
			exports.assertBlockParent = assertBlockParent
			exports.assertBlockStatement = assertBlockStatement
			exports.assertBooleanLiteral = assertBooleanLiteral
			exports.assertBooleanLiteralTypeAnnotation =
				assertBooleanLiteralTypeAnnotation
			exports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation
			exports.assertBreakStatement = assertBreakStatement
			exports.assertCallExpression = assertCallExpression
			exports.assertCatchClause = assertCatchClause
			exports.assertClass = assertClass
			exports.assertClassAccessorProperty = assertClassAccessorProperty
			exports.assertClassBody = assertClassBody
			exports.assertClassDeclaration = assertClassDeclaration
			exports.assertClassExpression = assertClassExpression
			exports.assertClassImplements = assertClassImplements
			exports.assertClassMethod = assertClassMethod
			exports.assertClassPrivateMethod = assertClassPrivateMethod
			exports.assertClassPrivateProperty = assertClassPrivateProperty
			exports.assertClassProperty = assertClassProperty
			exports.assertCompletionStatement = assertCompletionStatement
			exports.assertConditional = assertConditional
			exports.assertConditionalExpression = assertConditionalExpression
			exports.assertContinueStatement = assertContinueStatement
			exports.assertDebuggerStatement = assertDebuggerStatement
			exports.assertDecimalLiteral = assertDecimalLiteral
			exports.assertDeclaration = assertDeclaration
			exports.assertDeclareClass = assertDeclareClass
			exports.assertDeclareExportAllDeclaration =
				assertDeclareExportAllDeclaration
			exports.assertDeclareExportDeclaration = assertDeclareExportDeclaration
			exports.assertDeclareFunction = assertDeclareFunction
			exports.assertDeclareInterface = assertDeclareInterface
			exports.assertDeclareModule = assertDeclareModule
			exports.assertDeclareModuleExports = assertDeclareModuleExports
			exports.assertDeclareOpaqueType = assertDeclareOpaqueType
			exports.assertDeclareTypeAlias = assertDeclareTypeAlias
			exports.assertDeclareVariable = assertDeclareVariable
			exports.assertDeclaredPredicate = assertDeclaredPredicate
			exports.assertDecorator = assertDecorator
			exports.assertDirective = assertDirective
			exports.assertDirectiveLiteral = assertDirectiveLiteral
			exports.assertDoExpression = assertDoExpression
			exports.assertDoWhileStatement = assertDoWhileStatement
			exports.assertEmptyStatement = assertEmptyStatement
			exports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation
			exports.assertEnumBody = assertEnumBody
			exports.assertEnumBooleanBody = assertEnumBooleanBody
			exports.assertEnumBooleanMember = assertEnumBooleanMember
			exports.assertEnumDeclaration = assertEnumDeclaration
			exports.assertEnumDefaultedMember = assertEnumDefaultedMember
			exports.assertEnumMember = assertEnumMember
			exports.assertEnumNumberBody = assertEnumNumberBody
			exports.assertEnumNumberMember = assertEnumNumberMember
			exports.assertEnumStringBody = assertEnumStringBody
			exports.assertEnumStringMember = assertEnumStringMember
			exports.assertEnumSymbolBody = assertEnumSymbolBody
			exports.assertExistsTypeAnnotation = assertExistsTypeAnnotation
			exports.assertExportAllDeclaration = assertExportAllDeclaration
			exports.assertExportDeclaration = assertExportDeclaration
			exports.assertExportDefaultDeclaration = assertExportDefaultDeclaration
			exports.assertExportDefaultSpecifier = assertExportDefaultSpecifier
			exports.assertExportNamedDeclaration = assertExportNamedDeclaration
			exports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier
			exports.assertExportSpecifier = assertExportSpecifier
			exports.assertExpression = assertExpression
			exports.assertExpressionStatement = assertExpressionStatement
			exports.assertExpressionWrapper = assertExpressionWrapper
			exports.assertFile = assertFile
			exports.assertFlow = assertFlow
			exports.assertFlowBaseAnnotation = assertFlowBaseAnnotation
			exports.assertFlowDeclaration = assertFlowDeclaration
			exports.assertFlowPredicate = assertFlowPredicate
			exports.assertFlowType = assertFlowType
			exports.assertFor = assertFor
			exports.assertForInStatement = assertForInStatement
			exports.assertForOfStatement = assertForOfStatement
			exports.assertForStatement = assertForStatement
			exports.assertForXStatement = assertForXStatement
			exports.assertFunction = assertFunction
			exports.assertFunctionDeclaration = assertFunctionDeclaration
			exports.assertFunctionExpression = assertFunctionExpression
			exports.assertFunctionParent = assertFunctionParent
			exports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation
			exports.assertFunctionTypeParam = assertFunctionTypeParam
			exports.assertGenericTypeAnnotation = assertGenericTypeAnnotation
			exports.assertIdentifier = assertIdentifier
			exports.assertIfStatement = assertIfStatement
			exports.assertImmutable = assertImmutable
			exports.assertImport = assertImport
			exports.assertImportAttribute = assertImportAttribute
			exports.assertImportDeclaration = assertImportDeclaration
			exports.assertImportDefaultSpecifier = assertImportDefaultSpecifier
			exports.assertImportExpression = assertImportExpression
			exports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier
			exports.assertImportOrExportDeclaration = assertImportOrExportDeclaration
			exports.assertImportSpecifier = assertImportSpecifier
			exports.assertIndexedAccessType = assertIndexedAccessType
			exports.assertInferredPredicate = assertInferredPredicate
			exports.assertInterfaceDeclaration = assertInterfaceDeclaration
			exports.assertInterfaceExtends = assertInterfaceExtends
			exports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation
			exports.assertInterpreterDirective = assertInterpreterDirective
			exports.assertIntersectionTypeAnnotation =
				assertIntersectionTypeAnnotation
			exports.assertJSX = assertJSX
			exports.assertJSXAttribute = assertJSXAttribute
			exports.assertJSXClosingElement = assertJSXClosingElement
			exports.assertJSXClosingFragment = assertJSXClosingFragment
			exports.assertJSXElement = assertJSXElement
			exports.assertJSXEmptyExpression = assertJSXEmptyExpression
			exports.assertJSXExpressionContainer = assertJSXExpressionContainer
			exports.assertJSXFragment = assertJSXFragment
			exports.assertJSXIdentifier = assertJSXIdentifier
			exports.assertJSXMemberExpression = assertJSXMemberExpression
			exports.assertJSXNamespacedName = assertJSXNamespacedName
			exports.assertJSXOpeningElement = assertJSXOpeningElement
			exports.assertJSXOpeningFragment = assertJSXOpeningFragment
			exports.assertJSXSpreadAttribute = assertJSXSpreadAttribute
			exports.assertJSXSpreadChild = assertJSXSpreadChild
			exports.assertJSXText = assertJSXText
			exports.assertLVal = assertLVal
			exports.assertLabeledStatement = assertLabeledStatement
			exports.assertLiteral = assertLiteral
			exports.assertLogicalExpression = assertLogicalExpression
			exports.assertLoop = assertLoop
			exports.assertMemberExpression = assertMemberExpression
			exports.assertMetaProperty = assertMetaProperty
			exports.assertMethod = assertMethod
			exports.assertMiscellaneous = assertMiscellaneous
			exports.assertMixedTypeAnnotation = assertMixedTypeAnnotation
			exports.assertModuleDeclaration = assertModuleDeclaration
			exports.assertModuleExpression = assertModuleExpression
			exports.assertModuleSpecifier = assertModuleSpecifier
			exports.assertNewExpression = assertNewExpression
			exports.assertNoop = assertNoop
			exports.assertNullLiteral = assertNullLiteral
			exports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation
			exports.assertNullableTypeAnnotation = assertNullableTypeAnnotation
			exports.assertNumberLiteral = assertNumberLiteral
			exports.assertNumberLiteralTypeAnnotation =
				assertNumberLiteralTypeAnnotation
			exports.assertNumberTypeAnnotation = assertNumberTypeAnnotation
			exports.assertNumericLiteral = assertNumericLiteral
			exports.assertObjectExpression = assertObjectExpression
			exports.assertObjectMember = assertObjectMember
			exports.assertObjectMethod = assertObjectMethod
			exports.assertObjectPattern = assertObjectPattern
			exports.assertObjectProperty = assertObjectProperty
			exports.assertObjectTypeAnnotation = assertObjectTypeAnnotation
			exports.assertObjectTypeCallProperty = assertObjectTypeCallProperty
			exports.assertObjectTypeIndexer = assertObjectTypeIndexer
			exports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot
			exports.assertObjectTypeProperty = assertObjectTypeProperty
			exports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty
			exports.assertOpaqueType = assertOpaqueType
			exports.assertOptionalCallExpression = assertOptionalCallExpression
			exports.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType
			exports.assertOptionalMemberExpression = assertOptionalMemberExpression
			exports.assertParenthesizedExpression = assertParenthesizedExpression
			exports.assertPattern = assertPattern
			exports.assertPatternLike = assertPatternLike
			exports.assertPipelineBareFunction = assertPipelineBareFunction
			exports.assertPipelinePrimaryTopicReference =
				assertPipelinePrimaryTopicReference
			exports.assertPipelineTopicExpression = assertPipelineTopicExpression
			exports.assertPlaceholder = assertPlaceholder
			exports.assertPrivate = assertPrivate
			exports.assertPrivateName = assertPrivateName
			exports.assertProgram = assertProgram
			exports.assertProperty = assertProperty
			exports.assertPureish = assertPureish
			exports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier
			exports.assertRecordExpression = assertRecordExpression
			exports.assertRegExpLiteral = assertRegExpLiteral
			exports.assertRegexLiteral = assertRegexLiteral
			exports.assertRestElement = assertRestElement
			exports.assertRestProperty = assertRestProperty
			exports.assertReturnStatement = assertReturnStatement
			exports.assertScopable = assertScopable
			exports.assertSequenceExpression = assertSequenceExpression
			exports.assertSpreadElement = assertSpreadElement
			exports.assertSpreadProperty = assertSpreadProperty
			exports.assertStandardized = assertStandardized
			exports.assertStatement = assertStatement
			exports.assertStaticBlock = assertStaticBlock
			exports.assertStringLiteral = assertStringLiteral
			exports.assertStringLiteralTypeAnnotation =
				assertStringLiteralTypeAnnotation
			exports.assertStringTypeAnnotation = assertStringTypeAnnotation
			exports.assertSuper = assertSuper
			exports.assertSwitchCase = assertSwitchCase
			exports.assertSwitchStatement = assertSwitchStatement
			exports.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation
			exports.assertTSAnyKeyword = assertTSAnyKeyword
			exports.assertTSArrayType = assertTSArrayType
			exports.assertTSAsExpression = assertTSAsExpression
			exports.assertTSBaseType = assertTSBaseType
			exports.assertTSBigIntKeyword = assertTSBigIntKeyword
			exports.assertTSBooleanKeyword = assertTSBooleanKeyword
			exports.assertTSCallSignatureDeclaration =
				assertTSCallSignatureDeclaration
			exports.assertTSConditionalType = assertTSConditionalType
			exports.assertTSConstructSignatureDeclaration =
				assertTSConstructSignatureDeclaration
			exports.assertTSConstructorType = assertTSConstructorType
			exports.assertTSDeclareFunction = assertTSDeclareFunction
			exports.assertTSDeclareMethod = assertTSDeclareMethod
			exports.assertTSEntityName = assertTSEntityName
			exports.assertTSEnumBody = assertTSEnumBody
			exports.assertTSEnumDeclaration = assertTSEnumDeclaration
			exports.assertTSEnumMember = assertTSEnumMember
			exports.assertTSExportAssignment = assertTSExportAssignment
			exports.assertTSExpressionWithTypeArguments =
				assertTSExpressionWithTypeArguments
			exports.assertTSExternalModuleReference = assertTSExternalModuleReference
			exports.assertTSFunctionType = assertTSFunctionType
			exports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration
			exports.assertTSImportType = assertTSImportType
			exports.assertTSIndexSignature = assertTSIndexSignature
			exports.assertTSIndexedAccessType = assertTSIndexedAccessType
			exports.assertTSInferType = assertTSInferType
			exports.assertTSInstantiationExpression = assertTSInstantiationExpression
			exports.assertTSInterfaceBody = assertTSInterfaceBody
			exports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration
			exports.assertTSIntersectionType = assertTSIntersectionType
			exports.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword
			exports.assertTSLiteralType = assertTSLiteralType
			exports.assertTSMappedType = assertTSMappedType
			exports.assertTSMethodSignature = assertTSMethodSignature
			exports.assertTSModuleBlock = assertTSModuleBlock
			exports.assertTSModuleDeclaration = assertTSModuleDeclaration
			exports.assertTSNamedTupleMember = assertTSNamedTupleMember
			exports.assertTSNamespaceExportDeclaration =
				assertTSNamespaceExportDeclaration
			exports.assertTSNeverKeyword = assertTSNeverKeyword
			exports.assertTSNonNullExpression = assertTSNonNullExpression
			exports.assertTSNullKeyword = assertTSNullKeyword
			exports.assertTSNumberKeyword = assertTSNumberKeyword
			exports.assertTSObjectKeyword = assertTSObjectKeyword
			exports.assertTSOptionalType = assertTSOptionalType
			exports.assertTSParameterProperty = assertTSParameterProperty
			exports.assertTSParenthesizedType = assertTSParenthesizedType
			exports.assertTSPropertySignature = assertTSPropertySignature
			exports.assertTSQualifiedName = assertTSQualifiedName
			exports.assertTSRestType = assertTSRestType
			exports.assertTSSatisfiesExpression = assertTSSatisfiesExpression
			exports.assertTSStringKeyword = assertTSStringKeyword
			exports.assertTSSymbolKeyword = assertTSSymbolKeyword
			exports.assertTSTemplateLiteralType = assertTSTemplateLiteralType
			exports.assertTSThisType = assertTSThisType
			exports.assertTSTupleType = assertTSTupleType
			exports.assertTSType = assertTSType
			exports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration
			exports.assertTSTypeAnnotation = assertTSTypeAnnotation
			exports.assertTSTypeAssertion = assertTSTypeAssertion
			exports.assertTSTypeElement = assertTSTypeElement
			exports.assertTSTypeLiteral = assertTSTypeLiteral
			exports.assertTSTypeOperator = assertTSTypeOperator
			exports.assertTSTypeParameter = assertTSTypeParameter
			exports.assertTSTypeParameterDeclaration =
				assertTSTypeParameterDeclaration
			exports.assertTSTypeParameterInstantiation =
				assertTSTypeParameterInstantiation
			exports.assertTSTypePredicate = assertTSTypePredicate
			exports.assertTSTypeQuery = assertTSTypeQuery
			exports.assertTSTypeReference = assertTSTypeReference
			exports.assertTSUndefinedKeyword = assertTSUndefinedKeyword
			exports.assertTSUnionType = assertTSUnionType
			exports.assertTSUnknownKeyword = assertTSUnknownKeyword
			exports.assertTSVoidKeyword = assertTSVoidKeyword
			exports.assertTaggedTemplateExpression = assertTaggedTemplateExpression
			exports.assertTemplateElement = assertTemplateElement
			exports.assertTemplateLiteral = assertTemplateLiteral
			exports.assertTerminatorless = assertTerminatorless
			exports.assertThisExpression = assertThisExpression
			exports.assertThisTypeAnnotation = assertThisTypeAnnotation
			exports.assertThrowStatement = assertThrowStatement
			exports.assertTopicReference = assertTopicReference
			exports.assertTryStatement = assertTryStatement
			exports.assertTupleExpression = assertTupleExpression
			exports.assertTupleTypeAnnotation = assertTupleTypeAnnotation
			exports.assertTypeAlias = assertTypeAlias
			exports.assertTypeAnnotation = assertTypeAnnotation
			exports.assertTypeCastExpression = assertTypeCastExpression
			exports.assertTypeParameter = assertTypeParameter
			exports.assertTypeParameterDeclaration = assertTypeParameterDeclaration
			exports.assertTypeParameterInstantiation =
				assertTypeParameterInstantiation
			exports.assertTypeScript = assertTypeScript
			exports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation
			exports.assertUnaryExpression = assertUnaryExpression
			exports.assertUnaryLike = assertUnaryLike
			exports.assertUnionTypeAnnotation = assertUnionTypeAnnotation
			exports.assertUpdateExpression = assertUpdateExpression
			exports.assertUserWhitespacable = assertUserWhitespacable
			exports.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier
			exports.assertVariableDeclaration = assertVariableDeclaration
			exports.assertVariableDeclarator = assertVariableDeclarator
			exports.assertVariance = assertVariance
			exports.assertVoidTypeAnnotation = assertVoidTypeAnnotation
			exports.assertWhile = assertWhile
			exports.assertWhileStatement = assertWhileStatement
			exports.assertWithStatement = assertWithStatement
			exports.assertYieldExpression = assertYieldExpression
			var _is = __nccwpck_require__(20051)
			var _deprecationWarning = __nccwpck_require__(14711)
			function assert(type, node, opts) {
				if (!(0, _is.default)(type, node, opts)) {
					throw new Error(
						`Expected type "${type}" with option ${JSON.stringify(opts)}, ` +
							`but instead got "${node.type}".`,
					)
				}
			}
			function assertArrayExpression(node, opts) {
				assert('ArrayExpression', node, opts)
			}
			function assertAssignmentExpression(node, opts) {
				assert('AssignmentExpression', node, opts)
			}
			function assertBinaryExpression(node, opts) {
				assert('BinaryExpression', node, opts)
			}
			function assertInterpreterDirective(node, opts) {
				assert('InterpreterDirective', node, opts)
			}
			function assertDirective(node, opts) {
				assert('Directive', node, opts)
			}
			function assertDirectiveLiteral(node, opts) {
				assert('DirectiveLiteral', node, opts)
			}
			function assertBlockStatement(node, opts) {
				assert('BlockStatement', node, opts)
			}
			function assertBreakStatement(node, opts) {
				assert('BreakStatement', node, opts)
			}
			function assertCallExpression(node, opts) {
				assert('CallExpression', node, opts)
			}
			function assertCatchClause(node, opts) {
				assert('CatchClause', node, opts)
			}
			function assertConditionalExpression(node, opts) {
				assert('ConditionalExpression', node, opts)
			}
			function assertContinueStatement(node, opts) {
				assert('ContinueStatement', node, opts)
			}
			function assertDebuggerStatement(node, opts) {
				assert('DebuggerStatement', node, opts)
			}
			function assertDoWhileStatement(node, opts) {
				assert('DoWhileStatement', node, opts)
			}
			function assertEmptyStatement(node, opts) {
				assert('EmptyStatement', node, opts)
			}
			function assertExpressionStatement(node, opts) {
				assert('ExpressionStatement', node, opts)
			}
			function assertFile(node, opts) {
				assert('File', node, opts)
			}
			function assertForInStatement(node, opts) {
				assert('ForInStatement', node, opts)
			}
			function assertForStatement(node, opts) {
				assert('ForStatement', node, opts)
			}
			function assertFunctionDeclaration(node, opts) {
				assert('FunctionDeclaration', node, opts)
			}
			function assertFunctionExpression(node, opts) {
				assert('FunctionExpression', node, opts)
			}
			function assertIdentifier(node, opts) {
				assert('Identifier', node, opts)
			}
			function assertIfStatement(node, opts) {
				assert('IfStatement', node, opts)
			}
			function assertLabeledStatement(node, opts) {
				assert('LabeledStatement', node, opts)
			}
			function assertStringLiteral(node, opts) {
				assert('StringLiteral', node, opts)
			}
			function assertNumericLiteral(node, opts) {
				assert('NumericLiteral', node, opts)
			}
			function assertNullLiteral(node, opts) {
				assert('NullLiteral', node, opts)
			}
			function assertBooleanLiteral(node, opts) {
				assert('BooleanLiteral', node, opts)
			}
			function assertRegExpLiteral(node, opts) {
				assert('RegExpLiteral', node, opts)
			}
			function assertLogicalExpression(node, opts) {
				assert('LogicalExpression', node, opts)
			}
			function assertMemberExpression(node, opts) {
				assert('MemberExpression', node, opts)
			}
			function assertNewExpression(node, opts) {
				assert('NewExpression', node, opts)
			}
			function assertProgram(node, opts) {
				assert('Program', node, opts)
			}
			function assertObjectExpression(node, opts) {
				assert('ObjectExpression', node, opts)
			}
			function assertObjectMethod(node, opts) {
				assert('ObjectMethod', node, opts)
			}
			function assertObjectProperty(node, opts) {
				assert('ObjectProperty', node, opts)
			}
			function assertRestElement(node, opts) {
				assert('RestElement', node, opts)
			}
			function assertReturnStatement(node, opts) {
				assert('ReturnStatement', node, opts)
			}
			function assertSequenceExpression(node, opts) {
				assert('SequenceExpression', node, opts)
			}
			function assertParenthesizedExpression(node, opts) {
				assert('ParenthesizedExpression', node, opts)
			}
			function assertSwitchCase(node, opts) {
				assert('SwitchCase', node, opts)
			}
			function assertSwitchStatement(node, opts) {
				assert('SwitchStatement', node, opts)
			}
			function assertThisExpression(node, opts) {
				assert('ThisExpression', node, opts)
			}
			function assertThrowStatement(node, opts) {
				assert('ThrowStatement', node, opts)
			}
			function assertTryStatement(node, opts) {
				assert('TryStatement', node, opts)
			}
			function assertUnaryExpression(node, opts) {
				assert('UnaryExpression', node, opts)
			}
			function assertUpdateExpression(node, opts) {
				assert('UpdateExpression', node, opts)
			}
			function assertVariableDeclaration(node, opts) {
				assert('VariableDeclaration', node, opts)
			}
			function assertVariableDeclarator(node, opts) {
				assert('VariableDeclarator', node, opts)
			}
			function assertWhileStatement(node, opts) {
				assert('WhileStatement', node, opts)
			}
			function assertWithStatement(node, opts) {
				assert('WithStatement', node, opts)
			}
			function assertAssignmentPattern(node, opts) {
				assert('AssignmentPattern', node, opts)
			}
			function assertArrayPattern(node, opts) {
				assert('ArrayPattern', node, opts)
			}
			function assertArrowFunctionExpression(node, opts) {
				assert('ArrowFunctionExpression', node, opts)
			}
			function assertClassBody(node, opts) {
				assert('ClassBody', node, opts)
			}
			function assertClassExpression(node, opts) {
				assert('ClassExpression', node, opts)
			}
			function assertClassDeclaration(node, opts) {
				assert('ClassDeclaration', node, opts)
			}
			function assertExportAllDeclaration(node, opts) {
				assert('ExportAllDeclaration', node, opts)
			}
			function assertExportDefaultDeclaration(node, opts) {
				assert('ExportDefaultDeclaration', node, opts)
			}
			function assertExportNamedDeclaration(node, opts) {
				assert('ExportNamedDeclaration', node, opts)
			}
			function assertExportSpecifier(node, opts) {
				assert('ExportSpecifier', node, opts)
			}
			function assertForOfStatement(node, opts) {
				assert('ForOfStatement', node, opts)
			}
			function assertImportDeclaration(node, opts) {
				assert('ImportDeclaration', node, opts)
			}
			function assertImportDefaultSpecifier(node, opts) {
				assert('ImportDefaultSpecifier', node, opts)
			}
			function assertImportNamespaceSpecifier(node, opts) {
				assert('ImportNamespaceSpecifier', node, opts)
			}
			function assertImportSpecifier(node, opts) {
				assert('ImportSpecifier', node, opts)
			}
			function assertImportExpression(node, opts) {
				assert('ImportExpression', node, opts)
			}
			function assertMetaProperty(node, opts) {
				assert('MetaProperty', node, opts)
			}
			function assertClassMethod(node, opts) {
				assert('ClassMethod', node, opts)
			}
			function assertObjectPattern(node, opts) {
				assert('ObjectPattern', node, opts)
			}
			function assertSpreadElement(node, opts) {
				assert('SpreadElement', node, opts)
			}
			function assertSuper(node, opts) {
				assert('Super', node, opts)
			}
			function assertTaggedTemplateExpression(node, opts) {
				assert('TaggedTemplateExpression', node, opts)
			}
			function assertTemplateElement(node, opts) {
				assert('TemplateElement', node, opts)
			}
			function assertTemplateLiteral(node, opts) {
				assert('TemplateLiteral', node, opts)
			}
			function assertYieldExpression(node, opts) {
				assert('YieldExpression', node, opts)
			}
			function assertAwaitExpression(node, opts) {
				assert('AwaitExpression', node, opts)
			}
			function assertImport(node, opts) {
				assert('Import', node, opts)
			}
			function assertBigIntLiteral(node, opts) {
				assert('BigIntLiteral', node, opts)
			}
			function assertExportNamespaceSpecifier(node, opts) {
				assert('ExportNamespaceSpecifier', node, opts)
			}
			function assertOptionalMemberExpression(node, opts) {
				assert('OptionalMemberExpression', node, opts)
			}
			function assertOptionalCallExpression(node, opts) {
				assert('OptionalCallExpression', node, opts)
			}
			function assertClassProperty(node, opts) {
				assert('ClassProperty', node, opts)
			}
			function assertClassAccessorProperty(node, opts) {
				assert('ClassAccessorProperty', node, opts)
			}
			function assertClassPrivateProperty(node, opts) {
				assert('ClassPrivateProperty', node, opts)
			}
			function assertClassPrivateMethod(node, opts) {
				assert('ClassPrivateMethod', node, opts)
			}
			function assertPrivateName(node, opts) {
				assert('PrivateName', node, opts)
			}
			function assertStaticBlock(node, opts) {
				assert('StaticBlock', node, opts)
			}
			function assertImportAttribute(node, opts) {
				assert('ImportAttribute', node, opts)
			}
			function assertAnyTypeAnnotation(node, opts) {
				assert('AnyTypeAnnotation', node, opts)
			}
			function assertArrayTypeAnnotation(node, opts) {
				assert('ArrayTypeAnnotation', node, opts)
			}
			function assertBooleanTypeAnnotation(node, opts) {
				assert('BooleanTypeAnnotation', node, opts)
			}
			function assertBooleanLiteralTypeAnnotation(node, opts) {
				assert('BooleanLiteralTypeAnnotation', node, opts)
			}
			function assertNullLiteralTypeAnnotation(node, opts) {
				assert('NullLiteralTypeAnnotation', node, opts)
			}
			function assertClassImplements(node, opts) {
				assert('ClassImplements', node, opts)
			}
			function assertDeclareClass(node, opts) {
				assert('DeclareClass', node, opts)
			}
			function assertDeclareFunction(node, opts) {
				assert('DeclareFunction', node, opts)
			}
			function assertDeclareInterface(node, opts) {
				assert('DeclareInterface', node, opts)
			}
			function assertDeclareModule(node, opts) {
				assert('DeclareModule', node, opts)
			}
			function assertDeclareModuleExports(node, opts) {
				assert('DeclareModuleExports', node, opts)
			}
			function assertDeclareTypeAlias(node, opts) {
				assert('DeclareTypeAlias', node, opts)
			}
			function assertDeclareOpaqueType(node, opts) {
				assert('DeclareOpaqueType', node, opts)
			}
			function assertDeclareVariable(node, opts) {
				assert('DeclareVariable', node, opts)
			}
			function assertDeclareExportDeclaration(node, opts) {
				assert('DeclareExportDeclaration', node, opts)
			}
			function assertDeclareExportAllDeclaration(node, opts) {
				assert('DeclareExportAllDeclaration', node, opts)
			}
			function assertDeclaredPredicate(node, opts) {
				assert('DeclaredPredicate', node, opts)
			}
			function assertExistsTypeAnnotation(node, opts) {
				assert('ExistsTypeAnnotation', node, opts)
			}
			function assertFunctionTypeAnnotation(node, opts) {
				assert('FunctionTypeAnnotation', node, opts)
			}
			function assertFunctionTypeParam(node, opts) {
				assert('FunctionTypeParam', node, opts)
			}
			function assertGenericTypeAnnotation(node, opts) {
				assert('GenericTypeAnnotation', node, opts)
			}
			function assertInferredPredicate(node, opts) {
				assert('InferredPredicate', node, opts)
			}
			function assertInterfaceExtends(node, opts) {
				assert('InterfaceExtends', node, opts)
			}
			function assertInterfaceDeclaration(node, opts) {
				assert('InterfaceDeclaration', node, opts)
			}
			function assertInterfaceTypeAnnotation(node, opts) {
				assert('InterfaceTypeAnnotation', node, opts)
			}
			function assertIntersectionTypeAnnotation(node, opts) {
				assert('IntersectionTypeAnnotation', node, opts)
			}
			function assertMixedTypeAnnotation(node, opts) {
				assert('MixedTypeAnnotation', node, opts)
			}
			function assertEmptyTypeAnnotation(node, opts) {
				assert('EmptyTypeAnnotation', node, opts)
			}
			function assertNullableTypeAnnotation(node, opts) {
				assert('NullableTypeAnnotation', node, opts)
			}
			function assertNumberLiteralTypeAnnotation(node, opts) {
				assert('NumberLiteralTypeAnnotation', node, opts)
			}
			function assertNumberTypeAnnotation(node, opts) {
				assert('NumberTypeAnnotation', node, opts)
			}
			function assertObjectTypeAnnotation(node, opts) {
				assert('ObjectTypeAnnotation', node, opts)
			}
			function assertObjectTypeInternalSlot(node, opts) {
				assert('ObjectTypeInternalSlot', node, opts)
			}
			function assertObjectTypeCallProperty(node, opts) {
				assert('ObjectTypeCallProperty', node, opts)
			}
			function assertObjectTypeIndexer(node, opts) {
				assert('ObjectTypeIndexer', node, opts)
			}
			function assertObjectTypeProperty(node, opts) {
				assert('ObjectTypeProperty', node, opts)
			}
			function assertObjectTypeSpreadProperty(node, opts) {
				assert('ObjectTypeSpreadProperty', node, opts)
			}
			function assertOpaqueType(node, opts) {
				assert('OpaqueType', node, opts)
			}
			function assertQualifiedTypeIdentifier(node, opts) {
				assert('QualifiedTypeIdentifier', node, opts)
			}
			function assertStringLiteralTypeAnnotation(node, opts) {
				assert('StringLiteralTypeAnnotation', node, opts)
			}
			function assertStringTypeAnnotation(node, opts) {
				assert('StringTypeAnnotation', node, opts)
			}
			function assertSymbolTypeAnnotation(node, opts) {
				assert('SymbolTypeAnnotation', node, opts)
			}
			function assertThisTypeAnnotation(node, opts) {
				assert('ThisTypeAnnotation', node, opts)
			}
			function assertTupleTypeAnnotation(node, opts) {
				assert('TupleTypeAnnotation', node, opts)
			}
			function assertTypeofTypeAnnotation(node, opts) {
				assert('TypeofTypeAnnotation', node, opts)
			}
			function assertTypeAlias(node, opts) {
				assert('TypeAlias', node, opts)
			}
			function assertTypeAnnotation(node, opts) {
				assert('TypeAnnotation', node, opts)
			}
			function assertTypeCastExpression(node, opts) {
				assert('TypeCastExpression', node, opts)
			}
			function assertTypeParameter(node, opts) {
				assert('TypeParameter', node, opts)
			}
			function assertTypeParameterDeclaration(node, opts) {
				assert('TypeParameterDeclaration', node, opts)
			}
			function assertTypeParameterInstantiation(node, opts) {
				assert('TypeParameterInstantiation', node, opts)
			}
			function assertUnionTypeAnnotation(node, opts) {
				assert('UnionTypeAnnotation', node, opts)
			}
			function assertVariance(node, opts) {
				assert('Variance', node, opts)
			}
			function assertVoidTypeAnnotation(node, opts) {
				assert('VoidTypeAnnotation', node, opts)
			}
			function assertEnumDeclaration(node, opts) {
				assert('EnumDeclaration', node, opts)
			}
			function assertEnumBooleanBody(node, opts) {
				assert('EnumBooleanBody', node, opts)
			}
			function assertEnumNumberBody(node, opts) {
				assert('EnumNumberBody', node, opts)
			}
			function assertEnumStringBody(node, opts) {
				assert('EnumStringBody', node, opts)
			}
			function assertEnumSymbolBody(node, opts) {
				assert('EnumSymbolBody', node, opts)
			}
			function assertEnumBooleanMember(node, opts) {
				assert('EnumBooleanMember', node, opts)
			}
			function assertEnumNumberMember(node, opts) {
				assert('EnumNumberMember', node, opts)
			}
			function assertEnumStringMember(node, opts) {
				assert('EnumStringMember', node, opts)
			}
			function assertEnumDefaultedMember(node, opts) {
				assert('EnumDefaultedMember', node, opts)
			}
			function assertIndexedAccessType(node, opts) {
				assert('IndexedAccessType', node, opts)
			}
			function assertOptionalIndexedAccessType(node, opts) {
				assert('OptionalIndexedAccessType', node, opts)
			}
			function assertJSXAttribute(node, opts) {
				assert('JSXAttribute', node, opts)
			}
			function assertJSXClosingElement(node, opts) {
				assert('JSXClosingElement', node, opts)
			}
			function assertJSXElement(node, opts) {
				assert('JSXElement', node, opts)
			}
			function assertJSXEmptyExpression(node, opts) {
				assert('JSXEmptyExpression', node, opts)
			}
			function assertJSXExpressionContainer(node, opts) {
				assert('JSXExpressionContainer', node, opts)
			}
			function assertJSXSpreadChild(node, opts) {
				assert('JSXSpreadChild', node, opts)
			}
			function assertJSXIdentifier(node, opts) {
				assert('JSXIdentifier', node, opts)
			}
			function assertJSXMemberExpression(node, opts) {
				assert('JSXMemberExpression', node, opts)
			}
			function assertJSXNamespacedName(node, opts) {
				assert('JSXNamespacedName', node, opts)
			}
			function assertJSXOpeningElement(node, opts) {
				assert('JSXOpeningElement', node, opts)
			}
			function assertJSXSpreadAttribute(node, opts) {
				assert('JSXSpreadAttribute', node, opts)
			}
			function assertJSXText(node, opts) {
				assert('JSXText', node, opts)
			}
			function assertJSXFragment(node, opts) {
				assert('JSXFragment', node, opts)
			}
			function assertJSXOpeningFragment(node, opts) {
				assert('JSXOpeningFragment', node, opts)
			}
			function assertJSXClosingFragment(node, opts) {
				assert('JSXClosingFragment', node, opts)
			}
			function assertNoop(node, opts) {
				assert('Noop', node, opts)
			}
			function assertPlaceholder(node, opts) {
				assert('Placeholder', node, opts)
			}
			function assertV8IntrinsicIdentifier(node, opts) {
				assert('V8IntrinsicIdentifier', node, opts)
			}
			function assertArgumentPlaceholder(node, opts) {
				assert('ArgumentPlaceholder', node, opts)
			}
			function assertBindExpression(node, opts) {
				assert('BindExpression', node, opts)
			}
			function assertDecorator(node, opts) {
				assert('Decorator', node, opts)
			}
			function assertDoExpression(node, opts) {
				assert('DoExpression', node, opts)
			}
			function assertExportDefaultSpecifier(node, opts) {
				assert('ExportDefaultSpecifier', node, opts)
			}
			function assertRecordExpression(node, opts) {
				assert('RecordExpression', node, opts)
			}
			function assertTupleExpression(node, opts) {
				assert('TupleExpression', node, opts)
			}
			function assertDecimalLiteral(node, opts) {
				assert('DecimalLiteral', node, opts)
			}
			function assertModuleExpression(node, opts) {
				assert('ModuleExpression', node, opts)
			}
			function assertTopicReference(node, opts) {
				assert('TopicReference', node, opts)
			}
			function assertPipelineTopicExpression(node, opts) {
				assert('PipelineTopicExpression', node, opts)
			}
			function assertPipelineBareFunction(node, opts) {
				assert('PipelineBareFunction', node, opts)
			}
			function assertPipelinePrimaryTopicReference(node, opts) {
				assert('PipelinePrimaryTopicReference', node, opts)
			}
			function assertTSParameterProperty(node, opts) {
				assert('TSParameterProperty', node, opts)
			}
			function assertTSDeclareFunction(node, opts) {
				assert('TSDeclareFunction', node, opts)
			}
			function assertTSDeclareMethod(node, opts) {
				assert('TSDeclareMethod', node, opts)
			}
			function assertTSQualifiedName(node, opts) {
				assert('TSQualifiedName', node, opts)
			}
			function assertTSCallSignatureDeclaration(node, opts) {
				assert('TSCallSignatureDeclaration', node, opts)
			}
			function assertTSConstructSignatureDeclaration(node, opts) {
				assert('TSConstructSignatureDeclaration', node, opts)
			}
			function assertTSPropertySignature(node, opts) {
				assert('TSPropertySignature', node, opts)
			}
			function assertTSMethodSignature(node, opts) {
				assert('TSMethodSignature', node, opts)
			}
			function assertTSIndexSignature(node, opts) {
				assert('TSIndexSignature', node, opts)
			}
			function assertTSAnyKeyword(node, opts) {
				assert('TSAnyKeyword', node, opts)
			}
			function assertTSBooleanKeyword(node, opts) {
				assert('TSBooleanKeyword', node, opts)
			}
			function assertTSBigIntKeyword(node, opts) {
				assert('TSBigIntKeyword', node, opts)
			}
			function assertTSIntrinsicKeyword(node, opts) {
				assert('TSIntrinsicKeyword', node, opts)
			}
			function assertTSNeverKeyword(node, opts) {
				assert('TSNeverKeyword', node, opts)
			}
			function assertTSNullKeyword(node, opts) {
				assert('TSNullKeyword', node, opts)
			}
			function assertTSNumberKeyword(node, opts) {
				assert('TSNumberKeyword', node, opts)
			}
			function assertTSObjectKeyword(node, opts) {
				assert('TSObjectKeyword', node, opts)
			}
			function assertTSStringKeyword(node, opts) {
				assert('TSStringKeyword', node, opts)
			}
			function assertTSSymbolKeyword(node, opts) {
				assert('TSSymbolKeyword', node, opts)
			}
			function assertTSUndefinedKeyword(node, opts) {
				assert('TSUndefinedKeyword', node, opts)
			}
			function assertTSUnknownKeyword(node, opts) {
				assert('TSUnknownKeyword', node, opts)
			}
			function assertTSVoidKeyword(node, opts) {
				assert('TSVoidKeyword', node, opts)
			}
			function assertTSThisType(node, opts) {
				assert('TSThisType', node, opts)
			}
			function assertTSFunctionType(node, opts) {
				assert('TSFunctionType', node, opts)
			}
			function assertTSConstructorType(node, opts) {
				assert('TSConstructorType', node, opts)
			}
			function assertTSTypeReference(node, opts) {
				assert('TSTypeReference', node, opts)
			}
			function assertTSTypePredicate(node, opts) {
				assert('TSTypePredicate', node, opts)
			}
			function assertTSTypeQuery(node, opts) {
				assert('TSTypeQuery', node, opts)
			}
			function assertTSTypeLiteral(node, opts) {
				assert('TSTypeLiteral', node, opts)
			}
			function assertTSArrayType(node, opts) {
				assert('TSArrayType', node, opts)
			}
			function assertTSTupleType(node, opts) {
				assert('TSTupleType', node, opts)
			}
			function assertTSOptionalType(node, opts) {
				assert('TSOptionalType', node, opts)
			}
			function assertTSRestType(node, opts) {
				assert('TSRestType', node, opts)
			}
			function assertTSNamedTupleMember(node, opts) {
				assert('TSNamedTupleMember', node, opts)
			}
			function assertTSUnionType(node, opts) {
				assert('TSUnionType', node, opts)
			}
			function assertTSIntersectionType(node, opts) {
				assert('TSIntersectionType', node, opts)
			}
			function assertTSConditionalType(node, opts) {
				assert('TSConditionalType', node, opts)
			}
			function assertTSInferType(node, opts) {
				assert('TSInferType', node, opts)
			}
			function assertTSParenthesizedType(node, opts) {
				assert('TSParenthesizedType', node, opts)
			}
			function assertTSTypeOperator(node, opts) {
				assert('TSTypeOperator', node, opts)
			}
			function assertTSIndexedAccessType(node, opts) {
				assert('TSIndexedAccessType', node, opts)
			}
			function assertTSMappedType(node, opts) {
				assert('TSMappedType', node, opts)
			}
			function assertTSTemplateLiteralType(node, opts) {
				assert('TSTemplateLiteralType', node, opts)
			}
			function assertTSLiteralType(node, opts) {
				assert('TSLiteralType', node, opts)
			}
			function assertTSExpressionWithTypeArguments(node, opts) {
				assert('TSExpressionWithTypeArguments', node, opts)
			}
			function assertTSInterfaceDeclaration(node, opts) {
				assert('TSInterfaceDeclaration', node, opts)
			}
			function assertTSInterfaceBody(node, opts) {
				assert('TSInterfaceBody', node, opts)
			}
			function assertTSTypeAliasDeclaration(node, opts) {
				assert('TSTypeAliasDeclaration', node, opts)
			}
			function assertTSInstantiationExpression(node, opts) {
				assert('TSInstantiationExpression', node, opts)
			}
			function assertTSAsExpression(node, opts) {
				assert('TSAsExpression', node, opts)
			}
			function assertTSSatisfiesExpression(node, opts) {
				assert('TSSatisfiesExpression', node, opts)
			}
			function assertTSTypeAssertion(node, opts) {
				assert('TSTypeAssertion', node, opts)
			}
			function assertTSEnumBody(node, opts) {
				assert('TSEnumBody', node, opts)
			}
			function assertTSEnumDeclaration(node, opts) {
				assert('TSEnumDeclaration', node, opts)
			}
			function assertTSEnumMember(node, opts) {
				assert('TSEnumMember', node, opts)
			}
			function assertTSModuleDeclaration(node, opts) {
				assert('TSModuleDeclaration', node, opts)
			}
			function assertTSModuleBlock(node, opts) {
				assert('TSModuleBlock', node, opts)
			}
			function assertTSImportType(node, opts) {
				assert('TSImportType', node, opts)
			}
			function assertTSImportEqualsDeclaration(node, opts) {
				assert('TSImportEqualsDeclaration', node, opts)
			}
			function assertTSExternalModuleReference(node, opts) {
				assert('TSExternalModuleReference', node, opts)
			}
			function assertTSNonNullExpression(node, opts) {
				assert('TSNonNullExpression', node, opts)
			}
			function assertTSExportAssignment(node, opts) {
				assert('TSExportAssignment', node, opts)
			}
			function assertTSNamespaceExportDeclaration(node, opts) {
				assert('TSNamespaceExportDeclaration', node, opts)
			}
			function assertTSTypeAnnotation(node, opts) {
				assert('TSTypeAnnotation', node, opts)
			}
			function assertTSTypeParameterInstantiation(node, opts) {
				assert('TSTypeParameterInstantiation', node, opts)
			}
			function assertTSTypeParameterDeclaration(node, opts) {
				assert('TSTypeParameterDeclaration', node, opts)
			}
			function assertTSTypeParameter(node, opts) {
				assert('TSTypeParameter', node, opts)
			}
			function assertStandardized(node, opts) {
				assert('Standardized', node, opts)
			}
			function assertExpression(node, opts) {
				assert('Expression', node, opts)
			}
			function assertBinary(node, opts) {
				assert('Binary', node, opts)
			}
			function assertScopable(node, opts) {
				assert('Scopable', node, opts)
			}
			function assertBlockParent(node, opts) {
				assert('BlockParent', node, opts)
			}
			function assertBlock(node, opts) {
				assert('Block', node, opts)
			}
			function assertStatement(node, opts) {
				assert('Statement', node, opts)
			}
			function assertTerminatorless(node, opts) {
				assert('Terminatorless', node, opts)
			}
			function assertCompletionStatement(node, opts) {
				assert('CompletionStatement', node, opts)
			}
			function assertConditional(node, opts) {
				assert('Conditional', node, opts)
			}
			function assertLoop(node, opts) {
				assert('Loop', node, opts)
			}
			function assertWhile(node, opts) {
				assert('While', node, opts)
			}
			function assertExpressionWrapper(node, opts) {
				assert('ExpressionWrapper', node, opts)
			}
			function assertFor(node, opts) {
				assert('For', node, opts)
			}
			function assertForXStatement(node, opts) {
				assert('ForXStatement', node, opts)
			}
			function assertFunction(node, opts) {
				assert('Function', node, opts)
			}
			function assertFunctionParent(node, opts) {
				assert('FunctionParent', node, opts)
			}
			function assertPureish(node, opts) {
				assert('Pureish', node, opts)
			}
			function assertDeclaration(node, opts) {
				assert('Declaration', node, opts)
			}
			function assertPatternLike(node, opts) {
				assert('PatternLike', node, opts)
			}
			function assertLVal(node, opts) {
				assert('LVal', node, opts)
			}
			function assertTSEntityName(node, opts) {
				assert('TSEntityName', node, opts)
			}
			function assertLiteral(node, opts) {
				assert('Literal', node, opts)
			}
			function assertImmutable(node, opts) {
				assert('Immutable', node, opts)
			}
			function assertUserWhitespacable(node, opts) {
				assert('UserWhitespacable', node, opts)
			}
			function assertMethod(node, opts) {
				assert('Method', node, opts)
			}
			function assertObjectMember(node, opts) {
				assert('ObjectMember', node, opts)
			}
			function assertProperty(node, opts) {
				assert('Property', node, opts)
			}
			function assertUnaryLike(node, opts) {
				assert('UnaryLike', node, opts)
			}
			function assertPattern(node, opts) {
				assert('Pattern', node, opts)
			}
			function assertClass(node, opts) {
				assert('Class', node, opts)
			}
			function assertImportOrExportDeclaration(node, opts) {
				assert('ImportOrExportDeclaration', node, opts)
			}
			function assertExportDeclaration(node, opts) {
				assert('ExportDeclaration', node, opts)
			}
			function assertModuleSpecifier(node, opts) {
				assert('ModuleSpecifier', node, opts)
			}
			function assertAccessor(node, opts) {
				assert('Accessor', node, opts)
			}
			function assertPrivate(node, opts) {
				assert('Private', node, opts)
			}
			function assertFlow(node, opts) {
				assert('Flow', node, opts)
			}
			function assertFlowType(node, opts) {
				assert('FlowType', node, opts)
			}
			function assertFlowBaseAnnotation(node, opts) {
				assert('FlowBaseAnnotation', node, opts)
			}
			function assertFlowDeclaration(node, opts) {
				assert('FlowDeclaration', node, opts)
			}
			function assertFlowPredicate(node, opts) {
				assert('FlowPredicate', node, opts)
			}
			function assertEnumBody(node, opts) {
				assert('EnumBody', node, opts)
			}
			function assertEnumMember(node, opts) {
				assert('EnumMember', node, opts)
			}
			function assertJSX(node, opts) {
				assert('JSX', node, opts)
			}
			function assertMiscellaneous(node, opts) {
				assert('Miscellaneous', node, opts)
			}
			function assertTypeScript(node, opts) {
				assert('TypeScript', node, opts)
			}
			function assertTSTypeElement(node, opts) {
				assert('TSTypeElement', node, opts)
			}
			function assertTSType(node, opts) {
				assert('TSType', node, opts)
			}
			function assertTSBaseType(node, opts) {
				assert('TSBaseType', node, opts)
			}
			function assertNumberLiteral(node, opts) {
				;(0, _deprecationWarning.default)(
					'assertNumberLiteral',
					'assertNumericLiteral',
				)
				assert('NumberLiteral', node, opts)
			}
			function assertRegexLiteral(node, opts) {
				;(0, _deprecationWarning.default)(
					'assertRegexLiteral',
					'assertRegExpLiteral',
				)
				assert('RegexLiteral', node, opts)
			}
			function assertRestProperty(node, opts) {
				;(0, _deprecationWarning.default)(
					'assertRestProperty',
					'assertRestElement',
				)
				assert('RestProperty', node, opts)
			}
			function assertSpreadProperty(node, opts) {
				;(0, _deprecationWarning.default)(
					'assertSpreadProperty',
					'assertSpreadElement',
				)
				assert('SpreadProperty', node, opts)
			}
			function assertModuleDeclaration(node, opts) {
				;(0, _deprecationWarning.default)(
					'assertModuleDeclaration',
					'assertImportOrExportDeclaration',
				)
				assert('ModuleDeclaration', node, opts)
			}

			//# sourceMappingURL=index.js.map

			/***/
		},

		/***/ 58806: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = createFlowUnionType
			var _index = __nccwpck_require__(90670)
			var _removeTypeDuplicates = __nccwpck_require__(41034)
			function createFlowUnionType(types) {
				const flattened = (0, _removeTypeDuplicates.default)(types)
				if (flattened.length === 1) {
					return flattened[0]
				} else {
					return (0, _index.unionTypeAnnotation)(flattened)
				}
			}

			//# sourceMappingURL=createFlowUnionType.js.map

			/***/
		},

		/***/ 9197: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = void 0
			var _index = __nccwpck_require__(90670)
			var _default = (exports['default'] = createTypeAnnotationBasedOnTypeof)
			function createTypeAnnotationBasedOnTypeof(type) {
				switch (type) {
					case 'string':
						return (0, _index.stringTypeAnnotation)()
					case 'number':
						return (0, _index.numberTypeAnnotation)()
					case 'undefined':
						return (0, _index.voidTypeAnnotation)()
					case 'boolean':
						return (0, _index.booleanTypeAnnotation)()
					case 'function':
						return (0, _index.genericTypeAnnotation)(
							(0, _index.identifier)('Function'),
						)
					case 'object':
						return (0, _index.genericTypeAnnotation)(
							(0, _index.identifier)('Object'),
						)
					case 'symbol':
						return (0, _index.genericTypeAnnotation)(
							(0, _index.identifier)('Symbol'),
						)
					case 'bigint':
						return (0, _index.anyTypeAnnotation)()
				}
				throw new Error('Invalid typeof value: ' + type)
			}

			//# sourceMappingURL=createTypeAnnotationBasedOnTypeof.js.map

			/***/
		},

		/***/ 90670: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			var _lowercase = __nccwpck_require__(11999)
			Object.keys(_lowercase).forEach(function (key) {
				if (key === 'default' || key === '__esModule') return
				if (key in exports && exports[key] === _lowercase[key]) return
				Object.defineProperty(exports, key, {
					enumerable: true,
					get: function () {
						return _lowercase[key]
					},
				})
			})
			var _uppercase = __nccwpck_require__(1862)
			Object.keys(_uppercase).forEach(function (key) {
				if (key === 'default' || key === '__esModule') return
				if (key in exports && exports[key] === _uppercase[key]) return
				Object.defineProperty(exports, key, {
					enumerable: true,
					get: function () {
						return _uppercase[key]
					},
				})
			})

			//# sourceMappingURL=index.js.map

			/***/
		},

		/***/ 11999: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.anyTypeAnnotation = anyTypeAnnotation
			exports.argumentPlaceholder = argumentPlaceholder
			exports.arrayExpression = arrayExpression
			exports.arrayPattern = arrayPattern
			exports.arrayTypeAnnotation = arrayTypeAnnotation
			exports.arrowFunctionExpression = arrowFunctionExpression
			exports.assignmentExpression = assignmentExpression
			exports.assignmentPattern = assignmentPattern
			exports.awaitExpression = awaitExpression
			exports.bigIntLiteral = bigIntLiteral
			exports.binaryExpression = binaryExpression
			exports.bindExpression = bindExpression
			exports.blockStatement = blockStatement
			exports.booleanLiteral = booleanLiteral
			exports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation
			exports.booleanTypeAnnotation = booleanTypeAnnotation
			exports.breakStatement = breakStatement
			exports.callExpression = callExpression
			exports.catchClause = catchClause
			exports.classAccessorProperty = classAccessorProperty
			exports.classBody = classBody
			exports.classDeclaration = classDeclaration
			exports.classExpression = classExpression
			exports.classImplements = classImplements
			exports.classMethod = classMethod
			exports.classPrivateMethod = classPrivateMethod
			exports.classPrivateProperty = classPrivateProperty
			exports.classProperty = classProperty
			exports.conditionalExpression = conditionalExpression
			exports.continueStatement = continueStatement
			exports.debuggerStatement = debuggerStatement
			exports.decimalLiteral = decimalLiteral
			exports.declareClass = declareClass
			exports.declareExportAllDeclaration = declareExportAllDeclaration
			exports.declareExportDeclaration = declareExportDeclaration
			exports.declareFunction = declareFunction
			exports.declareInterface = declareInterface
			exports.declareModule = declareModule
			exports.declareModuleExports = declareModuleExports
			exports.declareOpaqueType = declareOpaqueType
			exports.declareTypeAlias = declareTypeAlias
			exports.declareVariable = declareVariable
			exports.declaredPredicate = declaredPredicate
			exports.decorator = decorator
			exports.directive = directive
			exports.directiveLiteral = directiveLiteral
			exports.doExpression = doExpression
			exports.doWhileStatement = doWhileStatement
			exports.emptyStatement = emptyStatement
			exports.emptyTypeAnnotation = emptyTypeAnnotation
			exports.enumBooleanBody = enumBooleanBody
			exports.enumBooleanMember = enumBooleanMember
			exports.enumDeclaration = enumDeclaration
			exports.enumDefaultedMember = enumDefaultedMember
			exports.enumNumberBody = enumNumberBody
			exports.enumNumberMember = enumNumberMember
			exports.enumStringBody = enumStringBody
			exports.enumStringMember = enumStringMember
			exports.enumSymbolBody = enumSymbolBody
			exports.existsTypeAnnotation = existsTypeAnnotation
			exports.exportAllDeclaration = exportAllDeclaration
			exports.exportDefaultDeclaration = exportDefaultDeclaration
			exports.exportDefaultSpecifier = exportDefaultSpecifier
			exports.exportNamedDeclaration = exportNamedDeclaration
			exports.exportNamespaceSpecifier = exportNamespaceSpecifier
			exports.exportSpecifier = exportSpecifier
			exports.expressionStatement = expressionStatement
			exports.file = file
			exports.forInStatement = forInStatement
			exports.forOfStatement = forOfStatement
			exports.forStatement = forStatement
			exports.functionDeclaration = functionDeclaration
			exports.functionExpression = functionExpression
			exports.functionTypeAnnotation = functionTypeAnnotation
			exports.functionTypeParam = functionTypeParam
			exports.genericTypeAnnotation = genericTypeAnnotation
			exports.identifier = identifier
			exports.ifStatement = ifStatement
			exports['import'] = _import
			exports.importAttribute = importAttribute
			exports.importDeclaration = importDeclaration
			exports.importDefaultSpecifier = importDefaultSpecifier
			exports.importExpression = importExpression
			exports.importNamespaceSpecifier = importNamespaceSpecifier
			exports.importSpecifier = importSpecifier
			exports.indexedAccessType = indexedAccessType
			exports.inferredPredicate = inferredPredicate
			exports.interfaceDeclaration = interfaceDeclaration
			exports.interfaceExtends = interfaceExtends
			exports.interfaceTypeAnnotation = interfaceTypeAnnotation
			exports.interpreterDirective = interpreterDirective
			exports.intersectionTypeAnnotation = intersectionTypeAnnotation
			exports.jSXAttribute = exports.jsxAttribute = jsxAttribute
			exports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement
			exports.jSXClosingFragment = exports.jsxClosingFragment =
				jsxClosingFragment
			exports.jSXElement = exports.jsxElement = jsxElement
			exports.jSXEmptyExpression = exports.jsxEmptyExpression =
				jsxEmptyExpression
			exports.jSXExpressionContainer = exports.jsxExpressionContainer =
				jsxExpressionContainer
			exports.jSXFragment = exports.jsxFragment = jsxFragment
			exports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier
			exports.jSXMemberExpression = exports.jsxMemberExpression =
				jsxMemberExpression
			exports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName
			exports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement
			exports.jSXOpeningFragment = exports.jsxOpeningFragment =
				jsxOpeningFragment
			exports.jSXSpreadAttribute = exports.jsxSpreadAttribute =
				jsxSpreadAttribute
			exports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild
			exports.jSXText = exports.jsxText = jsxText
			exports.labeledStatement = labeledStatement
			exports.logicalExpression = logicalExpression
			exports.memberExpression = memberExpression
			exports.metaProperty = metaProperty
			exports.mixedTypeAnnotation = mixedTypeAnnotation
			exports.moduleExpression = moduleExpression
			exports.newExpression = newExpression
			exports.noop = noop
			exports.nullLiteral = nullLiteral
			exports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation
			exports.nullableTypeAnnotation = nullableTypeAnnotation
			exports.numberLiteral = NumberLiteral
			exports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation
			exports.numberTypeAnnotation = numberTypeAnnotation
			exports.numericLiteral = numericLiteral
			exports.objectExpression = objectExpression
			exports.objectMethod = objectMethod
			exports.objectPattern = objectPattern
			exports.objectProperty = objectProperty
			exports.objectTypeAnnotation = objectTypeAnnotation
			exports.objectTypeCallProperty = objectTypeCallProperty
			exports.objectTypeIndexer = objectTypeIndexer
			exports.objectTypeInternalSlot = objectTypeInternalSlot
			exports.objectTypeProperty = objectTypeProperty
			exports.objectTypeSpreadProperty = objectTypeSpreadProperty
			exports.opaqueType = opaqueType
			exports.optionalCallExpression = optionalCallExpression
			exports.optionalIndexedAccessType = optionalIndexedAccessType
			exports.optionalMemberExpression = optionalMemberExpression
			exports.parenthesizedExpression = parenthesizedExpression
			exports.pipelineBareFunction = pipelineBareFunction
			exports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference
			exports.pipelineTopicExpression = pipelineTopicExpression
			exports.placeholder = placeholder
			exports.privateName = privateName
			exports.program = program
			exports.qualifiedTypeIdentifier = qualifiedTypeIdentifier
			exports.recordExpression = recordExpression
			exports.regExpLiteral = regExpLiteral
			exports.regexLiteral = RegexLiteral
			exports.restElement = restElement
			exports.restProperty = RestProperty
			exports.returnStatement = returnStatement
			exports.sequenceExpression = sequenceExpression
			exports.spreadElement = spreadElement
			exports.spreadProperty = SpreadProperty
			exports.staticBlock = staticBlock
			exports.stringLiteral = stringLiteral
			exports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation
			exports.stringTypeAnnotation = stringTypeAnnotation
			exports['super'] = _super
			exports.switchCase = switchCase
			exports.switchStatement = switchStatement
			exports.symbolTypeAnnotation = symbolTypeAnnotation
			exports.taggedTemplateExpression = taggedTemplateExpression
			exports.templateElement = templateElement
			exports.templateLiteral = templateLiteral
			exports.thisExpression = thisExpression
			exports.thisTypeAnnotation = thisTypeAnnotation
			exports.throwStatement = throwStatement
			exports.topicReference = topicReference
			exports.tryStatement = tryStatement
			exports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword
			exports.tSArrayType = exports.tsArrayType = tsArrayType
			exports.tSAsExpression = exports.tsAsExpression = tsAsExpression
			exports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword
			exports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword
			exports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration =
				tsCallSignatureDeclaration
			exports.tSConditionalType = exports.tsConditionalType = tsConditionalType
			exports.tSConstructSignatureDeclaration =
				exports.tsConstructSignatureDeclaration =
					tsConstructSignatureDeclaration
			exports.tSConstructorType = exports.tsConstructorType = tsConstructorType
			exports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction
			exports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod
			exports.tSEnumBody = exports.tsEnumBody = tsEnumBody
			exports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration
			exports.tSEnumMember = exports.tsEnumMember = tsEnumMember
			exports.tSExportAssignment = exports.tsExportAssignment =
				tsExportAssignment
			exports.tSExpressionWithTypeArguments =
				exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments
			exports.tSExternalModuleReference = exports.tsExternalModuleReference =
				tsExternalModuleReference
			exports.tSFunctionType = exports.tsFunctionType = tsFunctionType
			exports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration =
				tsImportEqualsDeclaration
			exports.tSImportType = exports.tsImportType = tsImportType
			exports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature
			exports.tSIndexedAccessType = exports.tsIndexedAccessType =
				tsIndexedAccessType
			exports.tSInferType = exports.tsInferType = tsInferType
			exports.tSInstantiationExpression = exports.tsInstantiationExpression =
				tsInstantiationExpression
			exports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody
			exports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration =
				tsInterfaceDeclaration
			exports.tSIntersectionType = exports.tsIntersectionType =
				tsIntersectionType
			exports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword =
				tsIntrinsicKeyword
			exports.tSLiteralType = exports.tsLiteralType = tsLiteralType
			exports.tSMappedType = exports.tsMappedType = tsMappedType
			exports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature
			exports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock
			exports.tSModuleDeclaration = exports.tsModuleDeclaration =
				tsModuleDeclaration
			exports.tSNamedTupleMember = exports.tsNamedTupleMember =
				tsNamedTupleMember
			exports.tSNamespaceExportDeclaration =
				exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration
			exports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword
			exports.tSNonNullExpression = exports.tsNonNullExpression =
				tsNonNullExpression
			exports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword
			exports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword
			exports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword
			exports.tSOptionalType = exports.tsOptionalType = tsOptionalType
			exports.tSParameterProperty = exports.tsParameterProperty =
				tsParameterProperty
			exports.tSParenthesizedType = exports.tsParenthesizedType =
				tsParenthesizedType
			exports.tSPropertySignature = exports.tsPropertySignature =
				tsPropertySignature
			exports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName
			exports.tSRestType = exports.tsRestType = tsRestType
			exports.tSSatisfiesExpression = exports.tsSatisfiesExpression =
				tsSatisfiesExpression
			exports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword
			exports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword
			exports.tSTemplateLiteralType = exports.tsTemplateLiteralType =
				tsTemplateLiteralType
			exports.tSThisType = exports.tsThisType = tsThisType
			exports.tSTupleType = exports.tsTupleType = tsTupleType
			exports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration =
				tsTypeAliasDeclaration
			exports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation
			exports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion
			exports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral
			exports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator
			exports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter
			exports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration =
				tsTypeParameterDeclaration
			exports.tSTypeParameterInstantiation =
				exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation
			exports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate
			exports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery
			exports.tSTypeReference = exports.tsTypeReference = tsTypeReference
			exports.tSUndefinedKeyword = exports.tsUndefinedKeyword =
				tsUndefinedKeyword
			exports.tSUnionType = exports.tsUnionType = tsUnionType
			exports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword
			exports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword
			exports.tupleExpression = tupleExpression
			exports.tupleTypeAnnotation = tupleTypeAnnotation
			exports.typeAlias = typeAlias
			exports.typeAnnotation = typeAnnotation
			exports.typeCastExpression = typeCastExpression
			exports.typeParameter = typeParameter
			exports.typeParameterDeclaration = typeParameterDeclaration
			exports.typeParameterInstantiation = typeParameterInstantiation
			exports.typeofTypeAnnotation = typeofTypeAnnotation
			exports.unaryExpression = unaryExpression
			exports.unionTypeAnnotation = unionTypeAnnotation
			exports.updateExpression = updateExpression
			exports.v8IntrinsicIdentifier = v8IntrinsicIdentifier
			exports.variableDeclaration = variableDeclaration
			exports.variableDeclarator = variableDeclarator
			exports.variance = variance
			exports.voidTypeAnnotation = voidTypeAnnotation
			exports.whileStatement = whileStatement
			exports.withStatement = withStatement
			exports.yieldExpression = yieldExpression
			var _validate = __nccwpck_require__(71581)
			var _deprecationWarning = __nccwpck_require__(14711)
			var utils = __nccwpck_require__(34559)
			const { validateInternal: validate } = _validate
			const { NODE_FIELDS } = utils
			function arrayExpression(elements = []) {
				const node = {
					type: 'ArrayExpression',
					elements,
				}
				const defs = NODE_FIELDS.ArrayExpression
				validate(defs.elements, node, 'elements', elements, 1)
				return node
			}
			function assignmentExpression(operator, left, right) {
				const node = {
					type: 'AssignmentExpression',
					operator,
					left,
					right,
				}
				const defs = NODE_FIELDS.AssignmentExpression
				validate(defs.operator, node, 'operator', operator)
				validate(defs.left, node, 'left', left, 1)
				validate(defs.right, node, 'right', right, 1)
				return node
			}
			function binaryExpression(operator, left, right) {
				const node = {
					type: 'BinaryExpression',
					operator,
					left,
					right,
				}
				const defs = NODE_FIELDS.BinaryExpression
				validate(defs.operator, node, 'operator', operator)
				validate(defs.left, node, 'left', left, 1)
				validate(defs.right, node, 'right', right, 1)
				return node
			}
			function interpreterDirective(value) {
				const node = {
					type: 'InterpreterDirective',
					value,
				}
				const defs = NODE_FIELDS.InterpreterDirective
				validate(defs.value, node, 'value', value)
				return node
			}
			function directive(value) {
				const node = {
					type: 'Directive',
					value,
				}
				const defs = NODE_FIELDS.Directive
				validate(defs.value, node, 'value', value, 1)
				return node
			}
			function directiveLiteral(value) {
				const node = {
					type: 'DirectiveLiteral',
					value,
				}
				const defs = NODE_FIELDS.DirectiveLiteral
				validate(defs.value, node, 'value', value)
				return node
			}
			function blockStatement(body, directives = []) {
				const node = {
					type: 'BlockStatement',
					body,
					directives,
				}
				const defs = NODE_FIELDS.BlockStatement
				validate(defs.body, node, 'body', body, 1)
				validate(defs.directives, node, 'directives', directives, 1)
				return node
			}
			function breakStatement(label = null) {
				const node = {
					type: 'BreakStatement',
					label,
				}
				const defs = NODE_FIELDS.BreakStatement
				validate(defs.label, node, 'label', label, 1)
				return node
			}
			function callExpression(callee, _arguments) {
				const node = {
					type: 'CallExpression',
					callee,
					arguments: _arguments,
				}
				const defs = NODE_FIELDS.CallExpression
				validate(defs.callee, node, 'callee', callee, 1)
				validate(defs.arguments, node, 'arguments', _arguments, 1)
				return node
			}
			function catchClause(param = null, body) {
				const node = {
					type: 'CatchClause',
					param,
					body,
				}
				const defs = NODE_FIELDS.CatchClause
				validate(defs.param, node, 'param', param, 1)
				validate(defs.body, node, 'body', body, 1)
				return node
			}
			function conditionalExpression(test, consequent, alternate) {
				const node = {
					type: 'ConditionalExpression',
					test,
					consequent,
					alternate,
				}
				const defs = NODE_FIELDS.ConditionalExpression
				validate(defs.test, node, 'test', test, 1)
				validate(defs.consequent, node, 'consequent', consequent, 1)
				validate(defs.alternate, node, 'alternate', alternate, 1)
				return node
			}
			function continueStatement(label = null) {
				const node = {
					type: 'ContinueStatement',
					label,
				}
				const defs = NODE_FIELDS.ContinueStatement
				validate(defs.label, node, 'label', label, 1)
				return node
			}
			function debuggerStatement() {
				return {
					type: 'DebuggerStatement',
				}
			}
			function doWhileStatement(test, body) {
				const node = {
					type: 'DoWhileStatement',
					test,
					body,
				}
				const defs = NODE_FIELDS.DoWhileStatement
				validate(defs.test, node, 'test', test, 1)
				validate(defs.body, node, 'body', body, 1)
				return node
			}
			function emptyStatement() {
				return {
					type: 'EmptyStatement',
				}
			}
			function expressionStatement(expression) {
				const node = {
					type: 'ExpressionStatement',
					expression,
				}
				const defs = NODE_FIELDS.ExpressionStatement
				validate(defs.expression, node, 'expression', expression, 1)
				return node
			}
			function file(program, comments = null, tokens = null) {
				const node = {
					type: 'File',
					program,
					comments,
					tokens,
				}
				const defs = NODE_FIELDS.File
				validate(defs.program, node, 'program', program, 1)
				validate(defs.comments, node, 'comments', comments, 1)
				validate(defs.tokens, node, 'tokens', tokens)
				return node
			}
			function forInStatement(left, right, body) {
				const node = {
					type: 'ForInStatement',
					left,
					right,
					body,
				}
				const defs = NODE_FIELDS.ForInStatement
				validate(defs.left, node, 'left', left, 1)
				validate(defs.right, node, 'right', right, 1)
				validate(defs.body, node, 'body', body, 1)
				return node
			}
			function forStatement(init = null, test = null, update = null, body) {
				const node = {
					type: 'ForStatement',
					init,
					test,
					update,
					body,
				}
				const defs = NODE_FIELDS.ForStatement
				validate(defs.init, node, 'init', init, 1)
				validate(defs.test, node, 'test', test, 1)
				validate(defs.update, node, 'update', update, 1)
				validate(defs.body, node, 'body', body, 1)
				return node
			}
			function functionDeclaration(
				id = null,
				params,
				body,
				generator = false,
				async = false,
			) {
				const node = {
					type: 'FunctionDeclaration',
					id,
					params,
					body,
					generator,
					async,
				}
				const defs = NODE_FIELDS.FunctionDeclaration
				validate(defs.id, node, 'id', id, 1)
				validate(defs.params, node, 'params', params, 1)
				validate(defs.body, node, 'body', body, 1)
				validate(defs.generator, node, 'generator', generator)
				validate(defs.async, node, 'async', async)
				return node
			}
			function functionExpression(
				id = null,
				params,
				body,
				generator = false,
				async = false,
			) {
				const node = {
					type: 'FunctionExpression',
					id,
					params,
					body,
					generator,
					async,
				}
				const defs = NODE_FIELDS.FunctionExpression
				validate(defs.id, node, 'id', id, 1)
				validate(defs.params, node, 'params', params, 1)
				validate(defs.body, node, 'body', body, 1)
				validate(defs.generator, node, 'generator', generator)
				validate(defs.async, node, 'async', async)
				return node
			}
			function identifier(name) {
				const node = {
					type: 'Identifier',
					name,
				}
				const defs = NODE_FIELDS.Identifier
				validate(defs.name, node, 'name', name)
				return node
			}
			function ifStatement(test, consequent, alternate = null) {
				const node = {
					type: 'IfStatement',
					test,
					consequent,
					alternate,
				}
				const defs = NODE_FIELDS.IfStatement
				validate(defs.test, node, 'test', test, 1)
				validate(defs.consequent, node, 'consequent', consequent, 1)
				validate(defs.alternate, node, 'alternate', alternate, 1)
				return node
			}
			function labeledStatement(label, body) {
				const node = {
					type: 'LabeledStatement',
					label,
					body,
				}
				const defs = NODE_FIELDS.LabeledStatement
				validate(defs.label, node, 'label', label, 1)
				validate(defs.body, node, 'body', body, 1)
				return node
			}
			function stringLiteral(value) {
				const node = {
					type: 'StringLiteral',
					value,
				}
				const defs = NODE_FIELDS.StringLiteral
				validate(defs.value, node, 'value', value)
				return node
			}
			function numericLiteral(value) {
				const node = {
					type: 'NumericLiteral',
					value,
				}
				const defs = NODE_FIELDS.NumericLiteral
				validate(defs.value, node, 'value', value)
				return node
			}
			function nullLiteral() {
				return {
					type: 'NullLiteral',
				}
			}
			function booleanLiteral(value) {
				const node = {
					type: 'BooleanLiteral',
					value,
				}
				const defs = NODE_FIELDS.BooleanLiteral
				validate(defs.value, node, 'value', value)
				return node
			}
			function regExpLiteral(pattern, flags = '') {
				const node = {
					type: 'RegExpLiteral',
					pattern,
					flags,
				}
				const defs = NODE_FIELDS.RegExpLiteral
				validate(defs.pattern, node, 'pattern', pattern)
				validate(defs.flags, node, 'flags', flags)
				return node
			}
			function logicalExpression(operator, left, right) {
				const node = {
					type: 'LogicalExpression',
					operator,
					left,
					right,
				}
				const defs = NODE_FIELDS.LogicalExpression
				validate(defs.operator, node, 'operator', operator)
				validate(defs.left, node, 'left', left, 1)
				validate(defs.right, node, 'right', right, 1)
				return node
			}
			function memberExpression(
				object,
				property,
				computed = false,
				optional = null,
			) {
				const node = {
					type: 'MemberExpression',
					object,
					property,
					computed,
					optional,
				}
				const defs = NODE_FIELDS.MemberExpression
				validate(defs.object, node, 'object', object, 1)
				validate(defs.property, node, 'property', property, 1)
				validate(defs.computed, node, 'computed', computed)
				validate(defs.optional, node, 'optional', optional)
				return node
			}
			function newExpression(callee, _arguments) {
				const node = {
					type: 'NewExpression',
					callee,
					arguments: _arguments,
				}
				const defs = NODE_FIELDS.NewExpression
				validate(defs.callee, node, 'callee', callee, 1)
				validate(defs.arguments, node, 'arguments', _arguments, 1)
				return node
			}
			function program(
				body,
				directives = [],
				sourceType = 'script',
				interpreter = null,
			) {
				const node = {
					type: 'Program',
					body,
					directives,
					sourceType,
					interpreter,
				}
				const defs = NODE_FIELDS.Program
				validate(defs.body, node, 'body', body, 1)
				validate(defs.directives, node, 'directives', directives, 1)
				validate(defs.sourceType, node, 'sourceType', sourceType)
				validate(defs.interpreter, node, 'interpreter', interpreter, 1)
				return node
			}
			function objectExpression(properties) {
				const node = {
					type: 'ObjectExpression',
					properties,
				}
				const defs = NODE_FIELDS.ObjectExpression
				validate(defs.properties, node, 'properties', properties, 1)
				return node
			}
			function objectMethod(
				kind = 'method',
				key,
				params,
				body,
				computed = false,
				generator = false,
				async = false,
			) {
				const node = {
					type: 'ObjectMethod',
					kind,
					key,
					params,
					body,
					computed,
					generator,
					async,
				}
				const defs = NODE_FIELDS.ObjectMethod
				validate(defs.kind, node, 'kind', kind)
				validate(defs.key, node, 'key', key, 1)
				validate(defs.params, node, 'params', params, 1)
				validate(defs.body, node, 'body', body, 1)
				validate(defs.computed, node, 'computed', computed)
				validate(defs.generator, node, 'generator', generator)
				validate(defs.async, node, 'async', async)
				return node
			}
			function objectProperty(
				key,
				value,
				computed = false,
				shorthand = false,
				decorators = null,
			) {
				const node = {
					type: 'ObjectProperty',
					key,
					value,
					computed,
					shorthand,
					decorators,
				}
				const defs = NODE_FIELDS.ObjectProperty
				validate(defs.key, node, 'key', key, 1)
				validate(defs.value, node, 'value', value, 1)
				validate(defs.computed, node, 'computed', computed)
				validate(defs.shorthand, node, 'shorthand', shorthand)
				validate(defs.decorators, node, 'decorators', decorators, 1)
				return node
			}
			function restElement(argument) {
				const node = {
					type: 'RestElement',
					argument,
				}
				const defs = NODE_FIELDS.RestElement
				validate(defs.argument, node, 'argument', argument, 1)
				return node
			}
			function returnStatement(argument = null) {
				const node = {
					type: 'ReturnStatement',
					argument,
				}
				const defs = NODE_FIELDS.ReturnStatement
				validate(defs.argument, node, 'argument', argument, 1)
				return node
			}
			function sequenceExpression(expressions) {
				const node = {
					type: 'SequenceExpression',
					expressions,
				}
				const defs = NODE_FIELDS.SequenceExpression
				validate(defs.expressions, node, 'expressions', expressions, 1)
				return node
			}
			function parenthesizedExpression(expression) {
				const node = {
					type: 'ParenthesizedExpression',
					expression,
				}
				const defs = NODE_FIELDS.ParenthesizedExpression
				validate(defs.expression, node, 'expression', expression, 1)
				return node
			}
			function switchCase(test = null, consequent) {
				const node = {
					type: 'SwitchCase',
					test,
					consequent,
				}
				const defs = NODE_FIELDS.SwitchCase
				validate(defs.test, node, 'test', test, 1)
				validate(defs.consequent, node, 'consequent', consequent, 1)
				return node
			}
			function switchStatement(discriminant, cases) {
				const node = {
					type: 'SwitchStatement',
					discriminant,
					cases,
				}
				const defs = NODE_FIELDS.SwitchStatement
				validate(defs.discriminant, node, 'discriminant', discriminant, 1)
				validate(defs.cases, node, 'cases', cases, 1)
				return node
			}
			function thisExpression() {
				return {
					type: 'ThisExpression',
				}
			}
			function throwStatement(argument) {
				const node = {
					type: 'ThrowStatement',
					argument,
				}
				const defs = NODE_FIELDS.ThrowStatement
				validate(defs.argument, node, 'argument', argument, 1)
				return node
			}
			function tryStatement(block, handler = null, finalizer = null) {
				const node = {
					type: 'TryStatement',
					block,
					handler,
					finalizer,
				}
				const defs = NODE_FIELDS.TryStatement
				validate(defs.block, node, 'block', block, 1)
				validate(defs.handler, node, 'handler', handler, 1)
				validate(defs.finalizer, node, 'finalizer', finalizer, 1)
				return node
			}
			function unaryExpression(operator, argument, prefix = true) {
				const node = {
					type: 'UnaryExpression',
					operator,
					argument,
					prefix,
				}
				const defs = NODE_FIELDS.UnaryExpression
				validate(defs.operator, node, 'operator', operator)
				validate(defs.argument, node, 'argument', argument, 1)
				validate(defs.prefix, node, 'prefix', prefix)
				return node
			}
			function updateExpression(operator, argument, prefix = false) {
				const node = {
					type: 'UpdateExpression',
					operator,
					argument,
					prefix,
				}
				const defs = NODE_FIELDS.UpdateExpression
				validate(defs.operator, node, 'operator', operator)
				validate(defs.argument, node, 'argument', argument, 1)
				validate(defs.prefix, node, 'prefix', prefix)
				return node
			}
			function variableDeclaration(kind, declarations) {
				const node = {
					type: 'VariableDeclaration',
					kind,
					declarations,
				}
				const defs = NODE_FIELDS.VariableDeclaration
				validate(defs.kind, node, 'kind', kind)
				validate(defs.declarations, node, 'declarations', declarations, 1)
				return node
			}
			function variableDeclarator(id, init = null) {
				const node = {
					type: 'VariableDeclarator',
					id,
					init,
				}
				const defs = NODE_FIELDS.VariableDeclarator
				validate(defs.id, node, 'id', id, 1)
				validate(defs.init, node, 'init', init, 1)
				return node
			}
			function whileStatement(test, body) {
				const node = {
					type: 'WhileStatement',
					test,
					body,
				}
				const defs = NODE_FIELDS.WhileStatement
				validate(defs.test, node, 'test', test, 1)
				validate(defs.body, node, 'body', body, 1)
				return node
			}
			function withStatement(object, body) {
				const node = {
					type: 'WithStatement',
					object,
					body,
				}
				const defs = NODE_FIELDS.WithStatement
				validate(defs.object, node, 'object', object, 1)
				validate(defs.body, node, 'body', body, 1)
				return node
			}
			function assignmentPattern(left, right) {
				const node = {
					type: 'AssignmentPattern',
					left,
					right,
				}
				const defs = NODE_FIELDS.AssignmentPattern
				validate(defs.left, node, 'left', left, 1)
				validate(defs.right, node, 'right', right, 1)
				return node
			}
			function arrayPattern(elements) {
				const node = {
					type: 'ArrayPattern',
					elements,
				}
				const defs = NODE_FIELDS.ArrayPattern
				validate(defs.elements, node, 'elements', elements, 1)
				return node
			}
			function arrowFunctionExpression(params, body, async = false) {
				const node = {
					type: 'ArrowFunctionExpression',
					params,
					body,
					async,
					expression: null,
				}
				const defs = NODE_FIELDS.ArrowFunctionExpression
				validate(defs.params, node, 'params', params, 1)
				validate(defs.body, node, 'body', body, 1)
				validate(defs.async, node, 'async', async)
				return node
			}
			function classBody(body) {
				const node = {
					type: 'ClassBody',
					body,
				}
				const defs = NODE_FIELDS.ClassBody
				validate(defs.body, node, 'body', body, 1)
				return node
			}
			function classExpression(
				id = null,
				superClass = null,
				body,
				decorators = null,
			) {
				const node = {
					type: 'ClassExpression',
					id,
					superClass,
					body,
					decorators,
				}
				const defs = NODE_FIELDS.ClassExpression
				validate(defs.id, node, 'id', id, 1)
				validate(defs.superClass, node, 'superClass', superClass, 1)
				validate(defs.body, node, 'body', body, 1)
				validate(defs.decorators, node, 'decorators', decorators, 1)
				return node
			}
			function classDeclaration(
				id = null,
				superClass = null,
				body,
				decorators = null,
			) {
				const node = {
					type: 'ClassDeclaration',
					id,
					superClass,
					body,
					decorators,
				}
				const defs = NODE_FIELDS.ClassDeclaration
				validate(defs.id, node, 'id', id, 1)
				validate(defs.superClass, node, 'superClass', superClass, 1)
				validate(defs.body, node, 'body', body, 1)
				validate(defs.decorators, node, 'decorators', decorators, 1)
				return node
			}
			function exportAllDeclaration(source) {
				const node = {
					type: 'ExportAllDeclaration',
					source,
				}
				const defs = NODE_FIELDS.ExportAllDeclaration
				validate(defs.source, node, 'source', source, 1)
				return node
			}
			function exportDefaultDeclaration(declaration) {
				const node = {
					type: 'ExportDefaultDeclaration',
					declaration,
				}
				const defs = NODE_FIELDS.ExportDefaultDeclaration
				validate(defs.declaration, node, 'declaration', declaration, 1)
				return node
			}
			function exportNamedDeclaration(
				declaration = null,
				specifiers = [],
				source = null,
			) {
				const node = {
					type: 'ExportNamedDeclaration',
					declaration,
					specifiers,
					source,
				}
				const defs = NODE_FIELDS.ExportNamedDeclaration
				validate(defs.declaration, node, 'declaration', declaration, 1)
				validate(defs.specifiers, node, 'specifiers', specifiers, 1)
				validate(defs.source, node, 'source', source, 1)
				return node
			}
			function exportSpecifier(local, exported) {
				const node = {
					type: 'ExportSpecifier',
					local,
					exported,
				}
				const defs = NODE_FIELDS.ExportSpecifier
				validate(defs.local, node, 'local', local, 1)
				validate(defs.exported, node, 'exported', exported, 1)
				return node
			}
			function forOfStatement(left, right, body, _await = false) {
				const node = {
					type: 'ForOfStatement',
					left,
					right,
					body,
					await: _await,
				}
				const defs = NODE_FIELDS.ForOfStatement
				validate(defs.left, node, 'left', left, 1)
				validate(defs.right, node, 'right', right, 1)
				validate(defs.body, node, 'body', body, 1)
				validate(defs.await, node, 'await', _await)
				return node
			}
			function importDeclaration(specifiers, source) {
				const node = {
					type: 'ImportDeclaration',
					specifiers,
					source,
				}
				const defs = NODE_FIELDS.ImportDeclaration
				validate(defs.specifiers, node, 'specifiers', specifiers, 1)
				validate(defs.source, node, 'source', source, 1)
				return node
			}
			function importDefaultSpecifier(local) {
				const node = {
					type: 'ImportDefaultSpecifier',
					local,
				}
				const defs = NODE_FIELDS.ImportDefaultSpecifier
				validate(defs.local, node, 'local', local, 1)
				return node
			}
			function importNamespaceSpecifier(local) {
				const node = {
					type: 'ImportNamespaceSpecifier',
					local,
				}
				const defs = NODE_FIELDS.ImportNamespaceSpecifier
				validate(defs.local, node, 'local', local, 1)
				return node
			}
			function importSpecifier(local, imported) {
				const node = {
					type: 'ImportSpecifier',
					local,
					imported,
				}
				const defs = NODE_FIELDS.ImportSpecifier
				validate(defs.local, node, 'local', local, 1)
				validate(defs.imported, node, 'imported', imported, 1)
				return node
			}
			function importExpression(source, options = null) {
				const node = {
					type: 'ImportExpression',
					source,
					options,
				}
				const defs = NODE_FIELDS.ImportExpression
				validate(defs.source, node, 'source', source, 1)
				validate(defs.options, node, 'options', options, 1)
				return node
			}
			function metaProperty(meta, property) {
				const node = {
					type: 'MetaProperty',
					meta,
					property,
				}
				const defs = NODE_FIELDS.MetaProperty
				validate(defs.meta, node, 'meta', meta, 1)
				validate(defs.property, node, 'property', property, 1)
				return node
			}
			function classMethod(
				kind = 'method',
				key,
				params,
				body,
				computed = false,
				_static = false,
				generator = false,
				async = false,
			) {
				const node = {
					type: 'ClassMethod',
					kind,
					key,
					params,
					body,
					computed,
					static: _static,
					generator,
					async,
				}
				const defs = NODE_FIELDS.ClassMethod
				validate(defs.kind, node, 'kind', kind)
				validate(defs.key, node, 'key', key, 1)
				validate(defs.params, node, 'params', params, 1)
				validate(defs.body, node, 'body', body, 1)
				validate(defs.computed, node, 'computed', computed)
				validate(defs.static, node, 'static', _static)
				validate(defs.generator, node, 'generator', generator)
				validate(defs.async, node, 'async', async)
				return node
			}
			function objectPattern(properties) {
				const node = {
					type: 'ObjectPattern',
					properties,
				}
				const defs = NODE_FIELDS.ObjectPattern
				validate(defs.properties, node, 'properties', properties, 1)
				return node
			}
			function spreadElement(argument) {
				const node = {
					type: 'SpreadElement',
					argument,
				}
				const defs = NODE_FIELDS.SpreadElement
				validate(defs.argument, node, 'argument', argument, 1)
				return node
			}
			function _super() {
				return {
					type: 'Super',
				}
			}
			function taggedTemplateExpression(tag, quasi) {
				const node = {
					type: 'TaggedTemplateExpression',
					tag,
					quasi,
				}
				const defs = NODE_FIELDS.TaggedTemplateExpression
				validate(defs.tag, node, 'tag', tag, 1)
				validate(defs.quasi, node, 'quasi', quasi, 1)
				return node
			}
			function templateElement(value, tail = false) {
				const node = {
					type: 'TemplateElement',
					value,
					tail,
				}
				const defs = NODE_FIELDS.TemplateElement
				validate(defs.value, node, 'value', value)
				validate(defs.tail, node, 'tail', tail)
				return node
			}
			function templateLiteral(quasis, expressions) {
				const node = {
					type: 'TemplateLiteral',
					quasis,
					expressions,
				}
				const defs = NODE_FIELDS.TemplateLiteral
				validate(defs.quasis, node, 'quasis', quasis, 1)
				validate(defs.expressions, node, 'expressions', expressions, 1)
				return node
			}
			function yieldExpression(argument = null, delegate = false) {
				const node = {
					type: 'YieldExpression',
					argument,
					delegate,
				}
				const defs = NODE_FIELDS.YieldExpression
				validate(defs.argument, node, 'argument', argument, 1)
				validate(defs.delegate, node, 'delegate', delegate)
				return node
			}
			function awaitExpression(argument) {
				const node = {
					type: 'AwaitExpression',
					argument,
				}
				const defs = NODE_FIELDS.AwaitExpression
				validate(defs.argument, node, 'argument', argument, 1)
				return node
			}
			function _import() {
				return {
					type: 'Import',
				}
			}
			function bigIntLiteral(value) {
				const node = {
					type: 'BigIntLiteral',
					value,
				}
				const defs = NODE_FIELDS.BigIntLiteral
				validate(defs.value, node, 'value', value)
				return node
			}
			function exportNamespaceSpecifier(exported) {
				const node = {
					type: 'ExportNamespaceSpecifier',
					exported,
				}
				const defs = NODE_FIELDS.ExportNamespaceSpecifier
				validate(defs.exported, node, 'exported', exported, 1)
				return node
			}
			function optionalMemberExpression(
				object,
				property,
				computed = false,
				optional,
			) {
				const node = {
					type: 'OptionalMemberExpression',
					object,
					property,
					computed,
					optional,
				}
				const defs = NODE_FIELDS.OptionalMemberExpression
				validate(defs.object, node, 'object', object, 1)
				validate(defs.property, node, 'property', property, 1)
				validate(defs.computed, node, 'computed', computed)
				validate(defs.optional, node, 'optional', optional)
				return node
			}
			function optionalCallExpression(callee, _arguments, optional) {
				const node = {
					type: 'OptionalCallExpression',
					callee,
					arguments: _arguments,
					optional,
				}
				const defs = NODE_FIELDS.OptionalCallExpression
				validate(defs.callee, node, 'callee', callee, 1)
				validate(defs.arguments, node, 'arguments', _arguments, 1)
				validate(defs.optional, node, 'optional', optional)
				return node
			}
			function classProperty(
				key,
				value = null,
				typeAnnotation = null,
				decorators = null,
				computed = false,
				_static = false,
			) {
				const node = {
					type: 'ClassProperty',
					key,
					value,
					typeAnnotation,
					decorators,
					computed,
					static: _static,
				}
				const defs = NODE_FIELDS.ClassProperty
				validate(defs.key, node, 'key', key, 1)
				validate(defs.value, node, 'value', value, 1)
				validate(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation, 1)
				validate(defs.decorators, node, 'decorators', decorators, 1)
				validate(defs.computed, node, 'computed', computed)
				validate(defs.static, node, 'static', _static)
				return node
			}
			function classAccessorProperty(
				key,
				value = null,
				typeAnnotation = null,
				decorators = null,
				computed = false,
				_static = false,
			) {
				const node = {
					type: 'ClassAccessorProperty',
					key,
					value,
					typeAnnotation,
					decorators,
					computed,
					static: _static,
				}
				const defs = NODE_FIELDS.ClassAccessorProperty
				validate(defs.key, node, 'key', key, 1)
				validate(defs.value, node, 'value', value, 1)
				validate(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation, 1)
				validate(defs.decorators, node, 'decorators', decorators, 1)
				validate(defs.computed, node, 'computed', computed)
				validate(defs.static, node, 'static', _static)
				return node
			}
			function classPrivateProperty(
				key,
				value = null,
				decorators = null,
				_static = false,
			) {
				const node = {
					type: 'ClassPrivateProperty',
					key,
					value,
					decorators,
					static: _static,
				}
				const defs = NODE_FIELDS.ClassPrivateProperty
				validate(defs.key, node, 'key', key, 1)
				validate(defs.value, node, 'value', value, 1)
				validate(defs.decorators, node, 'decorators', decorators, 1)
				validate(defs.static, node, 'static', _static)
				return node
			}
			function classPrivateMethod(
				kind = 'method',
				key,
				params,
				body,
				_static = false,
			) {
				const node = {
					type: 'ClassPrivateMethod',
					kind,
					key,
					params,
					body,
					static: _static,
				}
				const defs = NODE_FIELDS.ClassPrivateMethod
				validate(defs.kind, node, 'kind', kind)
				validate(defs.key, node, 'key', key, 1)
				validate(defs.params, node, 'params', params, 1)
				validate(defs.body, node, 'body', body, 1)
				validate(defs.static, node, 'static', _static)
				return node
			}
			function privateName(id) {
				const node = {
					type: 'PrivateName',
					id,
				}
				const defs = NODE_FIELDS.PrivateName
				validate(defs.id, node, 'id', id, 1)
				return node
			}
			function staticBlock(body) {
				const node = {
					type: 'StaticBlock',
					body,
				}
				const defs = NODE_FIELDS.StaticBlock
				validate(defs.body, node, 'body', body, 1)
				return node
			}
			function importAttribute(key, value) {
				const node = {
					type: 'ImportAttribute',
					key,
					value,
				}
				const defs = NODE_FIELDS.ImportAttribute
				validate(defs.key, node, 'key', key, 1)
				validate(defs.value, node, 'value', value, 1)
				return node
			}
			function anyTypeAnnotation() {
				return {
					type: 'AnyTypeAnnotation',
				}
			}
			function arrayTypeAnnotation(elementType) {
				const node = {
					type: 'ArrayTypeAnnotation',
					elementType,
				}
				const defs = NODE_FIELDS.ArrayTypeAnnotation
				validate(defs.elementType, node, 'elementType', elementType, 1)
				return node
			}
			function booleanTypeAnnotation() {
				return {
					type: 'BooleanTypeAnnotation',
				}
			}
			function booleanLiteralTypeAnnotation(value) {
				const node = {
					type: 'BooleanLiteralTypeAnnotation',
					value,
				}
				const defs = NODE_FIELDS.BooleanLiteralTypeAnnotation
				validate(defs.value, node, 'value', value)
				return node
			}
			function nullLiteralTypeAnnotation() {
				return {
					type: 'NullLiteralTypeAnnotation',
				}
			}
			function classImplements(id, typeParameters = null) {
				const node = {
					type: 'ClassImplements',
					id,
					typeParameters,
				}
				const defs = NODE_FIELDS.ClassImplements
				validate(defs.id, node, 'id', id, 1)
				validate(defs.typeParameters, node, 'typeParameters', typeParameters, 1)
				return node
			}
			function declareClass(id, typeParameters = null, _extends = null, body) {
				const node = {
					type: 'DeclareClass',
					id,
					typeParameters,
					extends: _extends,
					body,
				}
				const defs = NODE_FIELDS.DeclareClass
				validate(defs.id, node, 'id', id, 1)
				validate(defs.typeParameters, node, 'typeParameters', typeParameters, 1)
				validate(defs.extends, node, 'extends', _extends, 1)
				validate(defs.body, node, 'body', body, 1)
				return node
			}
			function declareFunction(id) {
				const node = {
					type: 'DeclareFunction',
					id,
				}
				const defs = NODE_FIELDS.DeclareFunction
				validate(defs.id, node, 'id', id, 1)
				return node
			}
			function declareInterface(
				id,
				typeParameters = null,
				_extends = null,
				body,
			) {
				const node = {
					type: 'DeclareInterface',
					id,
					typeParameters,
					extends: _extends,
					body,
				}
				const defs = NODE_FIELDS.DeclareInterface
				validate(defs.id, node, 'id', id, 1)
				validate(defs.typeParameters, node, 'typeParameters', typeParameters, 1)
				validate(defs.extends, node, 'extends', _extends, 1)
				validate(defs.body, node, 'body', body, 1)
				return node
			}
			function declareModule(id, body, kind = null) {
				const node = {
					type: 'DeclareModule',
					id,
					body,
					kind,
				}
				const defs = NODE_FIELDS.DeclareModule
				validate(defs.id, node, 'id', id, 1)
				validate(defs.body, node, 'body', body, 1)
				validate(defs.kind, node, 'kind', kind)
				return node
			}
			function declareModuleExports(typeAnnotation) {
				const node = {
					type: 'DeclareModuleExports',
					typeAnnotation,
				}
				const defs = NODE_FIELDS.DeclareModuleExports
				validate(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation, 1)
				return node
			}
			function declareTypeAlias(id, typeParameters = null, right) {
				const node = {
					type: 'DeclareTypeAlias',
					id,
					typeParameters,
					right,
				}
				const defs = NODE_FIELDS.DeclareTypeAlias
				validate(defs.id, node, 'id', id, 1)
				validate(defs.typeParameters, node, 'typeParameters', typeParameters, 1)
				validate(defs.right, node, 'right', right, 1)
				return node
			}
			function declareOpaqueType(id, typeParameters = null, supertype = null) {
				const node = {
					type: 'DeclareOpaqueType',
					id,
					typeParameters,
					supertype,
				}
				const defs = NODE_FIELDS.DeclareOpaqueType
				validate(defs.id, node, 'id', id, 1)
				validate(defs.typeParameters, node, 'typeParameters', typeParameters, 1)
				validate(defs.supertype, node, 'supertype', supertype, 1)
				return node
			}
			function declareVariable(id) {
				const node = {
					type: 'DeclareVariable',
					id,
				}
				const defs = NODE_FIELDS.DeclareVariable
				validate(defs.id, node, 'id', id, 1)
				return node
			}
			function declareExportDeclaration(
				declaration = null,
				specifiers = null,
				source = null,
				attributes = null,
			) {
				const node = {
					type: 'DeclareExportDeclaration',
					declaration,
					specifiers,
					source,
					attributes,
				}
				const defs = NODE_FIELDS.DeclareExportDeclaration
				validate(defs.declaration, node, 'declaration', declaration, 1)
				validate(defs.specifiers, node, 'specifiers', specifiers, 1)
				validate(defs.source, node, 'source', source, 1)
				validate(defs.attributes, node, 'attributes', attributes, 1)
				return node
			}
			function declareExportAllDeclaration(source, attributes = null) {
				const node = {
					type: 'DeclareExportAllDeclaration',
					source,
					attributes,
				}
				const defs = NODE_FIELDS.DeclareExportAllDeclaration
				validate(defs.source, node, 'source', source, 1)
				validate(defs.attributes, node, 'attributes', attributes, 1)
				return node
			}
			function declaredPredicate(value) {
				const node = {
					type: 'DeclaredPredicate',
					value,
				}
				const defs = NODE_FIELDS.DeclaredPredicate
				validate(defs.value, node, 'value', value, 1)
				return node
			}
			function existsTypeAnnotation() {
				return {
					type: 'ExistsTypeAnnotation',
				}
			}
			function functionTypeAnnotation(
				typeParameters = null,
				params,
				rest = null,
				returnType,
			) {
				const node = {
					type: 'FunctionTypeAnnotation',
					typeParameters,
					params,
					rest,
					returnType,
				}
				const defs = NODE_FIELDS.FunctionTypeAnnotation
				validate(defs.typeParameters, node, 'typeParameters', typeParameters, 1)
				validate(defs.params, node, 'params', params, 1)
				validate(defs.rest, node, 'rest', rest, 1)
				validate(defs.returnType, node, 'returnType', returnType, 1)
				return node
			}
			function functionTypeParam(name = null, typeAnnotation) {
				const node = {
					type: 'FunctionTypeParam',
					name,
					typeAnnotation,
				}
				const defs = NODE_FIELDS.FunctionTypeParam
				validate(defs.name, node, 'name', name, 1)
				validate(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation, 1)
				return node
			}
			function genericTypeAnnotation(id, typeParameters = null) {
				const node = {
					type: 'GenericTypeAnnotation',
					id,
					typeParameters,
				}
				const defs = NODE_FIELDS.GenericTypeAnnotation
				validate(defs.id, node, 'id', id, 1)
				validate(defs.typeParameters, node, 'typeParameters', typeParameters, 1)
				return node
			}
			function inferredPredicate() {
				return {
					type: 'InferredPredicate',
				}
			}
			function interfaceExtends(id, typeParameters = null) {
				const node = {
					type: 'InterfaceExtends',
					id,
					typeParameters,
				}
				const defs = NODE_FIELDS.InterfaceExtends
				validate(defs.id, node, 'id', id, 1)
				validate(defs.typeParameters, node, 'typeParameters', typeParameters, 1)
				return node
			}
			function interfaceDeclaration(
				id,
				typeParameters = null,
				_extends = null,
				body,
			) {
				const node = {
					type: 'InterfaceDeclaration',
					id,
					typeParameters,
					extends: _extends,
					body,
				}
				const defs = NODE_FIELDS.InterfaceDeclaration
				validate(defs.id, node, 'id', id, 1)
				validate(defs.typeParameters, node, 'typeParameters', typeParameters, 1)
				validate(defs.extends, node, 'extends', _extends, 1)
				validate(defs.body, node, 'body', body, 1)
				return node
			}
			function interfaceTypeAnnotation(_extends = null, body) {
				const node = {
					type: 'InterfaceTypeAnnotation',
					extends: _extends,
					body,
				}
				const defs = NODE_FIELDS.InterfaceTypeAnnotation
				validate(defs.extends, node, 'extends', _extends, 1)
				validate(defs.body, node, 'body', body, 1)
				return node
			}
			function intersectionTypeAnnotation(types) {
				const node = {
					type: 'IntersectionTypeAnnotation',
					types,
				}
				const defs = NODE_FIELDS.IntersectionTypeAnnotation
				validate(defs.types, node, 'types', types, 1)
				return node
			}
			function mixedTypeAnnotation() {
				return {
					type: 'MixedTypeAnnotation',
				}
			}
			function emptyTypeAnnotation() {
				return {
					type: 'EmptyTypeAnnotation',
				}
			}
			function nullableTypeAnnotation(typeAnnotation) {
				const node = {
					type: 'NullableTypeAnnotation',
					typeAnnotation,
				}
				const defs = NODE_FIELDS.NullableTypeAnnotation
				validate(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation, 1)
				return node
			}
			function numberLiteralTypeAnnotation(value) {
				const node = {
					type: 'NumberLiteralTypeAnnotation',
					value,
				}
				const defs = NODE_FIELDS.NumberLiteralTypeAnnotation
				validate(defs.value, node, 'value', value)
				return node
			}
			function numberTypeAnnotation() {
				return {
					type: 'NumberTypeAnnotation',
				}
			}
			function objectTypeAnnotation(
				properties,
				indexers = [],
				callProperties = [],
				internalSlots = [],
				exact = false,
			) {
				const node = {
					type: 'ObjectTypeAnnotation',
					properties,
					indexers,
					callProperties,
					internalSlots,
					exact,
				}
				const defs = NODE_FIELDS.ObjectTypeAnnotation
				validate(defs.properties, node, 'properties', properties, 1)
				validate(defs.indexers, node, 'indexers', indexers, 1)
				validate(defs.callProperties, node, 'callProperties', callProperties, 1)
				validate(defs.internalSlots, node, 'internalSlots', internalSlots, 1)
				validate(defs.exact, node, 'exact', exact)
				return node
			}
			function objectTypeInternalSlot(id, value, optional, _static, method) {
				const node = {
					type: 'ObjectTypeInternalSlot',
					id,
					value,
					optional,
					static: _static,
					method,
				}
				const defs = NODE_FIELDS.ObjectTypeInternalSlot
				validate(defs.id, node, 'id', id, 1)
				validate(defs.value, node, 'value', value, 1)
				validate(defs.optional, node, 'optional', optional)
				validate(defs.static, node, 'static', _static)
				validate(defs.method, node, 'method', method)
				return node
			}
			function objectTypeCallProperty(value) {
				const node = {
					type: 'ObjectTypeCallProperty',
					value,
					static: null,
				}
				const defs = NODE_FIELDS.ObjectTypeCallProperty
				validate(defs.value, node, 'value', value, 1)
				return node
			}
			function objectTypeIndexer(id = null, key, value, variance = null) {
				const node = {
					type: 'ObjectTypeIndexer',
					id,
					key,
					value,
					variance,
					static: null,
				}
				const defs = NODE_FIELDS.ObjectTypeIndexer
				validate(defs.id, node, 'id', id, 1)
				validate(defs.key, node, 'key', key, 1)
				validate(defs.value, node, 'value', value, 1)
				validate(defs.variance, node, 'variance', variance, 1)
				return node
			}
			function objectTypeProperty(key, value, variance = null) {
				const node = {
					type: 'ObjectTypeProperty',
					key,
					value,
					variance,
					kind: null,
					method: null,
					optional: null,
					proto: null,
					static: null,
				}
				const defs = NODE_FIELDS.ObjectTypeProperty
				validate(defs.key, node, 'key', key, 1)
				validate(defs.value, node, 'value', value, 1)
				validate(defs.variance, node, 'variance', variance, 1)
				return node
			}
			function objectTypeSpreadProperty(argument) {
				const node = {
					type: 'ObjectTypeSpreadProperty',
					argument,
				}
				const defs = NODE_FIELDS.ObjectTypeSpreadProperty
				validate(defs.argument, node, 'argument', argument, 1)
				return node
			}
			function opaqueType(
				id,
				typeParameters = null,
				supertype = null,
				impltype,
			) {
				const node = {
					type: 'OpaqueType',
					id,
					typeParameters,
					supertype,
					impltype,
				}
				const defs = NODE_FIELDS.OpaqueType
				validate(defs.id, node, 'id', id, 1)
				validate(defs.typeParameters, node, 'typeParameters', typeParameters, 1)
				validate(defs.supertype, node, 'supertype', supertype, 1)
				validate(defs.impltype, node, 'impltype', impltype, 1)
				return node
			}
			function qualifiedTypeIdentifier(id, qualification) {
				const node = {
					type: 'QualifiedTypeIdentifier',
					id,
					qualification,
				}
				const defs = NODE_FIELDS.QualifiedTypeIdentifier
				validate(defs.id, node, 'id', id, 1)
				validate(defs.qualification, node, 'qualification', qualification, 1)
				return node
			}
			function stringLiteralTypeAnnotation(value) {
				const node = {
					type: 'StringLiteralTypeAnnotation',
					value,
				}
				const defs = NODE_FIELDS.StringLiteralTypeAnnotation
				validate(defs.value, node, 'value', value)
				return node
			}
			function stringTypeAnnotation() {
				return {
					type: 'StringTypeAnnotation',
				}
			}
			function symbolTypeAnnotation() {
				return {
					type: 'SymbolTypeAnnotation',
				}
			}
			function thisTypeAnnotation() {
				return {
					type: 'ThisTypeAnnotation',
				}
			}
			function tupleTypeAnnotation(types) {
				const node = {
					type: 'TupleTypeAnnotation',
					types,
				}
				const defs = NODE_FIELDS.TupleTypeAnnotation
				validate(defs.types, node, 'types', types, 1)
				return node
			}
			function typeofTypeAnnotation(argument) {
				const node = {
					type: 'TypeofTypeAnnotation',
					argument,
				}
				const defs = NODE_FIELDS.TypeofTypeAnnotation
				validate(defs.argument, node, 'argument', argument, 1)
				return node
			}
			function typeAlias(id, typeParameters = null, right) {
				const node = {
					type: 'TypeAlias',
					id,
					typeParameters,
					right,
				}
				const defs = NODE_FIELDS.TypeAlias
				validate(defs.id, node, 'id', id, 1)
				validate(defs.typeParameters, node, 'typeParameters', typeParameters, 1)
				validate(defs.right, node, 'right', right, 1)
				return node
			}
			function typeAnnotation(typeAnnotation) {
				const node = {
					type: 'TypeAnnotation',
					typeAnnotation,
				}
				const defs = NODE_FIELDS.TypeAnnotation
				validate(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation, 1)
				return node
			}
			function typeCastExpression(expression, typeAnnotation) {
				const node = {
					type: 'TypeCastExpression',
					expression,
					typeAnnotation,
				}
				const defs = NODE_FIELDS.TypeCastExpression
				validate(defs.expression, node, 'expression', expression, 1)
				validate(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation, 1)
				return node
			}
			function typeParameter(bound = null, _default = null, variance = null) {
				const node = {
					type: 'TypeParameter',
					bound,
					default: _default,
					variance,
					name: null,
				}
				const defs = NODE_FIELDS.TypeParameter
				validate(defs.bound, node, 'bound', bound, 1)
				validate(defs.default, node, 'default', _default, 1)
				validate(defs.variance, node, 'variance', variance, 1)
				return node
			}
			function typeParameterDeclaration(params) {
				const node = {
					type: 'TypeParameterDeclaration',
					params,
				}
				const defs = NODE_FIELDS.TypeParameterDeclaration
				validate(defs.params, node, 'params', params, 1)
				return node
			}
			function typeParameterInstantiation(params) {
				const node = {
					type: 'TypeParameterInstantiation',
					params,
				}
				const defs = NODE_FIELDS.TypeParameterInstantiation
				validate(defs.params, node, 'params', params, 1)
				return node
			}
			function unionTypeAnnotation(types) {
				const node = {
					type: 'UnionTypeAnnotation',
					types,
				}
				const defs = NODE_FIELDS.UnionTypeAnnotation
				validate(defs.types, node, 'types', types, 1)
				return node
			}
			function variance(kind) {
				const node = {
					type: 'Variance',
					kind,
				}
				const defs = NODE_FIELDS.Variance
				validate(defs.kind, node, 'kind', kind)
				return node
			}
			function voidTypeAnnotation() {
				return {
					type: 'VoidTypeAnnotation',
				}
			}
			function enumDeclaration(id, body) {
				const node = {
					type: 'EnumDeclaration',
					id,
					body,
				}
				const defs = NODE_FIELDS.EnumDeclaration
				validate(defs.id, node, 'id', id, 1)
				validate(defs.body, node, 'body', body, 1)
				return node
			}
			function enumBooleanBody(members) {
				const node = {
					type: 'EnumBooleanBody',
					members,
					explicitType: null,
					hasUnknownMembers: null,
				}
				const defs = NODE_FIELDS.EnumBooleanBody
				validate(defs.members, node, 'members', members, 1)
				return node
			}
			function enumNumberBody(members) {
				const node = {
					type: 'EnumNumberBody',
					members,
					explicitType: null,
					hasUnknownMembers: null,
				}
				const defs = NODE_FIELDS.EnumNumberBody
				validate(defs.members, node, 'members', members, 1)
				return node
			}
			function enumStringBody(members) {
				const node = {
					type: 'EnumStringBody',
					members,
					explicitType: null,
					hasUnknownMembers: null,
				}
				const defs = NODE_FIELDS.EnumStringBody
				validate(defs.members, node, 'members', members, 1)
				return node
			}
			function enumSymbolBody(members) {
				const node = {
					type: 'EnumSymbolBody',
					members,
					hasUnknownMembers: null,
				}
				const defs = NODE_FIELDS.EnumSymbolBody
				validate(defs.members, node, 'members', members, 1)
				return node
			}
			function enumBooleanMember(id) {
				const node = {
					type: 'EnumBooleanMember',
					id,
					init: null,
				}
				const defs = NODE_FIELDS.EnumBooleanMember
				validate(defs.id, node, 'id', id, 1)
				return node
			}
			function enumNumberMember(id, init) {
				const node = {
					type: 'EnumNumberMember',
					id,
					init,
				}
				const defs = NODE_FIELDS.EnumNumberMember
				validate(defs.id, node, 'id', id, 1)
				validate(defs.init, node, 'init', init, 1)
				return node
			}
			function enumStringMember(id, init) {
				const node = {
					type: 'EnumStringMember',
					id,
					init,
				}
				const defs = NODE_FIELDS.EnumStringMember
				validate(defs.id, node, 'id', id, 1)
				validate(defs.init, node, 'init', init, 1)
				return node
			}
			function enumDefaultedMember(id) {
				const node = {
					type: 'EnumDefaultedMember',
					id,
				}
				const defs = NODE_FIELDS.EnumDefaultedMember
				validate(defs.id, node, 'id', id, 1)
				return node
			}
			function indexedAccessType(objectType, indexType) {
				const node = {
					type: 'IndexedAccessType',
					objectType,
					indexType,
				}
				const defs = NODE_FIELDS.IndexedAccessType
				validate(defs.objectType, node, 'objectType', objectType, 1)
				validate(defs.indexType, node, 'indexType', indexType, 1)
				return node
			}
			function optionalIndexedAccessType(objectType, indexType) {
				const node = {
					type: 'OptionalIndexedAccessType',
					objectType,
					indexType,
					optional: null,
				}
				const defs = NODE_FIELDS.OptionalIndexedAccessType
				validate(defs.objectType, node, 'objectType', objectType, 1)
				validate(defs.indexType, node, 'indexType', indexType, 1)
				return node
			}
			function jsxAttribute(name, value = null) {
				const node = {
					type: 'JSXAttribute',
					name,
					value,
				}
				const defs = NODE_FIELDS.JSXAttribute
				validate(defs.name, node, 'name', name, 1)
				validate(defs.value, node, 'value', value, 1)
				return node
			}
			function jsxClosingElement(name) {
				const node = {
					type: 'JSXClosingElement',
					name,
				}
				const defs = NODE_FIELDS.JSXClosingElement
				validate(defs.name, node, 'name', name, 1)
				return node
			}
			function jsxElement(
				openingElement,
				closingElement = null,
				children,
				selfClosing = null,
			) {
				const node = {
					type: 'JSXElement',
					openingElement,
					closingElement,
					children,
					selfClosing,
				}
				const defs = NODE_FIELDS.JSXElement
				validate(defs.openingElement, node, 'openingElement', openingElement, 1)
				validate(defs.closingElement, node, 'closingElement', closingElement, 1)
				validate(defs.children, node, 'children', children, 1)
				validate(defs.selfClosing, node, 'selfClosing', selfClosing)
				return node
			}
			function jsxEmptyExpression() {
				return {
					type: 'JSXEmptyExpression',
				}
			}
			function jsxExpressionContainer(expression) {
				const node = {
					type: 'JSXExpressionContainer',
					expression,
				}
				const defs = NODE_FIELDS.JSXExpressionContainer
				validate(defs.expression, node, 'expression', expression, 1)
				return node
			}
			function jsxSpreadChild(expression) {
				const node = {
					type: 'JSXSpreadChild',
					expression,
				}
				const defs = NODE_FIELDS.JSXSpreadChild
				validate(defs.expression, node, 'expression', expression, 1)
				return node
			}
			function jsxIdentifier(name) {
				const node = {
					type: 'JSXIdentifier',
					name,
				}
				const defs = NODE_FIELDS.JSXIdentifier
				validate(defs.name, node, 'name', name)
				return node
			}
			function jsxMemberExpression(object, property) {
				const node = {
					type: 'JSXMemberExpression',
					object,
					property,
				}
				const defs = NODE_FIELDS.JSXMemberExpression
				validate(defs.object, node, 'object', object, 1)
				validate(defs.property, node, 'property', property, 1)
				return node
			}
			function jsxNamespacedName(namespace, name) {
				const node = {
					type: 'JSXNamespacedName',
					namespace,
					name,
				}
				const defs = NODE_FIELDS.JSXNamespacedName
				validate(defs.namespace, node, 'namespace', namespace, 1)
				validate(defs.name, node, 'name', name, 1)
				return node
			}
			function jsxOpeningElement(name, attributes, selfClosing = false) {
				const node = {
					type: 'JSXOpeningElement',
					name,
					attributes,
					selfClosing,
				}
				const defs = NODE_FIELDS.JSXOpeningElement
				validate(defs.name, node, 'name', name, 1)
				validate(defs.attributes, node, 'attributes', attributes, 1)
				validate(defs.selfClosing, node, 'selfClosing', selfClosing)
				return node
			}
			function jsxSpreadAttribute(argument) {
				const node = {
					type: 'JSXSpreadAttribute',
					argument,
				}
				const defs = NODE_FIELDS.JSXSpreadAttribute
				validate(defs.argument, node, 'argument', argument, 1)
				return node
			}
			function jsxText(value) {
				const node = {
					type: 'JSXText',
					value,
				}
				const defs = NODE_FIELDS.JSXText
				validate(defs.value, node, 'value', value)
				return node
			}
			function jsxFragment(openingFragment, closingFragment, children) {
				const node = {
					type: 'JSXFragment',
					openingFragment,
					closingFragment,
					children,
				}
				const defs = NODE_FIELDS.JSXFragment
				validate(
					defs.openingFragment,
					node,
					'openingFragment',
					openingFragment,
					1,
				)
				validate(
					defs.closingFragment,
					node,
					'closingFragment',
					closingFragment,
					1,
				)
				validate(defs.children, node, 'children', children, 1)
				return node
			}
			function jsxOpeningFragment() {
				return {
					type: 'JSXOpeningFragment',
				}
			}
			function jsxClosingFragment() {
				return {
					type: 'JSXClosingFragment',
				}
			}
			function noop() {
				return {
					type: 'Noop',
				}
			}
			function placeholder(expectedNode, name) {
				const node = {
					type: 'Placeholder',
					expectedNode,
					name,
				}
				const defs = NODE_FIELDS.Placeholder
				validate(defs.expectedNode, node, 'expectedNode', expectedNode)
				validate(defs.name, node, 'name', name, 1)
				return node
			}
			function v8IntrinsicIdentifier(name) {
				const node = {
					type: 'V8IntrinsicIdentifier',
					name,
				}
				const defs = NODE_FIELDS.V8IntrinsicIdentifier
				validate(defs.name, node, 'name', name)
				return node
			}
			function argumentPlaceholder() {
				return {
					type: 'ArgumentPlaceholder',
				}
			}
			function bindExpression(object, callee) {
				const node = {
					type: 'BindExpression',
					object,
					callee,
				}
				const defs = NODE_FIELDS.BindExpression
				validate(defs.object, node, 'object', object, 1)
				validate(defs.callee, node, 'callee', callee, 1)
				return node
			}
			function decorator(expression) {
				const node = {
					type: 'Decorator',
					expression,
				}
				const defs = NODE_FIELDS.Decorator
				validate(defs.expression, node, 'expression', expression, 1)
				return node
			}
			function doExpression(body, async = false) {
				const node = {
					type: 'DoExpression',
					body,
					async,
				}
				const defs = NODE_FIELDS.DoExpression
				validate(defs.body, node, 'body', body, 1)
				validate(defs.async, node, 'async', async)
				return node
			}
			function exportDefaultSpecifier(exported) {
				const node = {
					type: 'ExportDefaultSpecifier',
					exported,
				}
				const defs = NODE_FIELDS.ExportDefaultSpecifier
				validate(defs.exported, node, 'exported', exported, 1)
				return node
			}
			function recordExpression(properties) {
				const node = {
					type: 'RecordExpression',
					properties,
				}
				const defs = NODE_FIELDS.RecordExpression
				validate(defs.properties, node, 'properties', properties, 1)
				return node
			}
			function tupleExpression(elements = []) {
				const node = {
					type: 'TupleExpression',
					elements,
				}
				const defs = NODE_FIELDS.TupleExpression
				validate(defs.elements, node, 'elements', elements, 1)
				return node
			}
			function decimalLiteral(value) {
				const node = {
					type: 'DecimalLiteral',
					value,
				}
				const defs = NODE_FIELDS.DecimalLiteral
				validate(defs.value, node, 'value', value)
				return node
			}
			function moduleExpression(body) {
				const node = {
					type: 'ModuleExpression',
					body,
				}
				const defs = NODE_FIELDS.ModuleExpression
				validate(defs.body, node, 'body', body, 1)
				return node
			}
			function topicReference() {
				return {
					type: 'TopicReference',
				}
			}
			function pipelineTopicExpression(expression) {
				const node = {
					type: 'PipelineTopicExpression',
					expression,
				}
				const defs = NODE_FIELDS.PipelineTopicExpression
				validate(defs.expression, node, 'expression', expression, 1)
				return node
			}
			function pipelineBareFunction(callee) {
				const node = {
					type: 'PipelineBareFunction',
					callee,
				}
				const defs = NODE_FIELDS.PipelineBareFunction
				validate(defs.callee, node, 'callee', callee, 1)
				return node
			}
			function pipelinePrimaryTopicReference() {
				return {
					type: 'PipelinePrimaryTopicReference',
				}
			}
			function tsParameterProperty(parameter) {
				const node = {
					type: 'TSParameterProperty',
					parameter,
				}
				const defs = NODE_FIELDS.TSParameterProperty
				validate(defs.parameter, node, 'parameter', parameter, 1)
				return node
			}
			function tsDeclareFunction(
				id = null,
				typeParameters = null,
				params,
				returnType = null,
			) {
				const node = {
					type: 'TSDeclareFunction',
					id,
					typeParameters,
					params,
					returnType,
				}
				const defs = NODE_FIELDS.TSDeclareFunction
				validate(defs.id, node, 'id', id, 1)
				validate(defs.typeParameters, node, 'typeParameters', typeParameters, 1)
				validate(defs.params, node, 'params', params, 1)
				validate(defs.returnType, node, 'returnType', returnType, 1)
				return node
			}
			function tsDeclareMethod(
				decorators = null,
				key,
				typeParameters = null,
				params,
				returnType = null,
			) {
				const node = {
					type: 'TSDeclareMethod',
					decorators,
					key,
					typeParameters,
					params,
					returnType,
				}
				const defs = NODE_FIELDS.TSDeclareMethod
				validate(defs.decorators, node, 'decorators', decorators, 1)
				validate(defs.key, node, 'key', key, 1)
				validate(defs.typeParameters, node, 'typeParameters', typeParameters, 1)
				validate(defs.params, node, 'params', params, 1)
				validate(defs.returnType, node, 'returnType', returnType, 1)
				return node
			}
			function tsQualifiedName(left, right) {
				const node = {
					type: 'TSQualifiedName',
					left,
					right,
				}
				const defs = NODE_FIELDS.TSQualifiedName
				validate(defs.left, node, 'left', left, 1)
				validate(defs.right, node, 'right', right, 1)
				return node
			}
			function tsCallSignatureDeclaration(
				typeParameters = null,
				parameters,
				typeAnnotation = null,
			) {
				const node = {
					type: 'TSCallSignatureDeclaration',
					typeParameters,
					parameters,
					typeAnnotation,
				}
				const defs = NODE_FIELDS.TSCallSignatureDeclaration
				validate(defs.typeParameters, node, 'typeParameters', typeParameters, 1)
				validate(defs.parameters, node, 'parameters', parameters, 1)
				validate(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation, 1)
				return node
			}
			function tsConstructSignatureDeclaration(
				typeParameters = null,
				parameters,
				typeAnnotation = null,
			) {
				const node = {
					type: 'TSConstructSignatureDeclaration',
					typeParameters,
					parameters,
					typeAnnotation,
				}
				const defs = NODE_FIELDS.TSConstructSignatureDeclaration
				validate(defs.typeParameters, node, 'typeParameters', typeParameters, 1)
				validate(defs.parameters, node, 'parameters', parameters, 1)
				validate(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation, 1)
				return node
			}
			function tsPropertySignature(key, typeAnnotation = null) {
				const node = {
					type: 'TSPropertySignature',
					key,
					typeAnnotation,
				}
				const defs = NODE_FIELDS.TSPropertySignature
				validate(defs.key, node, 'key', key, 1)
				validate(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation, 1)
				return node
			}
			function tsMethodSignature(
				key,
				typeParameters = null,
				parameters,
				typeAnnotation = null,
			) {
				const node = {
					type: 'TSMethodSignature',
					key,
					typeParameters,
					parameters,
					typeAnnotation,
					kind: null,
				}
				const defs = NODE_FIELDS.TSMethodSignature
				validate(defs.key, node, 'key', key, 1)
				validate(defs.typeParameters, node, 'typeParameters', typeParameters, 1)
				validate(defs.parameters, node, 'parameters', parameters, 1)
				validate(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation, 1)
				return node
			}
			function tsIndexSignature(parameters, typeAnnotation = null) {
				const node = {
					type: 'TSIndexSignature',
					parameters,
					typeAnnotation,
				}
				const defs = NODE_FIELDS.TSIndexSignature
				validate(defs.parameters, node, 'parameters', parameters, 1)
				validate(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation, 1)
				return node
			}
			function tsAnyKeyword() {
				return {
					type: 'TSAnyKeyword',
				}
			}
			function tsBooleanKeyword() {
				return {
					type: 'TSBooleanKeyword',
				}
			}
			function tsBigIntKeyword() {
				return {
					type: 'TSBigIntKeyword',
				}
			}
			function tsIntrinsicKeyword() {
				return {
					type: 'TSIntrinsicKeyword',
				}
			}
			function tsNeverKeyword() {
				return {
					type: 'TSNeverKeyword',
				}
			}
			function tsNullKeyword() {
				return {
					type: 'TSNullKeyword',
				}
			}
			function tsNumberKeyword() {
				return {
					type: 'TSNumberKeyword',
				}
			}
			function tsObjectKeyword() {
				return {
					type: 'TSObjectKeyword',
				}
			}
			function tsStringKeyword() {
				return {
					type: 'TSStringKeyword',
				}
			}
			function tsSymbolKeyword() {
				return {
					type: 'TSSymbolKeyword',
				}
			}
			function tsUndefinedKeyword() {
				return {
					type: 'TSUndefinedKeyword',
				}
			}
			function tsUnknownKeyword() {
				return {
					type: 'TSUnknownKeyword',
				}
			}
			function tsVoidKeyword() {
				return {
					type: 'TSVoidKeyword',
				}
			}
			function tsThisType() {
				return {
					type: 'TSThisType',
				}
			}
			function tsFunctionType(
				typeParameters = null,
				parameters,
				typeAnnotation = null,
			) {
				const node = {
					type: 'TSFunctionType',
					typeParameters,
					parameters,
					typeAnnotation,
				}
				const defs = NODE_FIELDS.TSFunctionType
				validate(defs.typeParameters, node, 'typeParameters', typeParameters, 1)
				validate(defs.parameters, node, 'parameters', parameters, 1)
				validate(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation, 1)
				return node
			}
			function tsConstructorType(
				typeParameters = null,
				parameters,
				typeAnnotation = null,
			) {
				const node = {
					type: 'TSConstructorType',
					typeParameters,
					parameters,
					typeAnnotation,
				}
				const defs = NODE_FIELDS.TSConstructorType
				validate(defs.typeParameters, node, 'typeParameters', typeParameters, 1)
				validate(defs.parameters, node, 'parameters', parameters, 1)
				validate(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation, 1)
				return node
			}
			function tsTypeReference(typeName, typeParameters = null) {
				const node = {
					type: 'TSTypeReference',
					typeName,
					typeParameters,
				}
				const defs = NODE_FIELDS.TSTypeReference
				validate(defs.typeName, node, 'typeName', typeName, 1)
				validate(defs.typeParameters, node, 'typeParameters', typeParameters, 1)
				return node
			}
			function tsTypePredicate(
				parameterName,
				typeAnnotation = null,
				asserts = null,
			) {
				const node = {
					type: 'TSTypePredicate',
					parameterName,
					typeAnnotation,
					asserts,
				}
				const defs = NODE_FIELDS.TSTypePredicate
				validate(defs.parameterName, node, 'parameterName', parameterName, 1)
				validate(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation, 1)
				validate(defs.asserts, node, 'asserts', asserts)
				return node
			}
			function tsTypeQuery(exprName, typeParameters = null) {
				const node = {
					type: 'TSTypeQuery',
					exprName,
					typeParameters,
				}
				const defs = NODE_FIELDS.TSTypeQuery
				validate(defs.exprName, node, 'exprName', exprName, 1)
				validate(defs.typeParameters, node, 'typeParameters', typeParameters, 1)
				return node
			}
			function tsTypeLiteral(members) {
				const node = {
					type: 'TSTypeLiteral',
					members,
				}
				const defs = NODE_FIELDS.TSTypeLiteral
				validate(defs.members, node, 'members', members, 1)
				return node
			}
			function tsArrayType(elementType) {
				const node = {
					type: 'TSArrayType',
					elementType,
				}
				const defs = NODE_FIELDS.TSArrayType
				validate(defs.elementType, node, 'elementType', elementType, 1)
				return node
			}
			function tsTupleType(elementTypes) {
				const node = {
					type: 'TSTupleType',
					elementTypes,
				}
				const defs = NODE_FIELDS.TSTupleType
				validate(defs.elementTypes, node, 'elementTypes', elementTypes, 1)
				return node
			}
			function tsOptionalType(typeAnnotation) {
				const node = {
					type: 'TSOptionalType',
					typeAnnotation,
				}
				const defs = NODE_FIELDS.TSOptionalType
				validate(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation, 1)
				return node
			}
			function tsRestType(typeAnnotation) {
				const node = {
					type: 'TSRestType',
					typeAnnotation,
				}
				const defs = NODE_FIELDS.TSRestType
				validate(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation, 1)
				return node
			}
			function tsNamedTupleMember(label, elementType, optional = false) {
				const node = {
					type: 'TSNamedTupleMember',
					label,
					elementType,
					optional,
				}
				const defs = NODE_FIELDS.TSNamedTupleMember
				validate(defs.label, node, 'label', label, 1)
				validate(defs.elementType, node, 'elementType', elementType, 1)
				validate(defs.optional, node, 'optional', optional)
				return node
			}
			function tsUnionType(types) {
				const node = {
					type: 'TSUnionType',
					types,
				}
				const defs = NODE_FIELDS.TSUnionType
				validate(defs.types, node, 'types', types, 1)
				return node
			}
			function tsIntersectionType(types) {
				const node = {
					type: 'TSIntersectionType',
					types,
				}
				const defs = NODE_FIELDS.TSIntersectionType
				validate(defs.types, node, 'types', types, 1)
				return node
			}
			function tsConditionalType(checkType, extendsType, trueType, falseType) {
				const node = {
					type: 'TSConditionalType',
					checkType,
					extendsType,
					trueType,
					falseType,
				}
				const defs = NODE_FIELDS.TSConditionalType
				validate(defs.checkType, node, 'checkType', checkType, 1)
				validate(defs.extendsType, node, 'extendsType', extendsType, 1)
				validate(defs.trueType, node, 'trueType', trueType, 1)
				validate(defs.falseType, node, 'falseType', falseType, 1)
				return node
			}
			function tsInferType(typeParameter) {
				const node = {
					type: 'TSInferType',
					typeParameter,
				}
				const defs = NODE_FIELDS.TSInferType
				validate(defs.typeParameter, node, 'typeParameter', typeParameter, 1)
				return node
			}
			function tsParenthesizedType(typeAnnotation) {
				const node = {
					type: 'TSParenthesizedType',
					typeAnnotation,
				}
				const defs = NODE_FIELDS.TSParenthesizedType
				validate(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation, 1)
				return node
			}
			function tsTypeOperator(typeAnnotation) {
				const node = {
					type: 'TSTypeOperator',
					typeAnnotation,
					operator: null,
				}
				const defs = NODE_FIELDS.TSTypeOperator
				validate(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation, 1)
				return node
			}
			function tsIndexedAccessType(objectType, indexType) {
				const node = {
					type: 'TSIndexedAccessType',
					objectType,
					indexType,
				}
				const defs = NODE_FIELDS.TSIndexedAccessType
				validate(defs.objectType, node, 'objectType', objectType, 1)
				validate(defs.indexType, node, 'indexType', indexType, 1)
				return node
			}
			function tsMappedType(
				typeParameter,
				typeAnnotation = null,
				nameType = null,
			) {
				const node = {
					type: 'TSMappedType',
					typeParameter,
					typeAnnotation,
					nameType,
				}
				const defs = NODE_FIELDS.TSMappedType
				validate(defs.typeParameter, node, 'typeParameter', typeParameter, 1)
				validate(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation, 1)
				validate(defs.nameType, node, 'nameType', nameType, 1)
				return node
			}
			function tsTemplateLiteralType(quasis, types) {
				const node = {
					type: 'TSTemplateLiteralType',
					quasis,
					types,
				}
				const defs = NODE_FIELDS.TSTemplateLiteralType
				validate(defs.quasis, node, 'quasis', quasis, 1)
				validate(defs.types, node, 'types', types, 1)
				return node
			}
			function tsLiteralType(literal) {
				const node = {
					type: 'TSLiteralType',
					literal,
				}
				const defs = NODE_FIELDS.TSLiteralType
				validate(defs.literal, node, 'literal', literal, 1)
				return node
			}
			function tsExpressionWithTypeArguments(
				expression,
				typeParameters = null,
			) {
				const node = {
					type: 'TSExpressionWithTypeArguments',
					expression,
					typeParameters,
				}
				const defs = NODE_FIELDS.TSExpressionWithTypeArguments
				validate(defs.expression, node, 'expression', expression, 1)
				validate(defs.typeParameters, node, 'typeParameters', typeParameters, 1)
				return node
			}
			function tsInterfaceDeclaration(
				id,
				typeParameters = null,
				_extends = null,
				body,
			) {
				const node = {
					type: 'TSInterfaceDeclaration',
					id,
					typeParameters,
					extends: _extends,
					body,
				}
				const defs = NODE_FIELDS.TSInterfaceDeclaration
				validate(defs.id, node, 'id', id, 1)
				validate(defs.typeParameters, node, 'typeParameters', typeParameters, 1)
				validate(defs.extends, node, 'extends', _extends, 1)
				validate(defs.body, node, 'body', body, 1)
				return node
			}
			function tsInterfaceBody(body) {
				const node = {
					type: 'TSInterfaceBody',
					body,
				}
				const defs = NODE_FIELDS.TSInterfaceBody
				validate(defs.body, node, 'body', body, 1)
				return node
			}
			function tsTypeAliasDeclaration(
				id,
				typeParameters = null,
				typeAnnotation,
			) {
				const node = {
					type: 'TSTypeAliasDeclaration',
					id,
					typeParameters,
					typeAnnotation,
				}
				const defs = NODE_FIELDS.TSTypeAliasDeclaration
				validate(defs.id, node, 'id', id, 1)
				validate(defs.typeParameters, node, 'typeParameters', typeParameters, 1)
				validate(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation, 1)
				return node
			}
			function tsInstantiationExpression(expression, typeParameters = null) {
				const node = {
					type: 'TSInstantiationExpression',
					expression,
					typeParameters,
				}
				const defs = NODE_FIELDS.TSInstantiationExpression
				validate(defs.expression, node, 'expression', expression, 1)
				validate(defs.typeParameters, node, 'typeParameters', typeParameters, 1)
				return node
			}
			function tsAsExpression(expression, typeAnnotation) {
				const node = {
					type: 'TSAsExpression',
					expression,
					typeAnnotation,
				}
				const defs = NODE_FIELDS.TSAsExpression
				validate(defs.expression, node, 'expression', expression, 1)
				validate(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation, 1)
				return node
			}
			function tsSatisfiesExpression(expression, typeAnnotation) {
				const node = {
					type: 'TSSatisfiesExpression',
					expression,
					typeAnnotation,
				}
				const defs = NODE_FIELDS.TSSatisfiesExpression
				validate(defs.expression, node, 'expression', expression, 1)
				validate(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation, 1)
				return node
			}
			function tsTypeAssertion(typeAnnotation, expression) {
				const node = {
					type: 'TSTypeAssertion',
					typeAnnotation,
					expression,
				}
				const defs = NODE_FIELDS.TSTypeAssertion
				validate(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation, 1)
				validate(defs.expression, node, 'expression', expression, 1)
				return node
			}
			function tsEnumBody(members) {
				const node = {
					type: 'TSEnumBody',
					members,
				}
				const defs = NODE_FIELDS.TSEnumBody
				validate(defs.members, node, 'members', members, 1)
				return node
			}
			function tsEnumDeclaration(id, members) {
				const node = {
					type: 'TSEnumDeclaration',
					id,
					members,
				}
				const defs = NODE_FIELDS.TSEnumDeclaration
				validate(defs.id, node, 'id', id, 1)
				validate(defs.members, node, 'members', members, 1)
				return node
			}
			function tsEnumMember(id, initializer = null) {
				const node = {
					type: 'TSEnumMember',
					id,
					initializer,
				}
				const defs = NODE_FIELDS.TSEnumMember
				validate(defs.id, node, 'id', id, 1)
				validate(defs.initializer, node, 'initializer', initializer, 1)
				return node
			}
			function tsModuleDeclaration(id, body) {
				const node = {
					type: 'TSModuleDeclaration',
					id,
					body,
					kind: null,
				}
				const defs = NODE_FIELDS.TSModuleDeclaration
				validate(defs.id, node, 'id', id, 1)
				validate(defs.body, node, 'body', body, 1)
				return node
			}
			function tsModuleBlock(body) {
				const node = {
					type: 'TSModuleBlock',
					body,
				}
				const defs = NODE_FIELDS.TSModuleBlock
				validate(defs.body, node, 'body', body, 1)
				return node
			}
			function tsImportType(argument, qualifier = null, typeParameters = null) {
				const node = {
					type: 'TSImportType',
					argument,
					qualifier,
					typeParameters,
				}
				const defs = NODE_FIELDS.TSImportType
				validate(defs.argument, node, 'argument', argument, 1)
				validate(defs.qualifier, node, 'qualifier', qualifier, 1)
				validate(defs.typeParameters, node, 'typeParameters', typeParameters, 1)
				return node
			}
			function tsImportEqualsDeclaration(id, moduleReference) {
				const node = {
					type: 'TSImportEqualsDeclaration',
					id,
					moduleReference,
					isExport: null,
				}
				const defs = NODE_FIELDS.TSImportEqualsDeclaration
				validate(defs.id, node, 'id', id, 1)
				validate(
					defs.moduleReference,
					node,
					'moduleReference',
					moduleReference,
					1,
				)
				return node
			}
			function tsExternalModuleReference(expression) {
				const node = {
					type: 'TSExternalModuleReference',
					expression,
				}
				const defs = NODE_FIELDS.TSExternalModuleReference
				validate(defs.expression, node, 'expression', expression, 1)
				return node
			}
			function tsNonNullExpression(expression) {
				const node = {
					type: 'TSNonNullExpression',
					expression,
				}
				const defs = NODE_FIELDS.TSNonNullExpression
				validate(defs.expression, node, 'expression', expression, 1)
				return node
			}
			function tsExportAssignment(expression) {
				const node = {
					type: 'TSExportAssignment',
					expression,
				}
				const defs = NODE_FIELDS.TSExportAssignment
				validate(defs.expression, node, 'expression', expression, 1)
				return node
			}
			function tsNamespaceExportDeclaration(id) {
				const node = {
					type: 'TSNamespaceExportDeclaration',
					id,
				}
				const defs = NODE_FIELDS.TSNamespaceExportDeclaration
				validate(defs.id, node, 'id', id, 1)
				return node
			}
			function tsTypeAnnotation(typeAnnotation) {
				const node = {
					type: 'TSTypeAnnotation',
					typeAnnotation,
				}
				const defs = NODE_FIELDS.TSTypeAnnotation
				validate(defs.typeAnnotation, node, 'typeAnnotation', typeAnnotation, 1)
				return node
			}
			function tsTypeParameterInstantiation(params) {
				const node = {
					type: 'TSTypeParameterInstantiation',
					params,
				}
				const defs = NODE_FIELDS.TSTypeParameterInstantiation
				validate(defs.params, node, 'params', params, 1)
				return node
			}
			function tsTypeParameterDeclaration(params) {
				const node = {
					type: 'TSTypeParameterDeclaration',
					params,
				}
				const defs = NODE_FIELDS.TSTypeParameterDeclaration
				validate(defs.params, node, 'params', params, 1)
				return node
			}
			function tsTypeParameter(constraint = null, _default = null, name) {
				const node = {
					type: 'TSTypeParameter',
					constraint,
					default: _default,
					name,
				}
				const defs = NODE_FIELDS.TSTypeParameter
				validate(defs.constraint, node, 'constraint', constraint, 1)
				validate(defs.default, node, 'default', _default, 1)
				validate(defs.name, node, 'name', name)
				return node
			}
			function NumberLiteral(value) {
				;(0, _deprecationWarning.default)(
					'NumberLiteral',
					'NumericLiteral',
					'The node type ',
				)
				return numericLiteral(value)
			}
			function RegexLiteral(pattern, flags = '') {
				;(0, _deprecationWarning.default)(
					'RegexLiteral',
					'RegExpLiteral',
					'The node type ',
				)
				return regExpLiteral(pattern, flags)
			}
			function RestProperty(argument) {
				;(0, _deprecationWarning.default)(
					'RestProperty',
					'RestElement',
					'The node type ',
				)
				return restElement(argument)
			}
			function SpreadProperty(argument) {
				;(0, _deprecationWarning.default)(
					'SpreadProperty',
					'SpreadElement',
					'The node type ',
				)
				return spreadElement(argument)
			}

			//# sourceMappingURL=lowercase.js.map

			/***/
		},

		/***/ 1862: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.JSXIdentifier =
				exports.JSXFragment =
				exports.JSXExpressionContainer =
				exports.JSXEmptyExpression =
				exports.JSXElement =
				exports.JSXClosingFragment =
				exports.JSXClosingElement =
				exports.JSXAttribute =
				exports.IntersectionTypeAnnotation =
				exports.InterpreterDirective =
				exports.InterfaceTypeAnnotation =
				exports.InterfaceExtends =
				exports.InterfaceDeclaration =
				exports.InferredPredicate =
				exports.IndexedAccessType =
				exports.ImportSpecifier =
				exports.ImportNamespaceSpecifier =
				exports.ImportExpression =
				exports.ImportDefaultSpecifier =
				exports.ImportDeclaration =
				exports.ImportAttribute =
				exports.Import =
				exports.IfStatement =
				exports.Identifier =
				exports.GenericTypeAnnotation =
				exports.FunctionTypeParam =
				exports.FunctionTypeAnnotation =
				exports.FunctionExpression =
				exports.FunctionDeclaration =
				exports.ForStatement =
				exports.ForOfStatement =
				exports.ForInStatement =
				exports.File =
				exports.ExpressionStatement =
				exports.ExportSpecifier =
				exports.ExportNamespaceSpecifier =
				exports.ExportNamedDeclaration =
				exports.ExportDefaultSpecifier =
				exports.ExportDefaultDeclaration =
				exports.ExportAllDeclaration =
				exports.ExistsTypeAnnotation =
				exports.EnumSymbolBody =
				exports.EnumStringMember =
				exports.EnumStringBody =
				exports.EnumNumberMember =
				exports.EnumNumberBody =
				exports.EnumDefaultedMember =
				exports.EnumDeclaration =
				exports.EnumBooleanMember =
				exports.EnumBooleanBody =
				exports.EmptyTypeAnnotation =
				exports.EmptyStatement =
				exports.DoWhileStatement =
				exports.DoExpression =
				exports.DirectiveLiteral =
				exports.Directive =
				exports.Decorator =
				exports.DeclaredPredicate =
				exports.DeclareVariable =
				exports.DeclareTypeAlias =
				exports.DeclareOpaqueType =
				exports.DeclareModuleExports =
				exports.DeclareModule =
				exports.DeclareInterface =
				exports.DeclareFunction =
				exports.DeclareExportDeclaration =
				exports.DeclareExportAllDeclaration =
				exports.DeclareClass =
				exports.DecimalLiteral =
				exports.DebuggerStatement =
				exports.ContinueStatement =
				exports.ConditionalExpression =
				exports.ClassProperty =
				exports.ClassPrivateProperty =
				exports.ClassPrivateMethod =
				exports.ClassMethod =
				exports.ClassImplements =
				exports.ClassExpression =
				exports.ClassDeclaration =
				exports.ClassBody =
				exports.ClassAccessorProperty =
				exports.CatchClause =
				exports.CallExpression =
				exports.BreakStatement =
				exports.BooleanTypeAnnotation =
				exports.BooleanLiteralTypeAnnotation =
				exports.BooleanLiteral =
				exports.BlockStatement =
				exports.BindExpression =
				exports.BinaryExpression =
				exports.BigIntLiteral =
				exports.AwaitExpression =
				exports.AssignmentPattern =
				exports.AssignmentExpression =
				exports.ArrowFunctionExpression =
				exports.ArrayTypeAnnotation =
				exports.ArrayPattern =
				exports.ArrayExpression =
				exports.ArgumentPlaceholder =
				exports.AnyTypeAnnotation =
					void 0
			exports.TSNumberKeyword =
				exports.TSNullKeyword =
				exports.TSNonNullExpression =
				exports.TSNeverKeyword =
				exports.TSNamespaceExportDeclaration =
				exports.TSNamedTupleMember =
				exports.TSModuleDeclaration =
				exports.TSModuleBlock =
				exports.TSMethodSignature =
				exports.TSMappedType =
				exports.TSLiteralType =
				exports.TSIntrinsicKeyword =
				exports.TSIntersectionType =
				exports.TSInterfaceDeclaration =
				exports.TSInterfaceBody =
				exports.TSInstantiationExpression =
				exports.TSInferType =
				exports.TSIndexedAccessType =
				exports.TSIndexSignature =
				exports.TSImportType =
				exports.TSImportEqualsDeclaration =
				exports.TSFunctionType =
				exports.TSExternalModuleReference =
				exports.TSExpressionWithTypeArguments =
				exports.TSExportAssignment =
				exports.TSEnumMember =
				exports.TSEnumDeclaration =
				exports.TSEnumBody =
				exports.TSDeclareMethod =
				exports.TSDeclareFunction =
				exports.TSConstructorType =
				exports.TSConstructSignatureDeclaration =
				exports.TSConditionalType =
				exports.TSCallSignatureDeclaration =
				exports.TSBooleanKeyword =
				exports.TSBigIntKeyword =
				exports.TSAsExpression =
				exports.TSArrayType =
				exports.TSAnyKeyword =
				exports.SymbolTypeAnnotation =
				exports.SwitchStatement =
				exports.SwitchCase =
				exports.Super =
				exports.StringTypeAnnotation =
				exports.StringLiteralTypeAnnotation =
				exports.StringLiteral =
				exports.StaticBlock =
				exports.SpreadProperty =
				exports.SpreadElement =
				exports.SequenceExpression =
				exports.ReturnStatement =
				exports.RestProperty =
				exports.RestElement =
				exports.RegexLiteral =
				exports.RegExpLiteral =
				exports.RecordExpression =
				exports.QualifiedTypeIdentifier =
				exports.Program =
				exports.PrivateName =
				exports.Placeholder =
				exports.PipelineTopicExpression =
				exports.PipelinePrimaryTopicReference =
				exports.PipelineBareFunction =
				exports.ParenthesizedExpression =
				exports.OptionalMemberExpression =
				exports.OptionalIndexedAccessType =
				exports.OptionalCallExpression =
				exports.OpaqueType =
				exports.ObjectTypeSpreadProperty =
				exports.ObjectTypeProperty =
				exports.ObjectTypeInternalSlot =
				exports.ObjectTypeIndexer =
				exports.ObjectTypeCallProperty =
				exports.ObjectTypeAnnotation =
				exports.ObjectProperty =
				exports.ObjectPattern =
				exports.ObjectMethod =
				exports.ObjectExpression =
				exports.NumericLiteral =
				exports.NumberTypeAnnotation =
				exports.NumberLiteralTypeAnnotation =
				exports.NumberLiteral =
				exports.NullableTypeAnnotation =
				exports.NullLiteralTypeAnnotation =
				exports.NullLiteral =
				exports.Noop =
				exports.NewExpression =
				exports.ModuleExpression =
				exports.MixedTypeAnnotation =
				exports.MetaProperty =
				exports.MemberExpression =
				exports.LogicalExpression =
				exports.LabeledStatement =
				exports.JSXText =
				exports.JSXSpreadChild =
				exports.JSXSpreadAttribute =
				exports.JSXOpeningFragment =
				exports.JSXOpeningElement =
				exports.JSXNamespacedName =
				exports.JSXMemberExpression =
					void 0
			exports.YieldExpression =
				exports.WithStatement =
				exports.WhileStatement =
				exports.VoidTypeAnnotation =
				exports.Variance =
				exports.VariableDeclarator =
				exports.VariableDeclaration =
				exports.V8IntrinsicIdentifier =
				exports.UpdateExpression =
				exports.UnionTypeAnnotation =
				exports.UnaryExpression =
				exports.TypeofTypeAnnotation =
				exports.TypeParameterInstantiation =
				exports.TypeParameterDeclaration =
				exports.TypeParameter =
				exports.TypeCastExpression =
				exports.TypeAnnotation =
				exports.TypeAlias =
				exports.TupleTypeAnnotation =
				exports.TupleExpression =
				exports.TryStatement =
				exports.TopicReference =
				exports.ThrowStatement =
				exports.ThisTypeAnnotation =
				exports.ThisExpression =
				exports.TemplateLiteral =
				exports.TemplateElement =
				exports.TaggedTemplateExpression =
				exports.TSVoidKeyword =
				exports.TSUnknownKeyword =
				exports.TSUnionType =
				exports.TSUndefinedKeyword =
				exports.TSTypeReference =
				exports.TSTypeQuery =
				exports.TSTypePredicate =
				exports.TSTypeParameterInstantiation =
				exports.TSTypeParameterDeclaration =
				exports.TSTypeParameter =
				exports.TSTypeOperator =
				exports.TSTypeLiteral =
				exports.TSTypeAssertion =
				exports.TSTypeAnnotation =
				exports.TSTypeAliasDeclaration =
				exports.TSTupleType =
				exports.TSThisType =
				exports.TSTemplateLiteralType =
				exports.TSSymbolKeyword =
				exports.TSStringKeyword =
				exports.TSSatisfiesExpression =
				exports.TSRestType =
				exports.TSQualifiedName =
				exports.TSPropertySignature =
				exports.TSParenthesizedType =
				exports.TSParameterProperty =
				exports.TSOptionalType =
				exports.TSObjectKeyword =
					void 0
			var b = __nccwpck_require__(11999)
			var _deprecationWarning = __nccwpck_require__(14711)
			function alias(lowercase) {
				{
					return b[lowercase]
				}
			}
			const ArrayExpression = (exports.ArrayExpression =
					alias('arrayExpression')),
				AssignmentExpression = (exports.AssignmentExpression = alias(
					'assignmentExpression',
				)),
				BinaryExpression = (exports.BinaryExpression =
					alias('binaryExpression')),
				InterpreterDirective = (exports.InterpreterDirective = alias(
					'interpreterDirective',
				)),
				Directive = (exports.Directive = alias('directive')),
				DirectiveLiteral = (exports.DirectiveLiteral =
					alias('directiveLiteral')),
				BlockStatement = (exports.BlockStatement = alias('blockStatement')),
				BreakStatement = (exports.BreakStatement = alias('breakStatement')),
				CallExpression = (exports.CallExpression = alias('callExpression')),
				CatchClause = (exports.CatchClause = alias('catchClause')),
				ConditionalExpression = (exports.ConditionalExpression = alias(
					'conditionalExpression',
				)),
				ContinueStatement = (exports.ContinueStatement =
					alias('continueStatement')),
				DebuggerStatement = (exports.DebuggerStatement =
					alias('debuggerStatement')),
				DoWhileStatement = (exports.DoWhileStatement =
					alias('doWhileStatement')),
				EmptyStatement = (exports.EmptyStatement = alias('emptyStatement')),
				ExpressionStatement = (exports.ExpressionStatement = alias(
					'expressionStatement',
				)),
				File = (exports.File = alias('file')),
				ForInStatement = (exports.ForInStatement = alias('forInStatement')),
				ForStatement = (exports.ForStatement = alias('forStatement')),
				FunctionDeclaration = (exports.FunctionDeclaration = alias(
					'functionDeclaration',
				)),
				FunctionExpression = (exports.FunctionExpression =
					alias('functionExpression')),
				Identifier = (exports.Identifier = alias('identifier')),
				IfStatement = (exports.IfStatement = alias('ifStatement')),
				LabeledStatement = (exports.LabeledStatement =
					alias('labeledStatement')),
				StringLiteral = (exports.StringLiteral = alias('stringLiteral')),
				NumericLiteral = (exports.NumericLiteral = alias('numericLiteral')),
				NullLiteral = (exports.NullLiteral = alias('nullLiteral')),
				BooleanLiteral = (exports.BooleanLiteral = alias('booleanLiteral')),
				RegExpLiteral = (exports.RegExpLiteral = alias('regExpLiteral')),
				LogicalExpression = (exports.LogicalExpression =
					alias('logicalExpression')),
				MemberExpression = (exports.MemberExpression =
					alias('memberExpression')),
				NewExpression = (exports.NewExpression = alias('newExpression')),
				Program = (exports.Program = alias('program')),
				ObjectExpression = (exports.ObjectExpression =
					alias('objectExpression')),
				ObjectMethod = (exports.ObjectMethod = alias('objectMethod')),
				ObjectProperty = (exports.ObjectProperty = alias('objectProperty')),
				RestElement = (exports.RestElement = alias('restElement')),
				ReturnStatement = (exports.ReturnStatement = alias('returnStatement')),
				SequenceExpression = (exports.SequenceExpression =
					alias('sequenceExpression')),
				ParenthesizedExpression = (exports.ParenthesizedExpression = alias(
					'parenthesizedExpression',
				)),
				SwitchCase = (exports.SwitchCase = alias('switchCase')),
				SwitchStatement = (exports.SwitchStatement = alias('switchStatement')),
				ThisExpression = (exports.ThisExpression = alias('thisExpression')),
				ThrowStatement = (exports.ThrowStatement = alias('throwStatement')),
				TryStatement = (exports.TryStatement = alias('tryStatement')),
				UnaryExpression = (exports.UnaryExpression = alias('unaryExpression')),
				UpdateExpression = (exports.UpdateExpression =
					alias('updateExpression')),
				VariableDeclaration = (exports.VariableDeclaration = alias(
					'variableDeclaration',
				)),
				VariableDeclarator = (exports.VariableDeclarator =
					alias('variableDeclarator')),
				WhileStatement = (exports.WhileStatement = alias('whileStatement')),
				WithStatement = (exports.WithStatement = alias('withStatement')),
				AssignmentPattern = (exports.AssignmentPattern =
					alias('assignmentPattern')),
				ArrayPattern = (exports.ArrayPattern = alias('arrayPattern')),
				ArrowFunctionExpression = (exports.ArrowFunctionExpression = alias(
					'arrowFunctionExpression',
				)),
				ClassBody = (exports.ClassBody = alias('classBody')),
				ClassExpression = (exports.ClassExpression = alias('classExpression')),
				ClassDeclaration = (exports.ClassDeclaration =
					alias('classDeclaration')),
				ExportAllDeclaration = (exports.ExportAllDeclaration = alias(
					'exportAllDeclaration',
				)),
				ExportDefaultDeclaration = (exports.ExportDefaultDeclaration = alias(
					'exportDefaultDeclaration',
				)),
				ExportNamedDeclaration = (exports.ExportNamedDeclaration = alias(
					'exportNamedDeclaration',
				)),
				ExportSpecifier = (exports.ExportSpecifier = alias('exportSpecifier')),
				ForOfStatement = (exports.ForOfStatement = alias('forOfStatement')),
				ImportDeclaration = (exports.ImportDeclaration =
					alias('importDeclaration')),
				ImportDefaultSpecifier = (exports.ImportDefaultSpecifier = alias(
					'importDefaultSpecifier',
				)),
				ImportNamespaceSpecifier = (exports.ImportNamespaceSpecifier = alias(
					'importNamespaceSpecifier',
				)),
				ImportSpecifier = (exports.ImportSpecifier = alias('importSpecifier')),
				ImportExpression = (exports.ImportExpression =
					alias('importExpression')),
				MetaProperty = (exports.MetaProperty = alias('metaProperty')),
				ClassMethod = (exports.ClassMethod = alias('classMethod')),
				ObjectPattern = (exports.ObjectPattern = alias('objectPattern')),
				SpreadElement = (exports.SpreadElement = alias('spreadElement')),
				Super = (exports.Super = alias('super')),
				TaggedTemplateExpression = (exports.TaggedTemplateExpression = alias(
					'taggedTemplateExpression',
				)),
				TemplateElement = (exports.TemplateElement = alias('templateElement')),
				TemplateLiteral = (exports.TemplateLiteral = alias('templateLiteral')),
				YieldExpression = (exports.YieldExpression = alias('yieldExpression')),
				AwaitExpression = (exports.AwaitExpression = alias('awaitExpression')),
				Import = (exports.Import = alias('import')),
				BigIntLiteral = (exports.BigIntLiteral = alias('bigIntLiteral')),
				ExportNamespaceSpecifier = (exports.ExportNamespaceSpecifier = alias(
					'exportNamespaceSpecifier',
				)),
				OptionalMemberExpression = (exports.OptionalMemberExpression = alias(
					'optionalMemberExpression',
				)),
				OptionalCallExpression = (exports.OptionalCallExpression = alias(
					'optionalCallExpression',
				)),
				ClassProperty = (exports.ClassProperty = alias('classProperty')),
				ClassAccessorProperty = (exports.ClassAccessorProperty = alias(
					'classAccessorProperty',
				)),
				ClassPrivateProperty = (exports.ClassPrivateProperty = alias(
					'classPrivateProperty',
				)),
				ClassPrivateMethod = (exports.ClassPrivateMethod =
					alias('classPrivateMethod')),
				PrivateName = (exports.PrivateName = alias('privateName')),
				StaticBlock = (exports.StaticBlock = alias('staticBlock')),
				ImportAttribute = (exports.ImportAttribute = alias('importAttribute')),
				AnyTypeAnnotation = (exports.AnyTypeAnnotation =
					alias('anyTypeAnnotation')),
				ArrayTypeAnnotation = (exports.ArrayTypeAnnotation = alias(
					'arrayTypeAnnotation',
				)),
				BooleanTypeAnnotation = (exports.BooleanTypeAnnotation = alias(
					'booleanTypeAnnotation',
				)),
				BooleanLiteralTypeAnnotation = (exports.BooleanLiteralTypeAnnotation =
					alias('booleanLiteralTypeAnnotation')),
				NullLiteralTypeAnnotation = (exports.NullLiteralTypeAnnotation = alias(
					'nullLiteralTypeAnnotation',
				)),
				ClassImplements = (exports.ClassImplements = alias('classImplements')),
				DeclareClass = (exports.DeclareClass = alias('declareClass')),
				DeclareFunction = (exports.DeclareFunction = alias('declareFunction')),
				DeclareInterface = (exports.DeclareInterface =
					alias('declareInterface')),
				DeclareModule = (exports.DeclareModule = alias('declareModule')),
				DeclareModuleExports = (exports.DeclareModuleExports = alias(
					'declareModuleExports',
				)),
				DeclareTypeAlias = (exports.DeclareTypeAlias =
					alias('declareTypeAlias')),
				DeclareOpaqueType = (exports.DeclareOpaqueType =
					alias('declareOpaqueType')),
				DeclareVariable = (exports.DeclareVariable = alias('declareVariable')),
				DeclareExportDeclaration = (exports.DeclareExportDeclaration = alias(
					'declareExportDeclaration',
				)),
				DeclareExportAllDeclaration = (exports.DeclareExportAllDeclaration =
					alias('declareExportAllDeclaration')),
				DeclaredPredicate = (exports.DeclaredPredicate =
					alias('declaredPredicate')),
				ExistsTypeAnnotation = (exports.ExistsTypeAnnotation = alias(
					'existsTypeAnnotation',
				)),
				FunctionTypeAnnotation = (exports.FunctionTypeAnnotation = alias(
					'functionTypeAnnotation',
				)),
				FunctionTypeParam = (exports.FunctionTypeParam =
					alias('functionTypeParam')),
				GenericTypeAnnotation = (exports.GenericTypeAnnotation = alias(
					'genericTypeAnnotation',
				)),
				InferredPredicate = (exports.InferredPredicate =
					alias('inferredPredicate')),
				InterfaceExtends = (exports.InterfaceExtends =
					alias('interfaceExtends')),
				InterfaceDeclaration = (exports.InterfaceDeclaration = alias(
					'interfaceDeclaration',
				)),
				InterfaceTypeAnnotation = (exports.InterfaceTypeAnnotation = alias(
					'interfaceTypeAnnotation',
				)),
				IntersectionTypeAnnotation = (exports.IntersectionTypeAnnotation =
					alias('intersectionTypeAnnotation')),
				MixedTypeAnnotation = (exports.MixedTypeAnnotation = alias(
					'mixedTypeAnnotation',
				)),
				EmptyTypeAnnotation = (exports.EmptyTypeAnnotation = alias(
					'emptyTypeAnnotation',
				)),
				NullableTypeAnnotation = (exports.NullableTypeAnnotation = alias(
					'nullableTypeAnnotation',
				)),
				NumberLiteralTypeAnnotation = (exports.NumberLiteralTypeAnnotation =
					alias('numberLiteralTypeAnnotation')),
				NumberTypeAnnotation = (exports.NumberTypeAnnotation = alias(
					'numberTypeAnnotation',
				)),
				ObjectTypeAnnotation = (exports.ObjectTypeAnnotation = alias(
					'objectTypeAnnotation',
				)),
				ObjectTypeInternalSlot = (exports.ObjectTypeInternalSlot = alias(
					'objectTypeInternalSlot',
				)),
				ObjectTypeCallProperty = (exports.ObjectTypeCallProperty = alias(
					'objectTypeCallProperty',
				)),
				ObjectTypeIndexer = (exports.ObjectTypeIndexer =
					alias('objectTypeIndexer')),
				ObjectTypeProperty = (exports.ObjectTypeProperty =
					alias('objectTypeProperty')),
				ObjectTypeSpreadProperty = (exports.ObjectTypeSpreadProperty = alias(
					'objectTypeSpreadProperty',
				)),
				OpaqueType = (exports.OpaqueType = alias('opaqueType')),
				QualifiedTypeIdentifier = (exports.QualifiedTypeIdentifier = alias(
					'qualifiedTypeIdentifier',
				)),
				StringLiteralTypeAnnotation = (exports.StringLiteralTypeAnnotation =
					alias('stringLiteralTypeAnnotation')),
				StringTypeAnnotation = (exports.StringTypeAnnotation = alias(
					'stringTypeAnnotation',
				)),
				SymbolTypeAnnotation = (exports.SymbolTypeAnnotation = alias(
					'symbolTypeAnnotation',
				)),
				ThisTypeAnnotation = (exports.ThisTypeAnnotation =
					alias('thisTypeAnnotation')),
				TupleTypeAnnotation = (exports.TupleTypeAnnotation = alias(
					'tupleTypeAnnotation',
				)),
				TypeofTypeAnnotation = (exports.TypeofTypeAnnotation = alias(
					'typeofTypeAnnotation',
				)),
				TypeAlias = (exports.TypeAlias = alias('typeAlias')),
				TypeAnnotation = (exports.TypeAnnotation = alias('typeAnnotation')),
				TypeCastExpression = (exports.TypeCastExpression =
					alias('typeCastExpression')),
				TypeParameter = (exports.TypeParameter = alias('typeParameter')),
				TypeParameterDeclaration = (exports.TypeParameterDeclaration = alias(
					'typeParameterDeclaration',
				)),
				TypeParameterInstantiation = (exports.TypeParameterInstantiation =
					alias('typeParameterInstantiation')),
				UnionTypeAnnotation = (exports.UnionTypeAnnotation = alias(
					'unionTypeAnnotation',
				)),
				Variance = (exports.Variance = alias('variance')),
				VoidTypeAnnotation = (exports.VoidTypeAnnotation =
					alias('voidTypeAnnotation')),
				EnumDeclaration = (exports.EnumDeclaration = alias('enumDeclaration')),
				EnumBooleanBody = (exports.EnumBooleanBody = alias('enumBooleanBody')),
				EnumNumberBody = (exports.EnumNumberBody = alias('enumNumberBody')),
				EnumStringBody = (exports.EnumStringBody = alias('enumStringBody')),
				EnumSymbolBody = (exports.EnumSymbolBody = alias('enumSymbolBody')),
				EnumBooleanMember = (exports.EnumBooleanMember =
					alias('enumBooleanMember')),
				EnumNumberMember = (exports.EnumNumberMember =
					alias('enumNumberMember')),
				EnumStringMember = (exports.EnumStringMember =
					alias('enumStringMember')),
				EnumDefaultedMember = (exports.EnumDefaultedMember = alias(
					'enumDefaultedMember',
				)),
				IndexedAccessType = (exports.IndexedAccessType =
					alias('indexedAccessType')),
				OptionalIndexedAccessType = (exports.OptionalIndexedAccessType = alias(
					'optionalIndexedAccessType',
				)),
				JSXAttribute = (exports.JSXAttribute = alias('jsxAttribute')),
				JSXClosingElement = (exports.JSXClosingElement =
					alias('jsxClosingElement')),
				JSXElement = (exports.JSXElement = alias('jsxElement')),
				JSXEmptyExpression = (exports.JSXEmptyExpression =
					alias('jsxEmptyExpression')),
				JSXExpressionContainer = (exports.JSXExpressionContainer = alias(
					'jsxExpressionContainer',
				)),
				JSXSpreadChild = (exports.JSXSpreadChild = alias('jsxSpreadChild')),
				JSXIdentifier = (exports.JSXIdentifier = alias('jsxIdentifier')),
				JSXMemberExpression = (exports.JSXMemberExpression = alias(
					'jsxMemberExpression',
				)),
				JSXNamespacedName = (exports.JSXNamespacedName =
					alias('jsxNamespacedName')),
				JSXOpeningElement = (exports.JSXOpeningElement =
					alias('jsxOpeningElement')),
				JSXSpreadAttribute = (exports.JSXSpreadAttribute =
					alias('jsxSpreadAttribute')),
				JSXText = (exports.JSXText = alias('jsxText')),
				JSXFragment = (exports.JSXFragment = alias('jsxFragment')),
				JSXOpeningFragment = (exports.JSXOpeningFragment =
					alias('jsxOpeningFragment')),
				JSXClosingFragment = (exports.JSXClosingFragment =
					alias('jsxClosingFragment')),
				Noop = (exports.Noop = alias('noop')),
				Placeholder = (exports.Placeholder = alias('placeholder')),
				V8IntrinsicIdentifier = (exports.V8IntrinsicIdentifier = alias(
					'v8IntrinsicIdentifier',
				)),
				ArgumentPlaceholder = (exports.ArgumentPlaceholder = alias(
					'argumentPlaceholder',
				)),
				BindExpression = (exports.BindExpression = alias('bindExpression')),
				Decorator = (exports.Decorator = alias('decorator')),
				DoExpression = (exports.DoExpression = alias('doExpression')),
				ExportDefaultSpecifier = (exports.ExportDefaultSpecifier = alias(
					'exportDefaultSpecifier',
				)),
				RecordExpression = (exports.RecordExpression =
					alias('recordExpression')),
				TupleExpression = (exports.TupleExpression = alias('tupleExpression')),
				DecimalLiteral = (exports.DecimalLiteral = alias('decimalLiteral')),
				ModuleExpression = (exports.ModuleExpression =
					alias('moduleExpression')),
				TopicReference = (exports.TopicReference = alias('topicReference')),
				PipelineTopicExpression = (exports.PipelineTopicExpression = alias(
					'pipelineTopicExpression',
				)),
				PipelineBareFunction = (exports.PipelineBareFunction = alias(
					'pipelineBareFunction',
				)),
				PipelinePrimaryTopicReference = (exports.PipelinePrimaryTopicReference =
					alias('pipelinePrimaryTopicReference')),
				TSParameterProperty = (exports.TSParameterProperty = alias(
					'tsParameterProperty',
				)),
				TSDeclareFunction = (exports.TSDeclareFunction =
					alias('tsDeclareFunction')),
				TSDeclareMethod = (exports.TSDeclareMethod = alias('tsDeclareMethod')),
				TSQualifiedName = (exports.TSQualifiedName = alias('tsQualifiedName')),
				TSCallSignatureDeclaration = (exports.TSCallSignatureDeclaration =
					alias('tsCallSignatureDeclaration')),
				TSConstructSignatureDeclaration =
					(exports.TSConstructSignatureDeclaration = alias(
						'tsConstructSignatureDeclaration',
					)),
				TSPropertySignature = (exports.TSPropertySignature = alias(
					'tsPropertySignature',
				)),
				TSMethodSignature = (exports.TSMethodSignature =
					alias('tsMethodSignature')),
				TSIndexSignature = (exports.TSIndexSignature =
					alias('tsIndexSignature')),
				TSAnyKeyword = (exports.TSAnyKeyword = alias('tsAnyKeyword')),
				TSBooleanKeyword = (exports.TSBooleanKeyword =
					alias('tsBooleanKeyword')),
				TSBigIntKeyword = (exports.TSBigIntKeyword = alias('tsBigIntKeyword')),
				TSIntrinsicKeyword = (exports.TSIntrinsicKeyword =
					alias('tsIntrinsicKeyword')),
				TSNeverKeyword = (exports.TSNeverKeyword = alias('tsNeverKeyword')),
				TSNullKeyword = (exports.TSNullKeyword = alias('tsNullKeyword')),
				TSNumberKeyword = (exports.TSNumberKeyword = alias('tsNumberKeyword')),
				TSObjectKeyword = (exports.TSObjectKeyword = alias('tsObjectKeyword')),
				TSStringKeyword = (exports.TSStringKeyword = alias('tsStringKeyword')),
				TSSymbolKeyword = (exports.TSSymbolKeyword = alias('tsSymbolKeyword')),
				TSUndefinedKeyword = (exports.TSUndefinedKeyword =
					alias('tsUndefinedKeyword')),
				TSUnknownKeyword = (exports.TSUnknownKeyword =
					alias('tsUnknownKeyword')),
				TSVoidKeyword = (exports.TSVoidKeyword = alias('tsVoidKeyword')),
				TSThisType = (exports.TSThisType = alias('tsThisType')),
				TSFunctionType = (exports.TSFunctionType = alias('tsFunctionType')),
				TSConstructorType = (exports.TSConstructorType =
					alias('tsConstructorType')),
				TSTypeReference = (exports.TSTypeReference = alias('tsTypeReference')),
				TSTypePredicate = (exports.TSTypePredicate = alias('tsTypePredicate')),
				TSTypeQuery = (exports.TSTypeQuery = alias('tsTypeQuery')),
				TSTypeLiteral = (exports.TSTypeLiteral = alias('tsTypeLiteral')),
				TSArrayType = (exports.TSArrayType = alias('tsArrayType')),
				TSTupleType = (exports.TSTupleType = alias('tsTupleType')),
				TSOptionalType = (exports.TSOptionalType = alias('tsOptionalType')),
				TSRestType = (exports.TSRestType = alias('tsRestType')),
				TSNamedTupleMember = (exports.TSNamedTupleMember =
					alias('tsNamedTupleMember')),
				TSUnionType = (exports.TSUnionType = alias('tsUnionType')),
				TSIntersectionType = (exports.TSIntersectionType =
					alias('tsIntersectionType')),
				TSConditionalType = (exports.TSConditionalType =
					alias('tsConditionalType')),
				TSInferType = (exports.TSInferType = alias('tsInferType')),
				TSParenthesizedType = (exports.TSParenthesizedType = alias(
					'tsParenthesizedType',
				)),
				TSTypeOperator = (exports.TSTypeOperator = alias('tsTypeOperator')),
				TSIndexedAccessType = (exports.TSIndexedAccessType = alias(
					'tsIndexedAccessType',
				)),
				TSMappedType = (exports.TSMappedType = alias('tsMappedType')),
				TSTemplateLiteralType = (exports.TSTemplateLiteralType = alias(
					'tsTemplateLiteralType',
				)),
				TSLiteralType = (exports.TSLiteralType = alias('tsLiteralType')),
				TSExpressionWithTypeArguments = (exports.TSExpressionWithTypeArguments =
					alias('tsExpressionWithTypeArguments')),
				TSInterfaceDeclaration = (exports.TSInterfaceDeclaration = alias(
					'tsInterfaceDeclaration',
				)),
				TSInterfaceBody = (exports.TSInterfaceBody = alias('tsInterfaceBody')),
				TSTypeAliasDeclaration = (exports.TSTypeAliasDeclaration = alias(
					'tsTypeAliasDeclaration',
				)),
				TSInstantiationExpression = (exports.TSInstantiationExpression = alias(
					'tsInstantiationExpression',
				)),
				TSAsExpression = (exports.TSAsExpression = alias('tsAsExpression')),
				TSSatisfiesExpression = (exports.TSSatisfiesExpression = alias(
					'tsSatisfiesExpression',
				)),
				TSTypeAssertion = (exports.TSTypeAssertion = alias('tsTypeAssertion')),
				TSEnumBody = (exports.TSEnumBody = alias('tsEnumBody')),
				TSEnumDeclaration = (exports.TSEnumDeclaration =
					alias('tsEnumDeclaration')),
				TSEnumMember = (exports.TSEnumMember = alias('tsEnumMember')),
				TSModuleDeclaration = (exports.TSModuleDeclaration = alias(
					'tsModuleDeclaration',
				)),
				TSModuleBlock = (exports.TSModuleBlock = alias('tsModuleBlock')),
				TSImportType = (exports.TSImportType = alias('tsImportType')),
				TSImportEqualsDeclaration = (exports.TSImportEqualsDeclaration = alias(
					'tsImportEqualsDeclaration',
				)),
				TSExternalModuleReference = (exports.TSExternalModuleReference = alias(
					'tsExternalModuleReference',
				)),
				TSNonNullExpression = (exports.TSNonNullExpression = alias(
					'tsNonNullExpression',
				)),
				TSExportAssignment = (exports.TSExportAssignment =
					alias('tsExportAssignment')),
				TSNamespaceExportDeclaration = (exports.TSNamespaceExportDeclaration =
					alias('tsNamespaceExportDeclaration')),
				TSTypeAnnotation = (exports.TSTypeAnnotation =
					alias('tsTypeAnnotation')),
				TSTypeParameterInstantiation = (exports.TSTypeParameterInstantiation =
					alias('tsTypeParameterInstantiation')),
				TSTypeParameterDeclaration = (exports.TSTypeParameterDeclaration =
					alias('tsTypeParameterDeclaration')),
				TSTypeParameter = (exports.TSTypeParameter = alias('tsTypeParameter'))
			const NumberLiteral = (exports.NumberLiteral = b.numberLiteral),
				RegexLiteral = (exports.RegexLiteral = b.regexLiteral),
				RestProperty = (exports.RestProperty = b.restProperty),
				SpreadProperty = (exports.SpreadProperty = b.spreadProperty)

			//# sourceMappingURL=uppercase.js.map

			/***/
		},

		/***/ 38504: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.buildUndefinedNode = buildUndefinedNode
			var _index = __nccwpck_require__(90670)
			function buildUndefinedNode() {
				return (0, _index.unaryExpression)(
					'void',
					(0, _index.numericLiteral)(0),
					true,
				)
			}

			//# sourceMappingURL=productions.js.map

			/***/
		},

		/***/ 93415: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = buildChildren
			var _index = __nccwpck_require__(40741)
			var _cleanJSXElementLiteralChild = __nccwpck_require__(43508)
			function buildChildren(node) {
				const elements = []
				for (let i = 0; i < node.children.length; i++) {
					let child = node.children[i]
					if ((0, _index.isJSXText)(child)) {
						;(0, _cleanJSXElementLiteralChild.default)(child, elements)
						continue
					}
					if ((0, _index.isJSXExpressionContainer)(child))
						child = child.expression
					if ((0, _index.isJSXEmptyExpression)(child)) continue
					elements.push(child)
				}
				return elements
			}

			//# sourceMappingURL=buildChildren.js.map

			/***/
		},

		/***/ 15766: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = createTSUnionType
			var _index = __nccwpck_require__(90670)
			var _removeTypeDuplicates = __nccwpck_require__(76123)
			var _index2 = __nccwpck_require__(40741)
			function createTSUnionType(typeAnnotations) {
				const types = typeAnnotations.map((type) => {
					return (0, _index2.isTSTypeAnnotation)(type)
						? type.typeAnnotation
						: type
				})
				const flattened = (0, _removeTypeDuplicates.default)(types)
				if (flattened.length === 1) {
					return flattened[0]
				} else {
					return (0, _index.tsUnionType)(flattened)
				}
			}

			//# sourceMappingURL=createTSUnionType.js.map

			/***/
		},

		/***/ 59260: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = clone
			var _cloneNode = __nccwpck_require__(89260)
			function clone(node) {
				return (0, _cloneNode.default)(node, false)
			}

			//# sourceMappingURL=clone.js.map

			/***/
		},

		/***/ 45922: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = cloneDeep
			var _cloneNode = __nccwpck_require__(89260)
			function cloneDeep(node) {
				return (0, _cloneNode.default)(node)
			}

			//# sourceMappingURL=cloneDeep.js.map

			/***/
		},

		/***/ 37992: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = cloneDeepWithoutLoc
			var _cloneNode = __nccwpck_require__(89260)
			function cloneDeepWithoutLoc(node) {
				return (0, _cloneNode.default)(node, true, true)
			}

			//# sourceMappingURL=cloneDeepWithoutLoc.js.map

			/***/
		},

		/***/ 89260: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = cloneNode
			var _index = __nccwpck_require__(40910)
			var _index2 = __nccwpck_require__(40741)
			const { hasOwn } = {
				hasOwn: Function.call.bind(Object.prototype.hasOwnProperty),
			}
			function cloneIfNode(obj, deep, withoutLoc, commentsCache) {
				if (obj && typeof obj.type === 'string') {
					return cloneNodeInternal(obj, deep, withoutLoc, commentsCache)
				}
				return obj
			}
			function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {
				if (Array.isArray(obj)) {
					return obj.map((node) =>
						cloneIfNode(node, deep, withoutLoc, commentsCache),
					)
				}
				return cloneIfNode(obj, deep, withoutLoc, commentsCache)
			}
			function cloneNode(node, deep = true, withoutLoc = false) {
				return cloneNodeInternal(node, deep, withoutLoc, new Map())
			}
			function cloneNodeInternal(
				node,
				deep = true,
				withoutLoc = false,
				commentsCache,
			) {
				if (!node) return node
				const { type } = node
				const newNode = {
					type: node.type,
				}
				if ((0, _index2.isIdentifier)(node)) {
					newNode.name = node.name
					if (hasOwn(node, 'optional') && typeof node.optional === 'boolean') {
						newNode.optional = node.optional
					}
					if (hasOwn(node, 'typeAnnotation')) {
						newNode.typeAnnotation = deep
							? cloneIfNodeOrArray(
									node.typeAnnotation,
									true,
									withoutLoc,
									commentsCache,
								)
							: node.typeAnnotation
					}
					if (hasOwn(node, 'decorators')) {
						newNode.decorators = deep
							? cloneIfNodeOrArray(
									node.decorators,
									true,
									withoutLoc,
									commentsCache,
								)
							: node.decorators
					}
				} else if (!hasOwn(_index.NODE_FIELDS, type)) {
					throw new Error(`Unknown node type: "${type}"`)
				} else {
					for (const field of Object.keys(_index.NODE_FIELDS[type])) {
						if (hasOwn(node, field)) {
							if (deep) {
								newNode[field] =
									(0, _index2.isFile)(node) && field === 'comments'
										? maybeCloneComments(
												node.comments,
												deep,
												withoutLoc,
												commentsCache,
											)
										: cloneIfNodeOrArray(
												node[field],
												true,
												withoutLoc,
												commentsCache,
											)
							} else {
								newNode[field] = node[field]
							}
						}
					}
				}
				if (hasOwn(node, 'loc')) {
					if (withoutLoc) {
						newNode.loc = null
					} else {
						newNode.loc = node.loc
					}
				}
				if (hasOwn(node, 'leadingComments')) {
					newNode.leadingComments = maybeCloneComments(
						node.leadingComments,
						deep,
						withoutLoc,
						commentsCache,
					)
				}
				if (hasOwn(node, 'innerComments')) {
					newNode.innerComments = maybeCloneComments(
						node.innerComments,
						deep,
						withoutLoc,
						commentsCache,
					)
				}
				if (hasOwn(node, 'trailingComments')) {
					newNode.trailingComments = maybeCloneComments(
						node.trailingComments,
						deep,
						withoutLoc,
						commentsCache,
					)
				}
				if (hasOwn(node, 'extra')) {
					newNode.extra = Object.assign({}, node.extra)
				}
				return newNode
			}
			function maybeCloneComments(comments, deep, withoutLoc, commentsCache) {
				if (!comments || !deep) {
					return comments
				}
				return comments.map((comment) => {
					const cache = commentsCache.get(comment)
					if (cache) return cache
					const { type, value, loc } = comment
					const ret = {
						type,
						value,
						loc,
					}
					if (withoutLoc) {
						ret.loc = null
					}
					commentsCache.set(comment, ret)
					return ret
				})
			}

			//# sourceMappingURL=cloneNode.js.map

			/***/
		},

		/***/ 19258: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = cloneWithoutLoc
			var _cloneNode = __nccwpck_require__(89260)
			function cloneWithoutLoc(node) {
				return (0, _cloneNode.default)(node, false, true)
			}

			//# sourceMappingURL=cloneWithoutLoc.js.map

			/***/
		},

		/***/ 70704: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = addComment
			var _addComments = __nccwpck_require__(21071)
			function addComment(node, type, content, line) {
				return (0, _addComments.default)(node, type, [
					{
						type: line ? 'CommentLine' : 'CommentBlock',
						value: content,
					},
				])
			}

			//# sourceMappingURL=addComment.js.map

			/***/
		},

		/***/ 21071: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = addComments
			function addComments(node, type, comments) {
				if (!comments || !node) return node
				const key = `${type}Comments`
				if (node[key]) {
					if (type === 'leading') {
						node[key] = comments.concat(node[key])
					} else {
						node[key].push(...comments)
					}
				} else {
					node[key] = comments
				}
				return node
			}

			//# sourceMappingURL=addComments.js.map

			/***/
		},

		/***/ 40731: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = inheritInnerComments
			var _inherit = __nccwpck_require__(40066)
			function inheritInnerComments(child, parent) {
				;(0, _inherit.default)('innerComments', child, parent)
			}

			//# sourceMappingURL=inheritInnerComments.js.map

			/***/
		},

		/***/ 7725: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = inheritLeadingComments
			var _inherit = __nccwpck_require__(40066)
			function inheritLeadingComments(child, parent) {
				;(0, _inherit.default)('leadingComments', child, parent)
			}

			//# sourceMappingURL=inheritLeadingComments.js.map

			/***/
		},

		/***/ 23491: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = inheritTrailingComments
			var _inherit = __nccwpck_require__(40066)
			function inheritTrailingComments(child, parent) {
				;(0, _inherit.default)('trailingComments', child, parent)
			}

			//# sourceMappingURL=inheritTrailingComments.js.map

			/***/
		},

		/***/ 32078: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = inheritsComments
			var _inheritTrailingComments = __nccwpck_require__(23491)
			var _inheritLeadingComments = __nccwpck_require__(7725)
			var _inheritInnerComments = __nccwpck_require__(40731)
			function inheritsComments(child, parent) {
				;(0, _inheritTrailingComments.default)(child, parent)
				;(0, _inheritLeadingComments.default)(child, parent)
				;(0, _inheritInnerComments.default)(child, parent)
				return child
			}

			//# sourceMappingURL=inheritsComments.js.map

			/***/
		},

		/***/ 84066: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = removeComments
			var _index = __nccwpck_require__(17945)
			function removeComments(node) {
				_index.COMMENT_KEYS.forEach((key) => {
					node[key] = null
				})
				return node
			}

			//# sourceMappingURL=removeComments.js.map

			/***/
		},

		/***/ 12359: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.WHILE_TYPES =
				exports.USERWHITESPACABLE_TYPES =
				exports.UNARYLIKE_TYPES =
				exports.TYPESCRIPT_TYPES =
				exports.TSTYPE_TYPES =
				exports.TSTYPEELEMENT_TYPES =
				exports.TSENTITYNAME_TYPES =
				exports.TSBASETYPE_TYPES =
				exports.TERMINATORLESS_TYPES =
				exports.STATEMENT_TYPES =
				exports.STANDARDIZED_TYPES =
				exports.SCOPABLE_TYPES =
				exports.PUREISH_TYPES =
				exports.PROPERTY_TYPES =
				exports.PRIVATE_TYPES =
				exports.PATTERN_TYPES =
				exports.PATTERNLIKE_TYPES =
				exports.OBJECTMEMBER_TYPES =
				exports.MODULESPECIFIER_TYPES =
				exports.MODULEDECLARATION_TYPES =
				exports.MISCELLANEOUS_TYPES =
				exports.METHOD_TYPES =
				exports.LVAL_TYPES =
				exports.LOOP_TYPES =
				exports.LITERAL_TYPES =
				exports.JSX_TYPES =
				exports.IMPORTOREXPORTDECLARATION_TYPES =
				exports.IMMUTABLE_TYPES =
				exports.FUNCTION_TYPES =
				exports.FUNCTIONPARENT_TYPES =
				exports.FOR_TYPES =
				exports.FORXSTATEMENT_TYPES =
				exports.FLOW_TYPES =
				exports.FLOWTYPE_TYPES =
				exports.FLOWPREDICATE_TYPES =
				exports.FLOWDECLARATION_TYPES =
				exports.FLOWBASEANNOTATION_TYPES =
				exports.EXPRESSION_TYPES =
				exports.EXPRESSIONWRAPPER_TYPES =
				exports.EXPORTDECLARATION_TYPES =
				exports.ENUMMEMBER_TYPES =
				exports.ENUMBODY_TYPES =
				exports.DECLARATION_TYPES =
				exports.CONDITIONAL_TYPES =
				exports.COMPLETIONSTATEMENT_TYPES =
				exports.CLASS_TYPES =
				exports.BLOCK_TYPES =
				exports.BLOCKPARENT_TYPES =
				exports.BINARY_TYPES =
				exports.ACCESSOR_TYPES =
					void 0
			var _index = __nccwpck_require__(40910)
			const STANDARDIZED_TYPES = (exports.STANDARDIZED_TYPES =
				_index.FLIPPED_ALIAS_KEYS['Standardized'])
			const EXPRESSION_TYPES = (exports.EXPRESSION_TYPES =
				_index.FLIPPED_ALIAS_KEYS['Expression'])
			const BINARY_TYPES = (exports.BINARY_TYPES =
				_index.FLIPPED_ALIAS_KEYS['Binary'])
			const SCOPABLE_TYPES = (exports.SCOPABLE_TYPES =
				_index.FLIPPED_ALIAS_KEYS['Scopable'])
			const BLOCKPARENT_TYPES = (exports.BLOCKPARENT_TYPES =
				_index.FLIPPED_ALIAS_KEYS['BlockParent'])
			const BLOCK_TYPES = (exports.BLOCK_TYPES =
				_index.FLIPPED_ALIAS_KEYS['Block'])
			const STATEMENT_TYPES = (exports.STATEMENT_TYPES =
				_index.FLIPPED_ALIAS_KEYS['Statement'])
			const TERMINATORLESS_TYPES = (exports.TERMINATORLESS_TYPES =
				_index.FLIPPED_ALIAS_KEYS['Terminatorless'])
			const COMPLETIONSTATEMENT_TYPES = (exports.COMPLETIONSTATEMENT_TYPES =
				_index.FLIPPED_ALIAS_KEYS['CompletionStatement'])
			const CONDITIONAL_TYPES = (exports.CONDITIONAL_TYPES =
				_index.FLIPPED_ALIAS_KEYS['Conditional'])
			const LOOP_TYPES = (exports.LOOP_TYPES =
				_index.FLIPPED_ALIAS_KEYS['Loop'])
			const WHILE_TYPES = (exports.WHILE_TYPES =
				_index.FLIPPED_ALIAS_KEYS['While'])
			const EXPRESSIONWRAPPER_TYPES = (exports.EXPRESSIONWRAPPER_TYPES =
				_index.FLIPPED_ALIAS_KEYS['ExpressionWrapper'])
			const FOR_TYPES = (exports.FOR_TYPES = _index.FLIPPED_ALIAS_KEYS['For'])
			const FORXSTATEMENT_TYPES = (exports.FORXSTATEMENT_TYPES =
				_index.FLIPPED_ALIAS_KEYS['ForXStatement'])
			const FUNCTION_TYPES = (exports.FUNCTION_TYPES =
				_index.FLIPPED_ALIAS_KEYS['Function'])
			const FUNCTIONPARENT_TYPES = (exports.FUNCTIONPARENT_TYPES =
				_index.FLIPPED_ALIAS_KEYS['FunctionParent'])
			const PUREISH_TYPES = (exports.PUREISH_TYPES =
				_index.FLIPPED_ALIAS_KEYS['Pureish'])
			const DECLARATION_TYPES = (exports.DECLARATION_TYPES =
				_index.FLIPPED_ALIAS_KEYS['Declaration'])
			const PATTERNLIKE_TYPES = (exports.PATTERNLIKE_TYPES =
				_index.FLIPPED_ALIAS_KEYS['PatternLike'])
			const LVAL_TYPES = (exports.LVAL_TYPES =
				_index.FLIPPED_ALIAS_KEYS['LVal'])
			const TSENTITYNAME_TYPES = (exports.TSENTITYNAME_TYPES =
				_index.FLIPPED_ALIAS_KEYS['TSEntityName'])
			const LITERAL_TYPES = (exports.LITERAL_TYPES =
				_index.FLIPPED_ALIAS_KEYS['Literal'])
			const IMMUTABLE_TYPES = (exports.IMMUTABLE_TYPES =
				_index.FLIPPED_ALIAS_KEYS['Immutable'])
			const USERWHITESPACABLE_TYPES = (exports.USERWHITESPACABLE_TYPES =
				_index.FLIPPED_ALIAS_KEYS['UserWhitespacable'])
			const METHOD_TYPES = (exports.METHOD_TYPES =
				_index.FLIPPED_ALIAS_KEYS['Method'])
			const OBJECTMEMBER_TYPES = (exports.OBJECTMEMBER_TYPES =
				_index.FLIPPED_ALIAS_KEYS['ObjectMember'])
			const PROPERTY_TYPES = (exports.PROPERTY_TYPES =
				_index.FLIPPED_ALIAS_KEYS['Property'])
			const UNARYLIKE_TYPES = (exports.UNARYLIKE_TYPES =
				_index.FLIPPED_ALIAS_KEYS['UnaryLike'])
			const PATTERN_TYPES = (exports.PATTERN_TYPES =
				_index.FLIPPED_ALIAS_KEYS['Pattern'])
			const CLASS_TYPES = (exports.CLASS_TYPES =
				_index.FLIPPED_ALIAS_KEYS['Class'])
			const IMPORTOREXPORTDECLARATION_TYPES =
				(exports.IMPORTOREXPORTDECLARATION_TYPES =
					_index.FLIPPED_ALIAS_KEYS['ImportOrExportDeclaration'])
			const EXPORTDECLARATION_TYPES = (exports.EXPORTDECLARATION_TYPES =
				_index.FLIPPED_ALIAS_KEYS['ExportDeclaration'])
			const MODULESPECIFIER_TYPES = (exports.MODULESPECIFIER_TYPES =
				_index.FLIPPED_ALIAS_KEYS['ModuleSpecifier'])
			const ACCESSOR_TYPES = (exports.ACCESSOR_TYPES =
				_index.FLIPPED_ALIAS_KEYS['Accessor'])
			const PRIVATE_TYPES = (exports.PRIVATE_TYPES =
				_index.FLIPPED_ALIAS_KEYS['Private'])
			const FLOW_TYPES = (exports.FLOW_TYPES =
				_index.FLIPPED_ALIAS_KEYS['Flow'])
			const FLOWTYPE_TYPES = (exports.FLOWTYPE_TYPES =
				_index.FLIPPED_ALIAS_KEYS['FlowType'])
			const FLOWBASEANNOTATION_TYPES = (exports.FLOWBASEANNOTATION_TYPES =
				_index.FLIPPED_ALIAS_KEYS['FlowBaseAnnotation'])
			const FLOWDECLARATION_TYPES = (exports.FLOWDECLARATION_TYPES =
				_index.FLIPPED_ALIAS_KEYS['FlowDeclaration'])
			const FLOWPREDICATE_TYPES = (exports.FLOWPREDICATE_TYPES =
				_index.FLIPPED_ALIAS_KEYS['FlowPredicate'])
			const ENUMBODY_TYPES = (exports.ENUMBODY_TYPES =
				_index.FLIPPED_ALIAS_KEYS['EnumBody'])
			const ENUMMEMBER_TYPES = (exports.ENUMMEMBER_TYPES =
				_index.FLIPPED_ALIAS_KEYS['EnumMember'])
			const JSX_TYPES = (exports.JSX_TYPES = _index.FLIPPED_ALIAS_KEYS['JSX'])
			const MISCELLANEOUS_TYPES = (exports.MISCELLANEOUS_TYPES =
				_index.FLIPPED_ALIAS_KEYS['Miscellaneous'])
			const TYPESCRIPT_TYPES = (exports.TYPESCRIPT_TYPES =
				_index.FLIPPED_ALIAS_KEYS['TypeScript'])
			const TSTYPEELEMENT_TYPES = (exports.TSTYPEELEMENT_TYPES =
				_index.FLIPPED_ALIAS_KEYS['TSTypeElement'])
			const TSTYPE_TYPES = (exports.TSTYPE_TYPES =
				_index.FLIPPED_ALIAS_KEYS['TSType'])
			const TSBASETYPE_TYPES = (exports.TSBASETYPE_TYPES =
				_index.FLIPPED_ALIAS_KEYS['TSBaseType'])
			const MODULEDECLARATION_TYPES = (exports.MODULEDECLARATION_TYPES =
				IMPORTOREXPORTDECLARATION_TYPES)

			//# sourceMappingURL=index.js.map

			/***/
		},

		/***/ 17945: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.UPDATE_OPERATORS =
				exports.UNARY_OPERATORS =
				exports.STRING_UNARY_OPERATORS =
				exports.STATEMENT_OR_BLOCK_KEYS =
				exports.NUMBER_UNARY_OPERATORS =
				exports.NUMBER_BINARY_OPERATORS =
				exports.LOGICAL_OPERATORS =
				exports.INHERIT_KEYS =
				exports.FOR_INIT_KEYS =
				exports.FLATTENABLE_KEYS =
				exports.EQUALITY_BINARY_OPERATORS =
				exports.COMPARISON_BINARY_OPERATORS =
				exports.COMMENT_KEYS =
				exports.BOOLEAN_UNARY_OPERATORS =
				exports.BOOLEAN_NUMBER_BINARY_OPERATORS =
				exports.BOOLEAN_BINARY_OPERATORS =
				exports.BINARY_OPERATORS =
				exports.ASSIGNMENT_OPERATORS =
					void 0
			const STATEMENT_OR_BLOCK_KEYS = (exports.STATEMENT_OR_BLOCK_KEYS = [
				'consequent',
				'body',
				'alternate',
			])
			const FLATTENABLE_KEYS = (exports.FLATTENABLE_KEYS = [
				'body',
				'expressions',
			])
			const FOR_INIT_KEYS = (exports.FOR_INIT_KEYS = ['left', 'init'])
			const COMMENT_KEYS = (exports.COMMENT_KEYS = [
				'leadingComments',
				'trailingComments',
				'innerComments',
			])
			const LOGICAL_OPERATORS = (exports.LOGICAL_OPERATORS = ['||', '&&', '??'])
			const UPDATE_OPERATORS = (exports.UPDATE_OPERATORS = ['++', '--'])
			const BOOLEAN_NUMBER_BINARY_OPERATORS =
				(exports.BOOLEAN_NUMBER_BINARY_OPERATORS = ['>', '<', '>=', '<='])
			const EQUALITY_BINARY_OPERATORS = (exports.EQUALITY_BINARY_OPERATORS = [
				'==',
				'===',
				'!=',
				'!==',
			])
			const COMPARISON_BINARY_OPERATORS = (exports.COMPARISON_BINARY_OPERATORS =
				[...EQUALITY_BINARY_OPERATORS, 'in', 'instanceof'])
			const BOOLEAN_BINARY_OPERATORS = (exports.BOOLEAN_BINARY_OPERATORS = [
				...COMPARISON_BINARY_OPERATORS,
				...BOOLEAN_NUMBER_BINARY_OPERATORS,
			])
			const NUMBER_BINARY_OPERATORS = (exports.NUMBER_BINARY_OPERATORS = [
				'-',
				'/',
				'%',
				'*',
				'**',
				'&',
				'|',
				'>>',
				'>>>',
				'<<',
				'^',
			])
			const BINARY_OPERATORS = (exports.BINARY_OPERATORS = [
				'+',
				...NUMBER_BINARY_OPERATORS,
				...BOOLEAN_BINARY_OPERATORS,
				'|>',
			])
			const ASSIGNMENT_OPERATORS = (exports.ASSIGNMENT_OPERATORS = [
				'=',
				'+=',
				...NUMBER_BINARY_OPERATORS.map((op) => op + '='),
				...LOGICAL_OPERATORS.map((op) => op + '='),
			])
			const BOOLEAN_UNARY_OPERATORS = (exports.BOOLEAN_UNARY_OPERATORS = [
				'delete',
				'!',
			])
			const NUMBER_UNARY_OPERATORS = (exports.NUMBER_UNARY_OPERATORS = [
				'+',
				'-',
				'~',
			])
			const STRING_UNARY_OPERATORS = (exports.STRING_UNARY_OPERATORS = [
				'typeof',
			])
			const UNARY_OPERATORS = (exports.UNARY_OPERATORS = [
				'void',
				'throw',
				...BOOLEAN_UNARY_OPERATORS,
				...NUMBER_UNARY_OPERATORS,
				...STRING_UNARY_OPERATORS,
			])
			const INHERIT_KEYS = (exports.INHERIT_KEYS = {
				optional: ['typeAnnotation', 'typeParameters', 'returnType'],
				force: ['start', 'loc', 'end'],
			})
			{
				exports.BLOCK_SCOPED_SYMBOL = Symbol.for('var used to be block scoped')
				exports.NOT_LOCAL_BINDING = Symbol.for(
					'should not be considered a local binding',
				)
			}

			//# sourceMappingURL=index.js.map

			/***/
		},

		/***/ 77046: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = ensureBlock
			var _toBlock = __nccwpck_require__(59735)
			function ensureBlock(node, key = 'body') {
				const result = (0, _toBlock.default)(node[key], node)
				node[key] = result
				return result
			}

			//# sourceMappingURL=ensureBlock.js.map

			/***/
		},

		/***/ 77060: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = gatherSequenceExpressions
			var _getBindingIdentifiers = __nccwpck_require__(45300)
			var _index = __nccwpck_require__(40741)
			var _index2 = __nccwpck_require__(90670)
			var _productions = __nccwpck_require__(38504)
			var _cloneNode = __nccwpck_require__(89260)
			function gatherSequenceExpressions(nodes, declars) {
				const exprs = []
				let ensureLastUndefined = true
				for (const node of nodes) {
					if (!(0, _index.isEmptyStatement)(node)) {
						ensureLastUndefined = false
					}
					if ((0, _index.isExpression)(node)) {
						exprs.push(node)
					} else if ((0, _index.isExpressionStatement)(node)) {
						exprs.push(node.expression)
					} else if ((0, _index.isVariableDeclaration)(node)) {
						if (node.kind !== 'var') return
						for (const declar of node.declarations) {
							const bindings = (0, _getBindingIdentifiers.default)(declar)
							for (const key of Object.keys(bindings)) {
								declars.push({
									kind: node.kind,
									id: (0, _cloneNode.default)(bindings[key]),
								})
							}
							if (declar.init) {
								exprs.push(
									(0, _index2.assignmentExpression)(
										'=',
										declar.id,
										declar.init,
									),
								)
							}
						}
						ensureLastUndefined = true
					} else if ((0, _index.isIfStatement)(node)) {
						const consequent = node.consequent
							? gatherSequenceExpressions([node.consequent], declars)
							: (0, _productions.buildUndefinedNode)()
						const alternate = node.alternate
							? gatherSequenceExpressions([node.alternate], declars)
							: (0, _productions.buildUndefinedNode)()
						if (!consequent || !alternate) return
						exprs.push(
							(0, _index2.conditionalExpression)(
								node.test,
								consequent,
								alternate,
							),
						)
					} else if ((0, _index.isBlockStatement)(node)) {
						const body = gatherSequenceExpressions(node.body, declars)
						if (!body) return
						exprs.push(body)
					} else if ((0, _index.isEmptyStatement)(node)) {
						if (nodes.indexOf(node) === 0) {
							ensureLastUndefined = true
						}
					} else {
						return
					}
				}
				if (ensureLastUndefined) {
					exprs.push((0, _productions.buildUndefinedNode)())
				}
				if (exprs.length === 1) {
					return exprs[0]
				} else {
					return (0, _index2.sequenceExpression)(exprs)
				}
			}

			//# sourceMappingURL=gatherSequenceExpressions.js.map

			/***/
		},

		/***/ 19687: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = toBindingIdentifierName
			var _toIdentifier = __nccwpck_require__(59451)
			function toBindingIdentifierName(name) {
				name = (0, _toIdentifier.default)(name)
				if (name === 'eval' || name === 'arguments') name = '_' + name
				return name
			}

			//# sourceMappingURL=toBindingIdentifierName.js.map

			/***/
		},

		/***/ 59735: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = toBlock
			var _index = __nccwpck_require__(40741)
			var _index2 = __nccwpck_require__(90670)
			function toBlock(node, parent) {
				if ((0, _index.isBlockStatement)(node)) {
					return node
				}
				let blockNodes = []
				if ((0, _index.isEmptyStatement)(node)) {
					blockNodes = []
				} else {
					if (!(0, _index.isStatement)(node)) {
						if ((0, _index.isFunction)(parent)) {
							node = (0, _index2.returnStatement)(node)
						} else {
							node = (0, _index2.expressionStatement)(node)
						}
					}
					blockNodes = [node]
				}
				return (0, _index2.blockStatement)(blockNodes)
			}

			//# sourceMappingURL=toBlock.js.map

			/***/
		},

		/***/ 49480: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = toComputedKey
			var _index = __nccwpck_require__(40741)
			var _index2 = __nccwpck_require__(90670)
			function toComputedKey(node, key = node.key || node.property) {
				if (!node.computed && (0, _index.isIdentifier)(key))
					key = (0, _index2.stringLiteral)(key.name)
				return key
			}

			//# sourceMappingURL=toComputedKey.js.map

			/***/
		},

		/***/ 36490: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = void 0
			var _index = __nccwpck_require__(40741)
			var _default = (exports['default'] = toExpression)
			function toExpression(node) {
				if ((0, _index.isExpressionStatement)(node)) {
					node = node.expression
				}
				if ((0, _index.isExpression)(node)) {
					return node
				}
				if ((0, _index.isClass)(node)) {
					node.type = 'ClassExpression'
				} else if ((0, _index.isFunction)(node)) {
					node.type = 'FunctionExpression'
				}
				if (!(0, _index.isExpression)(node)) {
					throw new Error(`cannot turn ${node.type} to an expression`)
				}
				return node
			}

			//# sourceMappingURL=toExpression.js.map

			/***/
		},

		/***/ 59451: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = toIdentifier
			var _isValidIdentifier = __nccwpck_require__(66030)
			var _helperValidatorIdentifier = __nccwpck_require__(76599)
			function toIdentifier(input) {
				input = input + ''
				let name = ''
				for (const c of input) {
					name += (0, _helperValidatorIdentifier.isIdentifierChar)(
						c.codePointAt(0),
					)
						? c
						: '-'
				}
				name = name.replace(/^[-0-9]+/, '')
				name = name.replace(/[-\s]+(.)?/g, function (match, c) {
					return c ? c.toUpperCase() : ''
				})
				if (!(0, _isValidIdentifier.default)(name)) {
					name = `_${name}`
				}
				return name || '_'
			}

			//# sourceMappingURL=toIdentifier.js.map

			/***/
		},

		/***/ 23381: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = toKeyAlias
			var _index = __nccwpck_require__(40741)
			var _cloneNode = __nccwpck_require__(89260)
			var _removePropertiesDeep = __nccwpck_require__(55902)
			function toKeyAlias(node, key = node.key) {
				let alias
				if (node.kind === 'method') {
					return toKeyAlias.increment() + ''
				} else if ((0, _index.isIdentifier)(key)) {
					alias = key.name
				} else if ((0, _index.isStringLiteral)(key)) {
					alias = JSON.stringify(key.value)
				} else {
					alias = JSON.stringify(
						(0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)),
					)
				}
				if (node.computed) {
					alias = `[${alias}]`
				}
				if (node.static) {
					alias = `static:${alias}`
				}
				return alias
			}
			toKeyAlias.uid = 0
			toKeyAlias.increment = function () {
				if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
					return (toKeyAlias.uid = 0)
				} else {
					return toKeyAlias.uid++
				}
			}

			//# sourceMappingURL=toKeyAlias.js.map

			/***/
		},

		/***/ 403: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = toSequenceExpression
			var _gatherSequenceExpressions = __nccwpck_require__(77060)
			function toSequenceExpression(nodes, scope) {
				if (!(nodes != null && nodes.length)) return
				const declars = []
				const result = (0, _gatherSequenceExpressions.default)(nodes, declars)
				if (!result) return
				for (const declar of declars) {
					scope.push(declar)
				}
				return result
			}

			//# sourceMappingURL=toSequenceExpression.js.map

			/***/
		},

		/***/ 82635: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = void 0
			var _index = __nccwpck_require__(40741)
			var _index2 = __nccwpck_require__(90670)
			var _default = (exports['default'] = toStatement)
			function toStatement(node, ignore) {
				if ((0, _index.isStatement)(node)) {
					return node
				}
				let mustHaveId = false
				let newType
				if ((0, _index.isClass)(node)) {
					mustHaveId = true
					newType = 'ClassDeclaration'
				} else if ((0, _index.isFunction)(node)) {
					mustHaveId = true
					newType = 'FunctionDeclaration'
				} else if ((0, _index.isAssignmentExpression)(node)) {
					return (0, _index2.expressionStatement)(node)
				}
				if (mustHaveId && !node.id) {
					newType = false
				}
				if (!newType) {
					if (ignore) {
						return false
					} else {
						throw new Error(`cannot turn ${node.type} to a statement`)
					}
				}
				node.type = newType
				return node
			}

			//# sourceMappingURL=toStatement.js.map

			/***/
		},

		/***/ 20021: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = void 0
			var _isValidIdentifier = __nccwpck_require__(66030)
			var _index = __nccwpck_require__(90670)
			var _default = (exports['default'] = valueToNode)
			const objectToString = Function.call.bind(Object.prototype.toString)
			function isRegExp(value) {
				return objectToString(value) === '[object RegExp]'
			}
			function isPlainObject(value) {
				if (
					typeof value !== 'object' ||
					value === null ||
					Object.prototype.toString.call(value) !== '[object Object]'
				) {
					return false
				}
				const proto = Object.getPrototypeOf(value)
				return proto === null || Object.getPrototypeOf(proto) === null
			}
			function valueToNode(value) {
				if (value === undefined) {
					return (0, _index.identifier)('undefined')
				}
				if (value === true || value === false) {
					return (0, _index.booleanLiteral)(value)
				}
				if (value === null) {
					return (0, _index.nullLiteral)()
				}
				if (typeof value === 'string') {
					return (0, _index.stringLiteral)(value)
				}
				if (typeof value === 'number') {
					let result
					if (Number.isFinite(value)) {
						result = (0, _index.numericLiteral)(Math.abs(value))
					} else {
						let numerator
						if (Number.isNaN(value)) {
							numerator = (0, _index.numericLiteral)(0)
						} else {
							numerator = (0, _index.numericLiteral)(1)
						}
						result = (0, _index.binaryExpression)(
							'/',
							numerator,
							(0, _index.numericLiteral)(0),
						)
					}
					if (value < 0 || Object.is(value, -0)) {
						result = (0, _index.unaryExpression)('-', result)
					}
					return result
				}
				if (typeof value === 'bigint') {
					return (0, _index.bigIntLiteral)(value.toString())
				}
				if (isRegExp(value)) {
					const pattern = value.source
					const flags = /\/([a-z]*)$/.exec(value.toString())[1]
					return (0, _index.regExpLiteral)(pattern, flags)
				}
				if (Array.isArray(value)) {
					return (0, _index.arrayExpression)(value.map(valueToNode))
				}
				if (isPlainObject(value)) {
					const props = []
					for (const key of Object.keys(value)) {
						let nodeKey,
							computed = false
						if ((0, _isValidIdentifier.default)(key)) {
							if (key === '__proto__') {
								computed = true
								nodeKey = (0, _index.stringLiteral)(key)
							} else {
								nodeKey = (0, _index.identifier)(key)
							}
						} else {
							nodeKey = (0, _index.stringLiteral)(key)
						}
						props.push(
							(0, _index.objectProperty)(
								nodeKey,
								valueToNode(value[key]),
								computed,
							),
						)
					}
					return (0, _index.objectExpression)(props)
				}
				throw new Error("don't know how to turn this value into a node")
			}

			//# sourceMappingURL=valueToNode.js.map

			/***/
		},

		/***/ 62803: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.patternLikeCommon =
				exports.importAttributes =
				exports.functionTypeAnnotationCommon =
				exports.functionDeclarationCommon =
				exports.functionCommon =
				exports.classMethodOrPropertyCommon =
				exports.classMethodOrDeclareMethodCommon =
					void 0
			var _is = __nccwpck_require__(20051)
			var _isValidIdentifier = __nccwpck_require__(66030)
			var _helperValidatorIdentifier = __nccwpck_require__(76599)
			var _helperStringParser = __nccwpck_require__(73728)
			var _index = __nccwpck_require__(17945)
			var _utils = __nccwpck_require__(34559)
			const defineType = (0, _utils.defineAliasedType)('Standardized')
			defineType('ArrayExpression', {
				fields: {
					elements: {
						validate: (0, _utils.arrayOf)(
							(0, _utils.assertNodeOrValueType)(
								'null',
								'Expression',
								'SpreadElement',
							),
						),
						default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined,
					},
				},
				visitor: ['elements'],
				aliases: ['Expression'],
			})
			defineType('AssignmentExpression', {
				fields: {
					operator: {
						validate: !process.env.BABEL_TYPES_8_BREAKING
							? (0, _utils.assertValueType)('string')
							: Object.assign(
									(function () {
										const identifier = (0, _utils.assertOneOf)(
											..._index.ASSIGNMENT_OPERATORS,
										)
										const pattern = (0, _utils.assertOneOf)('=')
										return function (node, key, val) {
											const validator = (0, _is.default)('Pattern', node.left)
												? pattern
												: identifier
											validator(node, key, val)
										}
									})(),
									{
										type: 'string',
									},
								),
					},
					left: {
						validate: !process.env.BABEL_TYPES_8_BREAKING
							? (0, _utils.assertNodeType)('LVal', 'OptionalMemberExpression')
							: (0, _utils.assertNodeType)(
									'Identifier',
									'MemberExpression',
									'OptionalMemberExpression',
									'ArrayPattern',
									'ObjectPattern',
									'TSAsExpression',
									'TSSatisfiesExpression',
									'TSTypeAssertion',
									'TSNonNullExpression',
								),
					},
					right: {
						validate: (0, _utils.assertNodeType)('Expression'),
					},
				},
				builder: ['operator', 'left', 'right'],
				visitor: ['left', 'right'],
				aliases: ['Expression'],
			})
			defineType('BinaryExpression', {
				builder: ['operator', 'left', 'right'],
				fields: {
					operator: {
						validate: (0, _utils.assertOneOf)(..._index.BINARY_OPERATORS),
					},
					left: {
						validate: (function () {
							const expression = (0, _utils.assertNodeType)('Expression')
							const inOp = (0, _utils.assertNodeType)(
								'Expression',
								'PrivateName',
							)
							const validator = Object.assign(
								function (node, key, val) {
									const validator = node.operator === 'in' ? inOp : expression
									validator(node, key, val)
								},
								{
									oneOfNodeTypes: ['Expression', 'PrivateName'],
								},
							)
							return validator
						})(),
					},
					right: {
						validate: (0, _utils.assertNodeType)('Expression'),
					},
				},
				visitor: ['left', 'right'],
				aliases: ['Binary', 'Expression'],
			})
			defineType('InterpreterDirective', {
				builder: ['value'],
				fields: {
					value: {
						validate: (0, _utils.assertValueType)('string'),
					},
				},
			})
			defineType('Directive', {
				visitor: ['value'],
				fields: {
					value: {
						validate: (0, _utils.assertNodeType)('DirectiveLiteral'),
					},
				},
			})
			defineType('DirectiveLiteral', {
				builder: ['value'],
				fields: {
					value: {
						validate: (0, _utils.assertValueType)('string'),
					},
				},
			})
			defineType('BlockStatement', {
				builder: ['body', 'directives'],
				visitor: ['directives', 'body'],
				fields: {
					directives: {
						validate: (0, _utils.arrayOfType)('Directive'),
						default: [],
					},
					body: (0, _utils.validateArrayOfType)('Statement'),
				},
				aliases: ['Scopable', 'BlockParent', 'Block', 'Statement'],
			})
			defineType('BreakStatement', {
				visitor: ['label'],
				fields: {
					label: {
						validate: (0, _utils.assertNodeType)('Identifier'),
						optional: true,
					},
				},
				aliases: ['Statement', 'Terminatorless', 'CompletionStatement'],
			})
			defineType('CallExpression', {
				visitor: ['callee', 'arguments', 'typeParameters', 'typeArguments'],
				builder: ['callee', 'arguments'],
				aliases: ['Expression'],
				fields: Object.assign(
					{
						callee: {
							validate: (0, _utils.assertNodeType)(
								'Expression',
								'Super',
								'V8IntrinsicIdentifier',
							),
						},
						arguments: (0, _utils.validateArrayOfType)(
							'Expression',
							'SpreadElement',
							'ArgumentPlaceholder',
						),
						typeArguments: {
							validate: (0, _utils.assertNodeType)(
								'TypeParameterInstantiation',
							),
							optional: true,
						},
					},
					{
						optional: {
							validate: (0, _utils.assertValueType)('boolean'),
							optional: true,
						},
						typeParameters: {
							validate: (0, _utils.assertNodeType)(
								'TSTypeParameterInstantiation',
							),
							optional: true,
						},
					},
					process.env.BABEL_TYPES_8_BREAKING
						? {}
						: {
								optional: {
									validate: (0, _utils.assertValueType)('boolean'),
									optional: true,
								},
							},
				),
			})
			defineType('CatchClause', {
				visitor: ['param', 'body'],
				fields: {
					param: {
						validate: (0, _utils.assertNodeType)(
							'Identifier',
							'ArrayPattern',
							'ObjectPattern',
						),
						optional: true,
					},
					body: {
						validate: (0, _utils.assertNodeType)('BlockStatement'),
					},
				},
				aliases: ['Scopable', 'BlockParent'],
			})
			defineType('ConditionalExpression', {
				visitor: ['test', 'consequent', 'alternate'],
				fields: {
					test: {
						validate: (0, _utils.assertNodeType)('Expression'),
					},
					consequent: {
						validate: (0, _utils.assertNodeType)('Expression'),
					},
					alternate: {
						validate: (0, _utils.assertNodeType)('Expression'),
					},
				},
				aliases: ['Expression', 'Conditional'],
			})
			defineType('ContinueStatement', {
				visitor: ['label'],
				fields: {
					label: {
						validate: (0, _utils.assertNodeType)('Identifier'),
						optional: true,
					},
				},
				aliases: ['Statement', 'Terminatorless', 'CompletionStatement'],
			})
			defineType('DebuggerStatement', {
				aliases: ['Statement'],
			})
			defineType('DoWhileStatement', {
				builder: ['test', 'body'],
				visitor: ['body', 'test'],
				fields: {
					test: {
						validate: (0, _utils.assertNodeType)('Expression'),
					},
					body: {
						validate: (0, _utils.assertNodeType)('Statement'),
					},
				},
				aliases: ['Statement', 'BlockParent', 'Loop', 'While', 'Scopable'],
			})
			defineType('EmptyStatement', {
				aliases: ['Statement'],
			})
			defineType('ExpressionStatement', {
				visitor: ['expression'],
				fields: {
					expression: {
						validate: (0, _utils.assertNodeType)('Expression'),
					},
				},
				aliases: ['Statement', 'ExpressionWrapper'],
			})
			defineType('File', {
				builder: ['program', 'comments', 'tokens'],
				visitor: ['program'],
				fields: {
					program: {
						validate: (0, _utils.assertNodeType)('Program'),
					},
					comments: {
						validate: !process.env.BABEL_TYPES_8_BREAKING
							? Object.assign(() => {}, {
									each: {
										oneOfNodeTypes: ['CommentBlock', 'CommentLine'],
									},
								})
							: (0, _utils.assertEach)(
									(0, _utils.assertNodeType)('CommentBlock', 'CommentLine'),
								),
						optional: true,
					},
					tokens: {
						validate: (0, _utils.assertEach)(
							Object.assign(() => {}, {
								type: 'any',
							}),
						),
						optional: true,
					},
				},
			})
			defineType('ForInStatement', {
				visitor: ['left', 'right', 'body'],
				aliases: [
					'Scopable',
					'Statement',
					'For',
					'BlockParent',
					'Loop',
					'ForXStatement',
				],
				fields: {
					left: {
						validate: !process.env.BABEL_TYPES_8_BREAKING
							? (0, _utils.assertNodeType)('VariableDeclaration', 'LVal')
							: (0, _utils.assertNodeType)(
									'VariableDeclaration',
									'Identifier',
									'MemberExpression',
									'ArrayPattern',
									'ObjectPattern',
									'TSAsExpression',
									'TSSatisfiesExpression',
									'TSTypeAssertion',
									'TSNonNullExpression',
								),
					},
					right: {
						validate: (0, _utils.assertNodeType)('Expression'),
					},
					body: {
						validate: (0, _utils.assertNodeType)('Statement'),
					},
				},
			})
			defineType('ForStatement', {
				visitor: ['init', 'test', 'update', 'body'],
				aliases: ['Scopable', 'Statement', 'For', 'BlockParent', 'Loop'],
				fields: {
					init: {
						validate: (0, _utils.assertNodeType)(
							'VariableDeclaration',
							'Expression',
						),
						optional: true,
					},
					test: {
						validate: (0, _utils.assertNodeType)('Expression'),
						optional: true,
					},
					update: {
						validate: (0, _utils.assertNodeType)('Expression'),
						optional: true,
					},
					body: {
						validate: (0, _utils.assertNodeType)('Statement'),
					},
				},
			})
			const functionCommon = () => ({
				params: (0, _utils.validateArrayOfType)(
					'Identifier',
					'Pattern',
					'RestElement',
				),
				generator: {
					default: false,
				},
				async: {
					default: false,
				},
			})
			exports.functionCommon = functionCommon
			const functionTypeAnnotationCommon = () => ({
				returnType: {
					validate: (0, _utils.assertNodeType)(
						'TypeAnnotation',
						'TSTypeAnnotation',
						'Noop',
					),
					optional: true,
				},
				typeParameters: {
					validate: (0, _utils.assertNodeType)(
						'TypeParameterDeclaration',
						'TSTypeParameterDeclaration',
						'Noop',
					),
					optional: true,
				},
			})
			exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon
			const functionDeclarationCommon = () =>
				Object.assign({}, functionCommon(), {
					declare: {
						validate: (0, _utils.assertValueType)('boolean'),
						optional: true,
					},
					id: {
						validate: (0, _utils.assertNodeType)('Identifier'),
						optional: true,
					},
				})
			exports.functionDeclarationCommon = functionDeclarationCommon
			defineType('FunctionDeclaration', {
				builder: ['id', 'params', 'body', 'generator', 'async'],
				visitor: [
					'id',
					'typeParameters',
					'params',
					'predicate',
					'returnType',
					'body',
				],
				fields: Object.assign(
					{},
					functionDeclarationCommon(),
					functionTypeAnnotationCommon(),
					{
						body: {
							validate: (0, _utils.assertNodeType)('BlockStatement'),
						},
						predicate: {
							validate: (0, _utils.assertNodeType)(
								'DeclaredPredicate',
								'InferredPredicate',
							),
							optional: true,
						},
					},
				),
				aliases: [
					'Scopable',
					'Function',
					'BlockParent',
					'FunctionParent',
					'Statement',
					'Pureish',
					'Declaration',
				],
				validate: !process.env.BABEL_TYPES_8_BREAKING
					? undefined
					: (function () {
							const identifier = (0, _utils.assertNodeType)('Identifier')
							return function (parent, key, node) {
								if (!(0, _is.default)('ExportDefaultDeclaration', parent)) {
									identifier(node, 'id', node.id)
								}
							}
						})(),
			})
			defineType('FunctionExpression', {
				inherits: 'FunctionDeclaration',
				aliases: [
					'Scopable',
					'Function',
					'BlockParent',
					'FunctionParent',
					'Expression',
					'Pureish',
				],
				fields: Object.assign(
					{},
					functionCommon(),
					functionTypeAnnotationCommon(),
					{
						id: {
							validate: (0, _utils.assertNodeType)('Identifier'),
							optional: true,
						},
						body: {
							validate: (0, _utils.assertNodeType)('BlockStatement'),
						},
						predicate: {
							validate: (0, _utils.assertNodeType)(
								'DeclaredPredicate',
								'InferredPredicate',
							),
							optional: true,
						},
					},
				),
			})
			const patternLikeCommon = () => ({
				typeAnnotation: {
					validate: (0, _utils.assertNodeType)(
						'TypeAnnotation',
						'TSTypeAnnotation',
						'Noop',
					),
					optional: true,
				},
				optional: {
					validate: (0, _utils.assertValueType)('boolean'),
					optional: true,
				},
				decorators: {
					validate: (0, _utils.arrayOfType)('Decorator'),
					optional: true,
				},
			})
			exports.patternLikeCommon = patternLikeCommon
			defineType('Identifier', {
				builder: ['name'],
				visitor: ['typeAnnotation', 'decorators'],
				aliases: ['Expression', 'PatternLike', 'LVal', 'TSEntityName'],
				fields: Object.assign({}, patternLikeCommon(), {
					name: {
						validate: process.env.BABEL_TYPES_8_BREAKING
							? (0, _utils.chain)(
									(0, _utils.assertValueType)('string'),
									Object.assign(
										function (node, key, val) {
											if (!(0, _isValidIdentifier.default)(val, false)) {
												throw new TypeError(
													`"${val}" is not a valid identifier name`,
												)
											}
										},
										{
											type: 'string',
										},
									),
								)
							: (0, _utils.assertValueType)('string'),
					},
				}),
				validate: process.env.BABEL_TYPES_8_BREAKING
					? function (parent, key, node) {
							const match = /\.(\w+)$/.exec(key.toString())
							if (!match) return
							const [, parentKey] = match
							const nonComp = {
								computed: false,
							}
							if (parentKey === 'property') {
								if ((0, _is.default)('MemberExpression', parent, nonComp))
									return
								if (
									(0, _is.default)('OptionalMemberExpression', parent, nonComp)
								)
									return
							} else if (parentKey === 'key') {
								if ((0, _is.default)('Property', parent, nonComp)) return
								if ((0, _is.default)('Method', parent, nonComp)) return
							} else if (parentKey === 'exported') {
								if ((0, _is.default)('ExportSpecifier', parent)) return
							} else if (parentKey === 'imported') {
								if (
									(0, _is.default)('ImportSpecifier', parent, {
										imported: node,
									})
								)
									return
							} else if (parentKey === 'meta') {
								if (
									(0, _is.default)('MetaProperty', parent, {
										meta: node,
									})
								)
									return
							}
							if (
								((0, _helperValidatorIdentifier.isKeyword)(node.name) ||
									(0, _helperValidatorIdentifier.isReservedWord)(
										node.name,
										false,
									)) &&
								node.name !== 'this'
							) {
								throw new TypeError(`"${node.name}" is not a valid identifier`)
							}
						}
					: undefined,
			})
			defineType('IfStatement', {
				visitor: ['test', 'consequent', 'alternate'],
				aliases: ['Statement', 'Conditional'],
				fields: {
					test: {
						validate: (0, _utils.assertNodeType)('Expression'),
					},
					consequent: {
						validate: (0, _utils.assertNodeType)('Statement'),
					},
					alternate: {
						optional: true,
						validate: (0, _utils.assertNodeType)('Statement'),
					},
				},
			})
			defineType('LabeledStatement', {
				visitor: ['label', 'body'],
				aliases: ['Statement'],
				fields: {
					label: {
						validate: (0, _utils.assertNodeType)('Identifier'),
					},
					body: {
						validate: (0, _utils.assertNodeType)('Statement'),
					},
				},
			})
			defineType('StringLiteral', {
				builder: ['value'],
				fields: {
					value: {
						validate: (0, _utils.assertValueType)('string'),
					},
				},
				aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
			})
			defineType('NumericLiteral', {
				builder: ['value'],
				deprecatedAlias: 'NumberLiteral',
				fields: {
					value: {
						validate: (0, _utils.chain)(
							(0, _utils.assertValueType)('number'),
							Object.assign(
								function (node, key, val) {
									if (1 / val < 0 || !Number.isFinite(val)) {
										const error = new Error(
											'NumericLiterals must be non-negative finite numbers. ' +
												`You can use t.valueToNode(${val}) instead.`,
										)
										{
										}
									}
								},
								{
									type: 'number',
								},
							),
						),
					},
				},
				aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
			})
			defineType('NullLiteral', {
				aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
			})
			defineType('BooleanLiteral', {
				builder: ['value'],
				fields: {
					value: {
						validate: (0, _utils.assertValueType)('boolean'),
					},
				},
				aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
			})
			defineType('RegExpLiteral', {
				builder: ['pattern', 'flags'],
				deprecatedAlias: 'RegexLiteral',
				aliases: ['Expression', 'Pureish', 'Literal'],
				fields: {
					pattern: {
						validate: (0, _utils.assertValueType)('string'),
					},
					flags: {
						validate: process.env.BABEL_TYPES_8_BREAKING
							? (0, _utils.chain)(
									(0, _utils.assertValueType)('string'),
									Object.assign(
										function (node, key, val) {
											const invalid = /[^gimsuy]/.exec(val)
											if (invalid) {
												throw new TypeError(
													`"${invalid[0]}" is not a valid RegExp flag`,
												)
											}
										},
										{
											type: 'string',
										},
									),
								)
							: (0, _utils.assertValueType)('string'),
						default: '',
					},
				},
			})
			defineType('LogicalExpression', {
				builder: ['operator', 'left', 'right'],
				visitor: ['left', 'right'],
				aliases: ['Binary', 'Expression'],
				fields: {
					operator: {
						validate: (0, _utils.assertOneOf)(..._index.LOGICAL_OPERATORS),
					},
					left: {
						validate: (0, _utils.assertNodeType)('Expression'),
					},
					right: {
						validate: (0, _utils.assertNodeType)('Expression'),
					},
				},
			})
			defineType('MemberExpression', {
				builder: [
					'object',
					'property',
					'computed',
					...(!process.env.BABEL_TYPES_8_BREAKING ? ['optional'] : []),
				],
				visitor: ['object', 'property'],
				aliases: ['Expression', 'LVal'],
				fields: Object.assign(
					{
						object: {
							validate: (0, _utils.assertNodeType)('Expression', 'Super'),
						},
						property: {
							validate: (function () {
								const normal = (0, _utils.assertNodeType)(
									'Identifier',
									'PrivateName',
								)
								const computed = (0, _utils.assertNodeType)('Expression')
								const validator = function (node, key, val) {
									const validator = node.computed ? computed : normal
									validator(node, key, val)
								}
								validator.oneOfNodeTypes = [
									'Expression',
									'Identifier',
									'PrivateName',
								]
								return validator
							})(),
						},
						computed: {
							default: false,
						},
					},
					!process.env.BABEL_TYPES_8_BREAKING
						? {
								optional: {
									validate: (0, _utils.assertValueType)('boolean'),
									optional: true,
								},
							}
						: {},
				),
			})
			defineType('NewExpression', {
				inherits: 'CallExpression',
			})
			defineType('Program', {
				visitor: ['directives', 'body'],
				builder: ['body', 'directives', 'sourceType', 'interpreter'],
				fields: {
					sourceType: {
						validate: (0, _utils.assertOneOf)('script', 'module'),
						default: 'script',
					},
					interpreter: {
						validate: (0, _utils.assertNodeType)('InterpreterDirective'),
						default: null,
						optional: true,
					},
					directives: {
						validate: (0, _utils.arrayOfType)('Directive'),
						default: [],
					},
					body: (0, _utils.validateArrayOfType)('Statement'),
				},
				aliases: ['Scopable', 'BlockParent', 'Block'],
			})
			defineType('ObjectExpression', {
				visitor: ['properties'],
				aliases: ['Expression'],
				fields: {
					properties: (0, _utils.validateArrayOfType)(
						'ObjectMethod',
						'ObjectProperty',
						'SpreadElement',
					),
				},
			})
			defineType('ObjectMethod', {
				builder: [
					'kind',
					'key',
					'params',
					'body',
					'computed',
					'generator',
					'async',
				],
				visitor: [
					'decorators',
					'key',
					'typeParameters',
					'params',
					'returnType',
					'body',
				],
				fields: Object.assign(
					{},
					functionCommon(),
					functionTypeAnnotationCommon(),
					{
						kind: Object.assign(
							{
								validate: (0, _utils.assertOneOf)('method', 'get', 'set'),
							},
							!process.env.BABEL_TYPES_8_BREAKING
								? {
										default: 'method',
									}
								: {},
						),
						computed: {
							default: false,
						},
						key: {
							validate: (function () {
								const normal = (0, _utils.assertNodeType)(
									'Identifier',
									'StringLiteral',
									'NumericLiteral',
									'BigIntLiteral',
								)
								const computed = (0, _utils.assertNodeType)('Expression')
								const validator = function (node, key, val) {
									const validator = node.computed ? computed : normal
									validator(node, key, val)
								}
								validator.oneOfNodeTypes = [
									'Expression',
									'Identifier',
									'StringLiteral',
									'NumericLiteral',
									'BigIntLiteral',
								]
								return validator
							})(),
						},
						decorators: {
							validate: (0, _utils.arrayOfType)('Decorator'),
							optional: true,
						},
						body: {
							validate: (0, _utils.assertNodeType)('BlockStatement'),
						},
					},
				),
				aliases: [
					'UserWhitespacable',
					'Function',
					'Scopable',
					'BlockParent',
					'FunctionParent',
					'Method',
					'ObjectMember',
				],
			})
			defineType('ObjectProperty', {
				builder: [
					'key',
					'value',
					'computed',
					'shorthand',
					...(!process.env.BABEL_TYPES_8_BREAKING ? ['decorators'] : []),
				],
				fields: {
					computed: {
						default: false,
					},
					key: {
						validate: (function () {
							const normal = (0, _utils.assertNodeType)(
								'Identifier',
								'StringLiteral',
								'NumericLiteral',
								'BigIntLiteral',
								'DecimalLiteral',
								'PrivateName',
							)
							const computed = (0, _utils.assertNodeType)('Expression')
							const validator = Object.assign(
								function (node, key, val) {
									const validator = node.computed ? computed : normal
									validator(node, key, val)
								},
								{
									oneOfNodeTypes: [
										'Expression',
										'Identifier',
										'StringLiteral',
										'NumericLiteral',
										'BigIntLiteral',
										'DecimalLiteral',
										'PrivateName',
									],
								},
							)
							return validator
						})(),
					},
					value: {
						validate: (0, _utils.assertNodeType)('Expression', 'PatternLike'),
					},
					shorthand: {
						validate: process.env.BABEL_TYPES_8_BREAKING
							? (0, _utils.chain)(
									(0, _utils.assertValueType)('boolean'),
									Object.assign(
										function (node, key, shorthand) {
											if (!shorthand) return
											if (node.computed) {
												throw new TypeError(
													'Property shorthand of ObjectProperty cannot be true if computed is true',
												)
											}
											if (!(0, _is.default)('Identifier', node.key)) {
												throw new TypeError(
													'Property shorthand of ObjectProperty cannot be true if key is not an Identifier',
												)
											}
										},
										{
											type: 'boolean',
										},
									),
								)
							: (0, _utils.assertValueType)('boolean'),
						default: false,
					},
					decorators: {
						validate: (0, _utils.arrayOfType)('Decorator'),
						optional: true,
					},
				},
				visitor: ['key', 'value', 'decorators'],
				aliases: ['UserWhitespacable', 'Property', 'ObjectMember'],
				validate: !process.env.BABEL_TYPES_8_BREAKING
					? undefined
					: (function () {
							const pattern = (0, _utils.assertNodeType)(
								'Identifier',
								'Pattern',
								'TSAsExpression',
								'TSSatisfiesExpression',
								'TSNonNullExpression',
								'TSTypeAssertion',
							)
							const expression = (0, _utils.assertNodeType)('Expression')
							return function (parent, key, node) {
								const validator = (0, _is.default)('ObjectPattern', parent)
									? pattern
									: expression
								validator(node, 'value', node.value)
							}
						})(),
			})
			defineType('RestElement', {
				visitor: ['argument', 'typeAnnotation'],
				builder: ['argument'],
				aliases: ['LVal', 'PatternLike'],
				deprecatedAlias: 'RestProperty',
				fields: Object.assign({}, patternLikeCommon(), {
					argument: {
						validate: !process.env.BABEL_TYPES_8_BREAKING
							? (0, _utils.assertNodeType)('LVal')
							: (0, _utils.assertNodeType)(
									'Identifier',
									'ArrayPattern',
									'ObjectPattern',
									'MemberExpression',
									'TSAsExpression',
									'TSSatisfiesExpression',
									'TSTypeAssertion',
									'TSNonNullExpression',
								),
					},
				}),
				validate: process.env.BABEL_TYPES_8_BREAKING
					? function (parent, key) {
							const match = /(\w+)\[(\d+)\]/.exec(key.toString())
							if (!match)
								throw new Error('Internal Babel error: malformed key.')
							const [, listKey, index] = match
							if (parent[listKey].length > +index + 1) {
								throw new TypeError(
									`RestElement must be last element of ${listKey}`,
								)
							}
						}
					: undefined,
			})
			defineType('ReturnStatement', {
				visitor: ['argument'],
				aliases: ['Statement', 'Terminatorless', 'CompletionStatement'],
				fields: {
					argument: {
						validate: (0, _utils.assertNodeType)('Expression'),
						optional: true,
					},
				},
			})
			defineType('SequenceExpression', {
				visitor: ['expressions'],
				fields: {
					expressions: (0, _utils.validateArrayOfType)('Expression'),
				},
				aliases: ['Expression'],
			})
			defineType('ParenthesizedExpression', {
				visitor: ['expression'],
				aliases: ['Expression', 'ExpressionWrapper'],
				fields: {
					expression: {
						validate: (0, _utils.assertNodeType)('Expression'),
					},
				},
			})
			defineType('SwitchCase', {
				visitor: ['test', 'consequent'],
				fields: {
					test: {
						validate: (0, _utils.assertNodeType)('Expression'),
						optional: true,
					},
					consequent: (0, _utils.validateArrayOfType)('Statement'),
				},
			})
			defineType('SwitchStatement', {
				visitor: ['discriminant', 'cases'],
				aliases: ['Statement', 'BlockParent', 'Scopable'],
				fields: {
					discriminant: {
						validate: (0, _utils.assertNodeType)('Expression'),
					},
					cases: (0, _utils.validateArrayOfType)('SwitchCase'),
				},
			})
			defineType('ThisExpression', {
				aliases: ['Expression'],
			})
			defineType('ThrowStatement', {
				visitor: ['argument'],
				aliases: ['Statement', 'Terminatorless', 'CompletionStatement'],
				fields: {
					argument: {
						validate: (0, _utils.assertNodeType)('Expression'),
					},
				},
			})
			defineType('TryStatement', {
				visitor: ['block', 'handler', 'finalizer'],
				aliases: ['Statement'],
				fields: {
					block: {
						validate: process.env.BABEL_TYPES_8_BREAKING
							? (0, _utils.chain)(
									(0, _utils.assertNodeType)('BlockStatement'),
									Object.assign(
										function (node) {
											if (!node.handler && !node.finalizer) {
												throw new TypeError(
													'TryStatement expects either a handler or finalizer, or both',
												)
											}
										},
										{
											oneOfNodeTypes: ['BlockStatement'],
										},
									),
								)
							: (0, _utils.assertNodeType)('BlockStatement'),
					},
					handler: {
						optional: true,
						validate: (0, _utils.assertNodeType)('CatchClause'),
					},
					finalizer: {
						optional: true,
						validate: (0, _utils.assertNodeType)('BlockStatement'),
					},
				},
			})
			defineType('UnaryExpression', {
				builder: ['operator', 'argument', 'prefix'],
				fields: {
					prefix: {
						default: true,
					},
					argument: {
						validate: (0, _utils.assertNodeType)('Expression'),
					},
					operator: {
						validate: (0, _utils.assertOneOf)(..._index.UNARY_OPERATORS),
					},
				},
				visitor: ['argument'],
				aliases: ['UnaryLike', 'Expression'],
			})
			defineType('UpdateExpression', {
				builder: ['operator', 'argument', 'prefix'],
				fields: {
					prefix: {
						default: false,
					},
					argument: {
						validate: !process.env.BABEL_TYPES_8_BREAKING
							? (0, _utils.assertNodeType)('Expression')
							: (0, _utils.assertNodeType)('Identifier', 'MemberExpression'),
					},
					operator: {
						validate: (0, _utils.assertOneOf)(..._index.UPDATE_OPERATORS),
					},
				},
				visitor: ['argument'],
				aliases: ['Expression'],
			})
			defineType('VariableDeclaration', {
				builder: ['kind', 'declarations'],
				visitor: ['declarations'],
				aliases: ['Statement', 'Declaration'],
				fields: {
					declare: {
						validate: (0, _utils.assertValueType)('boolean'),
						optional: true,
					},
					kind: {
						validate: (0, _utils.assertOneOf)(
							'var',
							'let',
							'const',
							'using',
							'await using',
						),
					},
					declarations: (0, _utils.validateArrayOfType)('VariableDeclarator'),
				},
				validate: process.env.BABEL_TYPES_8_BREAKING
					? (() => {
							const withoutInit = (0, _utils.assertNodeType)(
								'Identifier',
								'Placeholder',
							)
							const constOrLetOrVar = (0, _utils.assertNodeType)(
								'Identifier',
								'ArrayPattern',
								'ObjectPattern',
								'Placeholder',
							)
							const usingOrAwaitUsing = withoutInit
							return function (parent, key, node) {
								const { kind, declarations } = node
								const parentIsForX = (0, _is.default)('ForXStatement', parent, {
									left: node,
								})
								if (parentIsForX) {
									if (declarations.length !== 1) {
										throw new TypeError(
											`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`,
										)
									}
								}
								for (const decl of declarations) {
									if (kind === 'const' || kind === 'let' || kind === 'var') {
										if (!parentIsForX && !decl.init) {
											withoutInit(decl, 'id', decl.id)
										} else {
											constOrLetOrVar(decl, 'id', decl.id)
										}
									} else {
										usingOrAwaitUsing(decl, 'id', decl.id)
									}
								}
							}
						})()
					: undefined,
			})
			defineType('VariableDeclarator', {
				visitor: ['id', 'init'],
				fields: {
					id: {
						validate: !process.env.BABEL_TYPES_8_BREAKING
							? (0, _utils.assertNodeType)('LVal')
							: (0, _utils.assertNodeType)(
									'Identifier',
									'ArrayPattern',
									'ObjectPattern',
								),
					},
					definite: {
						optional: true,
						validate: (0, _utils.assertValueType)('boolean'),
					},
					init: {
						optional: true,
						validate: (0, _utils.assertNodeType)('Expression'),
					},
				},
			})
			defineType('WhileStatement', {
				visitor: ['test', 'body'],
				aliases: ['Statement', 'BlockParent', 'Loop', 'While', 'Scopable'],
				fields: {
					test: {
						validate: (0, _utils.assertNodeType)('Expression'),
					},
					body: {
						validate: (0, _utils.assertNodeType)('Statement'),
					},
				},
			})
			defineType('WithStatement', {
				visitor: ['object', 'body'],
				aliases: ['Statement'],
				fields: {
					object: {
						validate: (0, _utils.assertNodeType)('Expression'),
					},
					body: {
						validate: (0, _utils.assertNodeType)('Statement'),
					},
				},
			})
			defineType('AssignmentPattern', {
				visitor: ['left', 'right', 'decorators'],
				builder: ['left', 'right'],
				aliases: ['Pattern', 'PatternLike', 'LVal'],
				fields: Object.assign({}, patternLikeCommon(), {
					left: {
						validate: (0, _utils.assertNodeType)(
							'Identifier',
							'ObjectPattern',
							'ArrayPattern',
							'MemberExpression',
							'TSAsExpression',
							'TSSatisfiesExpression',
							'TSTypeAssertion',
							'TSNonNullExpression',
						),
					},
					right: {
						validate: (0, _utils.assertNodeType)('Expression'),
					},
					decorators: {
						validate: (0, _utils.arrayOfType)('Decorator'),
						optional: true,
					},
				}),
			})
			defineType('ArrayPattern', {
				visitor: ['elements', 'typeAnnotation'],
				builder: ['elements'],
				aliases: ['Pattern', 'PatternLike', 'LVal'],
				fields: Object.assign({}, patternLikeCommon(), {
					elements: {
						validate: (0, _utils.chain)(
							(0, _utils.assertValueType)('array'),
							(0, _utils.assertEach)(
								(0, _utils.assertNodeOrValueType)(
									'null',
									'PatternLike',
									'LVal',
								),
							),
						),
					},
				}),
			})
			defineType('ArrowFunctionExpression', {
				builder: ['params', 'body', 'async'],
				visitor: [
					'typeParameters',
					'params',
					'predicate',
					'returnType',
					'body',
				],
				aliases: [
					'Scopable',
					'Function',
					'BlockParent',
					'FunctionParent',
					'Expression',
					'Pureish',
				],
				fields: Object.assign(
					{},
					functionCommon(),
					functionTypeAnnotationCommon(),
					{
						expression: {
							validate: (0, _utils.assertValueType)('boolean'),
						},
						body: {
							validate: (0, _utils.assertNodeType)(
								'BlockStatement',
								'Expression',
							),
						},
						predicate: {
							validate: (0, _utils.assertNodeType)(
								'DeclaredPredicate',
								'InferredPredicate',
							),
							optional: true,
						},
					},
				),
			})
			defineType('ClassBody', {
				visitor: ['body'],
				fields: {
					body: (0, _utils.validateArrayOfType)(
						'ClassMethod',
						'ClassPrivateMethod',
						'ClassProperty',
						'ClassPrivateProperty',
						'ClassAccessorProperty',
						'TSDeclareMethod',
						'TSIndexSignature',
						'StaticBlock',
					),
				},
			})
			defineType('ClassExpression', {
				builder: ['id', 'superClass', 'body', 'decorators'],
				visitor: [
					'decorators',
					'id',
					'typeParameters',
					'superClass',
					'superTypeParameters',
					'mixins',
					'implements',
					'body',
				],
				aliases: ['Scopable', 'Class', 'Expression'],
				fields: {
					id: {
						validate: (0, _utils.assertNodeType)('Identifier'),
						optional: true,
					},
					typeParameters: {
						validate: (0, _utils.assertNodeType)(
							'TypeParameterDeclaration',
							'TSTypeParameterDeclaration',
							'Noop',
						),
						optional: true,
					},
					body: {
						validate: (0, _utils.assertNodeType)('ClassBody'),
					},
					superClass: {
						optional: true,
						validate: (0, _utils.assertNodeType)('Expression'),
					},
					['superTypeParameters']: {
						validate: (0, _utils.assertNodeType)(
							'TypeParameterInstantiation',
							'TSTypeParameterInstantiation',
						),
						optional: true,
					},
					implements: {
						validate: (0, _utils.arrayOfType)(
							'TSExpressionWithTypeArguments',
							'ClassImplements',
						),
						optional: true,
					},
					decorators: {
						validate: (0, _utils.arrayOfType)('Decorator'),
						optional: true,
					},
					mixins: {
						validate: (0, _utils.assertNodeType)('InterfaceExtends'),
						optional: true,
					},
				},
			})
			defineType('ClassDeclaration', {
				inherits: 'ClassExpression',
				aliases: ['Scopable', 'Class', 'Statement', 'Declaration'],
				fields: {
					id: {
						validate: (0, _utils.assertNodeType)('Identifier'),
						optional: true,
					},
					typeParameters: {
						validate: (0, _utils.assertNodeType)(
							'TypeParameterDeclaration',
							'TSTypeParameterDeclaration',
							'Noop',
						),
						optional: true,
					},
					body: {
						validate: (0, _utils.assertNodeType)('ClassBody'),
					},
					superClass: {
						optional: true,
						validate: (0, _utils.assertNodeType)('Expression'),
					},
					['superTypeParameters']: {
						validate: (0, _utils.assertNodeType)(
							'TypeParameterInstantiation',
							'TSTypeParameterInstantiation',
						),
						optional: true,
					},
					implements: {
						validate: (0, _utils.arrayOfType)(
							'TSExpressionWithTypeArguments',
							'ClassImplements',
						),
						optional: true,
					},
					decorators: {
						validate: (0, _utils.arrayOfType)('Decorator'),
						optional: true,
					},
					mixins: {
						validate: (0, _utils.assertNodeType)('InterfaceExtends'),
						optional: true,
					},
					declare: {
						validate: (0, _utils.assertValueType)('boolean'),
						optional: true,
					},
					abstract: {
						validate: (0, _utils.assertValueType)('boolean'),
						optional: true,
					},
				},
				validate: !process.env.BABEL_TYPES_8_BREAKING
					? undefined
					: (function () {
							const identifier = (0, _utils.assertNodeType)('Identifier')
							return function (parent, key, node) {
								if (!(0, _is.default)('ExportDefaultDeclaration', parent)) {
									identifier(node, 'id', node.id)
								}
							}
						})(),
			})
			const importAttributes = (exports.importAttributes = {
				attributes: {
					optional: true,
					validate: (0, _utils.arrayOfType)('ImportAttribute'),
				},
				assertions: {
					deprecated: true,
					optional: true,
					validate: (0, _utils.arrayOfType)('ImportAttribute'),
				},
			})
			defineType('ExportAllDeclaration', {
				builder: ['source'],
				visitor: ['source', 'attributes', 'assertions'],
				aliases: [
					'Statement',
					'Declaration',
					'ImportOrExportDeclaration',
					'ExportDeclaration',
				],
				fields: Object.assign(
					{
						source: {
							validate: (0, _utils.assertNodeType)('StringLiteral'),
						},
						exportKind: (0, _utils.validateOptional)(
							(0, _utils.assertOneOf)('type', 'value'),
						),
					},
					importAttributes,
				),
			})
			defineType('ExportDefaultDeclaration', {
				visitor: ['declaration'],
				aliases: [
					'Statement',
					'Declaration',
					'ImportOrExportDeclaration',
					'ExportDeclaration',
				],
				fields: {
					declaration: (0, _utils.validateType)(
						'TSDeclareFunction',
						'FunctionDeclaration',
						'ClassDeclaration',
						'Expression',
					),
					exportKind: (0, _utils.validateOptional)(
						(0, _utils.assertOneOf)('value'),
					),
				},
			})
			defineType('ExportNamedDeclaration', {
				builder: ['declaration', 'specifiers', 'source'],
				visitor: process.env
					? ['declaration', 'specifiers', 'source', 'attributes']
					: ['declaration', 'specifiers', 'source', 'attributes', 'assertions'],
				aliases: [
					'Statement',
					'Declaration',
					'ImportOrExportDeclaration',
					'ExportDeclaration',
				],
				fields: Object.assign(
					{
						declaration: {
							optional: true,
							validate: process.env.BABEL_TYPES_8_BREAKING
								? (0, _utils.chain)(
										(0, _utils.assertNodeType)('Declaration'),
										Object.assign(
											function (node, key, val) {
												if (val && node.specifiers.length) {
													throw new TypeError(
														'Only declaration or specifiers is allowed on ExportNamedDeclaration',
													)
												}
												if (val && node.source) {
													throw new TypeError(
														'Cannot export a declaration from a source',
													)
												}
											},
											{
												oneOfNodeTypes: ['Declaration'],
											},
										),
									)
								: (0, _utils.assertNodeType)('Declaration'),
						},
					},
					importAttributes,
					{
						specifiers: {
							default: [],
							validate: (0, _utils.arrayOf)(
								(function () {
									const sourced = (0, _utils.assertNodeType)(
										'ExportSpecifier',
										'ExportDefaultSpecifier',
										'ExportNamespaceSpecifier',
									)
									const sourceless = (0, _utils.assertNodeType)(
										'ExportSpecifier',
									)
									if (!process.env.BABEL_TYPES_8_BREAKING) return sourced
									return Object.assign(
										function (node, key, val) {
											const validator = node.source ? sourced : sourceless
											validator(node, key, val)
										},
										{
											oneOfNodeTypes: [
												'ExportSpecifier',
												'ExportDefaultSpecifier',
												'ExportNamespaceSpecifier',
											],
										},
									)
								})(),
							),
						},
						source: {
							validate: (0, _utils.assertNodeType)('StringLiteral'),
							optional: true,
						},
						exportKind: (0, _utils.validateOptional)(
							(0, _utils.assertOneOf)('type', 'value'),
						),
					},
				),
			})
			defineType('ExportSpecifier', {
				visitor: ['local', 'exported'],
				aliases: ['ModuleSpecifier'],
				fields: {
					local: {
						validate: (0, _utils.assertNodeType)('Identifier'),
					},
					exported: {
						validate: (0, _utils.assertNodeType)('Identifier', 'StringLiteral'),
					},
					exportKind: {
						validate: (0, _utils.assertOneOf)('type', 'value'),
						optional: true,
					},
				},
			})
			defineType('ForOfStatement', {
				visitor: ['left', 'right', 'body'],
				builder: ['left', 'right', 'body', 'await'],
				aliases: [
					'Scopable',
					'Statement',
					'For',
					'BlockParent',
					'Loop',
					'ForXStatement',
				],
				fields: {
					left: {
						validate: (function () {
							if (!process.env.BABEL_TYPES_8_BREAKING) {
								return (0, _utils.assertNodeType)('VariableDeclaration', 'LVal')
							}
							const declaration = (0, _utils.assertNodeType)(
								'VariableDeclaration',
							)
							const lval = (0, _utils.assertNodeType)(
								'Identifier',
								'MemberExpression',
								'ArrayPattern',
								'ObjectPattern',
								'TSAsExpression',
								'TSSatisfiesExpression',
								'TSTypeAssertion',
								'TSNonNullExpression',
							)
							return Object.assign(
								function (node, key, val) {
									if ((0, _is.default)('VariableDeclaration', val)) {
										declaration(node, key, val)
									} else {
										lval(node, key, val)
									}
								},
								{
									oneOfNodeTypes: [
										'VariableDeclaration',
										'Identifier',
										'MemberExpression',
										'ArrayPattern',
										'ObjectPattern',
										'TSAsExpression',
										'TSSatisfiesExpression',
										'TSTypeAssertion',
										'TSNonNullExpression',
									],
								},
							)
						})(),
					},
					right: {
						validate: (0, _utils.assertNodeType)('Expression'),
					},
					body: {
						validate: (0, _utils.assertNodeType)('Statement'),
					},
					await: {
						default: false,
					},
				},
			})
			defineType('ImportDeclaration', {
				builder: ['specifiers', 'source'],
				visitor: ['specifiers', 'source', 'attributes', 'assertions'],
				aliases: ['Statement', 'Declaration', 'ImportOrExportDeclaration'],
				fields: Object.assign({}, importAttributes, {
					module: {
						optional: true,
						validate: (0, _utils.assertValueType)('boolean'),
					},
					phase: {
						default: null,
						validate: (0, _utils.assertOneOf)('source', 'defer'),
					},
					specifiers: (0, _utils.validateArrayOfType)(
						'ImportSpecifier',
						'ImportDefaultSpecifier',
						'ImportNamespaceSpecifier',
					),
					source: {
						validate: (0, _utils.assertNodeType)('StringLiteral'),
					},
					importKind: {
						validate: (0, _utils.assertOneOf)('type', 'typeof', 'value'),
						optional: true,
					},
				}),
			})
			defineType('ImportDefaultSpecifier', {
				visitor: ['local'],
				aliases: ['ModuleSpecifier'],
				fields: {
					local: {
						validate: (0, _utils.assertNodeType)('Identifier'),
					},
				},
			})
			defineType('ImportNamespaceSpecifier', {
				visitor: ['local'],
				aliases: ['ModuleSpecifier'],
				fields: {
					local: {
						validate: (0, _utils.assertNodeType)('Identifier'),
					},
				},
			})
			defineType('ImportSpecifier', {
				visitor: ['imported', 'local'],
				builder: ['local', 'imported'],
				aliases: ['ModuleSpecifier'],
				fields: {
					local: {
						validate: (0, _utils.assertNodeType)('Identifier'),
					},
					imported: {
						validate: (0, _utils.assertNodeType)('Identifier', 'StringLiteral'),
					},
					importKind: {
						validate: (0, _utils.assertOneOf)('type', 'typeof', 'value'),
						optional: true,
					},
				},
			})
			defineType('ImportExpression', {
				visitor: ['source', 'options'],
				aliases: ['Expression'],
				fields: {
					phase: {
						default: null,
						validate: (0, _utils.assertOneOf)('source', 'defer'),
					},
					source: {
						validate: (0, _utils.assertNodeType)('Expression'),
					},
					options: {
						validate: (0, _utils.assertNodeType)('Expression'),
						optional: true,
					},
				},
			})
			defineType('MetaProperty', {
				visitor: ['meta', 'property'],
				aliases: ['Expression'],
				fields: {
					meta: {
						validate: process.env.BABEL_TYPES_8_BREAKING
							? (0, _utils.chain)(
									(0, _utils.assertNodeType)('Identifier'),
									Object.assign(
										function (node, key, val) {
											let property
											switch (val.name) {
												case 'function':
													property = 'sent'
													break
												case 'new':
													property = 'target'
													break
												case 'import':
													property = 'meta'
													break
											}
											if (
												!(0, _is.default)('Identifier', node.property, {
													name: property,
												})
											) {
												throw new TypeError('Unrecognised MetaProperty')
											}
										},
										{
											oneOfNodeTypes: ['Identifier'],
										},
									),
								)
							: (0, _utils.assertNodeType)('Identifier'),
					},
					property: {
						validate: (0, _utils.assertNodeType)('Identifier'),
					},
				},
			})
			const classMethodOrPropertyCommon = () => ({
				abstract: {
					validate: (0, _utils.assertValueType)('boolean'),
					optional: true,
				},
				accessibility: {
					validate: (0, _utils.assertOneOf)('public', 'private', 'protected'),
					optional: true,
				},
				static: {
					default: false,
				},
				override: {
					default: false,
				},
				computed: {
					default: false,
				},
				optional: {
					validate: (0, _utils.assertValueType)('boolean'),
					optional: true,
				},
				key: {
					validate: (0, _utils.chain)(
						(function () {
							const normal = (0, _utils.assertNodeType)(
								'Identifier',
								'StringLiteral',
								'NumericLiteral',
								'BigIntLiteral',
							)
							const computed = (0, _utils.assertNodeType)('Expression')
							return function (node, key, val) {
								const validator = node.computed ? computed : normal
								validator(node, key, val)
							}
						})(),
						(0, _utils.assertNodeType)(
							'Identifier',
							'StringLiteral',
							'NumericLiteral',
							'BigIntLiteral',
							'Expression',
						),
					),
				},
			})
			exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon
			const classMethodOrDeclareMethodCommon = () =>
				Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
					params: (0, _utils.validateArrayOfType)(
						'Identifier',
						'Pattern',
						'RestElement',
						'TSParameterProperty',
					),
					kind: {
						validate: (0, _utils.assertOneOf)(
							'get',
							'set',
							'method',
							'constructor',
						),
						default: 'method',
					},
					access: {
						validate: (0, _utils.chain)(
							(0, _utils.assertValueType)('string'),
							(0, _utils.assertOneOf)('public', 'private', 'protected'),
						),
						optional: true,
					},
					decorators: {
						validate: (0, _utils.arrayOfType)('Decorator'),
						optional: true,
					},
				})
			exports.classMethodOrDeclareMethodCommon =
				classMethodOrDeclareMethodCommon
			defineType('ClassMethod', {
				aliases: [
					'Function',
					'Scopable',
					'BlockParent',
					'FunctionParent',
					'Method',
				],
				builder: [
					'kind',
					'key',
					'params',
					'body',
					'computed',
					'static',
					'generator',
					'async',
				],
				visitor: [
					'decorators',
					'key',
					'typeParameters',
					'params',
					'returnType',
					'body',
				],
				fields: Object.assign(
					{},
					classMethodOrDeclareMethodCommon(),
					functionTypeAnnotationCommon(),
					{
						body: {
							validate: (0, _utils.assertNodeType)('BlockStatement'),
						},
					},
				),
			})
			defineType('ObjectPattern', {
				visitor: ['properties', 'typeAnnotation', 'decorators'],
				builder: ['properties'],
				aliases: ['Pattern', 'PatternLike', 'LVal'],
				fields: Object.assign({}, patternLikeCommon(), {
					properties: (0, _utils.validateArrayOfType)(
						'RestElement',
						'ObjectProperty',
					),
				}),
			})
			defineType('SpreadElement', {
				visitor: ['argument'],
				aliases: ['UnaryLike'],
				deprecatedAlias: 'SpreadProperty',
				fields: {
					argument: {
						validate: (0, _utils.assertNodeType)('Expression'),
					},
				},
			})
			defineType('Super', {
				aliases: ['Expression'],
			})
			defineType('TaggedTemplateExpression', {
				visitor: ['tag', 'typeParameters', 'quasi'],
				builder: ['tag', 'quasi'],
				aliases: ['Expression'],
				fields: {
					tag: {
						validate: (0, _utils.assertNodeType)('Expression'),
					},
					quasi: {
						validate: (0, _utils.assertNodeType)('TemplateLiteral'),
					},
					['typeParameters']: {
						validate: (0, _utils.assertNodeType)(
							'TypeParameterInstantiation',
							'TSTypeParameterInstantiation',
						),
						optional: true,
					},
				},
			})
			defineType('TemplateElement', {
				builder: ['value', 'tail'],
				fields: {
					value: {
						validate: (0, _utils.chain)(
							(0, _utils.assertShape)({
								raw: {
									validate: (0, _utils.assertValueType)('string'),
								},
								cooked: {
									validate: (0, _utils.assertValueType)('string'),
									optional: true,
								},
							}),
							function templateElementCookedValidator(node) {
								const raw = node.value.raw
								let unterminatedCalled = false
								const error = () => {
									throw new Error('Internal @babel/types error.')
								}
								const { str, firstInvalidLoc } = (0,
								_helperStringParser.readStringContents)(
									'template',
									raw,
									0,
									0,
									0,
									{
										unterminated() {
											unterminatedCalled = true
										},
										strictNumericEscape: error,
										invalidEscapeSequence: error,
										numericSeparatorInEscapeSequence: error,
										unexpectedNumericSeparator: error,
										invalidDigit: error,
										invalidCodePoint: error,
									},
								)
								if (!unterminatedCalled) throw new Error('Invalid raw')
								node.value.cooked = firstInvalidLoc ? null : str
							},
						),
					},
					tail: {
						default: false,
					},
				},
			})
			defineType('TemplateLiteral', {
				visitor: ['quasis', 'expressions'],
				aliases: ['Expression', 'Literal'],
				fields: {
					quasis: (0, _utils.validateArrayOfType)('TemplateElement'),
					expressions: {
						validate: (0, _utils.chain)(
							(0, _utils.assertValueType)('array'),
							(0, _utils.assertEach)(
								(0, _utils.assertNodeType)('Expression', 'TSType'),
							),
							function (node, key, val) {
								if (node.quasis.length !== val.length + 1) {
									throw new TypeError(
										`Number of ${node.type} quasis should be exactly one more than the number of expressions.\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`,
									)
								}
							},
						),
					},
				},
			})
			defineType('YieldExpression', {
				builder: ['argument', 'delegate'],
				visitor: ['argument'],
				aliases: ['Expression', 'Terminatorless'],
				fields: {
					delegate: {
						validate: process.env.BABEL_TYPES_8_BREAKING
							? (0, _utils.chain)(
									(0, _utils.assertValueType)('boolean'),
									Object.assign(
										function (node, key, val) {
											if (val && !node.argument) {
												throw new TypeError(
													'Property delegate of YieldExpression cannot be true if there is no argument',
												)
											}
										},
										{
											type: 'boolean',
										},
									),
								)
							: (0, _utils.assertValueType)('boolean'),
						default: false,
					},
					argument: {
						optional: true,
						validate: (0, _utils.assertNodeType)('Expression'),
					},
				},
			})
			defineType('AwaitExpression', {
				builder: ['argument'],
				visitor: ['argument'],
				aliases: ['Expression', 'Terminatorless'],
				fields: {
					argument: {
						validate: (0, _utils.assertNodeType)('Expression'),
					},
				},
			})
			defineType('Import', {
				aliases: ['Expression'],
			})
			defineType('BigIntLiteral', {
				builder: ['value'],
				fields: {
					value: {
						validate: (0, _utils.assertValueType)('string'),
					},
				},
				aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
			})
			defineType('ExportNamespaceSpecifier', {
				visitor: ['exported'],
				aliases: ['ModuleSpecifier'],
				fields: {
					exported: {
						validate: (0, _utils.assertNodeType)('Identifier'),
					},
				},
			})
			defineType('OptionalMemberExpression', {
				builder: ['object', 'property', 'computed', 'optional'],
				visitor: ['object', 'property'],
				aliases: ['Expression'],
				fields: {
					object: {
						validate: (0, _utils.assertNodeType)('Expression'),
					},
					property: {
						validate: (function () {
							const normal = (0, _utils.assertNodeType)('Identifier')
							const computed = (0, _utils.assertNodeType)('Expression')
							const validator = Object.assign(
								function (node, key, val) {
									const validator = node.computed ? computed : normal
									validator(node, key, val)
								},
								{
									oneOfNodeTypes: ['Expression', 'Identifier'],
								},
							)
							return validator
						})(),
					},
					computed: {
						default: false,
					},
					optional: {
						validate: !process.env.BABEL_TYPES_8_BREAKING
							? (0, _utils.assertValueType)('boolean')
							: (0, _utils.chain)(
									(0, _utils.assertValueType)('boolean'),
									(0, _utils.assertOptionalChainStart)(),
								),
					},
				},
			})
			defineType('OptionalCallExpression', {
				visitor: ['callee', 'arguments', 'typeParameters', 'typeArguments'],
				builder: ['callee', 'arguments', 'optional'],
				aliases: ['Expression'],
				fields: Object.assign(
					{
						callee: {
							validate: (0, _utils.assertNodeType)('Expression'),
						},
						arguments: (0, _utils.validateArrayOfType)(
							'Expression',
							'SpreadElement',
							'ArgumentPlaceholder',
						),
						optional: {
							validate: !process.env.BABEL_TYPES_8_BREAKING
								? (0, _utils.assertValueType)('boolean')
								: (0, _utils.chain)(
										(0, _utils.assertValueType)('boolean'),
										(0, _utils.assertOptionalChainStart)(),
									),
						},
						typeArguments: {
							validate: (0, _utils.assertNodeType)(
								'TypeParameterInstantiation',
							),
							optional: true,
						},
					},
					{
						typeParameters: {
							validate: (0, _utils.assertNodeType)(
								'TSTypeParameterInstantiation',
							),
							optional: true,
						},
					},
				),
			})
			defineType('ClassProperty', {
				visitor: ['decorators', 'variance', 'key', 'typeAnnotation', 'value'],
				builder: [
					'key',
					'value',
					'typeAnnotation',
					'decorators',
					'computed',
					'static',
				],
				aliases: ['Property'],
				fields: Object.assign({}, classMethodOrPropertyCommon(), {
					value: {
						validate: (0, _utils.assertNodeType)('Expression'),
						optional: true,
					},
					definite: {
						validate: (0, _utils.assertValueType)('boolean'),
						optional: true,
					},
					typeAnnotation: {
						validate: (0, _utils.assertNodeType)(
							'TypeAnnotation',
							'TSTypeAnnotation',
							'Noop',
						),
						optional: true,
					},
					decorators: {
						validate: (0, _utils.arrayOfType)('Decorator'),
						optional: true,
					},
					readonly: {
						validate: (0, _utils.assertValueType)('boolean'),
						optional: true,
					},
					declare: {
						validate: (0, _utils.assertValueType)('boolean'),
						optional: true,
					},
					variance: {
						validate: (0, _utils.assertNodeType)('Variance'),
						optional: true,
					},
				}),
			})
			defineType('ClassAccessorProperty', {
				visitor: ['decorators', 'key', 'typeAnnotation', 'value'],
				builder: [
					'key',
					'value',
					'typeAnnotation',
					'decorators',
					'computed',
					'static',
				],
				aliases: ['Property', 'Accessor'],
				fields: Object.assign({}, classMethodOrPropertyCommon(), {
					key: {
						validate: (0, _utils.chain)(
							(function () {
								const normal = (0, _utils.assertNodeType)(
									'Identifier',
									'StringLiteral',
									'NumericLiteral',
									'BigIntLiteral',
									'PrivateName',
								)
								const computed = (0, _utils.assertNodeType)('Expression')
								return function (node, key, val) {
									const validator = node.computed ? computed : normal
									validator(node, key, val)
								}
							})(),
							(0, _utils.assertNodeType)(
								'Identifier',
								'StringLiteral',
								'NumericLiteral',
								'BigIntLiteral',
								'Expression',
								'PrivateName',
							),
						),
					},
					value: {
						validate: (0, _utils.assertNodeType)('Expression'),
						optional: true,
					},
					definite: {
						validate: (0, _utils.assertValueType)('boolean'),
						optional: true,
					},
					typeAnnotation: {
						validate: (0, _utils.assertNodeType)(
							'TypeAnnotation',
							'TSTypeAnnotation',
							'Noop',
						),
						optional: true,
					},
					decorators: {
						validate: (0, _utils.arrayOfType)('Decorator'),
						optional: true,
					},
					readonly: {
						validate: (0, _utils.assertValueType)('boolean'),
						optional: true,
					},
					declare: {
						validate: (0, _utils.assertValueType)('boolean'),
						optional: true,
					},
					variance: {
						validate: (0, _utils.assertNodeType)('Variance'),
						optional: true,
					},
				}),
			})
			defineType('ClassPrivateProperty', {
				visitor: ['decorators', 'variance', 'key', 'typeAnnotation', 'value'],
				builder: ['key', 'value', 'decorators', 'static'],
				aliases: ['Property', 'Private'],
				fields: {
					key: {
						validate: (0, _utils.assertNodeType)('PrivateName'),
					},
					value: {
						validate: (0, _utils.assertNodeType)('Expression'),
						optional: true,
					},
					typeAnnotation: {
						validate: (0, _utils.assertNodeType)(
							'TypeAnnotation',
							'TSTypeAnnotation',
							'Noop',
						),
						optional: true,
					},
					decorators: {
						validate: (0, _utils.arrayOfType)('Decorator'),
						optional: true,
					},
					static: {
						validate: (0, _utils.assertValueType)('boolean'),
						default: false,
					},
					readonly: {
						validate: (0, _utils.assertValueType)('boolean'),
						optional: true,
					},
					optional: {
						validate: (0, _utils.assertValueType)('boolean'),
						optional: true,
					},
					definite: {
						validate: (0, _utils.assertValueType)('boolean'),
						optional: true,
					},
					variance: {
						validate: (0, _utils.assertNodeType)('Variance'),
						optional: true,
					},
				},
			})
			defineType('ClassPrivateMethod', {
				builder: ['kind', 'key', 'params', 'body', 'static'],
				visitor: [
					'decorators',
					'key',
					'typeParameters',
					'params',
					'returnType',
					'body',
				],
				aliases: [
					'Function',
					'Scopable',
					'BlockParent',
					'FunctionParent',
					'Method',
					'Private',
				],
				fields: Object.assign(
					{},
					classMethodOrDeclareMethodCommon(),
					functionTypeAnnotationCommon(),
					{
						kind: {
							validate: (0, _utils.assertOneOf)('get', 'set', 'method'),
							default: 'method',
						},
						key: {
							validate: (0, _utils.assertNodeType)('PrivateName'),
						},
						body: {
							validate: (0, _utils.assertNodeType)('BlockStatement'),
						},
					},
				),
			})
			defineType('PrivateName', {
				visitor: ['id'],
				aliases: ['Private'],
				fields: {
					id: {
						validate: (0, _utils.assertNodeType)('Identifier'),
					},
				},
			})
			defineType('StaticBlock', {
				visitor: ['body'],
				fields: {
					body: (0, _utils.validateArrayOfType)('Statement'),
				},
				aliases: ['Scopable', 'BlockParent', 'FunctionParent'],
			})
			defineType('ImportAttribute', {
				visitor: ['key', 'value'],
				fields: {
					key: {
						validate: (0, _utils.assertNodeType)('Identifier', 'StringLiteral'),
					},
					value: {
						validate: (0, _utils.assertNodeType)('StringLiteral'),
					},
				},
			})

			//# sourceMappingURL=core.js.map

			/***/
		},

		/***/ 44856: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.DEPRECATED_ALIASES = void 0
			const DEPRECATED_ALIASES = (exports.DEPRECATED_ALIASES = {
				ModuleDeclaration: 'ImportOrExportDeclaration',
			})

			//# sourceMappingURL=deprecated-aliases.js.map

			/***/
		},

		/***/ 78794: /***/ (
			__unused_webpack_module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var _utils = __nccwpck_require__(34559)
			;(0, _utils.default)('ArgumentPlaceholder', {})
			;(0, _utils.default)('BindExpression', {
				visitor: ['object', 'callee'],
				aliases: ['Expression'],
				fields: !process.env.BABEL_TYPES_8_BREAKING
					? {
							object: {
								validate: Object.assign(() => {}, {
									oneOfNodeTypes: ['Expression'],
								}),
							},
							callee: {
								validate: Object.assign(() => {}, {
									oneOfNodeTypes: ['Expression'],
								}),
							},
						}
					: {
							object: {
								validate: (0, _utils.assertNodeType)('Expression'),
							},
							callee: {
								validate: (0, _utils.assertNodeType)('Expression'),
							},
						},
			})
			;(0, _utils.default)('Decorator', {
				visitor: ['expression'],
				fields: {
					expression: {
						validate: (0, _utils.assertNodeType)('Expression'),
					},
				},
			})
			;(0, _utils.default)('DoExpression', {
				visitor: ['body'],
				builder: ['body', 'async'],
				aliases: ['Expression'],
				fields: {
					body: {
						validate: (0, _utils.assertNodeType)('BlockStatement'),
					},
					async: {
						validate: (0, _utils.assertValueType)('boolean'),
						default: false,
					},
				},
			})
			;(0, _utils.default)('ExportDefaultSpecifier', {
				visitor: ['exported'],
				aliases: ['ModuleSpecifier'],
				fields: {
					exported: {
						validate: (0, _utils.assertNodeType)('Identifier'),
					},
				},
			})
			;(0, _utils.default)('RecordExpression', {
				visitor: ['properties'],
				aliases: ['Expression'],
				fields: {
					properties: (0, _utils.validateArrayOfType)(
						'ObjectProperty',
						'SpreadElement',
					),
				},
			})
			;(0, _utils.default)('TupleExpression', {
				fields: {
					elements: {
						validate: (0, _utils.arrayOfType)('Expression', 'SpreadElement'),
						default: [],
					},
				},
				visitor: ['elements'],
				aliases: ['Expression'],
			})
			{
				;(0, _utils.default)('DecimalLiteral', {
					builder: ['value'],
					fields: {
						value: {
							validate: (0, _utils.assertValueType)('string'),
						},
					},
					aliases: ['Expression', 'Pureish', 'Literal', 'Immutable'],
				})
			}
			;(0, _utils.default)('ModuleExpression', {
				visitor: ['body'],
				fields: {
					body: {
						validate: (0, _utils.assertNodeType)('Program'),
					},
				},
				aliases: ['Expression'],
			})
			;(0, _utils.default)('TopicReference', {
				aliases: ['Expression'],
			})
			;(0, _utils.default)('PipelineTopicExpression', {
				builder: ['expression'],
				visitor: ['expression'],
				fields: {
					expression: {
						validate: (0, _utils.assertNodeType)('Expression'),
					},
				},
				aliases: ['Expression'],
			})
			;(0, _utils.default)('PipelineBareFunction', {
				builder: ['callee'],
				visitor: ['callee'],
				fields: {
					callee: {
						validate: (0, _utils.assertNodeType)('Expression'),
					},
				},
				aliases: ['Expression'],
			})
			;(0, _utils.default)('PipelinePrimaryTopicReference', {
				aliases: ['Expression'],
			})

			//# sourceMappingURL=experimental.js.map

			/***/
		},

		/***/ 67256: /***/ (
			__unused_webpack_module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var _core = __nccwpck_require__(62803)
			var _utils = __nccwpck_require__(34559)
			const defineType = (0, _utils.defineAliasedType)('Flow')
			const defineInterfaceishType = (name) => {
				const isDeclareClass = name === 'DeclareClass'
				defineType(name, {
					builder: ['id', 'typeParameters', 'extends', 'body'],
					visitor: [
						'id',
						'typeParameters',
						'extends',
						...(isDeclareClass ? ['mixins', 'implements'] : []),
						'body',
					],
					aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
					fields: Object.assign(
						{
							id: (0, _utils.validateType)('Identifier'),
							typeParameters: (0, _utils.validateOptionalType)(
								'TypeParameterDeclaration',
							),
							extends: (0, _utils.validateOptional)(
								(0, _utils.arrayOfType)('InterfaceExtends'),
							),
						},
						isDeclareClass
							? {
									mixins: (0, _utils.validateOptional)(
										(0, _utils.arrayOfType)('InterfaceExtends'),
									),
									implements: (0, _utils.validateOptional)(
										(0, _utils.arrayOfType)('ClassImplements'),
									),
								}
							: {},
						{
							body: (0, _utils.validateType)('ObjectTypeAnnotation'),
						},
					),
				})
			}
			defineType('AnyTypeAnnotation', {
				aliases: ['FlowType', 'FlowBaseAnnotation'],
			})
			defineType('ArrayTypeAnnotation', {
				visitor: ['elementType'],
				aliases: ['FlowType'],
				fields: {
					elementType: (0, _utils.validateType)('FlowType'),
				},
			})
			defineType('BooleanTypeAnnotation', {
				aliases: ['FlowType', 'FlowBaseAnnotation'],
			})
			defineType('BooleanLiteralTypeAnnotation', {
				builder: ['value'],
				aliases: ['FlowType'],
				fields: {
					value: (0, _utils.validate)((0, _utils.assertValueType)('boolean')),
				},
			})
			defineType('NullLiteralTypeAnnotation', {
				aliases: ['FlowType', 'FlowBaseAnnotation'],
			})
			defineType('ClassImplements', {
				visitor: ['id', 'typeParameters'],
				fields: {
					id: (0, _utils.validateType)('Identifier'),
					typeParameters: (0, _utils.validateOptionalType)(
						'TypeParameterInstantiation',
					),
				},
			})
			defineInterfaceishType('DeclareClass')
			defineType('DeclareFunction', {
				builder: ['id'],
				visitor: ['id', 'predicate'],
				aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
				fields: {
					id: (0, _utils.validateType)('Identifier'),
					predicate: (0, _utils.validateOptionalType)('DeclaredPredicate'),
				},
			})
			defineInterfaceishType('DeclareInterface')
			defineType('DeclareModule', {
				builder: ['id', 'body', 'kind'],
				visitor: ['id', 'body'],
				aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
				fields: {
					id: (0, _utils.validateType)('Identifier', 'StringLiteral'),
					body: (0, _utils.validateType)('BlockStatement'),
					kind: (0, _utils.validateOptional)(
						(0, _utils.assertOneOf)('CommonJS', 'ES'),
					),
				},
			})
			defineType('DeclareModuleExports', {
				visitor: ['typeAnnotation'],
				aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
				fields: {
					typeAnnotation: (0, _utils.validateType)('TypeAnnotation'),
				},
			})
			defineType('DeclareTypeAlias', {
				visitor: ['id', 'typeParameters', 'right'],
				aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
				fields: {
					id: (0, _utils.validateType)('Identifier'),
					typeParameters: (0, _utils.validateOptionalType)(
						'TypeParameterDeclaration',
					),
					right: (0, _utils.validateType)('FlowType'),
				},
			})
			defineType('DeclareOpaqueType', {
				visitor: ['id', 'typeParameters', 'supertype'],
				aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
				fields: {
					id: (0, _utils.validateType)('Identifier'),
					typeParameters: (0, _utils.validateOptionalType)(
						'TypeParameterDeclaration',
					),
					supertype: (0, _utils.validateOptionalType)('FlowType'),
					impltype: (0, _utils.validateOptionalType)('FlowType'),
				},
			})
			defineType('DeclareVariable', {
				visitor: ['id'],
				aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
				fields: {
					id: (0, _utils.validateType)('Identifier'),
				},
			})
			defineType('DeclareExportDeclaration', {
				visitor: ['declaration', 'specifiers', 'source', 'attributes'],
				aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
				fields: Object.assign(
					{
						declaration: (0, _utils.validateOptionalType)('Flow'),
						specifiers: (0, _utils.validateOptional)(
							(0, _utils.arrayOfType)(
								'ExportSpecifier',
								'ExportNamespaceSpecifier',
							),
						),
						source: (0, _utils.validateOptionalType)('StringLiteral'),
						default: (0, _utils.validateOptional)(
							(0, _utils.assertValueType)('boolean'),
						),
					},
					_core.importAttributes,
				),
			})
			defineType('DeclareExportAllDeclaration', {
				visitor: ['source', 'attributes'],
				aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
				fields: Object.assign(
					{
						source: (0, _utils.validateType)('StringLiteral'),
						exportKind: (0, _utils.validateOptional)(
							(0, _utils.assertOneOf)('type', 'value'),
						),
					},
					_core.importAttributes,
				),
			})
			defineType('DeclaredPredicate', {
				visitor: ['value'],
				aliases: ['FlowPredicate'],
				fields: {
					value: (0, _utils.validateType)('Flow'),
				},
			})
			defineType('ExistsTypeAnnotation', {
				aliases: ['FlowType'],
			})
			defineType('FunctionTypeAnnotation', {
				builder: ['typeParameters', 'params', 'rest', 'returnType'],
				visitor: ['typeParameters', 'this', 'params', 'rest', 'returnType'],
				aliases: ['FlowType'],
				fields: {
					typeParameters: (0, _utils.validateOptionalType)(
						'TypeParameterDeclaration',
					),
					params: (0, _utils.validateArrayOfType)('FunctionTypeParam'),
					rest: (0, _utils.validateOptionalType)('FunctionTypeParam'),
					this: (0, _utils.validateOptionalType)('FunctionTypeParam'),
					returnType: (0, _utils.validateType)('FlowType'),
				},
			})
			defineType('FunctionTypeParam', {
				visitor: ['name', 'typeAnnotation'],
				fields: {
					name: (0, _utils.validateOptionalType)('Identifier'),
					typeAnnotation: (0, _utils.validateType)('FlowType'),
					optional: (0, _utils.validateOptional)(
						(0, _utils.assertValueType)('boolean'),
					),
				},
			})
			defineType('GenericTypeAnnotation', {
				visitor: ['id', 'typeParameters'],
				aliases: ['FlowType'],
				fields: {
					id: (0, _utils.validateType)('Identifier', 'QualifiedTypeIdentifier'),
					typeParameters: (0, _utils.validateOptionalType)(
						'TypeParameterInstantiation',
					),
				},
			})
			defineType('InferredPredicate', {
				aliases: ['FlowPredicate'],
			})
			defineType('InterfaceExtends', {
				visitor: ['id', 'typeParameters'],
				fields: {
					id: (0, _utils.validateType)('Identifier', 'QualifiedTypeIdentifier'),
					typeParameters: (0, _utils.validateOptionalType)(
						'TypeParameterInstantiation',
					),
				},
			})
			defineInterfaceishType('InterfaceDeclaration')
			defineType('InterfaceTypeAnnotation', {
				visitor: ['extends', 'body'],
				aliases: ['FlowType'],
				fields: {
					extends: (0, _utils.validateOptional)(
						(0, _utils.arrayOfType)('InterfaceExtends'),
					),
					body: (0, _utils.validateType)('ObjectTypeAnnotation'),
				},
			})
			defineType('IntersectionTypeAnnotation', {
				visitor: ['types'],
				aliases: ['FlowType'],
				fields: {
					types: (0, _utils.validate)((0, _utils.arrayOfType)('FlowType')),
				},
			})
			defineType('MixedTypeAnnotation', {
				aliases: ['FlowType', 'FlowBaseAnnotation'],
			})
			defineType('EmptyTypeAnnotation', {
				aliases: ['FlowType', 'FlowBaseAnnotation'],
			})
			defineType('NullableTypeAnnotation', {
				visitor: ['typeAnnotation'],
				aliases: ['FlowType'],
				fields: {
					typeAnnotation: (0, _utils.validateType)('FlowType'),
				},
			})
			defineType('NumberLiteralTypeAnnotation', {
				builder: ['value'],
				aliases: ['FlowType'],
				fields: {
					value: (0, _utils.validate)((0, _utils.assertValueType)('number')),
				},
			})
			defineType('NumberTypeAnnotation', {
				aliases: ['FlowType', 'FlowBaseAnnotation'],
			})
			defineType('ObjectTypeAnnotation', {
				visitor: ['properties', 'indexers', 'callProperties', 'internalSlots'],
				aliases: ['FlowType'],
				builder: [
					'properties',
					'indexers',
					'callProperties',
					'internalSlots',
					'exact',
				],
				fields: {
					properties: (0, _utils.validate)(
						(0, _utils.arrayOfType)(
							'ObjectTypeProperty',
							'ObjectTypeSpreadProperty',
						),
					),
					indexers: {
						validate: (0, _utils.arrayOfType)('ObjectTypeIndexer'),
						optional: true,
						default: [],
					},
					callProperties: {
						validate: (0, _utils.arrayOfType)('ObjectTypeCallProperty'),
						optional: true,
						default: [],
					},
					internalSlots: {
						validate: (0, _utils.arrayOfType)('ObjectTypeInternalSlot'),
						optional: true,
						default: [],
					},
					exact: {
						validate: (0, _utils.assertValueType)('boolean'),
						default: false,
					},
					inexact: (0, _utils.validateOptional)(
						(0, _utils.assertValueType)('boolean'),
					),
				},
			})
			defineType('ObjectTypeInternalSlot', {
				visitor: ['id', 'value'],
				builder: ['id', 'value', 'optional', 'static', 'method'],
				aliases: ['UserWhitespacable'],
				fields: {
					id: (0, _utils.validateType)('Identifier'),
					value: (0, _utils.validateType)('FlowType'),
					optional: (0, _utils.validate)(
						(0, _utils.assertValueType)('boolean'),
					),
					static: (0, _utils.validate)((0, _utils.assertValueType)('boolean')),
					method: (0, _utils.validate)((0, _utils.assertValueType)('boolean')),
				},
			})
			defineType('ObjectTypeCallProperty', {
				visitor: ['value'],
				aliases: ['UserWhitespacable'],
				fields: {
					value: (0, _utils.validateType)('FlowType'),
					static: (0, _utils.validate)((0, _utils.assertValueType)('boolean')),
				},
			})
			defineType('ObjectTypeIndexer', {
				visitor: ['variance', 'id', 'key', 'value'],
				builder: ['id', 'key', 'value', 'variance'],
				aliases: ['UserWhitespacable'],
				fields: {
					id: (0, _utils.validateOptionalType)('Identifier'),
					key: (0, _utils.validateType)('FlowType'),
					value: (0, _utils.validateType)('FlowType'),
					static: (0, _utils.validate)((0, _utils.assertValueType)('boolean')),
					variance: (0, _utils.validateOptionalType)('Variance'),
				},
			})
			defineType('ObjectTypeProperty', {
				visitor: ['key', 'value', 'variance'],
				aliases: ['UserWhitespacable'],
				fields: {
					key: (0, _utils.validateType)('Identifier', 'StringLiteral'),
					value: (0, _utils.validateType)('FlowType'),
					kind: (0, _utils.validate)(
						(0, _utils.assertOneOf)('init', 'get', 'set'),
					),
					static: (0, _utils.validate)((0, _utils.assertValueType)('boolean')),
					proto: (0, _utils.validate)((0, _utils.assertValueType)('boolean')),
					optional: (0, _utils.validate)(
						(0, _utils.assertValueType)('boolean'),
					),
					variance: (0, _utils.validateOptionalType)('Variance'),
					method: (0, _utils.validate)((0, _utils.assertValueType)('boolean')),
				},
			})
			defineType('ObjectTypeSpreadProperty', {
				visitor: ['argument'],
				aliases: ['UserWhitespacable'],
				fields: {
					argument: (0, _utils.validateType)('FlowType'),
				},
			})
			defineType('OpaqueType', {
				visitor: ['id', 'typeParameters', 'supertype', 'impltype'],
				aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
				fields: {
					id: (0, _utils.validateType)('Identifier'),
					typeParameters: (0, _utils.validateOptionalType)(
						'TypeParameterDeclaration',
					),
					supertype: (0, _utils.validateOptionalType)('FlowType'),
					impltype: (0, _utils.validateType)('FlowType'),
				},
			})
			defineType('QualifiedTypeIdentifier', {
				visitor: ['qualification', 'id'],
				builder: ['id', 'qualification'],
				fields: {
					id: (0, _utils.validateType)('Identifier'),
					qualification: (0, _utils.validateType)(
						'Identifier',
						'QualifiedTypeIdentifier',
					),
				},
			})
			defineType('StringLiteralTypeAnnotation', {
				builder: ['value'],
				aliases: ['FlowType'],
				fields: {
					value: (0, _utils.validate)((0, _utils.assertValueType)('string')),
				},
			})
			defineType('StringTypeAnnotation', {
				aliases: ['FlowType', 'FlowBaseAnnotation'],
			})
			defineType('SymbolTypeAnnotation', {
				aliases: ['FlowType', 'FlowBaseAnnotation'],
			})
			defineType('ThisTypeAnnotation', {
				aliases: ['FlowType', 'FlowBaseAnnotation'],
			})
			defineType('TupleTypeAnnotation', {
				visitor: ['types'],
				aliases: ['FlowType'],
				fields: {
					types: (0, _utils.validate)((0, _utils.arrayOfType)('FlowType')),
				},
			})
			defineType('TypeofTypeAnnotation', {
				visitor: ['argument'],
				aliases: ['FlowType'],
				fields: {
					argument: (0, _utils.validateType)('FlowType'),
				},
			})
			defineType('TypeAlias', {
				visitor: ['id', 'typeParameters', 'right'],
				aliases: ['FlowDeclaration', 'Statement', 'Declaration'],
				fields: {
					id: (0, _utils.validateType)('Identifier'),
					typeParameters: (0, _utils.validateOptionalType)(
						'TypeParameterDeclaration',
					),
					right: (0, _utils.validateType)('FlowType'),
				},
			})
			defineType('TypeAnnotation', {
				visitor: ['typeAnnotation'],
				fields: {
					typeAnnotation: (0, _utils.validateType)('FlowType'),
				},
			})
			defineType('TypeCastExpression', {
				visitor: ['expression', 'typeAnnotation'],
				aliases: ['ExpressionWrapper', 'Expression'],
				fields: {
					expression: (0, _utils.validateType)('Expression'),
					typeAnnotation: (0, _utils.validateType)('TypeAnnotation'),
				},
			})
			defineType('TypeParameter', {
				visitor: ['bound', 'default', 'variance'],
				fields: {
					name: (0, _utils.validate)((0, _utils.assertValueType)('string')),
					bound: (0, _utils.validateOptionalType)('TypeAnnotation'),
					default: (0, _utils.validateOptionalType)('FlowType'),
					variance: (0, _utils.validateOptionalType)('Variance'),
				},
			})
			defineType('TypeParameterDeclaration', {
				visitor: ['params'],
				fields: {
					params: (0, _utils.validate)(
						(0, _utils.arrayOfType)('TypeParameter'),
					),
				},
			})
			defineType('TypeParameterInstantiation', {
				visitor: ['params'],
				fields: {
					params: (0, _utils.validate)((0, _utils.arrayOfType)('FlowType')),
				},
			})
			defineType('UnionTypeAnnotation', {
				visitor: ['types'],
				aliases: ['FlowType'],
				fields: {
					types: (0, _utils.validate)((0, _utils.arrayOfType)('FlowType')),
				},
			})
			defineType('Variance', {
				builder: ['kind'],
				fields: {
					kind: (0, _utils.validate)((0, _utils.assertOneOf)('minus', 'plus')),
				},
			})
			defineType('VoidTypeAnnotation', {
				aliases: ['FlowType', 'FlowBaseAnnotation'],
			})
			defineType('EnumDeclaration', {
				aliases: ['Statement', 'Declaration'],
				visitor: ['id', 'body'],
				fields: {
					id: (0, _utils.validateType)('Identifier'),
					body: (0, _utils.validateType)(
						'EnumBooleanBody',
						'EnumNumberBody',
						'EnumStringBody',
						'EnumSymbolBody',
					),
				},
			})
			defineType('EnumBooleanBody', {
				aliases: ['EnumBody'],
				visitor: ['members'],
				fields: {
					explicitType: (0, _utils.validate)(
						(0, _utils.assertValueType)('boolean'),
					),
					members: (0, _utils.validateArrayOfType)('EnumBooleanMember'),
					hasUnknownMembers: (0, _utils.validate)(
						(0, _utils.assertValueType)('boolean'),
					),
				},
			})
			defineType('EnumNumberBody', {
				aliases: ['EnumBody'],
				visitor: ['members'],
				fields: {
					explicitType: (0, _utils.validate)(
						(0, _utils.assertValueType)('boolean'),
					),
					members: (0, _utils.validateArrayOfType)('EnumNumberMember'),
					hasUnknownMembers: (0, _utils.validate)(
						(0, _utils.assertValueType)('boolean'),
					),
				},
			})
			defineType('EnumStringBody', {
				aliases: ['EnumBody'],
				visitor: ['members'],
				fields: {
					explicitType: (0, _utils.validate)(
						(0, _utils.assertValueType)('boolean'),
					),
					members: (0, _utils.validateArrayOfType)(
						'EnumStringMember',
						'EnumDefaultedMember',
					),
					hasUnknownMembers: (0, _utils.validate)(
						(0, _utils.assertValueType)('boolean'),
					),
				},
			})
			defineType('EnumSymbolBody', {
				aliases: ['EnumBody'],
				visitor: ['members'],
				fields: {
					members: (0, _utils.validateArrayOfType)('EnumDefaultedMember'),
					hasUnknownMembers: (0, _utils.validate)(
						(0, _utils.assertValueType)('boolean'),
					),
				},
			})
			defineType('EnumBooleanMember', {
				aliases: ['EnumMember'],
				builder: ['id'],
				visitor: ['id', 'init'],
				fields: {
					id: (0, _utils.validateType)('Identifier'),
					init: (0, _utils.validateType)('BooleanLiteral'),
				},
			})
			defineType('EnumNumberMember', {
				aliases: ['EnumMember'],
				visitor: ['id', 'init'],
				fields: {
					id: (0, _utils.validateType)('Identifier'),
					init: (0, _utils.validateType)('NumericLiteral'),
				},
			})
			defineType('EnumStringMember', {
				aliases: ['EnumMember'],
				visitor: ['id', 'init'],
				fields: {
					id: (0, _utils.validateType)('Identifier'),
					init: (0, _utils.validateType)('StringLiteral'),
				},
			})
			defineType('EnumDefaultedMember', {
				aliases: ['EnumMember'],
				visitor: ['id'],
				fields: {
					id: (0, _utils.validateType)('Identifier'),
				},
			})
			defineType('IndexedAccessType', {
				visitor: ['objectType', 'indexType'],
				aliases: ['FlowType'],
				fields: {
					objectType: (0, _utils.validateType)('FlowType'),
					indexType: (0, _utils.validateType)('FlowType'),
				},
			})
			defineType('OptionalIndexedAccessType', {
				visitor: ['objectType', 'indexType'],
				aliases: ['FlowType'],
				fields: {
					objectType: (0, _utils.validateType)('FlowType'),
					indexType: (0, _utils.validateType)('FlowType'),
					optional: (0, _utils.validate)(
						(0, _utils.assertValueType)('boolean'),
					),
				},
			})

			//# sourceMappingURL=flow.js.map

			/***/
		},

		/***/ 40910: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			Object.defineProperty(exports, 'ALIAS_KEYS', {
				enumerable: true,
				get: function () {
					return _utils.ALIAS_KEYS
				},
			})
			Object.defineProperty(exports, 'BUILDER_KEYS', {
				enumerable: true,
				get: function () {
					return _utils.BUILDER_KEYS
				},
			})
			Object.defineProperty(exports, 'DEPRECATED_ALIASES', {
				enumerable: true,
				get: function () {
					return _deprecatedAliases.DEPRECATED_ALIASES
				},
			})
			Object.defineProperty(exports, 'DEPRECATED_KEYS', {
				enumerable: true,
				get: function () {
					return _utils.DEPRECATED_KEYS
				},
			})
			Object.defineProperty(exports, 'FLIPPED_ALIAS_KEYS', {
				enumerable: true,
				get: function () {
					return _utils.FLIPPED_ALIAS_KEYS
				},
			})
			Object.defineProperty(exports, 'NODE_FIELDS', {
				enumerable: true,
				get: function () {
					return _utils.NODE_FIELDS
				},
			})
			Object.defineProperty(exports, 'NODE_PARENT_VALIDATIONS', {
				enumerable: true,
				get: function () {
					return _utils.NODE_PARENT_VALIDATIONS
				},
			})
			Object.defineProperty(exports, 'PLACEHOLDERS', {
				enumerable: true,
				get: function () {
					return _placeholders.PLACEHOLDERS
				},
			})
			Object.defineProperty(exports, 'PLACEHOLDERS_ALIAS', {
				enumerable: true,
				get: function () {
					return _placeholders.PLACEHOLDERS_ALIAS
				},
			})
			Object.defineProperty(exports, 'PLACEHOLDERS_FLIPPED_ALIAS', {
				enumerable: true,
				get: function () {
					return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS
				},
			})
			exports.TYPES = void 0
			Object.defineProperty(exports, 'VISITOR_KEYS', {
				enumerable: true,
				get: function () {
					return _utils.VISITOR_KEYS
				},
			})
			__nccwpck_require__(62803)
			__nccwpck_require__(67256)
			__nccwpck_require__(24379)
			__nccwpck_require__(34528)
			__nccwpck_require__(78794)
			__nccwpck_require__(60463)
			var _utils = __nccwpck_require__(34559)
			var _placeholders = __nccwpck_require__(73182)
			var _deprecatedAliases = __nccwpck_require__(44856)
			Object.keys(_deprecatedAliases.DEPRECATED_ALIASES).forEach(
				(deprecatedAlias) => {
					_utils.FLIPPED_ALIAS_KEYS[deprecatedAlias] =
						_utils.FLIPPED_ALIAS_KEYS[
							_deprecatedAliases.DEPRECATED_ALIASES[deprecatedAlias]
						]
				},
			)
			for (const { types, set } of _utils.allExpandedTypes) {
				for (const type of types) {
					const aliases = _utils.FLIPPED_ALIAS_KEYS[type]
					if (aliases) {
						aliases.forEach(set.add, set)
					} else {
						set.add(type)
					}
				}
			}
			const TYPES = (exports.TYPES = [].concat(
				Object.keys(_utils.VISITOR_KEYS),
				Object.keys(_utils.FLIPPED_ALIAS_KEYS),
				Object.keys(_utils.DEPRECATED_KEYS),
			))

			//# sourceMappingURL=index.js.map

			/***/
		},

		/***/ 24379: /***/ (
			__unused_webpack_module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var _utils = __nccwpck_require__(34559)
			const defineType = (0, _utils.defineAliasedType)('JSX')
			defineType('JSXAttribute', {
				visitor: ['name', 'value'],
				aliases: ['Immutable'],
				fields: {
					name: {
						validate: (0, _utils.assertNodeType)(
							'JSXIdentifier',
							'JSXNamespacedName',
						),
					},
					value: {
						optional: true,
						validate: (0, _utils.assertNodeType)(
							'JSXElement',
							'JSXFragment',
							'StringLiteral',
							'JSXExpressionContainer',
						),
					},
				},
			})
			defineType('JSXClosingElement', {
				visitor: ['name'],
				aliases: ['Immutable'],
				fields: {
					name: {
						validate: (0, _utils.assertNodeType)(
							'JSXIdentifier',
							'JSXMemberExpression',
							'JSXNamespacedName',
						),
					},
				},
			})
			defineType('JSXElement', {
				builder: [
					'openingElement',
					'closingElement',
					'children',
					'selfClosing',
				],
				visitor: ['openingElement', 'children', 'closingElement'],
				aliases: ['Immutable', 'Expression'],
				fields: Object.assign(
					{
						openingElement: {
							validate: (0, _utils.assertNodeType)('JSXOpeningElement'),
						},
						closingElement: {
							optional: true,
							validate: (0, _utils.assertNodeType)('JSXClosingElement'),
						},
						children: (0, _utils.validateArrayOfType)(
							'JSXText',
							'JSXExpressionContainer',
							'JSXSpreadChild',
							'JSXElement',
							'JSXFragment',
						),
					},
					{
						selfClosing: {
							validate: (0, _utils.assertValueType)('boolean'),
							optional: true,
						},
					},
				),
			})
			defineType('JSXEmptyExpression', {})
			defineType('JSXExpressionContainer', {
				visitor: ['expression'],
				aliases: ['Immutable'],
				fields: {
					expression: {
						validate: (0, _utils.assertNodeType)(
							'Expression',
							'JSXEmptyExpression',
						),
					},
				},
			})
			defineType('JSXSpreadChild', {
				visitor: ['expression'],
				aliases: ['Immutable'],
				fields: {
					expression: {
						validate: (0, _utils.assertNodeType)('Expression'),
					},
				},
			})
			defineType('JSXIdentifier', {
				builder: ['name'],
				fields: {
					name: {
						validate: (0, _utils.assertValueType)('string'),
					},
				},
			})
			defineType('JSXMemberExpression', {
				visitor: ['object', 'property'],
				fields: {
					object: {
						validate: (0, _utils.assertNodeType)(
							'JSXMemberExpression',
							'JSXIdentifier',
						),
					},
					property: {
						validate: (0, _utils.assertNodeType)('JSXIdentifier'),
					},
				},
			})
			defineType('JSXNamespacedName', {
				visitor: ['namespace', 'name'],
				fields: {
					namespace: {
						validate: (0, _utils.assertNodeType)('JSXIdentifier'),
					},
					name: {
						validate: (0, _utils.assertNodeType)('JSXIdentifier'),
					},
				},
			})
			defineType('JSXOpeningElement', {
				builder: ['name', 'attributes', 'selfClosing'],
				visitor: ['name', 'typeParameters', 'typeArguments', 'attributes'],
				aliases: ['Immutable'],
				fields: Object.assign(
					{
						name: {
							validate: (0, _utils.assertNodeType)(
								'JSXIdentifier',
								'JSXMemberExpression',
								'JSXNamespacedName',
							),
						},
						selfClosing: {
							default: false,
						},
						attributes: (0, _utils.validateArrayOfType)(
							'JSXAttribute',
							'JSXSpreadAttribute',
						),
						typeArguments: {
							validate: (0, _utils.assertNodeType)(
								'TypeParameterInstantiation',
							),
							optional: true,
						},
					},
					{
						typeParameters: {
							validate: (0, _utils.assertNodeType)(
								'TSTypeParameterInstantiation',
							),
							optional: true,
						},
					},
				),
			})
			defineType('JSXSpreadAttribute', {
				visitor: ['argument'],
				fields: {
					argument: {
						validate: (0, _utils.assertNodeType)('Expression'),
					},
				},
			})
			defineType('JSXText', {
				aliases: ['Immutable'],
				builder: ['value'],
				fields: {
					value: {
						validate: (0, _utils.assertValueType)('string'),
					},
				},
			})
			defineType('JSXFragment', {
				builder: ['openingFragment', 'closingFragment', 'children'],
				visitor: ['openingFragment', 'children', 'closingFragment'],
				aliases: ['Immutable', 'Expression'],
				fields: {
					openingFragment: {
						validate: (0, _utils.assertNodeType)('JSXOpeningFragment'),
					},
					closingFragment: {
						validate: (0, _utils.assertNodeType)('JSXClosingFragment'),
					},
					children: (0, _utils.validateArrayOfType)(
						'JSXText',
						'JSXExpressionContainer',
						'JSXSpreadChild',
						'JSXElement',
						'JSXFragment',
					),
				},
			})
			defineType('JSXOpeningFragment', {
				aliases: ['Immutable'],
			})
			defineType('JSXClosingFragment', {
				aliases: ['Immutable'],
			})

			//# sourceMappingURL=jsx.js.map

			/***/
		},

		/***/ 34528: /***/ (
			__unused_webpack_module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var _utils = __nccwpck_require__(34559)
			var _placeholders = __nccwpck_require__(73182)
			var _core = __nccwpck_require__(62803)
			const defineType = (0, _utils.defineAliasedType)('Miscellaneous')
			{
				defineType('Noop', {
					visitor: [],
				})
			}
			defineType('Placeholder', {
				visitor: [],
				builder: ['expectedNode', 'name'],
				fields: Object.assign(
					{
						name: {
							validate: (0, _utils.assertNodeType)('Identifier'),
						},
						expectedNode: {
							validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS),
						},
					},
					(0, _core.patternLikeCommon)(),
				),
			})
			defineType('V8IntrinsicIdentifier', {
				builder: ['name'],
				fields: {
					name: {
						validate: (0, _utils.assertValueType)('string'),
					},
				},
			})

			//# sourceMappingURL=misc.js.map

			/***/
		},

		/***/ 73182: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.PLACEHOLDERS_FLIPPED_ALIAS =
				exports.PLACEHOLDERS_ALIAS =
				exports.PLACEHOLDERS =
					void 0
			var _utils = __nccwpck_require__(34559)
			const PLACEHOLDERS = (exports.PLACEHOLDERS = [
				'Identifier',
				'StringLiteral',
				'Expression',
				'Statement',
				'Declaration',
				'BlockStatement',
				'ClassBody',
				'Pattern',
			])
			const PLACEHOLDERS_ALIAS = (exports.PLACEHOLDERS_ALIAS = {
				Declaration: ['Statement'],
				Pattern: ['PatternLike', 'LVal'],
			})
			for (const type of PLACEHOLDERS) {
				const alias = _utils.ALIAS_KEYS[type]
				if (alias != null && alias.length) PLACEHOLDERS_ALIAS[type] = alias
			}
			const PLACEHOLDERS_FLIPPED_ALIAS = (exports.PLACEHOLDERS_FLIPPED_ALIAS =
				{})
			Object.keys(PLACEHOLDERS_ALIAS).forEach((type) => {
				PLACEHOLDERS_ALIAS[type].forEach((alias) => {
					if (!hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
						PLACEHOLDERS_FLIPPED_ALIAS[alias] = []
					}
					PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type)
				})
			})

			//# sourceMappingURL=placeholders.js.map

			/***/
		},

		/***/ 60463: /***/ (
			__unused_webpack_module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			var _utils = __nccwpck_require__(34559)
			var _core = __nccwpck_require__(62803)
			var _is = __nccwpck_require__(20051)
			const defineType = (0, _utils.defineAliasedType)('TypeScript')
			const bool = (0, _utils.assertValueType)('boolean')
			const tSFunctionTypeAnnotationCommon = () => ({
				returnType: {
					validate: (0, _utils.assertNodeType)('TSTypeAnnotation', 'Noop'),
					optional: true,
				},
				typeParameters: {
					validate: (0, _utils.assertNodeType)(
						'TSTypeParameterDeclaration',
						'Noop',
					),
					optional: true,
				},
			})
			defineType('TSParameterProperty', {
				aliases: ['LVal'],
				visitor: ['parameter'],
				fields: {
					accessibility: {
						validate: (0, _utils.assertOneOf)('public', 'private', 'protected'),
						optional: true,
					},
					readonly: {
						validate: (0, _utils.assertValueType)('boolean'),
						optional: true,
					},
					parameter: {
						validate: (0, _utils.assertNodeType)(
							'Identifier',
							'AssignmentPattern',
						),
					},
					override: {
						validate: (0, _utils.assertValueType)('boolean'),
						optional: true,
					},
					decorators: {
						validate: (0, _utils.arrayOfType)('Decorator'),
						optional: true,
					},
				},
			})
			defineType('TSDeclareFunction', {
				aliases: ['Statement', 'Declaration'],
				visitor: ['id', 'typeParameters', 'params', 'returnType'],
				fields: Object.assign(
					{},
					(0, _core.functionDeclarationCommon)(),
					tSFunctionTypeAnnotationCommon(),
				),
			})
			defineType('TSDeclareMethod', {
				visitor: [
					'decorators',
					'key',
					'typeParameters',
					'params',
					'returnType',
				],
				fields: Object.assign(
					{},
					(0, _core.classMethodOrDeclareMethodCommon)(),
					tSFunctionTypeAnnotationCommon(),
				),
			})
			defineType('TSQualifiedName', {
				aliases: ['TSEntityName'],
				visitor: ['left', 'right'],
				fields: {
					left: (0, _utils.validateType)('TSEntityName'),
					right: (0, _utils.validateType)('Identifier'),
				},
			})
			const signatureDeclarationCommon = () => ({
				typeParameters: (0, _utils.validateOptionalType)(
					'TSTypeParameterDeclaration',
				),
				['parameters']: (0, _utils.validateArrayOfType)(
					'ArrayPattern',
					'Identifier',
					'ObjectPattern',
					'RestElement',
				),
				['typeAnnotation']: (0, _utils.validateOptionalType)(
					'TSTypeAnnotation',
				),
			})
			const callConstructSignatureDeclaration = {
				aliases: ['TSTypeElement'],
				visitor: ['typeParameters', 'parameters', 'typeAnnotation'],
				fields: signatureDeclarationCommon(),
			}
			defineType(
				'TSCallSignatureDeclaration',
				callConstructSignatureDeclaration,
			)
			defineType(
				'TSConstructSignatureDeclaration',
				callConstructSignatureDeclaration,
			)
			const namedTypeElementCommon = () => ({
				key: (0, _utils.validateType)('Expression'),
				computed: {
					default: false,
				},
				optional: (0, _utils.validateOptional)(bool),
			})
			defineType('TSPropertySignature', {
				aliases: ['TSTypeElement'],
				visitor: ['key', 'typeAnnotation'],
				fields: Object.assign({}, namedTypeElementCommon(), {
					readonly: (0, _utils.validateOptional)(bool),
					typeAnnotation: (0, _utils.validateOptionalType)('TSTypeAnnotation'),
					kind: {
						optional: true,
						validate: (0, _utils.assertOneOf)('get', 'set'),
					},
				}),
			})
			defineType('TSMethodSignature', {
				aliases: ['TSTypeElement'],
				visitor: ['key', 'typeParameters', 'parameters', 'typeAnnotation'],
				fields: Object.assign(
					{},
					signatureDeclarationCommon(),
					namedTypeElementCommon(),
					{
						kind: {
							validate: (0, _utils.assertOneOf)('method', 'get', 'set'),
						},
					},
				),
			})
			defineType('TSIndexSignature', {
				aliases: ['TSTypeElement'],
				visitor: ['parameters', 'typeAnnotation'],
				fields: {
					readonly: (0, _utils.validateOptional)(bool),
					static: (0, _utils.validateOptional)(bool),
					parameters: (0, _utils.validateArrayOfType)('Identifier'),
					typeAnnotation: (0, _utils.validateOptionalType)('TSTypeAnnotation'),
				},
			})
			const tsKeywordTypes = [
				'TSAnyKeyword',
				'TSBooleanKeyword',
				'TSBigIntKeyword',
				'TSIntrinsicKeyword',
				'TSNeverKeyword',
				'TSNullKeyword',
				'TSNumberKeyword',
				'TSObjectKeyword',
				'TSStringKeyword',
				'TSSymbolKeyword',
				'TSUndefinedKeyword',
				'TSUnknownKeyword',
				'TSVoidKeyword',
			]
			for (const type of tsKeywordTypes) {
				defineType(type, {
					aliases: ['TSType', 'TSBaseType'],
					visitor: [],
					fields: {},
				})
			}
			defineType('TSThisType', {
				aliases: ['TSType', 'TSBaseType'],
				visitor: [],
				fields: {},
			})
			const fnOrCtrBase = {
				aliases: ['TSType'],
				visitor: ['typeParameters', 'parameters', 'typeAnnotation'],
			}
			defineType(
				'TSFunctionType',
				Object.assign({}, fnOrCtrBase, {
					fields: signatureDeclarationCommon(),
				}),
			)
			defineType(
				'TSConstructorType',
				Object.assign({}, fnOrCtrBase, {
					fields: Object.assign({}, signatureDeclarationCommon(), {
						abstract: (0, _utils.validateOptional)(bool),
					}),
				}),
			)
			defineType('TSTypeReference', {
				aliases: ['TSType'],
				visitor: ['typeName', 'typeParameters'],
				fields: {
					typeName: (0, _utils.validateType)('TSEntityName'),
					['typeParameters']: (0, _utils.validateOptionalType)(
						'TSTypeParameterInstantiation',
					),
				},
			})
			defineType('TSTypePredicate', {
				aliases: ['TSType'],
				visitor: ['parameterName', 'typeAnnotation'],
				builder: ['parameterName', 'typeAnnotation', 'asserts'],
				fields: {
					parameterName: (0, _utils.validateType)('Identifier', 'TSThisType'),
					typeAnnotation: (0, _utils.validateOptionalType)('TSTypeAnnotation'),
					asserts: (0, _utils.validateOptional)(bool),
				},
			})
			defineType('TSTypeQuery', {
				aliases: ['TSType'],
				visitor: ['exprName', 'typeParameters'],
				fields: {
					exprName: (0, _utils.validateType)('TSEntityName', 'TSImportType'),
					['typeParameters']: (0, _utils.validateOptionalType)(
						'TSTypeParameterInstantiation',
					),
				},
			})
			defineType('TSTypeLiteral', {
				aliases: ['TSType'],
				visitor: ['members'],
				fields: {
					members: (0, _utils.validateArrayOfType)('TSTypeElement'),
				},
			})
			defineType('TSArrayType', {
				aliases: ['TSType'],
				visitor: ['elementType'],
				fields: {
					elementType: (0, _utils.validateType)('TSType'),
				},
			})
			defineType('TSTupleType', {
				aliases: ['TSType'],
				visitor: ['elementTypes'],
				fields: {
					elementTypes: (0, _utils.validateArrayOfType)(
						'TSType',
						'TSNamedTupleMember',
					),
				},
			})
			defineType('TSOptionalType', {
				aliases: ['TSType'],
				visitor: ['typeAnnotation'],
				fields: {
					typeAnnotation: (0, _utils.validateType)('TSType'),
				},
			})
			defineType('TSRestType', {
				aliases: ['TSType'],
				visitor: ['typeAnnotation'],
				fields: {
					typeAnnotation: (0, _utils.validateType)('TSType'),
				},
			})
			defineType('TSNamedTupleMember', {
				visitor: ['label', 'elementType'],
				builder: ['label', 'elementType', 'optional'],
				fields: {
					label: (0, _utils.validateType)('Identifier'),
					optional: {
						validate: bool,
						default: false,
					},
					elementType: (0, _utils.validateType)('TSType'),
				},
			})
			const unionOrIntersection = {
				aliases: ['TSType'],
				visitor: ['types'],
				fields: {
					types: (0, _utils.validateArrayOfType)('TSType'),
				},
			}
			defineType('TSUnionType', unionOrIntersection)
			defineType('TSIntersectionType', unionOrIntersection)
			defineType('TSConditionalType', {
				aliases: ['TSType'],
				visitor: ['checkType', 'extendsType', 'trueType', 'falseType'],
				fields: {
					checkType: (0, _utils.validateType)('TSType'),
					extendsType: (0, _utils.validateType)('TSType'),
					trueType: (0, _utils.validateType)('TSType'),
					falseType: (0, _utils.validateType)('TSType'),
				},
			})
			defineType('TSInferType', {
				aliases: ['TSType'],
				visitor: ['typeParameter'],
				fields: {
					typeParameter: (0, _utils.validateType)('TSTypeParameter'),
				},
			})
			defineType('TSParenthesizedType', {
				aliases: ['TSType'],
				visitor: ['typeAnnotation'],
				fields: {
					typeAnnotation: (0, _utils.validateType)('TSType'),
				},
			})
			defineType('TSTypeOperator', {
				aliases: ['TSType'],
				visitor: ['typeAnnotation'],
				fields: {
					operator: (0, _utils.validate)((0, _utils.assertValueType)('string')),
					typeAnnotation: (0, _utils.validateType)('TSType'),
				},
			})
			defineType('TSIndexedAccessType', {
				aliases: ['TSType'],
				visitor: ['objectType', 'indexType'],
				fields: {
					objectType: (0, _utils.validateType)('TSType'),
					indexType: (0, _utils.validateType)('TSType'),
				},
			})
			defineType('TSMappedType', {
				aliases: ['TSType'],
				visitor: ['typeParameter', 'nameType', 'typeAnnotation'],
				builder: ['typeParameter', 'typeAnnotation', 'nameType'],
				fields: Object.assign(
					{},
					{
						typeParameter: (0, _utils.validateType)('TSTypeParameter'),
					},
					{
						readonly: (0, _utils.validateOptional)(
							(0, _utils.assertOneOf)(true, false, '+', '-'),
						),
						optional: (0, _utils.validateOptional)(
							(0, _utils.assertOneOf)(true, false, '+', '-'),
						),
						typeAnnotation: (0, _utils.validateOptionalType)('TSType'),
						nameType: (0, _utils.validateOptionalType)('TSType'),
					},
				),
			})
			defineType('TSTemplateLiteralType', {
				aliases: ['TSType', 'TSBaseType'],
				visitor: ['quasis', 'types'],
				fields: {
					quasis: (0, _utils.validateArrayOfType)('TemplateElement'),
					types: {
						validate: (0, _utils.chain)(
							(0, _utils.assertValueType)('array'),
							(0, _utils.assertEach)((0, _utils.assertNodeType)('TSType')),
							function (node, key, val) {
								if (node.quasis.length !== val.length + 1) {
									throw new TypeError(
										`Number of ${node.type} quasis should be exactly one more than the number of types.\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`,
									)
								}
							},
						),
					},
				},
			})
			defineType('TSLiteralType', {
				aliases: ['TSType', 'TSBaseType'],
				visitor: ['literal'],
				fields: {
					literal: {
						validate: (function () {
							const unaryExpression = (0, _utils.assertNodeType)(
								'NumericLiteral',
								'BigIntLiteral',
							)
							const unaryOperator = (0, _utils.assertOneOf)('-')
							const literal = (0, _utils.assertNodeType)(
								'NumericLiteral',
								'StringLiteral',
								'BooleanLiteral',
								'BigIntLiteral',
								'TemplateLiteral',
							)
							function validator(parent, key, node) {
								if ((0, _is.default)('UnaryExpression', node)) {
									unaryOperator(node, 'operator', node.operator)
									unaryExpression(node, 'argument', node.argument)
								} else {
									literal(parent, key, node)
								}
							}
							validator.oneOfNodeTypes = [
								'NumericLiteral',
								'StringLiteral',
								'BooleanLiteral',
								'BigIntLiteral',
								'TemplateLiteral',
								'UnaryExpression',
							]
							return validator
						})(),
					},
				},
			})
			{
				defineType('TSExpressionWithTypeArguments', {
					aliases: ['TSType'],
					visitor: ['expression', 'typeParameters'],
					fields: {
						expression: (0, _utils.validateType)('TSEntityName'),
						typeParameters: (0, _utils.validateOptionalType)(
							'TSTypeParameterInstantiation',
						),
					},
				})
			}
			defineType('TSInterfaceDeclaration', {
				aliases: ['Statement', 'Declaration'],
				visitor: ['id', 'typeParameters', 'extends', 'body'],
				fields: {
					declare: (0, _utils.validateOptional)(bool),
					id: (0, _utils.validateType)('Identifier'),
					typeParameters: (0, _utils.validateOptionalType)(
						'TSTypeParameterDeclaration',
					),
					extends: (0, _utils.validateOptional)(
						(0, _utils.arrayOfType)('TSExpressionWithTypeArguments'),
					),
					body: (0, _utils.validateType)('TSInterfaceBody'),
				},
			})
			defineType('TSInterfaceBody', {
				visitor: ['body'],
				fields: {
					body: (0, _utils.validateArrayOfType)('TSTypeElement'),
				},
			})
			defineType('TSTypeAliasDeclaration', {
				aliases: ['Statement', 'Declaration'],
				visitor: ['id', 'typeParameters', 'typeAnnotation'],
				fields: {
					declare: (0, _utils.validateOptional)(bool),
					id: (0, _utils.validateType)('Identifier'),
					typeParameters: (0, _utils.validateOptionalType)(
						'TSTypeParameterDeclaration',
					),
					typeAnnotation: (0, _utils.validateType)('TSType'),
				},
			})
			defineType('TSInstantiationExpression', {
				aliases: ['Expression'],
				visitor: ['expression', 'typeParameters'],
				fields: {
					expression: (0, _utils.validateType)('Expression'),
					['typeParameters']: (0, _utils.validateOptionalType)(
						'TSTypeParameterInstantiation',
					),
				},
			})
			const TSTypeExpression = {
				aliases: ['Expression', 'LVal', 'PatternLike'],
				visitor: ['expression', 'typeAnnotation'],
				fields: {
					expression: (0, _utils.validateType)('Expression'),
					typeAnnotation: (0, _utils.validateType)('TSType'),
				},
			}
			defineType('TSAsExpression', TSTypeExpression)
			defineType('TSSatisfiesExpression', TSTypeExpression)
			defineType('TSTypeAssertion', {
				aliases: ['Expression', 'LVal', 'PatternLike'],
				visitor: ['typeAnnotation', 'expression'],
				fields: {
					typeAnnotation: (0, _utils.validateType)('TSType'),
					expression: (0, _utils.validateType)('Expression'),
				},
			})
			defineType('TSEnumBody', {
				visitor: ['members'],
				fields: {
					members: (0, _utils.validateArrayOfType)('TSEnumMember'),
				},
			})
			{
				defineType('TSEnumDeclaration', {
					aliases: ['Statement', 'Declaration'],
					visitor: ['id', 'members'],
					fields: {
						declare: (0, _utils.validateOptional)(bool),
						const: (0, _utils.validateOptional)(bool),
						id: (0, _utils.validateType)('Identifier'),
						members: (0, _utils.validateArrayOfType)('TSEnumMember'),
						initializer: (0, _utils.validateOptionalType)('Expression'),
						body: (0, _utils.validateOptionalType)('TSEnumBody'),
					},
				})
			}
			defineType('TSEnumMember', {
				visitor: ['id', 'initializer'],
				fields: {
					id: (0, _utils.validateType)('Identifier', 'StringLiteral'),
					initializer: (0, _utils.validateOptionalType)('Expression'),
				},
			})
			defineType('TSModuleDeclaration', {
				aliases: ['Statement', 'Declaration'],
				visitor: ['id', 'body'],
				fields: Object.assign(
					{
						kind: {
							validate: (0, _utils.assertOneOf)(
								'global',
								'module',
								'namespace',
							),
						},
						declare: (0, _utils.validateOptional)(bool),
					},
					{
						global: (0, _utils.validateOptional)(bool),
					},
					{
						id: (0, _utils.validateType)('Identifier', 'StringLiteral'),
						body: (0, _utils.validateType)(
							'TSModuleBlock',
							'TSModuleDeclaration',
						),
					},
				),
			})
			defineType('TSModuleBlock', {
				aliases: ['Scopable', 'Block', 'BlockParent', 'FunctionParent'],
				visitor: ['body'],
				fields: {
					body: (0, _utils.validateArrayOfType)('Statement'),
				},
			})
			defineType('TSImportType', {
				aliases: ['TSType'],
				builder: ['argument', 'qualifier', 'typeParameters'],
				visitor: ['argument', 'options', 'qualifier', 'typeParameters'],
				fields: {
					argument: (0, _utils.validateType)('StringLiteral'),
					qualifier: (0, _utils.validateOptionalType)('TSEntityName'),
					['typeParameters']: (0, _utils.validateOptionalType)(
						'TSTypeParameterInstantiation',
					),
					options: {
						validate: (0, _utils.assertNodeType)('ObjectExpression'),
						optional: true,
					},
				},
			})
			defineType('TSImportEqualsDeclaration', {
				aliases: ['Statement', 'Declaration'],
				visitor: ['id', 'moduleReference'],
				fields: Object.assign(
					{},
					{
						isExport: (0, _utils.validate)(bool),
					},
					{
						id: (0, _utils.validateType)('Identifier'),
						moduleReference: (0, _utils.validateType)(
							'TSEntityName',
							'TSExternalModuleReference',
						),
						importKind: {
							validate: (0, _utils.assertOneOf)('type', 'value'),
							optional: true,
						},
					},
				),
			})
			defineType('TSExternalModuleReference', {
				visitor: ['expression'],
				fields: {
					expression: (0, _utils.validateType)('StringLiteral'),
				},
			})
			defineType('TSNonNullExpression', {
				aliases: ['Expression', 'LVal', 'PatternLike'],
				visitor: ['expression'],
				fields: {
					expression: (0, _utils.validateType)('Expression'),
				},
			})
			defineType('TSExportAssignment', {
				aliases: ['Statement'],
				visitor: ['expression'],
				fields: {
					expression: (0, _utils.validateType)('Expression'),
				},
			})
			defineType('TSNamespaceExportDeclaration', {
				aliases: ['Statement'],
				visitor: ['id'],
				fields: {
					id: (0, _utils.validateType)('Identifier'),
				},
			})
			defineType('TSTypeAnnotation', {
				visitor: ['typeAnnotation'],
				fields: {
					typeAnnotation: {
						validate: (0, _utils.assertNodeType)('TSType'),
					},
				},
			})
			defineType('TSTypeParameterInstantiation', {
				visitor: ['params'],
				fields: {
					params: (0, _utils.validateArrayOfType)('TSType'),
				},
			})
			defineType('TSTypeParameterDeclaration', {
				visitor: ['params'],
				fields: {
					params: (0, _utils.validateArrayOfType)('TSTypeParameter'),
				},
			})
			defineType('TSTypeParameter', {
				builder: ['constraint', 'default', 'name'],
				visitor: ['constraint', 'default'],
				fields: {
					name: {
						validate: (0, _utils.assertValueType)('string'),
					},
					in: {
						validate: (0, _utils.assertValueType)('boolean'),
						optional: true,
					},
					out: {
						validate: (0, _utils.assertValueType)('boolean'),
						optional: true,
					},
					const: {
						validate: (0, _utils.assertValueType)('boolean'),
						optional: true,
					},
					constraint: {
						validate: (0, _utils.assertNodeType)('TSType'),
						optional: true,
					},
					default: {
						validate: (0, _utils.assertNodeType)('TSType'),
						optional: true,
					},
				},
			})

			//# sourceMappingURL=typescript.js.map

			/***/
		},

		/***/ 34559: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.allExpandedTypes =
				exports.VISITOR_KEYS =
				exports.NODE_PARENT_VALIDATIONS =
				exports.NODE_FIELDS =
				exports.FLIPPED_ALIAS_KEYS =
				exports.DEPRECATED_KEYS =
				exports.BUILDER_KEYS =
				exports.ALIAS_KEYS =
					void 0
			exports.arrayOf = arrayOf
			exports.arrayOfType = arrayOfType
			exports.assertEach = assertEach
			exports.assertNodeOrValueType = assertNodeOrValueType
			exports.assertNodeType = assertNodeType
			exports.assertOneOf = assertOneOf
			exports.assertOptionalChainStart = assertOptionalChainStart
			exports.assertShape = assertShape
			exports.assertValueType = assertValueType
			exports.chain = chain
			exports['default'] = defineType
			exports.defineAliasedType = defineAliasedType
			exports.validate = validate
			exports.validateArrayOfType = validateArrayOfType
			exports.validateOptional = validateOptional
			exports.validateOptionalType = validateOptionalType
			exports.validateType = validateType
			var _is = __nccwpck_require__(20051)
			var _validate = __nccwpck_require__(71581)
			const VISITOR_KEYS = (exports.VISITOR_KEYS = {})
			const ALIAS_KEYS = (exports.ALIAS_KEYS = {})
			const FLIPPED_ALIAS_KEYS = (exports.FLIPPED_ALIAS_KEYS = {})
			const NODE_FIELDS = (exports.NODE_FIELDS = {})
			const BUILDER_KEYS = (exports.BUILDER_KEYS = {})
			const DEPRECATED_KEYS = (exports.DEPRECATED_KEYS = {})
			const NODE_PARENT_VALIDATIONS = (exports.NODE_PARENT_VALIDATIONS = {})
			function getType(val) {
				if (Array.isArray(val)) {
					return 'array'
				} else if (val === null) {
					return 'null'
				} else {
					return typeof val
				}
			}
			function validate(validate) {
				return {
					validate,
				}
			}
			function validateType(...typeNames) {
				return validate(assertNodeType(...typeNames))
			}
			function validateOptional(validate) {
				return {
					validate,
					optional: true,
				}
			}
			function validateOptionalType(...typeNames) {
				return {
					validate: assertNodeType(...typeNames),
					optional: true,
				}
			}
			function arrayOf(elementType) {
				return chain(assertValueType('array'), assertEach(elementType))
			}
			function arrayOfType(...typeNames) {
				return arrayOf(assertNodeType(...typeNames))
			}
			function validateArrayOfType(...typeNames) {
				return validate(arrayOfType(...typeNames))
			}
			function assertEach(callback) {
				const childValidator = process.env.BABEL_TYPES_8_BREAKING
					? _validate.validateChild
					: () => {}
				function validator(node, key, val) {
					if (!Array.isArray(val)) return
					let i = 0
					const subKey = {
						toString() {
							return `${key}[${i}]`
						},
					}
					for (; i < val.length; i++) {
						const v = val[i]
						callback(node, subKey, v)
						childValidator(node, subKey, v)
					}
				}
				validator.each = callback
				return validator
			}
			function assertOneOf(...values) {
				function validate(node, key, val) {
					if (!values.includes(val)) {
						throw new TypeError(
							`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`,
						)
					}
				}
				validate.oneOf = values
				return validate
			}
			const allExpandedTypes = (exports.allExpandedTypes = [])
			function assertNodeType(...types) {
				const expandedTypes = new Set()
				allExpandedTypes.push({
					types,
					set: expandedTypes,
				})
				function validate(node, key, val) {
					const valType = val == null ? void 0 : val.type
					if (valType != null) {
						if (expandedTypes.has(valType)) {
							;(0, _validate.validateChild)(node, key, val)
							return
						}
						if (valType === 'Placeholder') {
							for (const type of types) {
								if ((0, _is.default)(type, val)) {
									;(0, _validate.validateChild)(node, key, val)
									return
								}
							}
						}
					}
					throw new TypeError(
						`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(valType)}`,
					)
				}
				validate.oneOfNodeTypes = types
				return validate
			}
			function assertNodeOrValueType(...types) {
				function validate(node, key, val) {
					const primitiveType = getType(val)
					for (const type of types) {
						if (primitiveType === type || (0, _is.default)(type, val)) {
							;(0, _validate.validateChild)(node, key, val)
							return
						}
					}
					throw new TypeError(
						`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`,
					)
				}
				validate.oneOfNodeOrValueTypes = types
				return validate
			}
			function assertValueType(type) {
				function validate(node, key, val) {
					if (getType(val) === type) {
						return
					}
					throw new TypeError(
						`Property ${key} expected type of ${type} but got ${getType(val)}`,
					)
				}
				validate.type = type
				return validate
			}
			function assertShape(shape) {
				const keys = Object.keys(shape)
				function validate(node, key, val) {
					const errors = []
					for (const property of keys) {
						try {
							;(0, _validate.validateField)(
								node,
								property,
								val[property],
								shape[property],
							)
						} catch (error) {
							if (error instanceof TypeError) {
								errors.push(error.message)
								continue
							}
							throw error
						}
					}
					if (errors.length) {
						throw new TypeError(
							`Property ${key} of ${node.type} expected to have the following:\n${errors.join('\n')}`,
						)
					}
				}
				validate.shapeOf = shape
				return validate
			}
			function assertOptionalChainStart() {
				function validate(node) {
					var _current
					let current = node
					while (node) {
						const { type } = current
						if (type === 'OptionalCallExpression') {
							if (current.optional) return
							current = current.callee
							continue
						}
						if (type === 'OptionalMemberExpression') {
							if (current.optional) return
							current = current.object
							continue
						}
						break
					}
					throw new TypeError(
						`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`,
					)
				}
				return validate
			}
			function chain(...fns) {
				function validate(...args) {
					for (const fn of fns) {
						fn(...args)
					}
				}
				validate.chainOf = fns
				if (
					fns.length >= 2 &&
					'type' in fns[0] &&
					fns[0].type === 'array' &&
					!('each' in fns[1])
				) {
					throw new Error(
						`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`,
					)
				}
				return validate
			}
			const validTypeOpts = new Set([
				'aliases',
				'builder',
				'deprecatedAlias',
				'fields',
				'inherits',
				'visitor',
				'validate',
			])
			const validFieldKeys = new Set([
				'default',
				'optional',
				'deprecated',
				'validate',
			])
			const store = {}
			function defineAliasedType(...aliases) {
				return (type, opts = {}) => {
					let defined = opts.aliases
					if (!defined) {
						var _store$opts$inherits$
						if (opts.inherits)
							defined =
								(_store$opts$inherits$ = store[opts.inherits].aliases) == null
									? void 0
									: _store$opts$inherits$.slice()
						defined != null ? defined : (defined = [])
						opts.aliases = defined
					}
					const additional = aliases.filter((a) => !defined.includes(a))
					defined.unshift(...additional)
					defineType(type, opts)
				}
			}
			function defineType(type, opts = {}) {
				const inherits = (opts.inherits && store[opts.inherits]) || {}
				let fields = opts.fields
				if (!fields) {
					fields = {}
					if (inherits.fields) {
						const keys = Object.getOwnPropertyNames(inherits.fields)
						for (const key of keys) {
							const field = inherits.fields[key]
							const def = field.default
							if (
								Array.isArray(def)
									? def.length > 0
									: def && typeof def === 'object'
							) {
								throw new Error(
									'field defaults can only be primitives or empty arrays currently',
								)
							}
							fields[key] = {
								default: Array.isArray(def) ? [] : def,
								optional: field.optional,
								deprecated: field.deprecated,
								validate: field.validate,
							}
						}
					}
				}
				const visitor = opts.visitor || inherits.visitor || []
				const aliases = opts.aliases || inherits.aliases || []
				const builder = opts.builder || inherits.builder || opts.visitor || []
				for (const k of Object.keys(opts)) {
					if (!validTypeOpts.has(k)) {
						throw new Error(`Unknown type option "${k}" on ${type}`)
					}
				}
				if (opts.deprecatedAlias) {
					DEPRECATED_KEYS[opts.deprecatedAlias] = type
				}
				for (const key of visitor.concat(builder)) {
					fields[key] = fields[key] || {}
				}
				for (const key of Object.keys(fields)) {
					const field = fields[key]
					if (field.default !== undefined && !builder.includes(key)) {
						field.optional = true
					}
					if (field.default === undefined) {
						field.default = null
					} else if (!field.validate && field.default != null) {
						field.validate = assertValueType(getType(field.default))
					}
					for (const k of Object.keys(field)) {
						if (!validFieldKeys.has(k)) {
							throw new Error(`Unknown field key "${k}" on ${type}.${key}`)
						}
					}
				}
				VISITOR_KEYS[type] = opts.visitor = visitor
				BUILDER_KEYS[type] = opts.builder = builder
				NODE_FIELDS[type] = opts.fields = fields
				ALIAS_KEYS[type] = opts.aliases = aliases
				aliases.forEach((alias) => {
					FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || []
					FLIPPED_ALIAS_KEYS[alias].push(type)
				})
				if (opts.validate) {
					NODE_PARENT_VALIDATIONS[type] = opts.validate
				}
				store[type] = opts
			}

			//# sourceMappingURL=utils.js.map

			/***/
		},

		/***/ 16535: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			var _exportNames = {
				react: true,
				assertNode: true,
				createTypeAnnotationBasedOnTypeof: true,
				createUnionTypeAnnotation: true,
				createFlowUnionType: true,
				createTSUnionType: true,
				cloneNode: true,
				clone: true,
				cloneDeep: true,
				cloneDeepWithoutLoc: true,
				cloneWithoutLoc: true,
				addComment: true,
				addComments: true,
				inheritInnerComments: true,
				inheritLeadingComments: true,
				inheritsComments: true,
				inheritTrailingComments: true,
				removeComments: true,
				ensureBlock: true,
				toBindingIdentifierName: true,
				toBlock: true,
				toComputedKey: true,
				toExpression: true,
				toIdentifier: true,
				toKeyAlias: true,
				toStatement: true,
				valueToNode: true,
				appendToMemberExpression: true,
				inherits: true,
				prependToMemberExpression: true,
				removeProperties: true,
				removePropertiesDeep: true,
				removeTypeDuplicates: true,
				getAssignmentIdentifiers: true,
				getBindingIdentifiers: true,
				getOuterBindingIdentifiers: true,
				getFunctionName: true,
				traverse: true,
				traverseFast: true,
				shallowEqual: true,
				is: true,
				isBinding: true,
				isBlockScoped: true,
				isImmutable: true,
				isLet: true,
				isNode: true,
				isNodesEquivalent: true,
				isPlaceholderType: true,
				isReferenced: true,
				isScope: true,
				isSpecifierDefault: true,
				isType: true,
				isValidES3Identifier: true,
				isValidIdentifier: true,
				isVar: true,
				matchesPattern: true,
				validate: true,
				buildMatchMemberExpression: true,
				__internal__deprecationWarning: true,
			}
			Object.defineProperty(exports, '__internal__deprecationWarning', {
				enumerable: true,
				get: function () {
					return _deprecationWarning.default
				},
			})
			Object.defineProperty(exports, 'addComment', {
				enumerable: true,
				get: function () {
					return _addComment.default
				},
			})
			Object.defineProperty(exports, 'addComments', {
				enumerable: true,
				get: function () {
					return _addComments.default
				},
			})
			Object.defineProperty(exports, 'appendToMemberExpression', {
				enumerable: true,
				get: function () {
					return _appendToMemberExpression.default
				},
			})
			Object.defineProperty(exports, 'assertNode', {
				enumerable: true,
				get: function () {
					return _assertNode.default
				},
			})
			Object.defineProperty(exports, 'buildMatchMemberExpression', {
				enumerable: true,
				get: function () {
					return _buildMatchMemberExpression.default
				},
			})
			Object.defineProperty(exports, 'clone', {
				enumerable: true,
				get: function () {
					return _clone.default
				},
			})
			Object.defineProperty(exports, 'cloneDeep', {
				enumerable: true,
				get: function () {
					return _cloneDeep.default
				},
			})
			Object.defineProperty(exports, 'cloneDeepWithoutLoc', {
				enumerable: true,
				get: function () {
					return _cloneDeepWithoutLoc.default
				},
			})
			Object.defineProperty(exports, 'cloneNode', {
				enumerable: true,
				get: function () {
					return _cloneNode.default
				},
			})
			Object.defineProperty(exports, 'cloneWithoutLoc', {
				enumerable: true,
				get: function () {
					return _cloneWithoutLoc.default
				},
			})
			Object.defineProperty(exports, 'createFlowUnionType', {
				enumerable: true,
				get: function () {
					return _createFlowUnionType.default
				},
			})
			Object.defineProperty(exports, 'createTSUnionType', {
				enumerable: true,
				get: function () {
					return _createTSUnionType.default
				},
			})
			Object.defineProperty(exports, 'createTypeAnnotationBasedOnTypeof', {
				enumerable: true,
				get: function () {
					return _createTypeAnnotationBasedOnTypeof.default
				},
			})
			Object.defineProperty(exports, 'createUnionTypeAnnotation', {
				enumerable: true,
				get: function () {
					return _createFlowUnionType.default
				},
			})
			Object.defineProperty(exports, 'ensureBlock', {
				enumerable: true,
				get: function () {
					return _ensureBlock.default
				},
			})
			Object.defineProperty(exports, 'getAssignmentIdentifiers', {
				enumerable: true,
				get: function () {
					return _getAssignmentIdentifiers.default
				},
			})
			Object.defineProperty(exports, 'getBindingIdentifiers', {
				enumerable: true,
				get: function () {
					return _getBindingIdentifiers.default
				},
			})
			Object.defineProperty(exports, 'getFunctionName', {
				enumerable: true,
				get: function () {
					return _getFunctionName.default
				},
			})
			Object.defineProperty(exports, 'getOuterBindingIdentifiers', {
				enumerable: true,
				get: function () {
					return _getOuterBindingIdentifiers.default
				},
			})
			Object.defineProperty(exports, 'inheritInnerComments', {
				enumerable: true,
				get: function () {
					return _inheritInnerComments.default
				},
			})
			Object.defineProperty(exports, 'inheritLeadingComments', {
				enumerable: true,
				get: function () {
					return _inheritLeadingComments.default
				},
			})
			Object.defineProperty(exports, 'inheritTrailingComments', {
				enumerable: true,
				get: function () {
					return _inheritTrailingComments.default
				},
			})
			Object.defineProperty(exports, 'inherits', {
				enumerable: true,
				get: function () {
					return _inherits.default
				},
			})
			Object.defineProperty(exports, 'inheritsComments', {
				enumerable: true,
				get: function () {
					return _inheritsComments.default
				},
			})
			Object.defineProperty(exports, 'is', {
				enumerable: true,
				get: function () {
					return _is.default
				},
			})
			Object.defineProperty(exports, 'isBinding', {
				enumerable: true,
				get: function () {
					return _isBinding.default
				},
			})
			Object.defineProperty(exports, 'isBlockScoped', {
				enumerable: true,
				get: function () {
					return _isBlockScoped.default
				},
			})
			Object.defineProperty(exports, 'isImmutable', {
				enumerable: true,
				get: function () {
					return _isImmutable.default
				},
			})
			Object.defineProperty(exports, 'isLet', {
				enumerable: true,
				get: function () {
					return _isLet.default
				},
			})
			Object.defineProperty(exports, 'isNode', {
				enumerable: true,
				get: function () {
					return _isNode.default
				},
			})
			Object.defineProperty(exports, 'isNodesEquivalent', {
				enumerable: true,
				get: function () {
					return _isNodesEquivalent.default
				},
			})
			Object.defineProperty(exports, 'isPlaceholderType', {
				enumerable: true,
				get: function () {
					return _isPlaceholderType.default
				},
			})
			Object.defineProperty(exports, 'isReferenced', {
				enumerable: true,
				get: function () {
					return _isReferenced.default
				},
			})
			Object.defineProperty(exports, 'isScope', {
				enumerable: true,
				get: function () {
					return _isScope.default
				},
			})
			Object.defineProperty(exports, 'isSpecifierDefault', {
				enumerable: true,
				get: function () {
					return _isSpecifierDefault.default
				},
			})
			Object.defineProperty(exports, 'isType', {
				enumerable: true,
				get: function () {
					return _isType.default
				},
			})
			Object.defineProperty(exports, 'isValidES3Identifier', {
				enumerable: true,
				get: function () {
					return _isValidES3Identifier.default
				},
			})
			Object.defineProperty(exports, 'isValidIdentifier', {
				enumerable: true,
				get: function () {
					return _isValidIdentifier.default
				},
			})
			Object.defineProperty(exports, 'isVar', {
				enumerable: true,
				get: function () {
					return _isVar.default
				},
			})
			Object.defineProperty(exports, 'matchesPattern', {
				enumerable: true,
				get: function () {
					return _matchesPattern.default
				},
			})
			Object.defineProperty(exports, 'prependToMemberExpression', {
				enumerable: true,
				get: function () {
					return _prependToMemberExpression.default
				},
			})
			exports.react = void 0
			Object.defineProperty(exports, 'removeComments', {
				enumerable: true,
				get: function () {
					return _removeComments.default
				},
			})
			Object.defineProperty(exports, 'removeProperties', {
				enumerable: true,
				get: function () {
					return _removeProperties.default
				},
			})
			Object.defineProperty(exports, 'removePropertiesDeep', {
				enumerable: true,
				get: function () {
					return _removePropertiesDeep.default
				},
			})
			Object.defineProperty(exports, 'removeTypeDuplicates', {
				enumerable: true,
				get: function () {
					return _removeTypeDuplicates.default
				},
			})
			Object.defineProperty(exports, 'shallowEqual', {
				enumerable: true,
				get: function () {
					return _shallowEqual.default
				},
			})
			Object.defineProperty(exports, 'toBindingIdentifierName', {
				enumerable: true,
				get: function () {
					return _toBindingIdentifierName.default
				},
			})
			Object.defineProperty(exports, 'toBlock', {
				enumerable: true,
				get: function () {
					return _toBlock.default
				},
			})
			Object.defineProperty(exports, 'toComputedKey', {
				enumerable: true,
				get: function () {
					return _toComputedKey.default
				},
			})
			Object.defineProperty(exports, 'toExpression', {
				enumerable: true,
				get: function () {
					return _toExpression.default
				},
			})
			Object.defineProperty(exports, 'toIdentifier', {
				enumerable: true,
				get: function () {
					return _toIdentifier.default
				},
			})
			Object.defineProperty(exports, 'toKeyAlias', {
				enumerable: true,
				get: function () {
					return _toKeyAlias.default
				},
			})
			Object.defineProperty(exports, 'toStatement', {
				enumerable: true,
				get: function () {
					return _toStatement.default
				},
			})
			Object.defineProperty(exports, 'traverse', {
				enumerable: true,
				get: function () {
					return _traverse.default
				},
			})
			Object.defineProperty(exports, 'traverseFast', {
				enumerable: true,
				get: function () {
					return _traverseFast.default
				},
			})
			Object.defineProperty(exports, 'validate', {
				enumerable: true,
				get: function () {
					return _validate.default
				},
			})
			Object.defineProperty(exports, 'valueToNode', {
				enumerable: true,
				get: function () {
					return _valueToNode.default
				},
			})
			var _isReactComponent = __nccwpck_require__(24513)
			var _isCompatTag = __nccwpck_require__(20817)
			var _buildChildren = __nccwpck_require__(93415)
			var _assertNode = __nccwpck_require__(41737)
			var _index = __nccwpck_require__(98345)
			Object.keys(_index).forEach(function (key) {
				if (key === 'default' || key === '__esModule') return
				if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return
				if (key in exports && exports[key] === _index[key]) return
				Object.defineProperty(exports, key, {
					enumerable: true,
					get: function () {
						return _index[key]
					},
				})
			})
			var _createTypeAnnotationBasedOnTypeof = __nccwpck_require__(9197)
			var _createFlowUnionType = __nccwpck_require__(58806)
			var _createTSUnionType = __nccwpck_require__(15766)
			var _productions = __nccwpck_require__(38504)
			Object.keys(_productions).forEach(function (key) {
				if (key === 'default' || key === '__esModule') return
				if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return
				if (key in exports && exports[key] === _productions[key]) return
				Object.defineProperty(exports, key, {
					enumerable: true,
					get: function () {
						return _productions[key]
					},
				})
			})
			var _index2 = __nccwpck_require__(90670)
			Object.keys(_index2).forEach(function (key) {
				if (key === 'default' || key === '__esModule') return
				if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return
				if (key in exports && exports[key] === _index2[key]) return
				Object.defineProperty(exports, key, {
					enumerable: true,
					get: function () {
						return _index2[key]
					},
				})
			})
			var _cloneNode = __nccwpck_require__(89260)
			var _clone = __nccwpck_require__(59260)
			var _cloneDeep = __nccwpck_require__(45922)
			var _cloneDeepWithoutLoc = __nccwpck_require__(37992)
			var _cloneWithoutLoc = __nccwpck_require__(19258)
			var _addComment = __nccwpck_require__(70704)
			var _addComments = __nccwpck_require__(21071)
			var _inheritInnerComments = __nccwpck_require__(40731)
			var _inheritLeadingComments = __nccwpck_require__(7725)
			var _inheritsComments = __nccwpck_require__(32078)
			var _inheritTrailingComments = __nccwpck_require__(23491)
			var _removeComments = __nccwpck_require__(84066)
			var _index3 = __nccwpck_require__(12359)
			Object.keys(_index3).forEach(function (key) {
				if (key === 'default' || key === '__esModule') return
				if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return
				if (key in exports && exports[key] === _index3[key]) return
				Object.defineProperty(exports, key, {
					enumerable: true,
					get: function () {
						return _index3[key]
					},
				})
			})
			var _index4 = __nccwpck_require__(17945)
			Object.keys(_index4).forEach(function (key) {
				if (key === 'default' || key === '__esModule') return
				if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return
				if (key in exports && exports[key] === _index4[key]) return
				Object.defineProperty(exports, key, {
					enumerable: true,
					get: function () {
						return _index4[key]
					},
				})
			})
			var _ensureBlock = __nccwpck_require__(77046)
			var _toBindingIdentifierName = __nccwpck_require__(19687)
			var _toBlock = __nccwpck_require__(59735)
			var _toComputedKey = __nccwpck_require__(49480)
			var _toExpression = __nccwpck_require__(36490)
			var _toIdentifier = __nccwpck_require__(59451)
			var _toKeyAlias = __nccwpck_require__(23381)
			var _toStatement = __nccwpck_require__(82635)
			var _valueToNode = __nccwpck_require__(20021)
			var _index5 = __nccwpck_require__(40910)
			Object.keys(_index5).forEach(function (key) {
				if (key === 'default' || key === '__esModule') return
				if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return
				if (key in exports && exports[key] === _index5[key]) return
				Object.defineProperty(exports, key, {
					enumerable: true,
					get: function () {
						return _index5[key]
					},
				})
			})
			var _appendToMemberExpression = __nccwpck_require__(4948)
			var _inherits = __nccwpck_require__(40257)
			var _prependToMemberExpression = __nccwpck_require__(78564)
			var _removeProperties = __nccwpck_require__(6656)
			var _removePropertiesDeep = __nccwpck_require__(55902)
			var _removeTypeDuplicates = __nccwpck_require__(41034)
			var _getAssignmentIdentifiers = __nccwpck_require__(21228)
			var _getBindingIdentifiers = __nccwpck_require__(45300)
			var _getOuterBindingIdentifiers = __nccwpck_require__(46815)
			var _getFunctionName = __nccwpck_require__(48836)
			var _traverse = __nccwpck_require__(6878)
			Object.keys(_traverse).forEach(function (key) {
				if (key === 'default' || key === '__esModule') return
				if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return
				if (key in exports && exports[key] === _traverse[key]) return
				Object.defineProperty(exports, key, {
					enumerable: true,
					get: function () {
						return _traverse[key]
					},
				})
			})
			var _traverseFast = __nccwpck_require__(47060)
			var _shallowEqual = __nccwpck_require__(56085)
			var _is = __nccwpck_require__(20051)
			var _isBinding = __nccwpck_require__(73998)
			var _isBlockScoped = __nccwpck_require__(942)
			var _isImmutable = __nccwpck_require__(42343)
			var _isLet = __nccwpck_require__(57674)
			var _isNode = __nccwpck_require__(84503)
			var _isNodesEquivalent = __nccwpck_require__(8338)
			var _isPlaceholderType = __nccwpck_require__(49410)
			var _isReferenced = __nccwpck_require__(89508)
			var _isScope = __nccwpck_require__(33583)
			var _isSpecifierDefault = __nccwpck_require__(64394)
			var _isType = __nccwpck_require__(53547)
			var _isValidES3Identifier = __nccwpck_require__(40267)
			var _isValidIdentifier = __nccwpck_require__(66030)
			var _isVar = __nccwpck_require__(21566)
			var _matchesPattern = __nccwpck_require__(47814)
			var _validate = __nccwpck_require__(71581)
			var _buildMatchMemberExpression = __nccwpck_require__(77334)
			var _index6 = __nccwpck_require__(40741)
			Object.keys(_index6).forEach(function (key) {
				if (key === 'default' || key === '__esModule') return
				if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return
				if (key in exports && exports[key] === _index6[key]) return
				Object.defineProperty(exports, key, {
					enumerable: true,
					get: function () {
						return _index6[key]
					},
				})
			})
			var _deprecationWarning = __nccwpck_require__(14711)
			var _toSequenceExpression = __nccwpck_require__(403)
			const react = (exports.react = {
				isReactComponent: _isReactComponent.default,
				isCompatTag: _isCompatTag.default,
				buildChildren: _buildChildren.default,
			})
			{
				exports.toSequenceExpression = _toSequenceExpression.default
			}
			if (process.env.BABEL_TYPES_8_BREAKING) {
				console.warn(
					'BABEL_TYPES_8_BREAKING is not supported anymore. Use the latest Babel 8.0.0 pre-release instead!',
				)
			}

			//# sourceMappingURL=index.js.map

			/***/
		},

		/***/ 4948: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = appendToMemberExpression
			var _index = __nccwpck_require__(90670)
			function appendToMemberExpression(member, append, computed = false) {
				member.object = (0, _index.memberExpression)(
					member.object,
					member.property,
					member.computed,
				)
				member.property = append
				member.computed = !!computed
				return member
			}

			//# sourceMappingURL=appendToMemberExpression.js.map

			/***/
		},

		/***/ 41034: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = removeTypeDuplicates
			var _index = __nccwpck_require__(40741)
			function getQualifiedName(node) {
				return (0, _index.isIdentifier)(node)
					? node.name
					: `${node.id.name}.${getQualifiedName(node.qualification)}`
			}
			function removeTypeDuplicates(nodesIn) {
				const nodes = Array.from(nodesIn)
				const generics = new Map()
				const bases = new Map()
				const typeGroups = new Set()
				const types = []
				for (let i = 0; i < nodes.length; i++) {
					const node = nodes[i]
					if (!node) continue
					if (types.includes(node)) {
						continue
					}
					if ((0, _index.isAnyTypeAnnotation)(node)) {
						return [node]
					}
					if ((0, _index.isFlowBaseAnnotation)(node)) {
						bases.set(node.type, node)
						continue
					}
					if ((0, _index.isUnionTypeAnnotation)(node)) {
						if (!typeGroups.has(node.types)) {
							nodes.push(...node.types)
							typeGroups.add(node.types)
						}
						continue
					}
					if ((0, _index.isGenericTypeAnnotation)(node)) {
						const name = getQualifiedName(node.id)
						if (generics.has(name)) {
							let existing = generics.get(name)
							if (existing.typeParameters) {
								if (node.typeParameters) {
									existing.typeParameters.params.push(
										...node.typeParameters.params,
									)
									existing.typeParameters.params = removeTypeDuplicates(
										existing.typeParameters.params,
									)
								}
							} else {
								existing = node.typeParameters
							}
						} else {
							generics.set(name, node)
						}
						continue
					}
					types.push(node)
				}
				for (const [, baseType] of bases) {
					types.push(baseType)
				}
				for (const [, genericName] of generics) {
					types.push(genericName)
				}
				return types
			}

			//# sourceMappingURL=removeTypeDuplicates.js.map

			/***/
		},

		/***/ 40257: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = inherits
			var _index = __nccwpck_require__(17945)
			var _inheritsComments = __nccwpck_require__(32078)
			function inherits(child, parent) {
				if (!child || !parent) return child
				for (const key of _index.INHERIT_KEYS.optional) {
					if (child[key] == null) {
						child[key] = parent[key]
					}
				}
				for (const key of Object.keys(parent)) {
					if (key[0] === '_' && key !== '__clone') {
						child[key] = parent[key]
					}
				}
				for (const key of _index.INHERIT_KEYS.force) {
					child[key] = parent[key]
				}
				;(0, _inheritsComments.default)(child, parent)
				return child
			}

			//# sourceMappingURL=inherits.js.map

			/***/
		},

		/***/ 78564: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = prependToMemberExpression
			var _index = __nccwpck_require__(90670)
			var _index2 = __nccwpck_require__(16535)
			function prependToMemberExpression(member, prepend) {
				if ((0, _index2.isSuper)(member.object)) {
					throw new Error(
						'Cannot prepend node to super property access (`super.foo`).',
					)
				}
				member.object = (0, _index.memberExpression)(prepend, member.object)
				return member
			}

			//# sourceMappingURL=prependToMemberExpression.js.map

			/***/
		},

		/***/ 6656: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = removeProperties
			var _index = __nccwpck_require__(17945)
			const CLEAR_KEYS = ['tokens', 'start', 'end', 'loc', 'raw', 'rawValue']
			const CLEAR_KEYS_PLUS_COMMENTS = [
				..._index.COMMENT_KEYS,
				'comments',
				...CLEAR_KEYS,
			]
			function removeProperties(node, opts = {}) {
				const map = opts.preserveComments
					? CLEAR_KEYS
					: CLEAR_KEYS_PLUS_COMMENTS
				for (const key of map) {
					if (node[key] != null) node[key] = undefined
				}
				for (const key of Object.keys(node)) {
					if (key[0] === '_' && node[key] != null) node[key] = undefined
				}
				const symbols = Object.getOwnPropertySymbols(node)
				for (const sym of symbols) {
					node[sym] = null
				}
			}

			//# sourceMappingURL=removeProperties.js.map

			/***/
		},

		/***/ 55902: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = removePropertiesDeep
			var _traverseFast = __nccwpck_require__(47060)
			var _removeProperties = __nccwpck_require__(6656)
			function removePropertiesDeep(tree, opts) {
				;(0, _traverseFast.default)(tree, _removeProperties.default, opts)
				return tree
			}

			//# sourceMappingURL=removePropertiesDeep.js.map

			/***/
		},

		/***/ 76123: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = removeTypeDuplicates
			var _index = __nccwpck_require__(40741)
			function getQualifiedName(node) {
				return (0, _index.isIdentifier)(node)
					? node.name
					: (0, _index.isThisExpression)(node)
						? 'this'
						: `${node.right.name}.${getQualifiedName(node.left)}`
			}
			function removeTypeDuplicates(nodesIn) {
				const nodes = Array.from(nodesIn)
				const generics = new Map()
				const bases = new Map()
				const typeGroups = new Set()
				const types = []
				for (let i = 0; i < nodes.length; i++) {
					const node = nodes[i]
					if (!node) continue
					if (types.includes(node)) {
						continue
					}
					if ((0, _index.isTSAnyKeyword)(node)) {
						return [node]
					}
					if ((0, _index.isTSBaseType)(node)) {
						bases.set(node.type, node)
						continue
					}
					if ((0, _index.isTSUnionType)(node)) {
						if (!typeGroups.has(node.types)) {
							nodes.push(...node.types)
							typeGroups.add(node.types)
						}
						continue
					}
					const typeArgumentsKey = 'typeParameters'
					if ((0, _index.isTSTypeReference)(node) && node[typeArgumentsKey]) {
						const typeArguments = node[typeArgumentsKey]
						const name = getQualifiedName(node.typeName)
						if (generics.has(name)) {
							let existing = generics.get(name)
							const existingTypeArguments = existing[typeArgumentsKey]
							if (existingTypeArguments) {
								existingTypeArguments.params.push(...typeArguments.params)
								existingTypeArguments.params = removeTypeDuplicates(
									existingTypeArguments.params,
								)
							} else {
								existing = typeArguments
							}
						} else {
							generics.set(name, node)
						}
						continue
					}
					types.push(node)
				}
				for (const [, baseType] of bases) {
					types.push(baseType)
				}
				for (const [, genericName] of generics) {
					types.push(genericName)
				}
				return types
			}

			//# sourceMappingURL=removeTypeDuplicates.js.map

			/***/
		},

		/***/ 21228: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = getAssignmentIdentifiers
			function getAssignmentIdentifiers(node) {
				const search = [].concat(node)
				const ids = Object.create(null)
				while (search.length) {
					const id = search.pop()
					if (!id) continue
					switch (id.type) {
						case 'ArrayPattern':
							search.push(...id.elements)
							break
						case 'AssignmentExpression':
						case 'AssignmentPattern':
						case 'ForInStatement':
						case 'ForOfStatement':
							search.push(id.left)
							break
						case 'ObjectPattern':
							search.push(...id.properties)
							break
						case 'ObjectProperty':
							search.push(id.value)
							break
						case 'RestElement':
						case 'UpdateExpression':
							search.push(id.argument)
							break
						case 'UnaryExpression':
							if (id.operator === 'delete') {
								search.push(id.argument)
							}
							break
						case 'Identifier':
							ids[id.name] = id
							break
						default:
							break
					}
				}
				return ids
			}

			//# sourceMappingURL=getAssignmentIdentifiers.js.map

			/***/
		},

		/***/ 45300: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = getBindingIdentifiers
			var _index = __nccwpck_require__(40741)
			function getBindingIdentifiers(
				node,
				duplicates,
				outerOnly,
				newBindingsOnly,
			) {
				const search = [].concat(node)
				const ids = Object.create(null)
				while (search.length) {
					const id = search.shift()
					if (!id) continue
					if (
						newBindingsOnly &&
						((0, _index.isAssignmentExpression)(id) ||
							(0, _index.isUnaryExpression)(id) ||
							(0, _index.isUpdateExpression)(id))
					) {
						continue
					}
					if ((0, _index.isIdentifier)(id)) {
						if (duplicates) {
							const _ids = (ids[id.name] = ids[id.name] || [])
							_ids.push(id)
						} else {
							ids[id.name] = id
						}
						continue
					}
					if (
						(0, _index.isExportDeclaration)(id) &&
						!(0, _index.isExportAllDeclaration)(id)
					) {
						if ((0, _index.isDeclaration)(id.declaration)) {
							search.push(id.declaration)
						}
						continue
					}
					if (outerOnly) {
						if ((0, _index.isFunctionDeclaration)(id)) {
							search.push(id.id)
							continue
						}
						if ((0, _index.isFunctionExpression)(id)) {
							continue
						}
					}
					const keys = getBindingIdentifiers.keys[id.type]
					if (keys) {
						for (let i = 0; i < keys.length; i++) {
							const key = keys[i]
							const nodes = id[key]
							if (nodes) {
								if (Array.isArray(nodes)) {
									search.push(...nodes)
								} else {
									search.push(nodes)
								}
							}
						}
					}
				}
				return ids
			}
			const keys = {
				DeclareClass: ['id'],
				DeclareFunction: ['id'],
				DeclareModule: ['id'],
				DeclareVariable: ['id'],
				DeclareInterface: ['id'],
				DeclareTypeAlias: ['id'],
				DeclareOpaqueType: ['id'],
				InterfaceDeclaration: ['id'],
				TypeAlias: ['id'],
				OpaqueType: ['id'],
				CatchClause: ['param'],
				LabeledStatement: ['label'],
				UnaryExpression: ['argument'],
				AssignmentExpression: ['left'],
				ImportSpecifier: ['local'],
				ImportNamespaceSpecifier: ['local'],
				ImportDefaultSpecifier: ['local'],
				ImportDeclaration: ['specifiers'],
				TSImportEqualsDeclaration: ['id'],
				ExportSpecifier: ['exported'],
				ExportNamespaceSpecifier: ['exported'],
				ExportDefaultSpecifier: ['exported'],
				FunctionDeclaration: ['id', 'params'],
				FunctionExpression: ['id', 'params'],
				ArrowFunctionExpression: ['params'],
				ObjectMethod: ['params'],
				ClassMethod: ['params'],
				ClassPrivateMethod: ['params'],
				ForInStatement: ['left'],
				ForOfStatement: ['left'],
				ClassDeclaration: ['id'],
				ClassExpression: ['id'],
				RestElement: ['argument'],
				UpdateExpression: ['argument'],
				ObjectProperty: ['value'],
				AssignmentPattern: ['left'],
				ArrayPattern: ['elements'],
				ObjectPattern: ['properties'],
				VariableDeclaration: ['declarations'],
				VariableDeclarator: ['id'],
			}
			getBindingIdentifiers.keys = keys

			//# sourceMappingURL=getBindingIdentifiers.js.map

			/***/
		},

		/***/ 48836: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = getFunctionName
			var _index = __nccwpck_require__(40741)
			function getNameFromLiteralId(id) {
				if ((0, _index.isNullLiteral)(id)) {
					return 'null'
				}
				if ((0, _index.isRegExpLiteral)(id)) {
					return `/${id.pattern}/${id.flags}`
				}
				if ((0, _index.isTemplateLiteral)(id)) {
					return id.quasis.map((quasi) => quasi.value.raw).join('')
				}
				if (id.value !== undefined) {
					return String(id.value)
				}
				return null
			}
			function getObjectMemberKey(node) {
				if (!node.computed || (0, _index.isLiteral)(node.key)) {
					return node.key
				}
			}
			function getFunctionName(node, parent) {
				if ('id' in node && node.id) {
					return {
						name: node.id.name,
						originalNode: node.id,
					}
				}
				let prefix = ''
				let id
				if (
					(0, _index.isObjectProperty)(parent, {
						value: node,
					})
				) {
					id = getObjectMemberKey(parent)
				} else if (
					(0, _index.isObjectMethod)(node) ||
					(0, _index.isClassMethod)(node)
				) {
					id = getObjectMemberKey(node)
					if (node.kind === 'get') prefix = 'get '
					else if (node.kind === 'set') prefix = 'set '
				} else if (
					(0, _index.isVariableDeclarator)(parent, {
						init: node,
					})
				) {
					id = parent.id
				} else if (
					(0, _index.isAssignmentExpression)(parent, {
						operator: '=',
						right: node,
					})
				) {
					id = parent.left
				}
				if (!id) return null
				const name = (0, _index.isLiteral)(id)
					? getNameFromLiteralId(id)
					: (0, _index.isIdentifier)(id)
						? id.name
						: (0, _index.isPrivateName)(id)
							? id.id.name
							: null
				if (name == null) return null
				return {
					name: prefix + name,
					originalNode: id,
				}
			}

			//# sourceMappingURL=getFunctionName.js.map

			/***/
		},

		/***/ 46815: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = void 0
			var _getBindingIdentifiers = __nccwpck_require__(45300)
			var _default = (exports['default'] = getOuterBindingIdentifiers)
			function getOuterBindingIdentifiers(node, duplicates) {
				return (0, _getBindingIdentifiers.default)(node, duplicates, true)
			}

			//# sourceMappingURL=getOuterBindingIdentifiers.js.map

			/***/
		},

		/***/ 6878: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = traverse
			var _index = __nccwpck_require__(40910)
			function traverse(node, handlers, state) {
				if (typeof handlers === 'function') {
					handlers = {
						enter: handlers,
					}
				}
				const { enter, exit } = handlers
				traverseSimpleImpl(node, enter, exit, state, [])
			}
			function traverseSimpleImpl(node, enter, exit, state, ancestors) {
				const keys = _index.VISITOR_KEYS[node.type]
				if (!keys) return
				if (enter) enter(node, ancestors, state)
				for (const key of keys) {
					const subNode = node[key]
					if (Array.isArray(subNode)) {
						for (let i = 0; i < subNode.length; i++) {
							const child = subNode[i]
							if (!child) continue
							ancestors.push({
								node,
								key,
								index: i,
							})
							traverseSimpleImpl(child, enter, exit, state, ancestors)
							ancestors.pop()
						}
					} else if (subNode) {
						ancestors.push({
							node,
							key,
						})
						traverseSimpleImpl(subNode, enter, exit, state, ancestors)
						ancestors.pop()
					}
				}
				if (exit) exit(node, ancestors, state)
			}

			//# sourceMappingURL=traverse.js.map

			/***/
		},

		/***/ 47060: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = traverseFast
			var _index = __nccwpck_require__(40910)
			const _skip = Symbol()
			const _stop = Symbol()
			function traverseFast(node, enter, opts) {
				if (!node) return false
				const keys = _index.VISITOR_KEYS[node.type]
				if (!keys) return false
				opts = opts || {}
				const ret = enter(node, opts)
				if (ret !== undefined) {
					switch (ret) {
						case _skip:
							return false
						case _stop:
							return true
					}
				}
				for (const key of keys) {
					const subNode = node[key]
					if (!subNode) continue
					if (Array.isArray(subNode)) {
						for (const node of subNode) {
							if (traverseFast(node, enter, opts)) return true
						}
					} else {
						if (traverseFast(subNode, enter, opts)) return true
					}
				}
				return false
			}
			traverseFast.skip = _skip
			traverseFast.stop = _stop

			//# sourceMappingURL=traverseFast.js.map

			/***/
		},

		/***/ 14711: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = deprecationWarning
			const warnings = new Set()
			function deprecationWarning(
				oldName,
				newName,
				prefix = '',
				cacheKey = oldName,
			) {
				if (warnings.has(cacheKey)) return
				warnings.add(cacheKey)
				const { internal, trace } = captureShortStackTrace(1, 2)
				if (internal) {
					return
				}
				console.warn(
					`${prefix}\`${oldName}\` has been deprecated, please migrate to \`${newName}\`\n${trace}`,
				)
			}
			function captureShortStackTrace(skip, length) {
				const { stackTraceLimit, prepareStackTrace } = Error
				let stackTrace
				Error.stackTraceLimit = 1 + skip + length
				Error.prepareStackTrace = function (err, stack) {
					stackTrace = stack
				}
				new Error().stack
				Error.stackTraceLimit = stackTraceLimit
				Error.prepareStackTrace = prepareStackTrace
				if (!stackTrace)
					return {
						internal: false,
						trace: '',
					}
				const shortStackTrace = stackTrace.slice(1 + skip, 1 + skip + length)
				return {
					internal: /[\\/]@babel[\\/]/.test(shortStackTrace[1].getFileName()),
					trace: shortStackTrace.map((frame) => `    at ${frame}`).join('\n'),
				}
			}

			//# sourceMappingURL=deprecationWarning.js.map

			/***/
		},

		/***/ 40066: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = inherit
			function inherit(key, child, parent) {
				if (child && parent) {
					child[key] = Array.from(
						new Set([].concat(child[key], parent[key]).filter(Boolean)),
					)
				}
			}

			//# sourceMappingURL=inherit.js.map

			/***/
		},

		/***/ 43508: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = cleanJSXElementLiteralChild
			var _index = __nccwpck_require__(90670)
			var _index2 = __nccwpck_require__(16535)
			function cleanJSXElementLiteralChild(child, args) {
				const lines = child.value.split(/\r\n|\n|\r/)
				let lastNonEmptyLine = 0
				for (let i = 0; i < lines.length; i++) {
					if (/[^ \t]/.exec(lines[i])) {
						lastNonEmptyLine = i
					}
				}
				let str = ''
				for (let i = 0; i < lines.length; i++) {
					const line = lines[i]
					const isFirstLine = i === 0
					const isLastLine = i === lines.length - 1
					const isLastNonEmptyLine = i === lastNonEmptyLine
					let trimmedLine = line.replace(/\t/g, ' ')
					if (!isFirstLine) {
						trimmedLine = trimmedLine.replace(/^ +/, '')
					}
					if (!isLastLine) {
						trimmedLine = trimmedLine.replace(/ +$/, '')
					}
					if (trimmedLine) {
						if (!isLastNonEmptyLine) {
							trimmedLine += ' '
						}
						str += trimmedLine
					}
				}
				if (str)
					args.push(
						(0, _index2.inherits)((0, _index.stringLiteral)(str), child),
					)
			}

			//# sourceMappingURL=cleanJSXElementLiteralChild.js.map

			/***/
		},

		/***/ 56085: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = shallowEqual
			function shallowEqual(actual, expected) {
				const keys = Object.keys(expected)
				for (const key of keys) {
					if (actual[key] !== expected[key]) {
						return false
					}
				}
				return true
			}

			//# sourceMappingURL=shallowEqual.js.map

			/***/
		},

		/***/ 77334: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = buildMatchMemberExpression
			var _matchesPattern = __nccwpck_require__(47814)
			function buildMatchMemberExpression(match, allowPartial) {
				const parts = match.split('.')
				return (member) =>
					(0, _matchesPattern.default)(member, parts, allowPartial)
			}

			//# sourceMappingURL=buildMatchMemberExpression.js.map

			/***/
		},

		/***/ 40741: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports.isAccessor = isAccessor
			exports.isAnyTypeAnnotation = isAnyTypeAnnotation
			exports.isArgumentPlaceholder = isArgumentPlaceholder
			exports.isArrayExpression = isArrayExpression
			exports.isArrayPattern = isArrayPattern
			exports.isArrayTypeAnnotation = isArrayTypeAnnotation
			exports.isArrowFunctionExpression = isArrowFunctionExpression
			exports.isAssignmentExpression = isAssignmentExpression
			exports.isAssignmentPattern = isAssignmentPattern
			exports.isAwaitExpression = isAwaitExpression
			exports.isBigIntLiteral = isBigIntLiteral
			exports.isBinary = isBinary
			exports.isBinaryExpression = isBinaryExpression
			exports.isBindExpression = isBindExpression
			exports.isBlock = isBlock
			exports.isBlockParent = isBlockParent
			exports.isBlockStatement = isBlockStatement
			exports.isBooleanLiteral = isBooleanLiteral
			exports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation
			exports.isBooleanTypeAnnotation = isBooleanTypeAnnotation
			exports.isBreakStatement = isBreakStatement
			exports.isCallExpression = isCallExpression
			exports.isCatchClause = isCatchClause
			exports.isClass = isClass
			exports.isClassAccessorProperty = isClassAccessorProperty
			exports.isClassBody = isClassBody
			exports.isClassDeclaration = isClassDeclaration
			exports.isClassExpression = isClassExpression
			exports.isClassImplements = isClassImplements
			exports.isClassMethod = isClassMethod
			exports.isClassPrivateMethod = isClassPrivateMethod
			exports.isClassPrivateProperty = isClassPrivateProperty
			exports.isClassProperty = isClassProperty
			exports.isCompletionStatement = isCompletionStatement
			exports.isConditional = isConditional
			exports.isConditionalExpression = isConditionalExpression
			exports.isContinueStatement = isContinueStatement
			exports.isDebuggerStatement = isDebuggerStatement
			exports.isDecimalLiteral = isDecimalLiteral
			exports.isDeclaration = isDeclaration
			exports.isDeclareClass = isDeclareClass
			exports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration
			exports.isDeclareExportDeclaration = isDeclareExportDeclaration
			exports.isDeclareFunction = isDeclareFunction
			exports.isDeclareInterface = isDeclareInterface
			exports.isDeclareModule = isDeclareModule
			exports.isDeclareModuleExports = isDeclareModuleExports
			exports.isDeclareOpaqueType = isDeclareOpaqueType
			exports.isDeclareTypeAlias = isDeclareTypeAlias
			exports.isDeclareVariable = isDeclareVariable
			exports.isDeclaredPredicate = isDeclaredPredicate
			exports.isDecorator = isDecorator
			exports.isDirective = isDirective
			exports.isDirectiveLiteral = isDirectiveLiteral
			exports.isDoExpression = isDoExpression
			exports.isDoWhileStatement = isDoWhileStatement
			exports.isEmptyStatement = isEmptyStatement
			exports.isEmptyTypeAnnotation = isEmptyTypeAnnotation
			exports.isEnumBody = isEnumBody
			exports.isEnumBooleanBody = isEnumBooleanBody
			exports.isEnumBooleanMember = isEnumBooleanMember
			exports.isEnumDeclaration = isEnumDeclaration
			exports.isEnumDefaultedMember = isEnumDefaultedMember
			exports.isEnumMember = isEnumMember
			exports.isEnumNumberBody = isEnumNumberBody
			exports.isEnumNumberMember = isEnumNumberMember
			exports.isEnumStringBody = isEnumStringBody
			exports.isEnumStringMember = isEnumStringMember
			exports.isEnumSymbolBody = isEnumSymbolBody
			exports.isExistsTypeAnnotation = isExistsTypeAnnotation
			exports.isExportAllDeclaration = isExportAllDeclaration
			exports.isExportDeclaration = isExportDeclaration
			exports.isExportDefaultDeclaration = isExportDefaultDeclaration
			exports.isExportDefaultSpecifier = isExportDefaultSpecifier
			exports.isExportNamedDeclaration = isExportNamedDeclaration
			exports.isExportNamespaceSpecifier = isExportNamespaceSpecifier
			exports.isExportSpecifier = isExportSpecifier
			exports.isExpression = isExpression
			exports.isExpressionStatement = isExpressionStatement
			exports.isExpressionWrapper = isExpressionWrapper
			exports.isFile = isFile
			exports.isFlow = isFlow
			exports.isFlowBaseAnnotation = isFlowBaseAnnotation
			exports.isFlowDeclaration = isFlowDeclaration
			exports.isFlowPredicate = isFlowPredicate
			exports.isFlowType = isFlowType
			exports.isFor = isFor
			exports.isForInStatement = isForInStatement
			exports.isForOfStatement = isForOfStatement
			exports.isForStatement = isForStatement
			exports.isForXStatement = isForXStatement
			exports.isFunction = isFunction
			exports.isFunctionDeclaration = isFunctionDeclaration
			exports.isFunctionExpression = isFunctionExpression
			exports.isFunctionParent = isFunctionParent
			exports.isFunctionTypeAnnotation = isFunctionTypeAnnotation
			exports.isFunctionTypeParam = isFunctionTypeParam
			exports.isGenericTypeAnnotation = isGenericTypeAnnotation
			exports.isIdentifier = isIdentifier
			exports.isIfStatement = isIfStatement
			exports.isImmutable = isImmutable
			exports.isImport = isImport
			exports.isImportAttribute = isImportAttribute
			exports.isImportDeclaration = isImportDeclaration
			exports.isImportDefaultSpecifier = isImportDefaultSpecifier
			exports.isImportExpression = isImportExpression
			exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier
			exports.isImportOrExportDeclaration = isImportOrExportDeclaration
			exports.isImportSpecifier = isImportSpecifier
			exports.isIndexedAccessType = isIndexedAccessType
			exports.isInferredPredicate = isInferredPredicate
			exports.isInterfaceDeclaration = isInterfaceDeclaration
			exports.isInterfaceExtends = isInterfaceExtends
			exports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation
			exports.isInterpreterDirective = isInterpreterDirective
			exports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation
			exports.isJSX = isJSX
			exports.isJSXAttribute = isJSXAttribute
			exports.isJSXClosingElement = isJSXClosingElement
			exports.isJSXClosingFragment = isJSXClosingFragment
			exports.isJSXElement = isJSXElement
			exports.isJSXEmptyExpression = isJSXEmptyExpression
			exports.isJSXExpressionContainer = isJSXExpressionContainer
			exports.isJSXFragment = isJSXFragment
			exports.isJSXIdentifier = isJSXIdentifier
			exports.isJSXMemberExpression = isJSXMemberExpression
			exports.isJSXNamespacedName = isJSXNamespacedName
			exports.isJSXOpeningElement = isJSXOpeningElement
			exports.isJSXOpeningFragment = isJSXOpeningFragment
			exports.isJSXSpreadAttribute = isJSXSpreadAttribute
			exports.isJSXSpreadChild = isJSXSpreadChild
			exports.isJSXText = isJSXText
			exports.isLVal = isLVal
			exports.isLabeledStatement = isLabeledStatement
			exports.isLiteral = isLiteral
			exports.isLogicalExpression = isLogicalExpression
			exports.isLoop = isLoop
			exports.isMemberExpression = isMemberExpression
			exports.isMetaProperty = isMetaProperty
			exports.isMethod = isMethod
			exports.isMiscellaneous = isMiscellaneous
			exports.isMixedTypeAnnotation = isMixedTypeAnnotation
			exports.isModuleDeclaration = isModuleDeclaration
			exports.isModuleExpression = isModuleExpression
			exports.isModuleSpecifier = isModuleSpecifier
			exports.isNewExpression = isNewExpression
			exports.isNoop = isNoop
			exports.isNullLiteral = isNullLiteral
			exports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation
			exports.isNullableTypeAnnotation = isNullableTypeAnnotation
			exports.isNumberLiteral = isNumberLiteral
			exports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation
			exports.isNumberTypeAnnotation = isNumberTypeAnnotation
			exports.isNumericLiteral = isNumericLiteral
			exports.isObjectExpression = isObjectExpression
			exports.isObjectMember = isObjectMember
			exports.isObjectMethod = isObjectMethod
			exports.isObjectPattern = isObjectPattern
			exports.isObjectProperty = isObjectProperty
			exports.isObjectTypeAnnotation = isObjectTypeAnnotation
			exports.isObjectTypeCallProperty = isObjectTypeCallProperty
			exports.isObjectTypeIndexer = isObjectTypeIndexer
			exports.isObjectTypeInternalSlot = isObjectTypeInternalSlot
			exports.isObjectTypeProperty = isObjectTypeProperty
			exports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty
			exports.isOpaqueType = isOpaqueType
			exports.isOptionalCallExpression = isOptionalCallExpression
			exports.isOptionalIndexedAccessType = isOptionalIndexedAccessType
			exports.isOptionalMemberExpression = isOptionalMemberExpression
			exports.isParenthesizedExpression = isParenthesizedExpression
			exports.isPattern = isPattern
			exports.isPatternLike = isPatternLike
			exports.isPipelineBareFunction = isPipelineBareFunction
			exports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference
			exports.isPipelineTopicExpression = isPipelineTopicExpression
			exports.isPlaceholder = isPlaceholder
			exports.isPrivate = isPrivate
			exports.isPrivateName = isPrivateName
			exports.isProgram = isProgram
			exports.isProperty = isProperty
			exports.isPureish = isPureish
			exports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier
			exports.isRecordExpression = isRecordExpression
			exports.isRegExpLiteral = isRegExpLiteral
			exports.isRegexLiteral = isRegexLiteral
			exports.isRestElement = isRestElement
			exports.isRestProperty = isRestProperty
			exports.isReturnStatement = isReturnStatement
			exports.isScopable = isScopable
			exports.isSequenceExpression = isSequenceExpression
			exports.isSpreadElement = isSpreadElement
			exports.isSpreadProperty = isSpreadProperty
			exports.isStandardized = isStandardized
			exports.isStatement = isStatement
			exports.isStaticBlock = isStaticBlock
			exports.isStringLiteral = isStringLiteral
			exports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation
			exports.isStringTypeAnnotation = isStringTypeAnnotation
			exports.isSuper = isSuper
			exports.isSwitchCase = isSwitchCase
			exports.isSwitchStatement = isSwitchStatement
			exports.isSymbolTypeAnnotation = isSymbolTypeAnnotation
			exports.isTSAnyKeyword = isTSAnyKeyword
			exports.isTSArrayType = isTSArrayType
			exports.isTSAsExpression = isTSAsExpression
			exports.isTSBaseType = isTSBaseType
			exports.isTSBigIntKeyword = isTSBigIntKeyword
			exports.isTSBooleanKeyword = isTSBooleanKeyword
			exports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration
			exports.isTSConditionalType = isTSConditionalType
			exports.isTSConstructSignatureDeclaration =
				isTSConstructSignatureDeclaration
			exports.isTSConstructorType = isTSConstructorType
			exports.isTSDeclareFunction = isTSDeclareFunction
			exports.isTSDeclareMethod = isTSDeclareMethod
			exports.isTSEntityName = isTSEntityName
			exports.isTSEnumBody = isTSEnumBody
			exports.isTSEnumDeclaration = isTSEnumDeclaration
			exports.isTSEnumMember = isTSEnumMember
			exports.isTSExportAssignment = isTSExportAssignment
			exports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments
			exports.isTSExternalModuleReference = isTSExternalModuleReference
			exports.isTSFunctionType = isTSFunctionType
			exports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration
			exports.isTSImportType = isTSImportType
			exports.isTSIndexSignature = isTSIndexSignature
			exports.isTSIndexedAccessType = isTSIndexedAccessType
			exports.isTSInferType = isTSInferType
			exports.isTSInstantiationExpression = isTSInstantiationExpression
			exports.isTSInterfaceBody = isTSInterfaceBody
			exports.isTSInterfaceDeclaration = isTSInterfaceDeclaration
			exports.isTSIntersectionType = isTSIntersectionType
			exports.isTSIntrinsicKeyword = isTSIntrinsicKeyword
			exports.isTSLiteralType = isTSLiteralType
			exports.isTSMappedType = isTSMappedType
			exports.isTSMethodSignature = isTSMethodSignature
			exports.isTSModuleBlock = isTSModuleBlock
			exports.isTSModuleDeclaration = isTSModuleDeclaration
			exports.isTSNamedTupleMember = isTSNamedTupleMember
			exports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration
			exports.isTSNeverKeyword = isTSNeverKeyword
			exports.isTSNonNullExpression = isTSNonNullExpression
			exports.isTSNullKeyword = isTSNullKeyword
			exports.isTSNumberKeyword = isTSNumberKeyword
			exports.isTSObjectKeyword = isTSObjectKeyword
			exports.isTSOptionalType = isTSOptionalType
			exports.isTSParameterProperty = isTSParameterProperty
			exports.isTSParenthesizedType = isTSParenthesizedType
			exports.isTSPropertySignature = isTSPropertySignature
			exports.isTSQualifiedName = isTSQualifiedName
			exports.isTSRestType = isTSRestType
			exports.isTSSatisfiesExpression = isTSSatisfiesExpression
			exports.isTSStringKeyword = isTSStringKeyword
			exports.isTSSymbolKeyword = isTSSymbolKeyword
			exports.isTSTemplateLiteralType = isTSTemplateLiteralType
			exports.isTSThisType = isTSThisType
			exports.isTSTupleType = isTSTupleType
			exports.isTSType = isTSType
			exports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration
			exports.isTSTypeAnnotation = isTSTypeAnnotation
			exports.isTSTypeAssertion = isTSTypeAssertion
			exports.isTSTypeElement = isTSTypeElement
			exports.isTSTypeLiteral = isTSTypeLiteral
			exports.isTSTypeOperator = isTSTypeOperator
			exports.isTSTypeParameter = isTSTypeParameter
			exports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration
			exports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation
			exports.isTSTypePredicate = isTSTypePredicate
			exports.isTSTypeQuery = isTSTypeQuery
			exports.isTSTypeReference = isTSTypeReference
			exports.isTSUndefinedKeyword = isTSUndefinedKeyword
			exports.isTSUnionType = isTSUnionType
			exports.isTSUnknownKeyword = isTSUnknownKeyword
			exports.isTSVoidKeyword = isTSVoidKeyword
			exports.isTaggedTemplateExpression = isTaggedTemplateExpression
			exports.isTemplateElement = isTemplateElement
			exports.isTemplateLiteral = isTemplateLiteral
			exports.isTerminatorless = isTerminatorless
			exports.isThisExpression = isThisExpression
			exports.isThisTypeAnnotation = isThisTypeAnnotation
			exports.isThrowStatement = isThrowStatement
			exports.isTopicReference = isTopicReference
			exports.isTryStatement = isTryStatement
			exports.isTupleExpression = isTupleExpression
			exports.isTupleTypeAnnotation = isTupleTypeAnnotation
			exports.isTypeAlias = isTypeAlias
			exports.isTypeAnnotation = isTypeAnnotation
			exports.isTypeCastExpression = isTypeCastExpression
			exports.isTypeParameter = isTypeParameter
			exports.isTypeParameterDeclaration = isTypeParameterDeclaration
			exports.isTypeParameterInstantiation = isTypeParameterInstantiation
			exports.isTypeScript = isTypeScript
			exports.isTypeofTypeAnnotation = isTypeofTypeAnnotation
			exports.isUnaryExpression = isUnaryExpression
			exports.isUnaryLike = isUnaryLike
			exports.isUnionTypeAnnotation = isUnionTypeAnnotation
			exports.isUpdateExpression = isUpdateExpression
			exports.isUserWhitespacable = isUserWhitespacable
			exports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier
			exports.isVariableDeclaration = isVariableDeclaration
			exports.isVariableDeclarator = isVariableDeclarator
			exports.isVariance = isVariance
			exports.isVoidTypeAnnotation = isVoidTypeAnnotation
			exports.isWhile = isWhile
			exports.isWhileStatement = isWhileStatement
			exports.isWithStatement = isWithStatement
			exports.isYieldExpression = isYieldExpression
			var _shallowEqual = __nccwpck_require__(56085)
			var _deprecationWarning = __nccwpck_require__(14711)
			function isArrayExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'ArrayExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isAssignmentExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'AssignmentExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isBinaryExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'BinaryExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isInterpreterDirective(node, opts) {
				if (!node) return false
				if (node.type !== 'InterpreterDirective') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isDirective(node, opts) {
				if (!node) return false
				if (node.type !== 'Directive') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isDirectiveLiteral(node, opts) {
				if (!node) return false
				if (node.type !== 'DirectiveLiteral') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isBlockStatement(node, opts) {
				if (!node) return false
				if (node.type !== 'BlockStatement') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isBreakStatement(node, opts) {
				if (!node) return false
				if (node.type !== 'BreakStatement') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isCallExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'CallExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isCatchClause(node, opts) {
				if (!node) return false
				if (node.type !== 'CatchClause') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isConditionalExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'ConditionalExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isContinueStatement(node, opts) {
				if (!node) return false
				if (node.type !== 'ContinueStatement') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isDebuggerStatement(node, opts) {
				if (!node) return false
				if (node.type !== 'DebuggerStatement') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isDoWhileStatement(node, opts) {
				if (!node) return false
				if (node.type !== 'DoWhileStatement') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isEmptyStatement(node, opts) {
				if (!node) return false
				if (node.type !== 'EmptyStatement') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isExpressionStatement(node, opts) {
				if (!node) return false
				if (node.type !== 'ExpressionStatement') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isFile(node, opts) {
				if (!node) return false
				if (node.type !== 'File') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isForInStatement(node, opts) {
				if (!node) return false
				if (node.type !== 'ForInStatement') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isForStatement(node, opts) {
				if (!node) return false
				if (node.type !== 'ForStatement') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isFunctionDeclaration(node, opts) {
				if (!node) return false
				if (node.type !== 'FunctionDeclaration') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isFunctionExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'FunctionExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isIdentifier(node, opts) {
				if (!node) return false
				if (node.type !== 'Identifier') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isIfStatement(node, opts) {
				if (!node) return false
				if (node.type !== 'IfStatement') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isLabeledStatement(node, opts) {
				if (!node) return false
				if (node.type !== 'LabeledStatement') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isStringLiteral(node, opts) {
				if (!node) return false
				if (node.type !== 'StringLiteral') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isNumericLiteral(node, opts) {
				if (!node) return false
				if (node.type !== 'NumericLiteral') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isNullLiteral(node, opts) {
				if (!node) return false
				if (node.type !== 'NullLiteral') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isBooleanLiteral(node, opts) {
				if (!node) return false
				if (node.type !== 'BooleanLiteral') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isRegExpLiteral(node, opts) {
				if (!node) return false
				if (node.type !== 'RegExpLiteral') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isLogicalExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'LogicalExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isMemberExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'MemberExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isNewExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'NewExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isProgram(node, opts) {
				if (!node) return false
				if (node.type !== 'Program') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isObjectExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'ObjectExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isObjectMethod(node, opts) {
				if (!node) return false
				if (node.type !== 'ObjectMethod') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isObjectProperty(node, opts) {
				if (!node) return false
				if (node.type !== 'ObjectProperty') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isRestElement(node, opts) {
				if (!node) return false
				if (node.type !== 'RestElement') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isReturnStatement(node, opts) {
				if (!node) return false
				if (node.type !== 'ReturnStatement') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isSequenceExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'SequenceExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isParenthesizedExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'ParenthesizedExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isSwitchCase(node, opts) {
				if (!node) return false
				if (node.type !== 'SwitchCase') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isSwitchStatement(node, opts) {
				if (!node) return false
				if (node.type !== 'SwitchStatement') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isThisExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'ThisExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isThrowStatement(node, opts) {
				if (!node) return false
				if (node.type !== 'ThrowStatement') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTryStatement(node, opts) {
				if (!node) return false
				if (node.type !== 'TryStatement') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isUnaryExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'UnaryExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isUpdateExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'UpdateExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isVariableDeclaration(node, opts) {
				if (!node) return false
				if (node.type !== 'VariableDeclaration') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isVariableDeclarator(node, opts) {
				if (!node) return false
				if (node.type !== 'VariableDeclarator') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isWhileStatement(node, opts) {
				if (!node) return false
				if (node.type !== 'WhileStatement') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isWithStatement(node, opts) {
				if (!node) return false
				if (node.type !== 'WithStatement') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isAssignmentPattern(node, opts) {
				if (!node) return false
				if (node.type !== 'AssignmentPattern') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isArrayPattern(node, opts) {
				if (!node) return false
				if (node.type !== 'ArrayPattern') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isArrowFunctionExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'ArrowFunctionExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isClassBody(node, opts) {
				if (!node) return false
				if (node.type !== 'ClassBody') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isClassExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'ClassExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isClassDeclaration(node, opts) {
				if (!node) return false
				if (node.type !== 'ClassDeclaration') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isExportAllDeclaration(node, opts) {
				if (!node) return false
				if (node.type !== 'ExportAllDeclaration') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isExportDefaultDeclaration(node, opts) {
				if (!node) return false
				if (node.type !== 'ExportDefaultDeclaration') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isExportNamedDeclaration(node, opts) {
				if (!node) return false
				if (node.type !== 'ExportNamedDeclaration') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isExportSpecifier(node, opts) {
				if (!node) return false
				if (node.type !== 'ExportSpecifier') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isForOfStatement(node, opts) {
				if (!node) return false
				if (node.type !== 'ForOfStatement') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isImportDeclaration(node, opts) {
				if (!node) return false
				if (node.type !== 'ImportDeclaration') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isImportDefaultSpecifier(node, opts) {
				if (!node) return false
				if (node.type !== 'ImportDefaultSpecifier') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isImportNamespaceSpecifier(node, opts) {
				if (!node) return false
				if (node.type !== 'ImportNamespaceSpecifier') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isImportSpecifier(node, opts) {
				if (!node) return false
				if (node.type !== 'ImportSpecifier') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isImportExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'ImportExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isMetaProperty(node, opts) {
				if (!node) return false
				if (node.type !== 'MetaProperty') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isClassMethod(node, opts) {
				if (!node) return false
				if (node.type !== 'ClassMethod') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isObjectPattern(node, opts) {
				if (!node) return false
				if (node.type !== 'ObjectPattern') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isSpreadElement(node, opts) {
				if (!node) return false
				if (node.type !== 'SpreadElement') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isSuper(node, opts) {
				if (!node) return false
				if (node.type !== 'Super') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTaggedTemplateExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'TaggedTemplateExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTemplateElement(node, opts) {
				if (!node) return false
				if (node.type !== 'TemplateElement') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTemplateLiteral(node, opts) {
				if (!node) return false
				if (node.type !== 'TemplateLiteral') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isYieldExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'YieldExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isAwaitExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'AwaitExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isImport(node, opts) {
				if (!node) return false
				if (node.type !== 'Import') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isBigIntLiteral(node, opts) {
				if (!node) return false
				if (node.type !== 'BigIntLiteral') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isExportNamespaceSpecifier(node, opts) {
				if (!node) return false
				if (node.type !== 'ExportNamespaceSpecifier') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isOptionalMemberExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'OptionalMemberExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isOptionalCallExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'OptionalCallExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isClassProperty(node, opts) {
				if (!node) return false
				if (node.type !== 'ClassProperty') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isClassAccessorProperty(node, opts) {
				if (!node) return false
				if (node.type !== 'ClassAccessorProperty') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isClassPrivateProperty(node, opts) {
				if (!node) return false
				if (node.type !== 'ClassPrivateProperty') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isClassPrivateMethod(node, opts) {
				if (!node) return false
				if (node.type !== 'ClassPrivateMethod') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isPrivateName(node, opts) {
				if (!node) return false
				if (node.type !== 'PrivateName') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isStaticBlock(node, opts) {
				if (!node) return false
				if (node.type !== 'StaticBlock') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isImportAttribute(node, opts) {
				if (!node) return false
				if (node.type !== 'ImportAttribute') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isAnyTypeAnnotation(node, opts) {
				if (!node) return false
				if (node.type !== 'AnyTypeAnnotation') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isArrayTypeAnnotation(node, opts) {
				if (!node) return false
				if (node.type !== 'ArrayTypeAnnotation') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isBooleanTypeAnnotation(node, opts) {
				if (!node) return false
				if (node.type !== 'BooleanTypeAnnotation') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isBooleanLiteralTypeAnnotation(node, opts) {
				if (!node) return false
				if (node.type !== 'BooleanLiteralTypeAnnotation') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isNullLiteralTypeAnnotation(node, opts) {
				if (!node) return false
				if (node.type !== 'NullLiteralTypeAnnotation') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isClassImplements(node, opts) {
				if (!node) return false
				if (node.type !== 'ClassImplements') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isDeclareClass(node, opts) {
				if (!node) return false
				if (node.type !== 'DeclareClass') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isDeclareFunction(node, opts) {
				if (!node) return false
				if (node.type !== 'DeclareFunction') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isDeclareInterface(node, opts) {
				if (!node) return false
				if (node.type !== 'DeclareInterface') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isDeclareModule(node, opts) {
				if (!node) return false
				if (node.type !== 'DeclareModule') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isDeclareModuleExports(node, opts) {
				if (!node) return false
				if (node.type !== 'DeclareModuleExports') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isDeclareTypeAlias(node, opts) {
				if (!node) return false
				if (node.type !== 'DeclareTypeAlias') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isDeclareOpaqueType(node, opts) {
				if (!node) return false
				if (node.type !== 'DeclareOpaqueType') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isDeclareVariable(node, opts) {
				if (!node) return false
				if (node.type !== 'DeclareVariable') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isDeclareExportDeclaration(node, opts) {
				if (!node) return false
				if (node.type !== 'DeclareExportDeclaration') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isDeclareExportAllDeclaration(node, opts) {
				if (!node) return false
				if (node.type !== 'DeclareExportAllDeclaration') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isDeclaredPredicate(node, opts) {
				if (!node) return false
				if (node.type !== 'DeclaredPredicate') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isExistsTypeAnnotation(node, opts) {
				if (!node) return false
				if (node.type !== 'ExistsTypeAnnotation') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isFunctionTypeAnnotation(node, opts) {
				if (!node) return false
				if (node.type !== 'FunctionTypeAnnotation') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isFunctionTypeParam(node, opts) {
				if (!node) return false
				if (node.type !== 'FunctionTypeParam') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isGenericTypeAnnotation(node, opts) {
				if (!node) return false
				if (node.type !== 'GenericTypeAnnotation') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isInferredPredicate(node, opts) {
				if (!node) return false
				if (node.type !== 'InferredPredicate') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isInterfaceExtends(node, opts) {
				if (!node) return false
				if (node.type !== 'InterfaceExtends') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isInterfaceDeclaration(node, opts) {
				if (!node) return false
				if (node.type !== 'InterfaceDeclaration') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isInterfaceTypeAnnotation(node, opts) {
				if (!node) return false
				if (node.type !== 'InterfaceTypeAnnotation') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isIntersectionTypeAnnotation(node, opts) {
				if (!node) return false
				if (node.type !== 'IntersectionTypeAnnotation') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isMixedTypeAnnotation(node, opts) {
				if (!node) return false
				if (node.type !== 'MixedTypeAnnotation') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isEmptyTypeAnnotation(node, opts) {
				if (!node) return false
				if (node.type !== 'EmptyTypeAnnotation') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isNullableTypeAnnotation(node, opts) {
				if (!node) return false
				if (node.type !== 'NullableTypeAnnotation') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isNumberLiteralTypeAnnotation(node, opts) {
				if (!node) return false
				if (node.type !== 'NumberLiteralTypeAnnotation') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isNumberTypeAnnotation(node, opts) {
				if (!node) return false
				if (node.type !== 'NumberTypeAnnotation') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isObjectTypeAnnotation(node, opts) {
				if (!node) return false
				if (node.type !== 'ObjectTypeAnnotation') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isObjectTypeInternalSlot(node, opts) {
				if (!node) return false
				if (node.type !== 'ObjectTypeInternalSlot') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isObjectTypeCallProperty(node, opts) {
				if (!node) return false
				if (node.type !== 'ObjectTypeCallProperty') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isObjectTypeIndexer(node, opts) {
				if (!node) return false
				if (node.type !== 'ObjectTypeIndexer') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isObjectTypeProperty(node, opts) {
				if (!node) return false
				if (node.type !== 'ObjectTypeProperty') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isObjectTypeSpreadProperty(node, opts) {
				if (!node) return false
				if (node.type !== 'ObjectTypeSpreadProperty') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isOpaqueType(node, opts) {
				if (!node) return false
				if (node.type !== 'OpaqueType') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isQualifiedTypeIdentifier(node, opts) {
				if (!node) return false
				if (node.type !== 'QualifiedTypeIdentifier') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isStringLiteralTypeAnnotation(node, opts) {
				if (!node) return false
				if (node.type !== 'StringLiteralTypeAnnotation') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isStringTypeAnnotation(node, opts) {
				if (!node) return false
				if (node.type !== 'StringTypeAnnotation') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isSymbolTypeAnnotation(node, opts) {
				if (!node) return false
				if (node.type !== 'SymbolTypeAnnotation') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isThisTypeAnnotation(node, opts) {
				if (!node) return false
				if (node.type !== 'ThisTypeAnnotation') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTupleTypeAnnotation(node, opts) {
				if (!node) return false
				if (node.type !== 'TupleTypeAnnotation') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTypeofTypeAnnotation(node, opts) {
				if (!node) return false
				if (node.type !== 'TypeofTypeAnnotation') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTypeAlias(node, opts) {
				if (!node) return false
				if (node.type !== 'TypeAlias') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTypeAnnotation(node, opts) {
				if (!node) return false
				if (node.type !== 'TypeAnnotation') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTypeCastExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'TypeCastExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTypeParameter(node, opts) {
				if (!node) return false
				if (node.type !== 'TypeParameter') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTypeParameterDeclaration(node, opts) {
				if (!node) return false
				if (node.type !== 'TypeParameterDeclaration') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTypeParameterInstantiation(node, opts) {
				if (!node) return false
				if (node.type !== 'TypeParameterInstantiation') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isUnionTypeAnnotation(node, opts) {
				if (!node) return false
				if (node.type !== 'UnionTypeAnnotation') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isVariance(node, opts) {
				if (!node) return false
				if (node.type !== 'Variance') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isVoidTypeAnnotation(node, opts) {
				if (!node) return false
				if (node.type !== 'VoidTypeAnnotation') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isEnumDeclaration(node, opts) {
				if (!node) return false
				if (node.type !== 'EnumDeclaration') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isEnumBooleanBody(node, opts) {
				if (!node) return false
				if (node.type !== 'EnumBooleanBody') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isEnumNumberBody(node, opts) {
				if (!node) return false
				if (node.type !== 'EnumNumberBody') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isEnumStringBody(node, opts) {
				if (!node) return false
				if (node.type !== 'EnumStringBody') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isEnumSymbolBody(node, opts) {
				if (!node) return false
				if (node.type !== 'EnumSymbolBody') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isEnumBooleanMember(node, opts) {
				if (!node) return false
				if (node.type !== 'EnumBooleanMember') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isEnumNumberMember(node, opts) {
				if (!node) return false
				if (node.type !== 'EnumNumberMember') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isEnumStringMember(node, opts) {
				if (!node) return false
				if (node.type !== 'EnumStringMember') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isEnumDefaultedMember(node, opts) {
				if (!node) return false
				if (node.type !== 'EnumDefaultedMember') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isIndexedAccessType(node, opts) {
				if (!node) return false
				if (node.type !== 'IndexedAccessType') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isOptionalIndexedAccessType(node, opts) {
				if (!node) return false
				if (node.type !== 'OptionalIndexedAccessType') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isJSXAttribute(node, opts) {
				if (!node) return false
				if (node.type !== 'JSXAttribute') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isJSXClosingElement(node, opts) {
				if (!node) return false
				if (node.type !== 'JSXClosingElement') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isJSXElement(node, opts) {
				if (!node) return false
				if (node.type !== 'JSXElement') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isJSXEmptyExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'JSXEmptyExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isJSXExpressionContainer(node, opts) {
				if (!node) return false
				if (node.type !== 'JSXExpressionContainer') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isJSXSpreadChild(node, opts) {
				if (!node) return false
				if (node.type !== 'JSXSpreadChild') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isJSXIdentifier(node, opts) {
				if (!node) return false
				if (node.type !== 'JSXIdentifier') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isJSXMemberExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'JSXMemberExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isJSXNamespacedName(node, opts) {
				if (!node) return false
				if (node.type !== 'JSXNamespacedName') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isJSXOpeningElement(node, opts) {
				if (!node) return false
				if (node.type !== 'JSXOpeningElement') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isJSXSpreadAttribute(node, opts) {
				if (!node) return false
				if (node.type !== 'JSXSpreadAttribute') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isJSXText(node, opts) {
				if (!node) return false
				if (node.type !== 'JSXText') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isJSXFragment(node, opts) {
				if (!node) return false
				if (node.type !== 'JSXFragment') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isJSXOpeningFragment(node, opts) {
				if (!node) return false
				if (node.type !== 'JSXOpeningFragment') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isJSXClosingFragment(node, opts) {
				if (!node) return false
				if (node.type !== 'JSXClosingFragment') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isNoop(node, opts) {
				if (!node) return false
				if (node.type !== 'Noop') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isPlaceholder(node, opts) {
				if (!node) return false
				if (node.type !== 'Placeholder') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isV8IntrinsicIdentifier(node, opts) {
				if (!node) return false
				if (node.type !== 'V8IntrinsicIdentifier') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isArgumentPlaceholder(node, opts) {
				if (!node) return false
				if (node.type !== 'ArgumentPlaceholder') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isBindExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'BindExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isDecorator(node, opts) {
				if (!node) return false
				if (node.type !== 'Decorator') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isDoExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'DoExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isExportDefaultSpecifier(node, opts) {
				if (!node) return false
				if (node.type !== 'ExportDefaultSpecifier') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isRecordExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'RecordExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTupleExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'TupleExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isDecimalLiteral(node, opts) {
				if (!node) return false
				if (node.type !== 'DecimalLiteral') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isModuleExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'ModuleExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTopicReference(node, opts) {
				if (!node) return false
				if (node.type !== 'TopicReference') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isPipelineTopicExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'PipelineTopicExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isPipelineBareFunction(node, opts) {
				if (!node) return false
				if (node.type !== 'PipelineBareFunction') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isPipelinePrimaryTopicReference(node, opts) {
				if (!node) return false
				if (node.type !== 'PipelinePrimaryTopicReference') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSParameterProperty(node, opts) {
				if (!node) return false
				if (node.type !== 'TSParameterProperty') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSDeclareFunction(node, opts) {
				if (!node) return false
				if (node.type !== 'TSDeclareFunction') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSDeclareMethod(node, opts) {
				if (!node) return false
				if (node.type !== 'TSDeclareMethod') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSQualifiedName(node, opts) {
				if (!node) return false
				if (node.type !== 'TSQualifiedName') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSCallSignatureDeclaration(node, opts) {
				if (!node) return false
				if (node.type !== 'TSCallSignatureDeclaration') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSConstructSignatureDeclaration(node, opts) {
				if (!node) return false
				if (node.type !== 'TSConstructSignatureDeclaration') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSPropertySignature(node, opts) {
				if (!node) return false
				if (node.type !== 'TSPropertySignature') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSMethodSignature(node, opts) {
				if (!node) return false
				if (node.type !== 'TSMethodSignature') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSIndexSignature(node, opts) {
				if (!node) return false
				if (node.type !== 'TSIndexSignature') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSAnyKeyword(node, opts) {
				if (!node) return false
				if (node.type !== 'TSAnyKeyword') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSBooleanKeyword(node, opts) {
				if (!node) return false
				if (node.type !== 'TSBooleanKeyword') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSBigIntKeyword(node, opts) {
				if (!node) return false
				if (node.type !== 'TSBigIntKeyword') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSIntrinsicKeyword(node, opts) {
				if (!node) return false
				if (node.type !== 'TSIntrinsicKeyword') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSNeverKeyword(node, opts) {
				if (!node) return false
				if (node.type !== 'TSNeverKeyword') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSNullKeyword(node, opts) {
				if (!node) return false
				if (node.type !== 'TSNullKeyword') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSNumberKeyword(node, opts) {
				if (!node) return false
				if (node.type !== 'TSNumberKeyword') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSObjectKeyword(node, opts) {
				if (!node) return false
				if (node.type !== 'TSObjectKeyword') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSStringKeyword(node, opts) {
				if (!node) return false
				if (node.type !== 'TSStringKeyword') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSSymbolKeyword(node, opts) {
				if (!node) return false
				if (node.type !== 'TSSymbolKeyword') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSUndefinedKeyword(node, opts) {
				if (!node) return false
				if (node.type !== 'TSUndefinedKeyword') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSUnknownKeyword(node, opts) {
				if (!node) return false
				if (node.type !== 'TSUnknownKeyword') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSVoidKeyword(node, opts) {
				if (!node) return false
				if (node.type !== 'TSVoidKeyword') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSThisType(node, opts) {
				if (!node) return false
				if (node.type !== 'TSThisType') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSFunctionType(node, opts) {
				if (!node) return false
				if (node.type !== 'TSFunctionType') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSConstructorType(node, opts) {
				if (!node) return false
				if (node.type !== 'TSConstructorType') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSTypeReference(node, opts) {
				if (!node) return false
				if (node.type !== 'TSTypeReference') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSTypePredicate(node, opts) {
				if (!node) return false
				if (node.type !== 'TSTypePredicate') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSTypeQuery(node, opts) {
				if (!node) return false
				if (node.type !== 'TSTypeQuery') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSTypeLiteral(node, opts) {
				if (!node) return false
				if (node.type !== 'TSTypeLiteral') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSArrayType(node, opts) {
				if (!node) return false
				if (node.type !== 'TSArrayType') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSTupleType(node, opts) {
				if (!node) return false
				if (node.type !== 'TSTupleType') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSOptionalType(node, opts) {
				if (!node) return false
				if (node.type !== 'TSOptionalType') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSRestType(node, opts) {
				if (!node) return false
				if (node.type !== 'TSRestType') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSNamedTupleMember(node, opts) {
				if (!node) return false
				if (node.type !== 'TSNamedTupleMember') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSUnionType(node, opts) {
				if (!node) return false
				if (node.type !== 'TSUnionType') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSIntersectionType(node, opts) {
				if (!node) return false
				if (node.type !== 'TSIntersectionType') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSConditionalType(node, opts) {
				if (!node) return false
				if (node.type !== 'TSConditionalType') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSInferType(node, opts) {
				if (!node) return false
				if (node.type !== 'TSInferType') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSParenthesizedType(node, opts) {
				if (!node) return false
				if (node.type !== 'TSParenthesizedType') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSTypeOperator(node, opts) {
				if (!node) return false
				if (node.type !== 'TSTypeOperator') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSIndexedAccessType(node, opts) {
				if (!node) return false
				if (node.type !== 'TSIndexedAccessType') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSMappedType(node, opts) {
				if (!node) return false
				if (node.type !== 'TSMappedType') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSTemplateLiteralType(node, opts) {
				if (!node) return false
				if (node.type !== 'TSTemplateLiteralType') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSLiteralType(node, opts) {
				if (!node) return false
				if (node.type !== 'TSLiteralType') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSExpressionWithTypeArguments(node, opts) {
				if (!node) return false
				if (node.type !== 'TSExpressionWithTypeArguments') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSInterfaceDeclaration(node, opts) {
				if (!node) return false
				if (node.type !== 'TSInterfaceDeclaration') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSInterfaceBody(node, opts) {
				if (!node) return false
				if (node.type !== 'TSInterfaceBody') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSTypeAliasDeclaration(node, opts) {
				if (!node) return false
				if (node.type !== 'TSTypeAliasDeclaration') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSInstantiationExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'TSInstantiationExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSAsExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'TSAsExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSSatisfiesExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'TSSatisfiesExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSTypeAssertion(node, opts) {
				if (!node) return false
				if (node.type !== 'TSTypeAssertion') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSEnumBody(node, opts) {
				if (!node) return false
				if (node.type !== 'TSEnumBody') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSEnumDeclaration(node, opts) {
				if (!node) return false
				if (node.type !== 'TSEnumDeclaration') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSEnumMember(node, opts) {
				if (!node) return false
				if (node.type !== 'TSEnumMember') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSModuleDeclaration(node, opts) {
				if (!node) return false
				if (node.type !== 'TSModuleDeclaration') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSModuleBlock(node, opts) {
				if (!node) return false
				if (node.type !== 'TSModuleBlock') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSImportType(node, opts) {
				if (!node) return false
				if (node.type !== 'TSImportType') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSImportEqualsDeclaration(node, opts) {
				if (!node) return false
				if (node.type !== 'TSImportEqualsDeclaration') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSExternalModuleReference(node, opts) {
				if (!node) return false
				if (node.type !== 'TSExternalModuleReference') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSNonNullExpression(node, opts) {
				if (!node) return false
				if (node.type !== 'TSNonNullExpression') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSExportAssignment(node, opts) {
				if (!node) return false
				if (node.type !== 'TSExportAssignment') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSNamespaceExportDeclaration(node, opts) {
				if (!node) return false
				if (node.type !== 'TSNamespaceExportDeclaration') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSTypeAnnotation(node, opts) {
				if (!node) return false
				if (node.type !== 'TSTypeAnnotation') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSTypeParameterInstantiation(node, opts) {
				if (!node) return false
				if (node.type !== 'TSTypeParameterInstantiation') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSTypeParameterDeclaration(node, opts) {
				if (!node) return false
				if (node.type !== 'TSTypeParameterDeclaration') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSTypeParameter(node, opts) {
				if (!node) return false
				if (node.type !== 'TSTypeParameter') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isStandardized(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'ArrayExpression':
					case 'AssignmentExpression':
					case 'BinaryExpression':
					case 'InterpreterDirective':
					case 'Directive':
					case 'DirectiveLiteral':
					case 'BlockStatement':
					case 'BreakStatement':
					case 'CallExpression':
					case 'CatchClause':
					case 'ConditionalExpression':
					case 'ContinueStatement':
					case 'DebuggerStatement':
					case 'DoWhileStatement':
					case 'EmptyStatement':
					case 'ExpressionStatement':
					case 'File':
					case 'ForInStatement':
					case 'ForStatement':
					case 'FunctionDeclaration':
					case 'FunctionExpression':
					case 'Identifier':
					case 'IfStatement':
					case 'LabeledStatement':
					case 'StringLiteral':
					case 'NumericLiteral':
					case 'NullLiteral':
					case 'BooleanLiteral':
					case 'RegExpLiteral':
					case 'LogicalExpression':
					case 'MemberExpression':
					case 'NewExpression':
					case 'Program':
					case 'ObjectExpression':
					case 'ObjectMethod':
					case 'ObjectProperty':
					case 'RestElement':
					case 'ReturnStatement':
					case 'SequenceExpression':
					case 'ParenthesizedExpression':
					case 'SwitchCase':
					case 'SwitchStatement':
					case 'ThisExpression':
					case 'ThrowStatement':
					case 'TryStatement':
					case 'UnaryExpression':
					case 'UpdateExpression':
					case 'VariableDeclaration':
					case 'VariableDeclarator':
					case 'WhileStatement':
					case 'WithStatement':
					case 'AssignmentPattern':
					case 'ArrayPattern':
					case 'ArrowFunctionExpression':
					case 'ClassBody':
					case 'ClassExpression':
					case 'ClassDeclaration':
					case 'ExportAllDeclaration':
					case 'ExportDefaultDeclaration':
					case 'ExportNamedDeclaration':
					case 'ExportSpecifier':
					case 'ForOfStatement':
					case 'ImportDeclaration':
					case 'ImportDefaultSpecifier':
					case 'ImportNamespaceSpecifier':
					case 'ImportSpecifier':
					case 'ImportExpression':
					case 'MetaProperty':
					case 'ClassMethod':
					case 'ObjectPattern':
					case 'SpreadElement':
					case 'Super':
					case 'TaggedTemplateExpression':
					case 'TemplateElement':
					case 'TemplateLiteral':
					case 'YieldExpression':
					case 'AwaitExpression':
					case 'Import':
					case 'BigIntLiteral':
					case 'ExportNamespaceSpecifier':
					case 'OptionalMemberExpression':
					case 'OptionalCallExpression':
					case 'ClassProperty':
					case 'ClassAccessorProperty':
					case 'ClassPrivateProperty':
					case 'ClassPrivateMethod':
					case 'PrivateName':
					case 'StaticBlock':
					case 'ImportAttribute':
						break
					case 'Placeholder':
						switch (node.expectedNode) {
							case 'Identifier':
							case 'StringLiteral':
							case 'BlockStatement':
							case 'ClassBody':
								break
							default:
								return false
						}
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isExpression(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'ArrayExpression':
					case 'AssignmentExpression':
					case 'BinaryExpression':
					case 'CallExpression':
					case 'ConditionalExpression':
					case 'FunctionExpression':
					case 'Identifier':
					case 'StringLiteral':
					case 'NumericLiteral':
					case 'NullLiteral':
					case 'BooleanLiteral':
					case 'RegExpLiteral':
					case 'LogicalExpression':
					case 'MemberExpression':
					case 'NewExpression':
					case 'ObjectExpression':
					case 'SequenceExpression':
					case 'ParenthesizedExpression':
					case 'ThisExpression':
					case 'UnaryExpression':
					case 'UpdateExpression':
					case 'ArrowFunctionExpression':
					case 'ClassExpression':
					case 'ImportExpression':
					case 'MetaProperty':
					case 'Super':
					case 'TaggedTemplateExpression':
					case 'TemplateLiteral':
					case 'YieldExpression':
					case 'AwaitExpression':
					case 'Import':
					case 'BigIntLiteral':
					case 'OptionalMemberExpression':
					case 'OptionalCallExpression':
					case 'TypeCastExpression':
					case 'JSXElement':
					case 'JSXFragment':
					case 'BindExpression':
					case 'DoExpression':
					case 'RecordExpression':
					case 'TupleExpression':
					case 'DecimalLiteral':
					case 'ModuleExpression':
					case 'TopicReference':
					case 'PipelineTopicExpression':
					case 'PipelineBareFunction':
					case 'PipelinePrimaryTopicReference':
					case 'TSInstantiationExpression':
					case 'TSAsExpression':
					case 'TSSatisfiesExpression':
					case 'TSTypeAssertion':
					case 'TSNonNullExpression':
						break
					case 'Placeholder':
						switch (node.expectedNode) {
							case 'Expression':
							case 'Identifier':
							case 'StringLiteral':
								break
							default:
								return false
						}
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isBinary(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'BinaryExpression':
					case 'LogicalExpression':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isScopable(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'BlockStatement':
					case 'CatchClause':
					case 'DoWhileStatement':
					case 'ForInStatement':
					case 'ForStatement':
					case 'FunctionDeclaration':
					case 'FunctionExpression':
					case 'Program':
					case 'ObjectMethod':
					case 'SwitchStatement':
					case 'WhileStatement':
					case 'ArrowFunctionExpression':
					case 'ClassExpression':
					case 'ClassDeclaration':
					case 'ForOfStatement':
					case 'ClassMethod':
					case 'ClassPrivateMethod':
					case 'StaticBlock':
					case 'TSModuleBlock':
						break
					case 'Placeholder':
						if (node.expectedNode === 'BlockStatement') break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isBlockParent(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'BlockStatement':
					case 'CatchClause':
					case 'DoWhileStatement':
					case 'ForInStatement':
					case 'ForStatement':
					case 'FunctionDeclaration':
					case 'FunctionExpression':
					case 'Program':
					case 'ObjectMethod':
					case 'SwitchStatement':
					case 'WhileStatement':
					case 'ArrowFunctionExpression':
					case 'ForOfStatement':
					case 'ClassMethod':
					case 'ClassPrivateMethod':
					case 'StaticBlock':
					case 'TSModuleBlock':
						break
					case 'Placeholder':
						if (node.expectedNode === 'BlockStatement') break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isBlock(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'BlockStatement':
					case 'Program':
					case 'TSModuleBlock':
						break
					case 'Placeholder':
						if (node.expectedNode === 'BlockStatement') break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isStatement(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'BlockStatement':
					case 'BreakStatement':
					case 'ContinueStatement':
					case 'DebuggerStatement':
					case 'DoWhileStatement':
					case 'EmptyStatement':
					case 'ExpressionStatement':
					case 'ForInStatement':
					case 'ForStatement':
					case 'FunctionDeclaration':
					case 'IfStatement':
					case 'LabeledStatement':
					case 'ReturnStatement':
					case 'SwitchStatement':
					case 'ThrowStatement':
					case 'TryStatement':
					case 'VariableDeclaration':
					case 'WhileStatement':
					case 'WithStatement':
					case 'ClassDeclaration':
					case 'ExportAllDeclaration':
					case 'ExportDefaultDeclaration':
					case 'ExportNamedDeclaration':
					case 'ForOfStatement':
					case 'ImportDeclaration':
					case 'DeclareClass':
					case 'DeclareFunction':
					case 'DeclareInterface':
					case 'DeclareModule':
					case 'DeclareModuleExports':
					case 'DeclareTypeAlias':
					case 'DeclareOpaqueType':
					case 'DeclareVariable':
					case 'DeclareExportDeclaration':
					case 'DeclareExportAllDeclaration':
					case 'InterfaceDeclaration':
					case 'OpaqueType':
					case 'TypeAlias':
					case 'EnumDeclaration':
					case 'TSDeclareFunction':
					case 'TSInterfaceDeclaration':
					case 'TSTypeAliasDeclaration':
					case 'TSEnumDeclaration':
					case 'TSModuleDeclaration':
					case 'TSImportEqualsDeclaration':
					case 'TSExportAssignment':
					case 'TSNamespaceExportDeclaration':
						break
					case 'Placeholder':
						switch (node.expectedNode) {
							case 'Statement':
							case 'Declaration':
							case 'BlockStatement':
								break
							default:
								return false
						}
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTerminatorless(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'BreakStatement':
					case 'ContinueStatement':
					case 'ReturnStatement':
					case 'ThrowStatement':
					case 'YieldExpression':
					case 'AwaitExpression':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isCompletionStatement(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'BreakStatement':
					case 'ContinueStatement':
					case 'ReturnStatement':
					case 'ThrowStatement':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isConditional(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'ConditionalExpression':
					case 'IfStatement':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isLoop(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'DoWhileStatement':
					case 'ForInStatement':
					case 'ForStatement':
					case 'WhileStatement':
					case 'ForOfStatement':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isWhile(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'DoWhileStatement':
					case 'WhileStatement':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isExpressionWrapper(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'ExpressionStatement':
					case 'ParenthesizedExpression':
					case 'TypeCastExpression':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isFor(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'ForInStatement':
					case 'ForStatement':
					case 'ForOfStatement':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isForXStatement(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'ForInStatement':
					case 'ForOfStatement':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isFunction(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'FunctionDeclaration':
					case 'FunctionExpression':
					case 'ObjectMethod':
					case 'ArrowFunctionExpression':
					case 'ClassMethod':
					case 'ClassPrivateMethod':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isFunctionParent(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'FunctionDeclaration':
					case 'FunctionExpression':
					case 'ObjectMethod':
					case 'ArrowFunctionExpression':
					case 'ClassMethod':
					case 'ClassPrivateMethod':
					case 'StaticBlock':
					case 'TSModuleBlock':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isPureish(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'FunctionDeclaration':
					case 'FunctionExpression':
					case 'StringLiteral':
					case 'NumericLiteral':
					case 'NullLiteral':
					case 'BooleanLiteral':
					case 'RegExpLiteral':
					case 'ArrowFunctionExpression':
					case 'BigIntLiteral':
					case 'DecimalLiteral':
						break
					case 'Placeholder':
						if (node.expectedNode === 'StringLiteral') break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isDeclaration(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'FunctionDeclaration':
					case 'VariableDeclaration':
					case 'ClassDeclaration':
					case 'ExportAllDeclaration':
					case 'ExportDefaultDeclaration':
					case 'ExportNamedDeclaration':
					case 'ImportDeclaration':
					case 'DeclareClass':
					case 'DeclareFunction':
					case 'DeclareInterface':
					case 'DeclareModule':
					case 'DeclareModuleExports':
					case 'DeclareTypeAlias':
					case 'DeclareOpaqueType':
					case 'DeclareVariable':
					case 'DeclareExportDeclaration':
					case 'DeclareExportAllDeclaration':
					case 'InterfaceDeclaration':
					case 'OpaqueType':
					case 'TypeAlias':
					case 'EnumDeclaration':
					case 'TSDeclareFunction':
					case 'TSInterfaceDeclaration':
					case 'TSTypeAliasDeclaration':
					case 'TSEnumDeclaration':
					case 'TSModuleDeclaration':
					case 'TSImportEqualsDeclaration':
						break
					case 'Placeholder':
						if (node.expectedNode === 'Declaration') break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isPatternLike(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'Identifier':
					case 'RestElement':
					case 'AssignmentPattern':
					case 'ArrayPattern':
					case 'ObjectPattern':
					case 'TSAsExpression':
					case 'TSSatisfiesExpression':
					case 'TSTypeAssertion':
					case 'TSNonNullExpression':
						break
					case 'Placeholder':
						switch (node.expectedNode) {
							case 'Pattern':
							case 'Identifier':
								break
							default:
								return false
						}
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isLVal(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'Identifier':
					case 'MemberExpression':
					case 'RestElement':
					case 'AssignmentPattern':
					case 'ArrayPattern':
					case 'ObjectPattern':
					case 'TSParameterProperty':
					case 'TSAsExpression':
					case 'TSSatisfiesExpression':
					case 'TSTypeAssertion':
					case 'TSNonNullExpression':
						break
					case 'Placeholder':
						switch (node.expectedNode) {
							case 'Pattern':
							case 'Identifier':
								break
							default:
								return false
						}
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSEntityName(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'Identifier':
					case 'TSQualifiedName':
						break
					case 'Placeholder':
						if (node.expectedNode === 'Identifier') break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isLiteral(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'StringLiteral':
					case 'NumericLiteral':
					case 'NullLiteral':
					case 'BooleanLiteral':
					case 'RegExpLiteral':
					case 'TemplateLiteral':
					case 'BigIntLiteral':
					case 'DecimalLiteral':
						break
					case 'Placeholder':
						if (node.expectedNode === 'StringLiteral') break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isImmutable(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'StringLiteral':
					case 'NumericLiteral':
					case 'NullLiteral':
					case 'BooleanLiteral':
					case 'BigIntLiteral':
					case 'JSXAttribute':
					case 'JSXClosingElement':
					case 'JSXElement':
					case 'JSXExpressionContainer':
					case 'JSXSpreadChild':
					case 'JSXOpeningElement':
					case 'JSXText':
					case 'JSXFragment':
					case 'JSXOpeningFragment':
					case 'JSXClosingFragment':
					case 'DecimalLiteral':
						break
					case 'Placeholder':
						if (node.expectedNode === 'StringLiteral') break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isUserWhitespacable(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'ObjectMethod':
					case 'ObjectProperty':
					case 'ObjectTypeInternalSlot':
					case 'ObjectTypeCallProperty':
					case 'ObjectTypeIndexer':
					case 'ObjectTypeProperty':
					case 'ObjectTypeSpreadProperty':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isMethod(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'ObjectMethod':
					case 'ClassMethod':
					case 'ClassPrivateMethod':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isObjectMember(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'ObjectMethod':
					case 'ObjectProperty':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isProperty(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'ObjectProperty':
					case 'ClassProperty':
					case 'ClassAccessorProperty':
					case 'ClassPrivateProperty':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isUnaryLike(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'UnaryExpression':
					case 'SpreadElement':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isPattern(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'AssignmentPattern':
					case 'ArrayPattern':
					case 'ObjectPattern':
						break
					case 'Placeholder':
						if (node.expectedNode === 'Pattern') break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isClass(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'ClassExpression':
					case 'ClassDeclaration':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isImportOrExportDeclaration(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'ExportAllDeclaration':
					case 'ExportDefaultDeclaration':
					case 'ExportNamedDeclaration':
					case 'ImportDeclaration':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isExportDeclaration(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'ExportAllDeclaration':
					case 'ExportDefaultDeclaration':
					case 'ExportNamedDeclaration':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isModuleSpecifier(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'ExportSpecifier':
					case 'ImportDefaultSpecifier':
					case 'ImportNamespaceSpecifier':
					case 'ImportSpecifier':
					case 'ExportNamespaceSpecifier':
					case 'ExportDefaultSpecifier':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isAccessor(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'ClassAccessorProperty':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isPrivate(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'ClassPrivateProperty':
					case 'ClassPrivateMethod':
					case 'PrivateName':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isFlow(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'AnyTypeAnnotation':
					case 'ArrayTypeAnnotation':
					case 'BooleanTypeAnnotation':
					case 'BooleanLiteralTypeAnnotation':
					case 'NullLiteralTypeAnnotation':
					case 'ClassImplements':
					case 'DeclareClass':
					case 'DeclareFunction':
					case 'DeclareInterface':
					case 'DeclareModule':
					case 'DeclareModuleExports':
					case 'DeclareTypeAlias':
					case 'DeclareOpaqueType':
					case 'DeclareVariable':
					case 'DeclareExportDeclaration':
					case 'DeclareExportAllDeclaration':
					case 'DeclaredPredicate':
					case 'ExistsTypeAnnotation':
					case 'FunctionTypeAnnotation':
					case 'FunctionTypeParam':
					case 'GenericTypeAnnotation':
					case 'InferredPredicate':
					case 'InterfaceExtends':
					case 'InterfaceDeclaration':
					case 'InterfaceTypeAnnotation':
					case 'IntersectionTypeAnnotation':
					case 'MixedTypeAnnotation':
					case 'EmptyTypeAnnotation':
					case 'NullableTypeAnnotation':
					case 'NumberLiteralTypeAnnotation':
					case 'NumberTypeAnnotation':
					case 'ObjectTypeAnnotation':
					case 'ObjectTypeInternalSlot':
					case 'ObjectTypeCallProperty':
					case 'ObjectTypeIndexer':
					case 'ObjectTypeProperty':
					case 'ObjectTypeSpreadProperty':
					case 'OpaqueType':
					case 'QualifiedTypeIdentifier':
					case 'StringLiteralTypeAnnotation':
					case 'StringTypeAnnotation':
					case 'SymbolTypeAnnotation':
					case 'ThisTypeAnnotation':
					case 'TupleTypeAnnotation':
					case 'TypeofTypeAnnotation':
					case 'TypeAlias':
					case 'TypeAnnotation':
					case 'TypeCastExpression':
					case 'TypeParameter':
					case 'TypeParameterDeclaration':
					case 'TypeParameterInstantiation':
					case 'UnionTypeAnnotation':
					case 'Variance':
					case 'VoidTypeAnnotation':
					case 'EnumDeclaration':
					case 'EnumBooleanBody':
					case 'EnumNumberBody':
					case 'EnumStringBody':
					case 'EnumSymbolBody':
					case 'EnumBooleanMember':
					case 'EnumNumberMember':
					case 'EnumStringMember':
					case 'EnumDefaultedMember':
					case 'IndexedAccessType':
					case 'OptionalIndexedAccessType':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isFlowType(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'AnyTypeAnnotation':
					case 'ArrayTypeAnnotation':
					case 'BooleanTypeAnnotation':
					case 'BooleanLiteralTypeAnnotation':
					case 'NullLiteralTypeAnnotation':
					case 'ExistsTypeAnnotation':
					case 'FunctionTypeAnnotation':
					case 'GenericTypeAnnotation':
					case 'InterfaceTypeAnnotation':
					case 'IntersectionTypeAnnotation':
					case 'MixedTypeAnnotation':
					case 'EmptyTypeAnnotation':
					case 'NullableTypeAnnotation':
					case 'NumberLiteralTypeAnnotation':
					case 'NumberTypeAnnotation':
					case 'ObjectTypeAnnotation':
					case 'StringLiteralTypeAnnotation':
					case 'StringTypeAnnotation':
					case 'SymbolTypeAnnotation':
					case 'ThisTypeAnnotation':
					case 'TupleTypeAnnotation':
					case 'TypeofTypeAnnotation':
					case 'UnionTypeAnnotation':
					case 'VoidTypeAnnotation':
					case 'IndexedAccessType':
					case 'OptionalIndexedAccessType':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isFlowBaseAnnotation(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'AnyTypeAnnotation':
					case 'BooleanTypeAnnotation':
					case 'NullLiteralTypeAnnotation':
					case 'MixedTypeAnnotation':
					case 'EmptyTypeAnnotation':
					case 'NumberTypeAnnotation':
					case 'StringTypeAnnotation':
					case 'SymbolTypeAnnotation':
					case 'ThisTypeAnnotation':
					case 'VoidTypeAnnotation':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isFlowDeclaration(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'DeclareClass':
					case 'DeclareFunction':
					case 'DeclareInterface':
					case 'DeclareModule':
					case 'DeclareModuleExports':
					case 'DeclareTypeAlias':
					case 'DeclareOpaqueType':
					case 'DeclareVariable':
					case 'DeclareExportDeclaration':
					case 'DeclareExportAllDeclaration':
					case 'InterfaceDeclaration':
					case 'OpaqueType':
					case 'TypeAlias':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isFlowPredicate(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'DeclaredPredicate':
					case 'InferredPredicate':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isEnumBody(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'EnumBooleanBody':
					case 'EnumNumberBody':
					case 'EnumStringBody':
					case 'EnumSymbolBody':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isEnumMember(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'EnumBooleanMember':
					case 'EnumNumberMember':
					case 'EnumStringMember':
					case 'EnumDefaultedMember':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isJSX(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'JSXAttribute':
					case 'JSXClosingElement':
					case 'JSXElement':
					case 'JSXEmptyExpression':
					case 'JSXExpressionContainer':
					case 'JSXSpreadChild':
					case 'JSXIdentifier':
					case 'JSXMemberExpression':
					case 'JSXNamespacedName':
					case 'JSXOpeningElement':
					case 'JSXSpreadAttribute':
					case 'JSXText':
					case 'JSXFragment':
					case 'JSXOpeningFragment':
					case 'JSXClosingFragment':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isMiscellaneous(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'Noop':
					case 'Placeholder':
					case 'V8IntrinsicIdentifier':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTypeScript(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'TSParameterProperty':
					case 'TSDeclareFunction':
					case 'TSDeclareMethod':
					case 'TSQualifiedName':
					case 'TSCallSignatureDeclaration':
					case 'TSConstructSignatureDeclaration':
					case 'TSPropertySignature':
					case 'TSMethodSignature':
					case 'TSIndexSignature':
					case 'TSAnyKeyword':
					case 'TSBooleanKeyword':
					case 'TSBigIntKeyword':
					case 'TSIntrinsicKeyword':
					case 'TSNeverKeyword':
					case 'TSNullKeyword':
					case 'TSNumberKeyword':
					case 'TSObjectKeyword':
					case 'TSStringKeyword':
					case 'TSSymbolKeyword':
					case 'TSUndefinedKeyword':
					case 'TSUnknownKeyword':
					case 'TSVoidKeyword':
					case 'TSThisType':
					case 'TSFunctionType':
					case 'TSConstructorType':
					case 'TSTypeReference':
					case 'TSTypePredicate':
					case 'TSTypeQuery':
					case 'TSTypeLiteral':
					case 'TSArrayType':
					case 'TSTupleType':
					case 'TSOptionalType':
					case 'TSRestType':
					case 'TSNamedTupleMember':
					case 'TSUnionType':
					case 'TSIntersectionType':
					case 'TSConditionalType':
					case 'TSInferType':
					case 'TSParenthesizedType':
					case 'TSTypeOperator':
					case 'TSIndexedAccessType':
					case 'TSMappedType':
					case 'TSTemplateLiteralType':
					case 'TSLiteralType':
					case 'TSExpressionWithTypeArguments':
					case 'TSInterfaceDeclaration':
					case 'TSInterfaceBody':
					case 'TSTypeAliasDeclaration':
					case 'TSInstantiationExpression':
					case 'TSAsExpression':
					case 'TSSatisfiesExpression':
					case 'TSTypeAssertion':
					case 'TSEnumBody':
					case 'TSEnumDeclaration':
					case 'TSEnumMember':
					case 'TSModuleDeclaration':
					case 'TSModuleBlock':
					case 'TSImportType':
					case 'TSImportEqualsDeclaration':
					case 'TSExternalModuleReference':
					case 'TSNonNullExpression':
					case 'TSExportAssignment':
					case 'TSNamespaceExportDeclaration':
					case 'TSTypeAnnotation':
					case 'TSTypeParameterInstantiation':
					case 'TSTypeParameterDeclaration':
					case 'TSTypeParameter':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSTypeElement(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'TSCallSignatureDeclaration':
					case 'TSConstructSignatureDeclaration':
					case 'TSPropertySignature':
					case 'TSMethodSignature':
					case 'TSIndexSignature':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSType(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'TSAnyKeyword':
					case 'TSBooleanKeyword':
					case 'TSBigIntKeyword':
					case 'TSIntrinsicKeyword':
					case 'TSNeverKeyword':
					case 'TSNullKeyword':
					case 'TSNumberKeyword':
					case 'TSObjectKeyword':
					case 'TSStringKeyword':
					case 'TSSymbolKeyword':
					case 'TSUndefinedKeyword':
					case 'TSUnknownKeyword':
					case 'TSVoidKeyword':
					case 'TSThisType':
					case 'TSFunctionType':
					case 'TSConstructorType':
					case 'TSTypeReference':
					case 'TSTypePredicate':
					case 'TSTypeQuery':
					case 'TSTypeLiteral':
					case 'TSArrayType':
					case 'TSTupleType':
					case 'TSOptionalType':
					case 'TSRestType':
					case 'TSUnionType':
					case 'TSIntersectionType':
					case 'TSConditionalType':
					case 'TSInferType':
					case 'TSParenthesizedType':
					case 'TSTypeOperator':
					case 'TSIndexedAccessType':
					case 'TSMappedType':
					case 'TSTemplateLiteralType':
					case 'TSLiteralType':
					case 'TSExpressionWithTypeArguments':
					case 'TSImportType':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isTSBaseType(node, opts) {
				if (!node) return false
				switch (node.type) {
					case 'TSAnyKeyword':
					case 'TSBooleanKeyword':
					case 'TSBigIntKeyword':
					case 'TSIntrinsicKeyword':
					case 'TSNeverKeyword':
					case 'TSNullKeyword':
					case 'TSNumberKeyword':
					case 'TSObjectKeyword':
					case 'TSStringKeyword':
					case 'TSSymbolKeyword':
					case 'TSUndefinedKeyword':
					case 'TSUnknownKeyword':
					case 'TSVoidKeyword':
					case 'TSThisType':
					case 'TSTemplateLiteralType':
					case 'TSLiteralType':
						break
					default:
						return false
				}
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isNumberLiteral(node, opts) {
				;(0, _deprecationWarning.default)('isNumberLiteral', 'isNumericLiteral')
				if (!node) return false
				if (node.type !== 'NumberLiteral') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isRegexLiteral(node, opts) {
				;(0, _deprecationWarning.default)('isRegexLiteral', 'isRegExpLiteral')
				if (!node) return false
				if (node.type !== 'RegexLiteral') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isRestProperty(node, opts) {
				;(0, _deprecationWarning.default)('isRestProperty', 'isRestElement')
				if (!node) return false
				if (node.type !== 'RestProperty') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isSpreadProperty(node, opts) {
				;(0, _deprecationWarning.default)('isSpreadProperty', 'isSpreadElement')
				if (!node) return false
				if (node.type !== 'SpreadProperty') return false
				return opts == null || (0, _shallowEqual.default)(node, opts)
			}
			function isModuleDeclaration(node, opts) {
				;(0, _deprecationWarning.default)(
					'isModuleDeclaration',
					'isImportOrExportDeclaration',
				)
				return isImportOrExportDeclaration(node, opts)
			}

			//# sourceMappingURL=index.js.map

			/***/
		},

		/***/ 20051: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = is
			var _shallowEqual = __nccwpck_require__(56085)
			var _isType = __nccwpck_require__(53547)
			var _isPlaceholderType = __nccwpck_require__(49410)
			var _index = __nccwpck_require__(40910)
			function is(type, node, opts) {
				if (!node) return false
				const matches = (0, _isType.default)(node.type, type)
				if (!matches) {
					if (
						!opts &&
						node.type === 'Placeholder' &&
						type in _index.FLIPPED_ALIAS_KEYS
					) {
						return (0, _isPlaceholderType.default)(node.expectedNode, type)
					}
					return false
				}
				if (opts === undefined) {
					return true
				} else {
					return (0, _shallowEqual.default)(node, opts)
				}
			}

			//# sourceMappingURL=is.js.map

			/***/
		},

		/***/ 73998: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = isBinding
			var _getBindingIdentifiers = __nccwpck_require__(45300)
			function isBinding(node, parent, grandparent) {
				if (
					grandparent &&
					node.type === 'Identifier' &&
					parent.type === 'ObjectProperty' &&
					grandparent.type === 'ObjectExpression'
				) {
					return false
				}
				const keys = _getBindingIdentifiers.default.keys[parent.type]
				if (keys) {
					for (let i = 0; i < keys.length; i++) {
						const key = keys[i]
						const val = parent[key]
						if (Array.isArray(val)) {
							if (val.includes(node)) return true
						} else {
							if (val === node) return true
						}
					}
				}
				return false
			}

			//# sourceMappingURL=isBinding.js.map

			/***/
		},

		/***/ 942: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = isBlockScoped
			var _index = __nccwpck_require__(40741)
			var _isLet = __nccwpck_require__(57674)
			function isBlockScoped(node) {
				return (
					(0, _index.isFunctionDeclaration)(node) ||
					(0, _index.isClassDeclaration)(node) ||
					(0, _isLet.default)(node)
				)
			}

			//# sourceMappingURL=isBlockScoped.js.map

			/***/
		},

		/***/ 42343: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = isImmutable
			var _isType = __nccwpck_require__(53547)
			var _index = __nccwpck_require__(40741)
			function isImmutable(node) {
				if ((0, _isType.default)(node.type, 'Immutable')) return true
				if ((0, _index.isIdentifier)(node)) {
					if (node.name === 'undefined') {
						return true
					} else {
						return false
					}
				}
				return false
			}

			//# sourceMappingURL=isImmutable.js.map

			/***/
		},

		/***/ 57674: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = isLet
			var _index = __nccwpck_require__(40741)
			{
				var BLOCK_SCOPED_SYMBOL = Symbol.for('var used to be block scoped')
			}
			function isLet(node) {
				{
					return (
						(0, _index.isVariableDeclaration)(node) &&
						(node.kind !== 'var' || node[BLOCK_SCOPED_SYMBOL])
					)
				}
			}

			//# sourceMappingURL=isLet.js.map

			/***/
		},

		/***/ 84503: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = isNode
			var _index = __nccwpck_require__(40910)
			function isNode(node) {
				return !!(node && _index.VISITOR_KEYS[node.type])
			}

			//# sourceMappingURL=isNode.js.map

			/***/
		},

		/***/ 8338: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = isNodesEquivalent
			var _index = __nccwpck_require__(40910)
			function isNodesEquivalent(a, b) {
				if (
					typeof a !== 'object' ||
					typeof b !== 'object' ||
					a == null ||
					b == null
				) {
					return a === b
				}
				if (a.type !== b.type) {
					return false
				}
				const fields = Object.keys(_index.NODE_FIELDS[a.type] || a.type)
				const visitorKeys = _index.VISITOR_KEYS[a.type]
				for (const field of fields) {
					const val_a = a[field]
					const val_b = b[field]
					if (typeof val_a !== typeof val_b) {
						return false
					}
					if (val_a == null && val_b == null) {
						continue
					} else if (val_a == null || val_b == null) {
						return false
					}
					if (Array.isArray(val_a)) {
						if (!Array.isArray(val_b)) {
							return false
						}
						if (val_a.length !== val_b.length) {
							return false
						}
						for (let i = 0; i < val_a.length; i++) {
							if (!isNodesEquivalent(val_a[i], val_b[i])) {
								return false
							}
						}
						continue
					}
					if (
						typeof val_a === 'object' &&
						!(visitorKeys != null && visitorKeys.includes(field))
					) {
						for (const key of Object.keys(val_a)) {
							if (val_a[key] !== val_b[key]) {
								return false
							}
						}
						continue
					}
					if (!isNodesEquivalent(val_a, val_b)) {
						return false
					}
				}
				return true
			}

			//# sourceMappingURL=isNodesEquivalent.js.map

			/***/
		},

		/***/ 49410: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = isPlaceholderType
			var _index = __nccwpck_require__(40910)
			function isPlaceholderType(placeholderType, targetType) {
				if (placeholderType === targetType) return true
				const aliases = _index.PLACEHOLDERS_ALIAS[placeholderType]
				if (aliases != null && aliases.includes(targetType)) return true
				return false
			}

			//# sourceMappingURL=isPlaceholderType.js.map

			/***/
		},

		/***/ 89508: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = isReferenced
			function isReferenced(node, parent, grandparent) {
				switch (parent.type) {
					case 'MemberExpression':
					case 'OptionalMemberExpression':
						if (parent.property === node) {
							return !!parent.computed
						}
						return parent.object === node
					case 'JSXMemberExpression':
						return parent.object === node
					case 'VariableDeclarator':
						return parent.init === node
					case 'ArrowFunctionExpression':
						return parent.body === node
					case 'PrivateName':
						return false
					case 'ClassMethod':
					case 'ClassPrivateMethod':
					case 'ObjectMethod':
						if (parent.key === node) {
							return !!parent.computed
						}
						return false
					case 'ObjectProperty':
						if (parent.key === node) {
							return !!parent.computed
						}
						return !grandparent || grandparent.type !== 'ObjectPattern'
					case 'ClassProperty':
					case 'ClassAccessorProperty':
						if (parent.key === node) {
							return !!parent.computed
						}
						return true
					case 'ClassPrivateProperty':
						return parent.key !== node
					case 'ClassDeclaration':
					case 'ClassExpression':
						return parent.superClass === node
					case 'AssignmentExpression':
						return parent.right === node
					case 'AssignmentPattern':
						return parent.right === node
					case 'LabeledStatement':
						return false
					case 'CatchClause':
						return false
					case 'RestElement':
						return false
					case 'BreakStatement':
					case 'ContinueStatement':
						return false
					case 'FunctionDeclaration':
					case 'FunctionExpression':
						return false
					case 'ExportNamespaceSpecifier':
					case 'ExportDefaultSpecifier':
						return false
					case 'ExportSpecifier':
						if (grandparent != null && grandparent.source) {
							return false
						}
						return parent.local === node
					case 'ImportDefaultSpecifier':
					case 'ImportNamespaceSpecifier':
					case 'ImportSpecifier':
						return false
					case 'ImportAttribute':
						return false
					case 'JSXAttribute':
						return false
					case 'ObjectPattern':
					case 'ArrayPattern':
						return false
					case 'MetaProperty':
						return false
					case 'ObjectTypeProperty':
						return parent.key !== node
					case 'TSEnumMember':
						return parent.id !== node
					case 'TSPropertySignature':
						if (parent.key === node) {
							return !!parent.computed
						}
						return true
				}
				return true
			}

			//# sourceMappingURL=isReferenced.js.map

			/***/
		},

		/***/ 33583: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = isScope
			var _index = __nccwpck_require__(40741)
			function isScope(node, parent) {
				if (
					(0, _index.isBlockStatement)(node) &&
					((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))
				) {
					return false
				}
				if (
					(0, _index.isPattern)(node) &&
					((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))
				) {
					return true
				}
				return (0, _index.isScopable)(node)
			}

			//# sourceMappingURL=isScope.js.map

			/***/
		},

		/***/ 64394: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = isSpecifierDefault
			var _index = __nccwpck_require__(40741)
			function isSpecifierDefault(specifier) {
				return (
					(0, _index.isImportDefaultSpecifier)(specifier) ||
					(0, _index.isIdentifier)(specifier.imported || specifier.exported, {
						name: 'default',
					})
				)
			}

			//# sourceMappingURL=isSpecifierDefault.js.map

			/***/
		},

		/***/ 53547: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = isType
			var _index = __nccwpck_require__(40910)
			function isType(nodeType, targetType) {
				if (nodeType === targetType) return true
				if (nodeType == null) return false
				if (_index.ALIAS_KEYS[targetType]) return false
				const aliases = _index.FLIPPED_ALIAS_KEYS[targetType]
				if (aliases != null && aliases.includes(nodeType)) return true
				return false
			}

			//# sourceMappingURL=isType.js.map

			/***/
		},

		/***/ 40267: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = isValidES3Identifier
			var _isValidIdentifier = __nccwpck_require__(66030)
			const RESERVED_WORDS_ES3_ONLY = new Set([
				'abstract',
				'boolean',
				'byte',
				'char',
				'double',
				'enum',
				'final',
				'float',
				'goto',
				'implements',
				'int',
				'interface',
				'long',
				'native',
				'package',
				'private',
				'protected',
				'public',
				'short',
				'static',
				'synchronized',
				'throws',
				'transient',
				'volatile',
			])
			function isValidES3Identifier(name) {
				return (
					(0, _isValidIdentifier.default)(name) &&
					!RESERVED_WORDS_ES3_ONLY.has(name)
				)
			}

			//# sourceMappingURL=isValidES3Identifier.js.map

			/***/
		},

		/***/ 66030: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = isValidIdentifier
			var _helperValidatorIdentifier = __nccwpck_require__(76599)
			function isValidIdentifier(name, reserved = true) {
				if (typeof name !== 'string') return false
				if (reserved) {
					if (
						(0, _helperValidatorIdentifier.isKeyword)(name) ||
						(0, _helperValidatorIdentifier.isStrictReservedWord)(name, true)
					) {
						return false
					}
				}
				return (0, _helperValidatorIdentifier.isIdentifierName)(name)
			}

			//# sourceMappingURL=isValidIdentifier.js.map

			/***/
		},

		/***/ 21566: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = isVar
			var _index = __nccwpck_require__(40741)
			{
				var BLOCK_SCOPED_SYMBOL = Symbol.for('var used to be block scoped')
			}
			function isVar(node) {
				{
					return (
						(0, _index.isVariableDeclaration)(node, {
							kind: 'var',
						}) && !node[BLOCK_SCOPED_SYMBOL]
					)
				}
			}

			//# sourceMappingURL=isVar.js.map

			/***/
		},

		/***/ 47814: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = matchesPattern
			var _index = __nccwpck_require__(40741)
			function matchesPattern(member, match, allowPartial) {
				if (!(0, _index.isMemberExpression)(member)) return false
				const parts = Array.isArray(match) ? match : match.split('.')
				const nodes = []
				let node
				for (
					node = member;
					(0, _index.isMemberExpression)(node);
					node = node.object
				) {
					nodes.push(node.property)
				}
				nodes.push(node)
				if (nodes.length < parts.length) return false
				if (!allowPartial && nodes.length > parts.length) return false
				for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
					const node = nodes[j]
					let value
					if ((0, _index.isIdentifier)(node)) {
						value = node.name
					} else if ((0, _index.isStringLiteral)(node)) {
						value = node.value
					} else if ((0, _index.isThisExpression)(node)) {
						value = 'this'
					} else {
						return false
					}
					if (parts[i] !== value) return false
				}
				return true
			}

			//# sourceMappingURL=matchesPattern.js.map

			/***/
		},

		/***/ 20817: /***/ (__unused_webpack_module, exports) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = isCompatTag
			function isCompatTag(tagName) {
				return !!tagName && /^[a-z]/.test(tagName)
			}

			//# sourceMappingURL=isCompatTag.js.map

			/***/
		},

		/***/ 24513: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = void 0
			var _buildMatchMemberExpression = __nccwpck_require__(77334)
			const isReactComponent = (0, _buildMatchMemberExpression.default)(
				'React.Component',
			)
			var _default = (exports['default'] = isReactComponent)

			//# sourceMappingURL=isReactComponent.js.map

			/***/
		},

		/***/ 71581: /***/ (
			__unused_webpack_module,
			exports,
			__nccwpck_require__,
		) => {
			'use strict'

			Object.defineProperty(exports, '__esModule', {
				value: true,
			})
			exports['default'] = validate
			exports.validateChild = validateChild
			exports.validateField = validateField
			exports.validateInternal = validateInternal
			var _index = __nccwpck_require__(40910)
			function validate(node, key, val) {
				if (!node) return
				const fields = _index.NODE_FIELDS[node.type]
				if (!fields) return
				const field = fields[key]
				validateField(node, key, val, field)
				validateChild(node, key, val)
			}
			function validateInternal(field, node, key, val, maybeNode) {
				if (!(field != null && field.validate)) return
				if (field.optional && val == null) return
				field.validate(node, key, val)
				if (maybeNode) {
					var _NODE_PARENT_VALIDATI
					const type = val.type
					if (type == null) return
					;(_NODE_PARENT_VALIDATI = _index.NODE_PARENT_VALIDATIONS[type]) ==
						null ||
						_NODE_PARENT_VALIDATI.call(
							_index.NODE_PARENT_VALIDATIONS,
							node,
							key,
							val,
						)
				}
			}
			function validateField(node, key, val, field) {
				if (!(field != null && field.validate)) return
				if (field.optional && val == null) return
				field.validate(node, key, val)
			}
			function validateChild(node, key, val) {
				var _NODE_PARENT_VALIDATI2
				const type = val == null ? void 0 : val.type
				if (type == null) return
				;(_NODE_PARENT_VALIDATI2 = _index.NODE_PARENT_VALIDATIONS[type]) ==
					null ||
					_NODE_PARENT_VALIDATI2.call(
						_index.NODE_PARENT_VALIDATIONS,
						node,
						key,
						val,
					)
			}

			//# sourceMappingURL=validate.js.map

			/***/
		},

		/***/ 27182: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const WritableStream = __nccwpck_require__(57075).Writable
			const inherits = __nccwpck_require__(57975).inherits

			const StreamSearch = __nccwpck_require__(84136)

			const PartStream = __nccwpck_require__(50612)
			const HeaderParser = __nccwpck_require__(62271)

			const DASH = 45
			const B_ONEDASH = Buffer.from('-')
			const B_CRLF = Buffer.from('\r\n')
			const EMPTY_FN = function () {}

			function Dicer(cfg) {
				if (!(this instanceof Dicer)) {
					return new Dicer(cfg)
				}
				WritableStream.call(this, cfg)

				if (!cfg || (!cfg.headerFirst && typeof cfg.boundary !== 'string')) {
					throw new TypeError('Boundary required')
				}

				if (typeof cfg.boundary === 'string') {
					this.setBoundary(cfg.boundary)
				} else {
					this._bparser = undefined
				}

				this._headerFirst = cfg.headerFirst

				this._dashes = 0
				this._parts = 0
				this._finished = false
				this._realFinish = false
				this._isPreamble = true
				this._justMatched = false
				this._firstWrite = true
				this._inHeader = true
				this._part = undefined
				this._cb = undefined
				this._ignoreData = false
				this._partOpts = { highWaterMark: cfg.partHwm }
				this._pause = false

				const self = this
				this._hparser = new HeaderParser(cfg)
				this._hparser.on('header', function (header) {
					self._inHeader = false
					self._part.emit('header', header)
				})
			}
			inherits(Dicer, WritableStream)

			Dicer.prototype.emit = function (ev) {
				if (ev === 'finish' && !this._realFinish) {
					if (!this._finished) {
						const self = this
						process.nextTick(function () {
							self.emit('error', new Error('Unexpected end of multipart data'))
							if (self._part && !self._ignoreData) {
								const type = self._isPreamble ? 'Preamble' : 'Part'
								self._part.emit(
									'error',
									new Error(
										type +
											' terminated early due to unexpected end of multipart data',
									),
								)
								self._part.push(null)
								process.nextTick(function () {
									self._realFinish = true
									self.emit('finish')
									self._realFinish = false
								})
								return
							}
							self._realFinish = true
							self.emit('finish')
							self._realFinish = false
						})
					}
				} else {
					WritableStream.prototype.emit.apply(this, arguments)
				}
			}

			Dicer.prototype._write = function (data, encoding, cb) {
				// ignore unexpected data (e.g. extra trailer data after finished)
				if (!this._hparser && !this._bparser) {
					return cb()
				}

				if (this._headerFirst && this._isPreamble) {
					if (!this._part) {
						this._part = new PartStream(this._partOpts)
						if (this.listenerCount('preamble') !== 0) {
							this.emit('preamble', this._part)
						} else {
							this._ignore()
						}
					}
					const r = this._hparser.push(data)
					if (!this._inHeader && r !== undefined && r < data.length) {
						data = data.slice(r)
					} else {
						return cb()
					}
				}

				// allows for "easier" testing
				if (this._firstWrite) {
					this._bparser.push(B_CRLF)
					this._firstWrite = false
				}

				this._bparser.push(data)

				if (this._pause) {
					this._cb = cb
				} else {
					cb()
				}
			}

			Dicer.prototype.reset = function () {
				this._part = undefined
				this._bparser = undefined
				this._hparser = undefined
			}

			Dicer.prototype.setBoundary = function (boundary) {
				const self = this
				this._bparser = new StreamSearch('\r\n--' + boundary)
				this._bparser.on('info', function (isMatch, data, start, end) {
					self._oninfo(isMatch, data, start, end)
				})
			}

			Dicer.prototype._ignore = function () {
				if (this._part && !this._ignoreData) {
					this._ignoreData = true
					this._part.on('error', EMPTY_FN)
					// we must perform some kind of read on the stream even though we are
					// ignoring the data, otherwise node's Readable stream will not emit 'end'
					// after pushing null to the stream
					this._part.resume()
				}
			}

			Dicer.prototype._oninfo = function (isMatch, data, start, end) {
				let buf
				const self = this
				let i = 0
				let r
				let shouldWriteMore = true

				if (!this._part && this._justMatched && data) {
					while (this._dashes < 2 && start + i < end) {
						if (data[start + i] === DASH) {
							++i
							++this._dashes
						} else {
							if (this._dashes) {
								buf = B_ONEDASH
							}
							this._dashes = 0
							break
						}
					}
					if (this._dashes === 2) {
						if (start + i < end && this.listenerCount('trailer') !== 0) {
							this.emit('trailer', data.slice(start + i, end))
						}
						this.reset()
						this._finished = true
						// no more parts will be added
						if (self._parts === 0) {
							self._realFinish = true
							self.emit('finish')
							self._realFinish = false
						}
					}
					if (this._dashes) {
						return
					}
				}
				if (this._justMatched) {
					this._justMatched = false
				}
				if (!this._part) {
					this._part = new PartStream(this._partOpts)
					this._part._read = function (n) {
						self._unpause()
					}
					if (this._isPreamble && this.listenerCount('preamble') !== 0) {
						this.emit('preamble', this._part)
					} else if (
						this._isPreamble !== true &&
						this.listenerCount('part') !== 0
					) {
						this.emit('part', this._part)
					} else {
						this._ignore()
					}
					if (!this._isPreamble) {
						this._inHeader = true
					}
				}
				if (data && start < end && !this._ignoreData) {
					if (this._isPreamble || !this._inHeader) {
						if (buf) {
							shouldWriteMore = this._part.push(buf)
						}
						shouldWriteMore = this._part.push(data.slice(start, end))
						if (!shouldWriteMore) {
							this._pause = true
						}
					} else if (!this._isPreamble && this._inHeader) {
						if (buf) {
							this._hparser.push(buf)
						}
						r = this._hparser.push(data.slice(start, end))
						if (!this._inHeader && r !== undefined && r < end) {
							this._oninfo(false, data, start + r, end)
						}
					}
				}
				if (isMatch) {
					this._hparser.reset()
					if (this._isPreamble) {
						this._isPreamble = false
					} else {
						if (start !== end) {
							++this._parts
							this._part.on('end', function () {
								if (--self._parts === 0) {
									if (self._finished) {
										self._realFinish = true
										self.emit('finish')
										self._realFinish = false
									} else {
										self._unpause()
									}
								}
							})
						}
					}
					this._part.push(null)
					this._part = undefined
					this._ignoreData = false
					this._justMatched = true
					this._dashes = 0
				}
			}

			Dicer.prototype._unpause = function () {
				if (!this._pause) {
					return
				}

				this._pause = false
				if (this._cb) {
					const cb = this._cb
					this._cb = undefined
					cb()
				}
			}

			module.exports = Dicer

			/***/
		},

		/***/ 62271: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const EventEmitter = __nccwpck_require__(78474).EventEmitter
			const inherits = __nccwpck_require__(57975).inherits
			const getLimit = __nccwpck_require__(22393)

			const StreamSearch = __nccwpck_require__(84136)

			const B_DCRLF = Buffer.from('\r\n\r\n')
			const RE_CRLF = /\r\n/g
			const RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/ // eslint-disable-line no-control-regex

			function HeaderParser(cfg) {
				EventEmitter.call(this)

				cfg = cfg || {}
				const self = this
				this.nread = 0
				this.maxed = false
				this.npairs = 0
				this.maxHeaderPairs = getLimit(cfg, 'maxHeaderPairs', 2000)
				this.maxHeaderSize = getLimit(cfg, 'maxHeaderSize', 80 * 1024)
				this.buffer = ''
				this.header = {}
				this.finished = false
				this.ss = new StreamSearch(B_DCRLF)
				this.ss.on('info', function (isMatch, data, start, end) {
					if (data && !self.maxed) {
						if (self.nread + end - start >= self.maxHeaderSize) {
							end = self.maxHeaderSize - self.nread + start
							self.nread = self.maxHeaderSize
							self.maxed = true
						} else {
							self.nread += end - start
						}

						self.buffer += data.toString('binary', start, end)
					}
					if (isMatch) {
						self._finish()
					}
				})
			}
			inherits(HeaderParser, EventEmitter)

			HeaderParser.prototype.push = function (data) {
				const r = this.ss.push(data)
				if (this.finished) {
					return r
				}
			}

			HeaderParser.prototype.reset = function () {
				this.finished = false
				this.buffer = ''
				this.header = {}
				this.ss.reset()
			}

			HeaderParser.prototype._finish = function () {
				if (this.buffer) {
					this._parseHeader()
				}
				this.ss.matches = this.ss.maxMatches
				const header = this.header
				this.header = {}
				this.buffer = ''
				this.finished = true
				this.nread = this.npairs = 0
				this.maxed = false
				this.emit('header', header)
			}

			HeaderParser.prototype._parseHeader = function () {
				if (this.npairs === this.maxHeaderPairs) {
					return
				}

				const lines = this.buffer.split(RE_CRLF)
				const len = lines.length
				let m, h

				for (var i = 0; i < len; ++i) {
					// eslint-disable-line no-var
					if (lines[i].length === 0) {
						continue
					}
					if (lines[i][0] === '\t' || lines[i][0] === ' ') {
						// folded header content
						// RFC2822 says to just remove the CRLF and not the whitespace following
						// it, so we follow the RFC and include the leading whitespace ...
						if (h) {
							this.header[h][this.header[h].length - 1] += lines[i]
							continue
						}
					}

					const posColon = lines[i].indexOf(':')
					if (posColon === -1 || posColon === 0) {
						return
					}
					m = RE_HDR.exec(lines[i])
					h = m[1].toLowerCase()
					this.header[h] = this.header[h] || []
					this.header[h].push(m[2] || '')
					if (++this.npairs === this.maxHeaderPairs) {
						break
					}
				}
			}

			module.exports = HeaderParser

			/***/
		},

		/***/ 50612: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const inherits = __nccwpck_require__(57975).inherits
			const ReadableStream = __nccwpck_require__(57075).Readable

			function PartStream(opts) {
				ReadableStream.call(this, opts)
			}
			inherits(PartStream, ReadableStream)

			PartStream.prototype._read = function (n) {}

			module.exports = PartStream

			/***/
		},

		/***/ 84136: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			/**
			 * Copyright Brian White. All rights reserved.
			 *
			 * @see https://github.com/mscdex/streamsearch
			 *
			 * Permission is hereby granted, free of charge, to any person obtaining a copy
			 * of this software and associated documentation files (the "Software"), to
			 * deal in the Software without restriction, including without limitation the
			 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
			 * sell copies of the Software, and to permit persons to whom the Software is
			 * furnished to do so, subject to the following conditions:
			 *
			 * The above copyright notice and this permission notice shall be included in
			 * all copies or substantial portions of the Software.
			 *
			 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
			 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
			 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
			 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
			 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
			 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
			 * IN THE SOFTWARE.
			 *
			 * Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation
			 * by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool
			 */
			const EventEmitter = __nccwpck_require__(78474).EventEmitter
			const inherits = __nccwpck_require__(57975).inherits

			function SBMH(needle) {
				if (typeof needle === 'string') {
					needle = Buffer.from(needle)
				}

				if (!Buffer.isBuffer(needle)) {
					throw new TypeError('The needle has to be a String or a Buffer.')
				}

				const needleLength = needle.length

				if (needleLength === 0) {
					throw new Error('The needle cannot be an empty String/Buffer.')
				}

				if (needleLength > 256) {
					throw new Error('The needle cannot have a length bigger than 256.')
				}

				this.maxMatches = Infinity
				this.matches = 0

				this._occ = new Array(256).fill(needleLength) // Initialize occurrence table.
				this._lookbehind_size = 0
				this._needle = needle
				this._bufpos = 0

				this._lookbehind = Buffer.alloc(needleLength)

				// Populate occurrence table with analysis of the needle,
				// ignoring last letter.
				for (var i = 0; i < needleLength - 1; ++i) {
					// eslint-disable-line no-var
					this._occ[needle[i]] = needleLength - 1 - i
				}
			}
			inherits(SBMH, EventEmitter)

			SBMH.prototype.reset = function () {
				this._lookbehind_size = 0
				this.matches = 0
				this._bufpos = 0
			}

			SBMH.prototype.push = function (chunk, pos) {
				if (!Buffer.isBuffer(chunk)) {
					chunk = Buffer.from(chunk, 'binary')
				}
				const chlen = chunk.length
				this._bufpos = pos || 0
				let r
				while (r !== chlen && this.matches < this.maxMatches) {
					r = this._sbmh_feed(chunk)
				}
				return r
			}

			SBMH.prototype._sbmh_feed = function (data) {
				const len = data.length
				const needle = this._needle
				const needleLength = needle.length
				const lastNeedleChar = needle[needleLength - 1]

				// Positive: points to a position in `data`
				//           pos == 3 points to data[3]
				// Negative: points to a position in the lookbehind buffer
				//           pos == -2 points to lookbehind[lookbehind_size - 2]
				let pos = -this._lookbehind_size
				let ch

				if (pos < 0) {
					// Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool
					// search with character lookup code that considers both the
					// lookbehind buffer and the current round's haystack data.
					//
					// Loop until
					//   there is a match.
					// or until
					//   we've moved past the position that requires the
					//   lookbehind buffer. In this case we switch to the
					//   optimized loop.
					// or until
					//   the character to look at lies outside the haystack.
					while (pos < 0 && pos <= len - needleLength) {
						ch = this._sbmh_lookup_char(data, pos + needleLength - 1)

						if (
							ch === lastNeedleChar &&
							this._sbmh_memcmp(data, pos, needleLength - 1)
						) {
							this._lookbehind_size = 0
							++this.matches
							this.emit('info', true)

							return (this._bufpos = pos + needleLength)
						}
						pos += this._occ[ch]
					}

					// No match.

					if (pos < 0) {
						// There's too few data for Boyer-Moore-Horspool to run,
						// so let's use a different algorithm to skip as much as
						// we can.
						// Forward pos until
						//   the trailing part of lookbehind + data
						//   looks like the beginning of the needle
						// or until
						//   pos == 0
						while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) {
							++pos
						}
					}

					if (pos >= 0) {
						// Discard lookbehind buffer.
						this.emit('info', false, this._lookbehind, 0, this._lookbehind_size)
						this._lookbehind_size = 0
					} else {
						// Cut off part of the lookbehind buffer that has
						// been processed and append the entire haystack
						// into it.
						const bytesToCutOff = this._lookbehind_size + pos
						if (bytesToCutOff > 0) {
							// The cut off data is guaranteed not to contain the needle.
							this.emit('info', false, this._lookbehind, 0, bytesToCutOff)
						}

						this._lookbehind.copy(
							this._lookbehind,
							0,
							bytesToCutOff,
							this._lookbehind_size - bytesToCutOff,
						)
						this._lookbehind_size -= bytesToCutOff

						data.copy(this._lookbehind, this._lookbehind_size)
						this._lookbehind_size += len

						this._bufpos = len
						return len
					}
				}

				pos += (pos >= 0) * this._bufpos

				// Lookbehind buffer is now empty. We only need to check if the
				// needle is in the haystack.
				if (data.indexOf(needle, pos) !== -1) {
					pos = data.indexOf(needle, pos)
					++this.matches
					if (pos > 0) {
						this.emit('info', true, data, this._bufpos, pos)
					} else {
						this.emit('info', true)
					}

					return (this._bufpos = pos + needleLength)
				} else {
					pos = len - needleLength
				}

				// There was no match. If there's trailing haystack data that we cannot
				// match yet using the Boyer-Moore-Horspool algorithm (because the trailing
				// data is less than the needle size) then match using a modified
				// algorithm that starts matching from the beginning instead of the end.
				// Whatever trailing data is left after running this algorithm is added to
				// the lookbehind buffer.
				while (
					pos < len &&
					(data[pos] !== needle[0] ||
						Buffer.compare(
							data.subarray(pos, pos + len - pos),
							needle.subarray(0, len - pos),
						) !== 0)
				) {
					++pos
				}
				if (pos < len) {
					data.copy(this._lookbehind, 0, pos, pos + (len - pos))
					this._lookbehind_size = len - pos
				}

				// Everything until pos is guaranteed not to contain needle data.
				if (pos > 0) {
					this.emit('info', false, data, this._bufpos, pos < len ? pos : len)
				}

				this._bufpos = len
				return len
			}

			SBMH.prototype._sbmh_lookup_char = function (data, pos) {
				return pos < 0
					? this._lookbehind[this._lookbehind_size + pos]
					: data[pos]
			}

			SBMH.prototype._sbmh_memcmp = function (data, pos, len) {
				for (var i = 0; i < len; ++i) {
					// eslint-disable-line no-var
					if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) {
						return false
					}
				}
				return true
			}

			module.exports = SBMH

			/***/
		},

		/***/ 89581: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const WritableStream = __nccwpck_require__(57075).Writable
			const { inherits } = __nccwpck_require__(57975)
			const Dicer = __nccwpck_require__(27182)

			const MultipartParser = __nccwpck_require__(41192)
			const UrlencodedParser = __nccwpck_require__(80855)
			const parseParams = __nccwpck_require__(8929)

			function Busboy(opts) {
				if (!(this instanceof Busboy)) {
					return new Busboy(opts)
				}

				if (typeof opts !== 'object') {
					throw new TypeError('Busboy expected an options-Object.')
				}
				if (typeof opts.headers !== 'object') {
					throw new TypeError(
						'Busboy expected an options-Object with headers-attribute.',
					)
				}
				if (typeof opts.headers['content-type'] !== 'string') {
					throw new TypeError('Missing Content-Type-header.')
				}

				const { headers, ...streamOptions } = opts

				this.opts = {
					autoDestroy: false,
					...streamOptions,
				}
				WritableStream.call(this, this.opts)

				this._done = false
				this._parser = this.getParserByHeaders(headers)
				this._finished = false
			}
			inherits(Busboy, WritableStream)

			Busboy.prototype.emit = function (ev) {
				if (ev === 'finish') {
					if (!this._done) {
						this._parser?.end()
						return
					} else if (this._finished) {
						return
					}
					this._finished = true
				}
				WritableStream.prototype.emit.apply(this, arguments)
			}

			Busboy.prototype.getParserByHeaders = function (headers) {
				const parsed = parseParams(headers['content-type'])

				const cfg = {
					defCharset: this.opts.defCharset,
					fileHwm: this.opts.fileHwm,
					headers,
					highWaterMark: this.opts.highWaterMark,
					isPartAFile: this.opts.isPartAFile,
					limits: this.opts.limits,
					parsedConType: parsed,
					preservePath: this.opts.preservePath,
				}

				if (MultipartParser.detect.test(parsed[0])) {
					return new MultipartParser(this, cfg)
				}
				if (UrlencodedParser.detect.test(parsed[0])) {
					return new UrlencodedParser(this, cfg)
				}
				throw new Error('Unsupported Content-Type.')
			}

			Busboy.prototype._write = function (chunk, encoding, cb) {
				this._parser.write(chunk, cb)
			}

			module.exports = Busboy
			module.exports['default'] = Busboy
			module.exports.Busboy = Busboy

			module.exports.Dicer = Dicer

			/***/
		},

		/***/ 41192: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			// TODO:
			//  * support 1 nested multipart level
			//    (see second multipart example here:
			//     http://www.w3.org/TR/html401/interact/forms.html#didx-multipartform-data)
			//  * support limits.fieldNameSize
			//     -- this will require modifications to utils.parseParams

			const { Readable } = __nccwpck_require__(57075)
			const { inherits } = __nccwpck_require__(57975)

			const Dicer = __nccwpck_require__(27182)

			const parseParams = __nccwpck_require__(8929)
			const decodeText = __nccwpck_require__(72747)
			const basename = __nccwpck_require__(20692)
			const getLimit = __nccwpck_require__(22393)

			const RE_BOUNDARY = /^boundary$/i
			const RE_FIELD = /^form-data$/i
			const RE_CHARSET = /^charset$/i
			const RE_FILENAME = /^filename$/i
			const RE_NAME = /^name$/i

			Multipart.detect = /^multipart\/form-data/i
			function Multipart(boy, cfg) {
				let i
				let len
				const self = this
				let boundary
				const limits = cfg.limits
				const isPartAFile =
					cfg.isPartAFile ||
					((fieldName, contentType, fileName) =>
						contentType === 'application/octet-stream' ||
						fileName !== undefined)
				const parsedConType = cfg.parsedConType || []
				const defCharset = cfg.defCharset || 'utf8'
				const preservePath = cfg.preservePath
				const fileOpts = { highWaterMark: cfg.fileHwm }

				for (i = 0, len = parsedConType.length; i < len; ++i) {
					if (
						Array.isArray(parsedConType[i]) &&
						RE_BOUNDARY.test(parsedConType[i][0])
					) {
						boundary = parsedConType[i][1]
						break
					}
				}

				function checkFinished() {
					if (nends === 0 && finished && !boy._done) {
						finished = false
						self.end()
					}
				}

				if (typeof boundary !== 'string') {
					throw new Error('Multipart: Boundary not found')
				}

				const fieldSizeLimit = getLimit(limits, 'fieldSize', 1 * 1024 * 1024)
				const fileSizeLimit = getLimit(limits, 'fileSize', Infinity)
				const filesLimit = getLimit(limits, 'files', Infinity)
				const fieldsLimit = getLimit(limits, 'fields', Infinity)
				const partsLimit = getLimit(limits, 'parts', Infinity)
				const headerPairsLimit = getLimit(limits, 'headerPairs', 2000)
				const headerSizeLimit = getLimit(limits, 'headerSize', 80 * 1024)

				let nfiles = 0
				let nfields = 0
				let nends = 0
				let curFile
				let curField
				let finished = false

				this._needDrain = false
				this._pause = false
				this._cb = undefined
				this._nparts = 0
				this._boy = boy

				const parserCfg = {
					boundary,
					maxHeaderPairs: headerPairsLimit,
					maxHeaderSize: headerSizeLimit,
					partHwm: fileOpts.highWaterMark,
					highWaterMark: cfg.highWaterMark,
				}

				this.parser = new Dicer(parserCfg)
				this.parser
					.on('drain', function () {
						self._needDrain = false
						if (self._cb && !self._pause) {
							const cb = self._cb
							self._cb = undefined
							cb()
						}
					})
					.on('part', function onPart(part) {
						if (++self._nparts > partsLimit) {
							self.parser.removeListener('part', onPart)
							self.parser.on('part', skipPart)
							boy.hitPartsLimit = true
							boy.emit('partsLimit')
							return skipPart(part)
						}

						// hack because streams2 _always_ doesn't emit 'end' until nextTick, so let
						// us emit 'end' early since we know the part has ended if we are already
						// seeing the next part
						if (curField) {
							const field = curField
							field.emit('end')
							field.removeAllListeners('end')
						}

						part
							.on('header', function (header) {
								let contype
								let fieldname
								let parsed
								let charset
								let encoding
								let filename
								let nsize = 0

								if (header['content-type']) {
									parsed = parseParams(header['content-type'][0])
									if (parsed[0]) {
										contype = parsed[0].toLowerCase()
										for (i = 0, len = parsed.length; i < len; ++i) {
											if (RE_CHARSET.test(parsed[i][0])) {
												charset = parsed[i][1].toLowerCase()
												break
											}
										}
									}
								}

								if (contype === undefined) {
									contype = 'text/plain'
								}
								if (charset === undefined) {
									charset = defCharset
								}

								if (header['content-disposition']) {
									parsed = parseParams(header['content-disposition'][0])
									if (!RE_FIELD.test(parsed[0])) {
										return skipPart(part)
									}
									for (i = 0, len = parsed.length; i < len; ++i) {
										if (RE_NAME.test(parsed[i][0])) {
											fieldname = parsed[i][1]
										} else if (RE_FILENAME.test(parsed[i][0])) {
											filename = parsed[i][1]
											if (!preservePath) {
												filename = basename(filename)
											}
										}
									}
								} else {
									return skipPart(part)
								}

								if (header['content-transfer-encoding']) {
									encoding =
										header['content-transfer-encoding'][0].toLowerCase()
								} else {
									encoding = '7bit'
								}

								let onData, onEnd

								if (isPartAFile(fieldname, contype, filename)) {
									// file/binary field
									if (nfiles === filesLimit) {
										if (!boy.hitFilesLimit) {
											boy.hitFilesLimit = true
											boy.emit('filesLimit')
										}
										return skipPart(part)
									}

									++nfiles

									if (boy.listenerCount('file') === 0) {
										self.parser._ignore()
										return
									}

									++nends
									const file = new FileStream(fileOpts)
									curFile = file
									file.on('end', function () {
										--nends
										self._pause = false
										checkFinished()
										if (self._cb && !self._needDrain) {
											const cb = self._cb
											self._cb = undefined
											cb()
										}
									})
									file._read = function (n) {
										if (!self._pause) {
											return
										}
										self._pause = false
										if (self._cb && !self._needDrain) {
											const cb = self._cb
											self._cb = undefined
											cb()
										}
									}
									boy.emit('file', fieldname, file, filename, encoding, contype)

									onData = function (data) {
										if ((nsize += data.length) > fileSizeLimit) {
											const extralen = fileSizeLimit - nsize + data.length
											if (extralen > 0) {
												file.push(data.slice(0, extralen))
											}
											file.truncated = true
											file.bytesRead = fileSizeLimit
											part.removeAllListeners('data')
											file.emit('limit')
											return
										} else if (!file.push(data)) {
											self._pause = true
										}

										file.bytesRead = nsize
									}

									onEnd = function () {
										curFile = undefined
										file.push(null)
									}
								} else {
									// non-file field
									if (nfields === fieldsLimit) {
										if (!boy.hitFieldsLimit) {
											boy.hitFieldsLimit = true
											boy.emit('fieldsLimit')
										}
										return skipPart(part)
									}

									++nfields
									++nends
									let buffer = ''
									let truncated = false
									curField = part

									onData = function (data) {
										if ((nsize += data.length) > fieldSizeLimit) {
											const extralen = fieldSizeLimit - (nsize - data.length)
											buffer += data.toString('binary', 0, extralen)
											truncated = true
											part.removeAllListeners('data')
										} else {
											buffer += data.toString('binary')
										}
									}

									onEnd = function () {
										curField = undefined
										if (buffer.length) {
											buffer = decodeText(buffer, 'binary', charset)
										}
										boy.emit(
											'field',
											fieldname,
											buffer,
											false,
											truncated,
											encoding,
											contype,
										)
										--nends
										checkFinished()
									}
								}

								/* As of node@2efe4ab761666 (v0.10.29+/v0.11.14+), busboy had become
         broken. Streams2/streams3 is a huge black box of confusion, but
         somehow overriding the sync state seems to fix things again (and still
         seems to work for previous node versions).
      */
								part._readableState.sync = false

								part.on('data', onData)
								part.on('end', onEnd)
							})
							.on('error', function (err) {
								if (curFile) {
									curFile.emit('error', err)
								}
							})
					})
					.on('error', function (err) {
						boy.emit('error', err)
					})
					.on('finish', function () {
						finished = true
						checkFinished()
					})
			}

			Multipart.prototype.write = function (chunk, cb) {
				const r = this.parser.write(chunk)
				if (r && !this._pause) {
					cb()
				} else {
					this._needDrain = !r
					this._cb = cb
				}
			}

			Multipart.prototype.end = function () {
				const self = this

				if (self.parser.writable) {
					self.parser.end()
				} else if (!self._boy._done) {
					process.nextTick(function () {
						self._boy._done = true
						self._boy.emit('finish')
					})
				}
			}

			function skipPart(part) {
				part.resume()
			}

			function FileStream(opts) {
				Readable.call(this, opts)

				this.bytesRead = 0

				this.truncated = false
			}

			inherits(FileStream, Readable)

			FileStream.prototype._read = function (n) {}

			module.exports = Multipart

			/***/
		},

		/***/ 80855: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'

			const Decoder = __nccwpck_require__(11496)
			const decodeText = __nccwpck_require__(72747)
			const getLimit = __nccwpck_require__(22393)

			const RE_CHARSET = /^charset$/i

			UrlEncoded.detect = /^application\/x-www-form-urlencoded/i
			function UrlEncoded(boy, cfg) {
				const limits = cfg.limits
				const parsedConType = cfg.parsedConType
				this.boy = boy

				this.fieldSizeLimit = getLimit(limits, 'fieldSize', 1 * 1024 * 1024)
				this.fieldNameSizeLimit = getLimit(limits, 'fieldNameSize', 100)
				this.fieldsLimit = getLimit(limits, 'fields', Infinity)

				let charset
				for (var i = 0, len = parsedConType.length; i < len; ++i) {
					// eslint-disable-line no-var
					if (
						Array.isArray(parsedConType[i]) &&
						RE_CHARSET.test(parsedConType[i][0])
					) {
						charset = parsedConType[i][1].toLowerCase()
						break
					}
				}

				if (charset === undefined) {
					charset = cfg.defCharset || 'utf8'
				}

				this.decoder = new Decoder()
				this.charset = charset
				this._fields = 0
				this._state = 'key'
				this._checkingBytes = true
				this._bytesKey = 0
				this._bytesVal = 0
				this._key = ''
				this._val = ''
				this._keyTrunc = false
				this._valTrunc = false
				this._hitLimit = false
			}

			UrlEncoded.prototype.write = function (data, cb) {
				if (this._fields === this.fieldsLimit) {
					if (!this.boy.hitFieldsLimit) {
						this.boy.hitFieldsLimit = true
						this.boy.emit('fieldsLimit')
					}
					return cb()
				}

				let idxeq
				let idxamp
				let i
				let p = 0
				const len = data.length

				while (p < len) {
					if (this._state === 'key') {
						idxeq = idxamp = undefined
						for (i = p; i < len; ++i) {
							if (!this._checkingBytes) {
								++p
							}
							if (data[i] === 0x3d /* = */) {
								idxeq = i
								break
							} else if (data[i] === 0x26 /* & */) {
								idxamp = i
								break
							}
							if (
								this._checkingBytes &&
								this._bytesKey === this.fieldNameSizeLimit
							) {
								this._hitLimit = true
								break
							} else if (this._checkingBytes) {
								++this._bytesKey
							}
						}

						if (idxeq !== undefined) {
							// key with assignment
							if (idxeq > p) {
								this._key += this.decoder.write(
									data.toString('binary', p, idxeq),
								)
							}
							this._state = 'val'

							this._hitLimit = false
							this._checkingBytes = true
							this._val = ''
							this._bytesVal = 0
							this._valTrunc = false
							this.decoder.reset()

							p = idxeq + 1
						} else if (idxamp !== undefined) {
							// key with no assignment
							++this._fields
							let key
							const keyTrunc = this._keyTrunc
							if (idxamp > p) {
								key = this._key += this.decoder.write(
									data.toString('binary', p, idxamp),
								)
							} else {
								key = this._key
							}

							this._hitLimit = false
							this._checkingBytes = true
							this._key = ''
							this._bytesKey = 0
							this._keyTrunc = false
							this.decoder.reset()

							if (key.length) {
								this.boy.emit(
									'field',
									decodeText(key, 'binary', this.charset),
									'',
									keyTrunc,
									false,
								)
							}

							p = idxamp + 1
							if (this._fields === this.fieldsLimit) {
								return cb()
							}
						} else if (this._hitLimit) {
							// we may not have hit the actual limit if there are encoded bytes...
							if (i > p) {
								this._key += this.decoder.write(data.toString('binary', p, i))
							}
							p = i
							if (
								(this._bytesKey = this._key.length) === this.fieldNameSizeLimit
							) {
								// yep, we actually did hit the limit
								this._checkingBytes = false
								this._keyTrunc = true
							}
						} else {
							if (p < len) {
								this._key += this.decoder.write(data.toString('binary', p))
							}
							p = len
						}
					} else {
						idxamp = undefined
						for (i = p; i < len; ++i) {
							if (!this._checkingBytes) {
								++p
							}
							if (data[i] === 0x26 /* & */) {
								idxamp = i
								break
							}
							if (
								this._checkingBytes &&
								this._bytesVal === this.fieldSizeLimit
							) {
								this._hitLimit = true
								break
							} else if (this._checkingBytes) {
								++this._bytesVal
							}
						}

						if (idxamp !== undefined) {
							++this._fields
							if (idxamp > p) {
								this._val += this.decoder.write(
									data.toString('binary', p, idxamp),
								)
							}
							this.boy.emit(
								'field',
								decodeText(this._key, 'binary', this.charset),
								decodeText(this._val, 'binary', this.charset),
								this._keyTrunc,
								this._valTrunc,
							)
							this._state = 'key'

							this._hitLimit = false
							this._checkingBytes = true
							this._key = ''
							this._bytesKey = 0
							this._keyTrunc = false
							this.decoder.reset()

							p = idxamp + 1
							if (this._fields === this.fieldsLimit) {
								return cb()
							}
						} else if (this._hitLimit) {
							// we may not have hit the actual limit if there are encoded bytes...
							if (i > p) {
								this._val += this.decoder.write(data.toString('binary', p, i))
							}
							p = i
							if (
								(this._val === '' && this.fieldSizeLimit === 0) ||
								(this._bytesVal = this._val.length) === this.fieldSizeLimit
							) {
								// yep, we actually did hit the limit
								this._checkingBytes = false
								this._valTrunc = true
							}
						} else {
							if (p < len) {
								this._val += this.decoder.write(data.toString('binary', p))
							}
							p = len
						}
					}
				}
				cb()
			}

			UrlEncoded.prototype.end = function () {
				if (this.boy._done) {
					return
				}

				if (this._state === 'key' && this._key.length > 0) {
					this.boy.emit(
						'field',
						decodeText(this._key, 'binary', this.charset),
						'',
						this._keyTrunc,
						false,
					)
				} else if (this._state === 'val') {
					this.boy.emit(
						'field',
						decodeText(this._key, 'binary', this.charset),
						decodeText(this._val, 'binary', this.charset),
						this._keyTrunc,
						this._valTrunc,
					)
				}
				this.boy._done = true
				this.boy.emit('finish')
			}

			module.exports = UrlEncoded

			/***/
		},

		/***/ 11496: /***/ (module) => {
			'use strict'

			const RE_PLUS = /\+/g

			const HEX = [
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0,
			]

			function Decoder() {
				this.buffer = undefined
			}
			Decoder.prototype.write = function (str) {
				// Replace '+' with ' ' before decoding
				str = str.replace(RE_PLUS, ' ')
				let res = ''
				let i = 0
				let p = 0
				const len = str.length
				for (; i < len; ++i) {
					if (this.buffer !== undefined) {
						if (!HEX[str.charCodeAt(i)]) {
							res += '%' + this.buffer
							this.buffer = undefined
							--i // retry character
						} else {
							this.buffer += str[i]
							++p
							if (this.buffer.length === 2) {
								res += String.fromCharCode(parseInt(this.buffer, 16))
								this.buffer = undefined
							}
						}
					} else if (str[i] === '%') {
						if (i > p) {
							res += str.substring(p, i)
							p = i
						}
						this.buffer = ''
						++p
					}
				}
				if (p < len && this.buffer === undefined) {
					res += str.substring(p)
				}
				return res
			}
			Decoder.prototype.reset = function () {
				this.buffer = undefined
			}

			module.exports = Decoder

			/***/
		},

		/***/ 20692: /***/ (module) => {
			'use strict'

			module.exports = function basename(path) {
				if (typeof path !== 'string') {
					return ''
				}
				for (var i = path.length - 1; i >= 0; --i) {
					// eslint-disable-line no-var
					switch (path.charCodeAt(i)) {
						case 0x2f: // '/'
						case 0x5c: // '\'
							path = path.slice(i + 1)
							return path === '..' || path === '.' ? '' : path
					}
				}
				return path === '..' || path === '.' ? '' : path
			}

			/***/
		},

		/***/ 72747: /***/ function (module) {
			'use strict'

			// Node has always utf-8
			const utf8Decoder = new TextDecoder('utf-8')
			const textDecoders = new Map([
				['utf-8', utf8Decoder],
				['utf8', utf8Decoder],
			])

			function getDecoder(charset) {
				let lc
				while (true) {
					switch (charset) {
						case 'utf-8':
						case 'utf8':
							return decoders.utf8
						case 'latin1':
						case 'ascii': // TODO: Make these a separate, strict decoder?
						case 'us-ascii':
						case 'iso-8859-1':
						case 'iso8859-1':
						case 'iso88591':
						case 'iso_8859-1':
						case 'windows-1252':
						case 'iso_8859-1:1987':
						case 'cp1252':
						case 'x-cp1252':
							return decoders.latin1
						case 'utf16le':
						case 'utf-16le':
						case 'ucs2':
						case 'ucs-2':
							return decoders.utf16le
						case 'base64':
							return decoders.base64
						default:
							if (lc === undefined) {
								lc = true
								charset = charset.toLowerCase()
								continue
							}
							return decoders.other.bind(charset)
					}
				}
			}

			const decoders = {
				utf8: (data, sourceEncoding) => {
					if (data.length === 0) {
						return ''
					}
					if (typeof data === 'string') {
						data = Buffer.from(data, sourceEncoding)
					}
					return data.utf8Slice(0, data.length)
				},

				latin1: (data, sourceEncoding) => {
					if (data.length === 0) {
						return ''
					}
					if (typeof data === 'string') {
						return data
					}
					return data.latin1Slice(0, data.length)
				},

				utf16le: (data, sourceEncoding) => {
					if (data.length === 0) {
						return ''
					}
					if (typeof data === 'string') {
						data = Buffer.from(data, sourceEncoding)
					}
					return data.ucs2Slice(0, data.length)
				},

				base64: (data, sourceEncoding) => {
					if (data.length === 0) {
						return ''
					}
					if (typeof data === 'string') {
						data = Buffer.from(data, sourceEncoding)
					}
					return data.base64Slice(0, data.length)
				},

				other: (data, sourceEncoding) => {
					if (data.length === 0) {
						return ''
					}
					if (typeof data === 'string') {
						data = Buffer.from(data, sourceEncoding)
					}

					if (textDecoders.has(this.toString())) {
						try {
							return textDecoders.get(this).decode(data)
						} catch {}
					}
					return typeof data === 'string' ? data : data.toString()
				},
			}

			function decodeText(text, sourceEncoding, destEncoding) {
				if (text) {
					return getDecoder(destEncoding)(text, sourceEncoding)
				}
				return text
			}

			module.exports = decodeText

			/***/
		},

		/***/ 22393: /***/ (module) => {
			'use strict'

			module.exports = function getLimit(limits, name, defaultLimit) {
				if (!limits || limits[name] === undefined || limits[name] === null) {
					return defaultLimit
				}

				if (typeof limits[name] !== 'number' || isNaN(limits[name])) {
					throw new TypeError('Limit ' + name + ' is not a valid number')
				}

				return limits[name]
			}

			/***/
		},

		/***/ 8929: /***/ (
			module,
			__unused_webpack_exports,
			__nccwpck_require__,
		) => {
			'use strict'
			/* eslint-disable object-property-newline */

			const decodeText = __nccwpck_require__(72747)

			const RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g

			const EncodedLookup = {
				'%00': '\x00',
				'%01': '\x01',
				'%02': '\x02',
				'%03': '\x03',
				'%04': '\x04',
				'%05': '\x05',
				'%06': '\x06',
				'%07': '\x07',
				'%08': '\x08',
				'%09': '\x09',
				'%0a': '\x0a',
				'%0A': '\x0a',
				'%0b': '\x0b',
				'%0B': '\x0b',
				'%0c': '\x0c',
				'%0C': '\x0c',
				'%0d': '\x0d',
				'%0D': '\x0d',
				'%0e': '\x0e',
				'%0E': '\x0e',
				'%0f': '\x0f',
				'%0F': '\x0f',
				'%10': '\x10',
				'%11': '\x11',
				'%12': '\x12',
				'%13': '\x13',
				'%14': '\x14',
				'%15': '\x15',
				'%16': '\x16',
				'%17': '\x17',
				'%18': '\x18',
				'%19': '\x19',
				'%1a': '\x1a',
				'%1A': '\x1a',
				'%1b': '\x1b',
				'%1B': '\x1b',
				'%1c': '\x1c',
				'%1C': '\x1c',
				'%1d': '\x1d',
				'%1D': '\x1d',
				'%1e': '\x1e',
				'%1E': '\x1e',
				'%1f': '\x1f',
				'%1F': '\x1f',
				'%20': '\x20',
				'%21': '\x21',
				'%22': '\x22',
				'%23': '\x23',
				'%24': '\x24',
				'%25': '\x25',
				'%26': '\x26',
				'%27': '\x27',
				'%28': '\x28',
				'%29': '\x29',
				'%2a': '\x2a',
				'%2A': '\x2a',
				'%2b': '\x2b',
				'%2B': '\x2b',
				'%2c': '\x2c',
				'%2C': '\x2c',
				'%2d': '\x2d',
				'%2D': '\x2d',
				'%2e': '\x2e',
				'%2E': '\x2e',
				'%2f': '\x2f',
				'%2F': '\x2f',
				'%30': '\x30',
				'%31': '\x31',
				'%32': '\x32',
				'%33': '\x33',
				'%34': '\x34',
				'%35': '\x35',
				'%36': '\x36',
				'%37': '\x37',
				'%38': '\x38',
				'%39': '\x39',
				'%3a': '\x3a',
				'%3A': '\x3a',
				'%3b': '\x3b',
				'%3B': '\x3b',
				'%3c': '\x3c',
				'%3C': '\x3c',
				'%3d': '\x3d',
				'%3D': '\x3d',
				'%3e': '\x3e',
				'%3E': '\x3e',
				'%3f': '\x3f',
				'%3F': '\x3f',
				'%40': '\x40',
				'%41': '\x41',
				'%42': '\x42',
				'%43': '\x43',
				'%44': '\x44',
				'%45': '\x45',
				'%46': '\x46',
				'%47': '\x47',
				'%48': '\x48',
				'%49': '\x49',
				'%4a': '\x4a',
				'%4A': '\x4a',
				'%4b': '\x4b',
				'%4B': '\x4b',
				'%4c': '\x4c',
				'%4C': '\x4c',
				'%4d': '\x4d',
				'%4D': '\x4d',
				'%4e': '\x4e',
				'%4E': '\x4e',
				'%4f': '\x4f',
				'%4F': '\x4f',
				'%50': '\x50',
				'%51': '\x51',
				'%52': '\x52',
				'%53': '\x53',
				'%54': '\x54',
				'%55': '\x55',
				'%56': '\x56',
				'%57': '\x57',
				'%58': '\x58',
				'%59': '\x59',
				'%5a': '\x5a',
				'%5A': '\x5a',
				'%5b': '\x5b',
				'%5B': '\x5b',
				'%5c': '\x5c',
				'%5C': '\x5c',
				'%5d': '\x5d',
				'%5D': '\x5d',
				'%5e': '\x5e',
				'%5E': '\x5e',
				'%5f': '\x5f',
				'%5F': '\x5f',
				'%60': '\x60',
				'%61': '\x61',
				'%62': '\x62',
				'%63': '\x63',
				'%64': '\x64',
				'%65': '\x65',
				'%66': '\x66',
				'%67': '\x67',
				'%68': '\x68',
				'%69': '\x69',
				'%6a': '\x6a',
				'%6A': '\x6a',
				'%6b': '\x6b',
				'%6B': '\x6b',
				'%6c': '\x6c',
				'%6C': '\x6c',
				'%6d': '\x6d',
				'%6D': '\x6d',
				'%6e': '\x6e',
				'%6E': '\x6e',
				'%6f': '\x6f',
				'%6F': '\x6f',
				'%70': '\x70',
				'%71': '\x71',
				'%72': '\x72',
				'%73': '\x73',
				'%74': '\x74',
				'%75': '\x75',
				'%76': '\x76',
				'%77': '\x77',
				'%78': '\x78',
				'%79': '\x79',
				'%7a': '\x7a',
				'%7A': '\x7a',
				'%7b': '\x7b',
				'%7B': '\x7b',
				'%7c': '\x7c',
				'%7C': '\x7c',
				'%7d': '\x7d',
				'%7D': '\x7d',
				'%7e': '\x7e',
				'%7E': '\x7e',
				'%7f': '\x7f',
				'%7F': '\x7f',
				'%80': '\x80',
				'%81': '\x81',
				'%82': '\x82',
				'%83': '\x83',
				'%84': '\x84',
				'%85': '\x85',
				'%86': '\x86',
				'%87': '\x87',
				'%88': '\x88',
				'%89': '\x89',
				'%8a': '\x8a',
				'%8A': '\x8a',
				'%8b': '\x8b',
				'%8B': '\x8b',
				'%8c': '\x8c',
				'%8C': '\x8c',
				'%8d': '\x8d',
				'%8D': '\x8d',
				'%8e': '\x8e',
				'%8E': '\x8e',
				'%8f': '\x8f',
				'%8F': '\x8f',
				'%90': '\x90',
				'%91': '\x91',
				'%92': '\x92',
				'%93': '\x93',
				'%94': '\x94',
				'%95': '\x95',
				'%96': '\x96',
				'%97': '\x97',
				'%98': '\x98',
				'%99': '\x99',
				'%9a': '\x9a',
				'%9A': '\x9a',
				'%9b': '\x9b',
				'%9B': '\x9b',
				'%9c': '\x9c',
				'%9C': '\x9c',
				'%9d': '\x9d',
				'%9D': '\x9d',
				'%9e': '\x9e',
				'%9E': '\x9e',
				'%9f': '\x9f',
				'%9F': '\x9f',
				'%a0': '\xa0',
				'%A0': '\xa0',
				'%a1': '\xa1',
				'%A1': '\xa1',
				'%a2': '\xa2',
				'%A2': '\xa2',
				'%a3': '\xa3',
				'%A3': '\xa3',
				'%a4': '\xa4',
				'%A4': '\xa4',
				'%a5': '\xa5',
				'%A5': '\xa5',
				'%a6': '\xa6',
				'%A6': '\xa6',
				'%a7': '\xa7',
				'%A7': '\xa7',
				'%a8': '\xa8',
				'%A8': '\xa8',
				'%a9': '\xa9',
				'%A9': '\xa9',
				'%aa': '\xaa',
				'%Aa': '\xaa',
				'%aA': '\xaa',
				'%AA': '\xaa',
				'%ab': '\xab',
				'%Ab': '\xab',
				'%aB': '\xab',
				'%AB': '\xab',
				'%ac': '\xac',
				'%Ac': '\xac',
				'%aC': '\xac',
				'%AC': '\xac',
				'%ad': '\xad',
				'%Ad': '\xad',
				'%aD': '\xad',
				'%AD': '\xad',
				'%ae': '\xae',
				'%Ae': '\xae',
				'%aE': '\xae',
				'%AE': '\xae',
				'%af': '\xaf',
				'%Af': '\xaf',
				'%aF': '\xaf',
				'%AF': '\xaf',
				'%b0': '\xb0',
				'%B0': '\xb0',
				'%b1': '\xb1',
				'%B1': '\xb1',
				'%b2': '\xb2',
				'%B2': '\xb2',
				'%b3': '\xb3',
				'%B3': '\xb3',
				'%b4': '\xb4',
				'%B4': '\xb4',
				'%b5': '\xb5',
				'%B5': '\xb5',
				'%b6': '\xb6',
				'%B6': '\xb6',
				'%b7': '\xb7',
				'%B7': '\xb7',
				'%b8': '\xb8',
				'%B8': '\xb8',
				'%b9': '\xb9',
				'%B9': '\xb9',
				'%ba': '\xba',
				'%Ba': '\xba',
				'%bA': '\xba',
				'%BA': '\xba',
				'%bb': '\xbb',
				'%Bb': '\xbb',
				'%bB': '\xbb',
				'%BB': '\xbb',
				'%bc': '\xbc',
				'%Bc': '\xbc',
				'%bC': '\xbc',
				'%BC': '\xbc',
				'%bd': '\xbd',
				'%Bd': '\xbd',
				'%bD': '\xbd',
				'%BD': '\xbd',
				'%be': '\xbe',
				'%Be': '\xbe',
				'%bE': '\xbe',
				'%BE': '\xbe',
				'%bf': '\xbf',
				'%Bf': '\xbf',
				'%bF': '\xbf',
				'%BF': '\xbf',
				'%c0': '\xc0',
				'%C0': '\xc0',
				'%c1': '\xc1',
				'%C1': '\xc1',
				'%c2': '\xc2',
				'%C2': '\xc2',
				'%c3': '\xc3',
				'%C3': '\xc3',
				'%c4': '\xc4',
				'%C4': '\xc4',
				'%c5': '\xc5',
				'%C5': '\xc5',
				'%c6': '\xc6',
				'%C6': '\xc6',
				'%c7': '\xc7',
				'%C7': '\xc7',
				'%c8': '\xc8',
				'%C8': '\xc8',
				'%c9': '\xc9',
				'%C9': '\xc9',
				'%ca': '\xca',
				'%Ca': '\xca',
				'%cA': '\xca',
				'%CA': '\xca',
				'%cb': '\xcb',
				'%Cb': '\xcb',
				'%cB': '\xcb',
				'%CB': '\xcb',
				'%cc': '\xcc',
				'%Cc': '\xcc',
				'%cC': '\xcc',
				'%CC': '\xcc',
				'%cd': '\xcd',
				'%Cd': '\xcd',
				'%cD': '\xcd',
				'%CD': '\xcd',
				'%ce': '\xce',
				'%Ce': '\xce',
				'%cE': '\xce',
				'%CE': '\xce',
				'%cf': '\xcf',
				'%Cf': '\xcf',
				'%cF': '\xcf',
				'%CF': '\xcf',
				'%d0': '\xd0',
				'%D0': '\xd0',
				'%d1': '\xd1',
				'%D1': '\xd1',
				'%d2': '\xd2',
				'%D2': '\xd2',
				'%d3': '\xd3',
				'%D3': '\xd3',
				'%d4': '\xd4',
				'%D4': '\xd4',
				'%d5': '\xd5',
				'%D5': '\xd5',
				'%d6': '\xd6',
				'%D6': '\xd6',
				'%d7': '\xd7',
				'%D7': '\xd7',
				'%d8': '\xd8',
				'%D8': '\xd8',
				'%d9': '\xd9',
				'%D9': '\xd9',
				'%da': '\xda',
				'%Da': '\xda',
				'%dA': '\xda',
				'%DA': '\xda',
				'%db': '\xdb',
				'%Db': '\xdb',
				'%dB': '\xdb',
				'%DB': '\xdb',
				'%dc': '\xdc',
				'%Dc': '\xdc',
				'%dC': '\xdc',
				'%DC': '\xdc',
				'%dd': '\xdd',
				'%Dd': '\xdd',
				'%dD': '\xdd',
				'%DD': '\xdd',
				'%de': '\xde',
				'%De': '\xde',
				'%dE': '\xde',
				'%DE': '\xde',
				'%df': '\xdf',
				'%Df': '\xdf',
				'%dF': '\xdf',
				'%DF': '\xdf',
				'%e0': '\xe0',
				'%E0': '\xe0',
				'%e1': '\xe1',
				'%E1': '\xe1',
				'%e2': '\xe2',
				'%E2': '\xe2',
				'%e3': '\xe3',
				'%E3': '\xe3',
				'%e4': '\xe4',
				'%E4': '\xe4',
				'%e5': '\xe5',
				'%E5': '\xe5',
				'%e6': '\xe6',
				'%E6': '\xe6',
				'%e7': '\xe7',
				'%E7': '\xe7',
				'%e8': '\xe8',
				'%E8': '\xe8',
				'%e9': '\xe9',
				'%E9': '\xe9',
				'%ea': '\xea',
				'%Ea': '\xea',
				'%eA': '\xea',
				'%EA': '\xea',
				'%eb': '\xeb',
				'%Eb': '\xeb',
				'%eB': '\xeb',
				'%EB': '\xeb',
				'%ec': '\xec',
				'%Ec': '\xec',
				'%eC': '\xec',
				'%EC': '\xec',
				'%ed': '\xed',
				'%Ed': '\xed',
				'%eD': '\xed',
				'%ED': '\xed',
				'%ee': '\xee',
				'%Ee': '\xee',
				'%eE': '\xee',
				'%EE': '\xee',
				'%ef': '\xef',
				'%Ef': '\xef',
				'%eF': '\xef',
				'%EF': '\xef',
				'%f0': '\xf0',
				'%F0': '\xf0',
				'%f1': '\xf1',
				'%F1': '\xf1',
				'%f2': '\xf2',
				'%F2': '\xf2',
				'%f3': '\xf3',
				'%F3': '\xf3',
				'%f4': '\xf4',
				'%F4': '\xf4',
				'%f5': '\xf5',
				'%F5': '\xf5',
				'%f6': '\xf6',
				'%F6': '\xf6',
				'%f7': '\xf7',
				'%F7': '\xf7',
				'%f8': '\xf8',
				'%F8': '\xf8',
				'%f9': '\xf9',
				'%F9': '\xf9',
				'%fa': '\xfa',
				'%Fa': '\xfa',
				'%fA': '\xfa',
				'%FA': '\xfa',
				'%fb': '\xfb',
				'%Fb': '\xfb',
				'%fB': '\xfb',
				'%FB': '\xfb',
				'%fc': '\xfc',
				'%Fc': '\xfc',
				'%fC': '\xfc',
				'%FC': '\xfc',
				'%fd': '\xfd',
				'%Fd': '\xfd',
				'%fD': '\xfd',
				'%FD': '\xfd',
				'%fe': '\xfe',
				'%Fe': '\xfe',
				'%fE': '\xfe',
				'%FE': '\xfe',
				'%ff': '\xff',
				'%Ff': '\xff',
				'%fF': '\xff',
				'%FF': '\xff',
			}

			function encodedReplacer(match) {
				return EncodedLookup[match]
			}

			const STATE_KEY = 0
			const STATE_VALUE = 1
			const STATE_CHARSET = 2
			const STATE_LANG = 3

			function parseParams(str) {
				const res = []
				let state = STATE_KEY
				let charset = ''
				let inquote = false
				let escaping = false
				let p = 0
				let tmp = ''
				const len = str.length

				for (var i = 0; i < len; ++i) {
					// eslint-disable-line no-var
					const char = str[i]
					if (char === '\\' && inquote) {
						if (escaping) {
							escaping = false
						} else {
							escaping = true
							continue
						}
					} else if (char === '"') {
						if (!escaping) {
							if (inquote) {
								inquote = false
								state = STATE_KEY
							} else {
								inquote = true
							}
							continue
						} else {
							escaping = false
						}
					} else {
						if (escaping && inquote) {
							tmp += '\\'
						}
						escaping = false
						if (
							(state === STATE_CHARSET || state === STATE_LANG) &&
							char === "'"
						) {
							if (state === STATE_CHARSET) {
								state = STATE_LANG
								charset = tmp.substring(1)
							} else {
								state = STATE_VALUE
							}
							tmp = ''
							continue
						} else if (
							state === STATE_KEY &&
							(char === '*' || char === '=') &&
							res.length
						) {
							state = char === '*' ? STATE_CHARSET : STATE_VALUE
							res[p] = [tmp, undefined]
							tmp = ''
							continue
						} else if (!inquote && char === ';') {
							state = STATE_KEY
							if (charset) {
								if (tmp.length) {
									tmp = decodeText(
										tmp.replace(RE_ENCODED, encodedReplacer),
										'binary',
										charset,
									)
								}
								charset = ''
							} else if (tmp.length) {
								tmp = decodeText(tmp, 'binary', 'utf8')
							}
							if (res[p] === undefined) {
								res[p] = tmp
							} else {
								res[p][1] = tmp
							}
							tmp = ''
							++p
							continue
						} else if (!inquote && (char === ' ' || char === '\t')) {
							continue
						}
					}
					tmp += char
				}
				if (charset && tmp.length) {
					tmp = decodeText(
						tmp.replace(RE_ENCODED, encodedReplacer),
						'binary',
						charset,
					)
				} else if (tmp) {
					tmp = decodeText(tmp, 'binary', 'utf8')
				}

				if (res[p] === undefined) {
					if (tmp) {
						res[p] = tmp
					}
				} else {
					res[p][1] = tmp
				}

				return res
			}

			module.exports = parseParams

			/***/
		},

		/***/ 29602: /***/ (module) => {
			'use strict'
			module.exports = /*#__PURE__*/ JSON.parse(
				'{"name":"@babel/core","version":"7.12.9","description":"Babel compiler core.","main":"lib/index.js","author":"Sebastian McKenzie <sebmck@gmail.com>","homepage":"https://babeljs.io/","license":"MIT","publishConfig":{"access":"public"},"repository":{"type":"git","url":"https://github.com/babel/babel.git","directory":"packages/babel-core"},"keywords":["6to5","babel","classes","const","es6","harmony","let","modules","transpile","transpiler","var","babel-core","compiler"],"engines":{"node":">=6.9.0"},"funding":{"type":"opencollective","url":"https://opencollective.com/babel"},"browser":{"./lib/config/files/index.js":"./lib/config/files/index-browser.js","./lib/transform-file.js":"./lib/transform-file-browser.js","./src/config/files/index.js":"./src/config/files/index-browser.js","./src/transform-file.js":"./src/transform-file-browser.js"},"dependencies":{"@babel/code-frame":"^7.10.4","@babel/generator":"^7.12.5","@babel/helper-module-transforms":"^7.12.1","@babel/helpers":"^7.12.5","@babel/parser":"^7.12.7","@babel/template":"^7.12.7","@babel/traverse":"^7.12.9","@babel/types":"^7.12.7","convert-source-map":"^1.7.0","debug":"^4.1.0","gensync":"^1.0.0-beta.1","json5":"^2.1.2","lodash":"^4.17.19","resolve":"^1.3.2","semver":"^5.4.1","source-map":"^0.5.0"},"devDependencies":{"@babel/helper-transform-fixture-test-runner":"7.12.1"}}',
			)

			/***/
		},

		/***/ 33757: /***/ (module) => {
			'use strict'
			module.exports = /*#__PURE__*/ JSON.parse(
				'{"nbsp":"","iexcl":"","cent":"","pound":"","curren":"","yen":"","brvbar":"","sect":"","uml":"","copy":"","ordf":"","laquo":"","not":"","shy":"","reg":"","macr":"","deg":"","plusmn":"","sup2":"","sup3":"","acute":"","micro":"","para":"","middot":"","cedil":"","sup1":"","ordm":"","raquo":"","frac14":"","frac12":"","frac34":"","iquest":"","Agrave":"","Aacute":"","Acirc":"","Atilde":"","Auml":"","Aring":"","AElig":"","Ccedil":"","Egrave":"","Eacute":"","Ecirc":"","Euml":"","Igrave":"","Iacute":"","Icirc":"","Iuml":"","ETH":"","Ntilde":"","Ograve":"","Oacute":"","Ocirc":"","Otilde":"","Ouml":"","times":"","Oslash":"","Ugrave":"","Uacute":"","Ucirc":"","Uuml":"","Yacute":"","THORN":"","szlig":"","agrave":"","aacute":"","acirc":"","atilde":"","auml":"","aring":"","aelig":"","ccedil":"","egrave":"","eacute":"","ecirc":"","euml":"","igrave":"","iacute":"","icirc":"","iuml":"","eth":"","ntilde":"","ograve":"","oacute":"","ocirc":"","otilde":"","ouml":"","divide":"","oslash":"","ugrave":"","uacute":"","ucirc":"","uuml":"","yacute":"","thorn":"","yuml":"","fnof":"","Alpha":"","Beta":"","Gamma":"","Delta":"","Epsilon":"","Zeta":"","Eta":"","Theta":"","Iota":"","Kappa":"","Lambda":"","Mu":"","Nu":"","Xi":"","Omicron":"","Pi":"","Rho":"","Sigma":"","Tau":"","Upsilon":"","Phi":"","Chi":"","Psi":"","Omega":"","alpha":"","beta":"","gamma":"","delta":"","epsilon":"","zeta":"","eta":"","theta":"","iota":"","kappa":"","lambda":"","mu":"","nu":"","xi":"","omicron":"","pi":"","rho":"","sigmaf":"","sigma":"","tau":"","upsilon":"","phi":"","chi":"","psi":"","omega":"","thetasym":"","upsih":"","piv":"","bull":"","hellip":"","prime":"","Prime":"","oline":"","frasl":"","weierp":"","image":"","real":"","trade":"","alefsym":"","larr":"","uarr":"","rarr":"","darr":"","harr":"","crarr":"","lArr":"","uArr":"","rArr":"","dArr":"","hArr":"","forall":"","part":"","exist":"","empty":"","nabla":"","isin":"","notin":"","ni":"","prod":"","sum":"","minus":"","lowast":"","radic":"","prop":"","infin":"","ang":"","and":"","or":"","cap":"","cup":"","int":"","there4":"","sim":"","cong":"","asymp":"","ne":"","equiv":"","le":"","ge":"","sub":"","sup":"","nsub":"","sube":"","supe":"","oplus":"","otimes":"","perp":"","sdot":"","lceil":"","rceil":"","lfloor":"","rfloor":"","lang":"","rang":"","loz":"","spades":"","clubs":"","hearts":"","diams":"","quot":"\\"","amp":"&","lt":"<","gt":">","OElig":"","oelig":"","Scaron":"","scaron":"","Yuml":"","circ":"","tilde":"","ensp":"","emsp":"","thinsp":"","zwnj":"","zwj":"","lrm":"","rlm":"","ndash":"","mdash":"","lsquo":"","rsquo":"","sbquo":"","ldquo":"","rdquo":"","bdquo":"","dagger":"","Dagger":"","permil":"","lsaquo":"","rsaquo":"","euro":""}',
			)

			/***/
		},

		/***/ 82719: /***/ (module) => {
			'use strict'
			module.exports = /*#__PURE__*/ JSON.parse(
				'{"AElig":"","AMP":"&","Aacute":"","Acirc":"","Agrave":"","Aring":"","Atilde":"","Auml":"","COPY":"","Ccedil":"","ETH":"","Eacute":"","Ecirc":"","Egrave":"","Euml":"","GT":">","Iacute":"","Icirc":"","Igrave":"","Iuml":"","LT":"<","Ntilde":"","Oacute":"","Ocirc":"","Ograve":"","Oslash":"","Otilde":"","Ouml":"","QUOT":"\\"","REG":"","THORN":"","Uacute":"","Ucirc":"","Ugrave":"","Uuml":"","Yacute":"","aacute":"","acirc":"","acute":"","aelig":"","agrave":"","amp":"&","aring":"","atilde":"","auml":"","brvbar":"","ccedil":"","cedil":"","cent":"","copy":"","curren":"","deg":"","divide":"","eacute":"","ecirc":"","egrave":"","eth":"","euml":"","frac12":"","frac14":"","frac34":"","gt":">","iacute":"","icirc":"","iexcl":"","igrave":"","iquest":"","iuml":"","laquo":"","lt":"<","macr":"","micro":"","middot":"","nbsp":"","not":"","ntilde":"","oacute":"","ocirc":"","ograve":"","ordf":"","ordm":"","oslash":"","otilde":"","ouml":"","para":"","plusmn":"","pound":"","quot":"\\"","raquo":"","reg":"","sect":"","shy":"","sup1":"","sup2":"","sup3":"","szlig":"","thorn":"","times":"","uacute":"","ucirc":"","ugrave":"","uml":"","uuml":"","yacute":"","yen":"","yuml":""}',
			)

			/***/
		},

		/***/ 37839: /***/ (module) => {
			'use strict'
			module.exports = /*#__PURE__*/ JSON.parse(
				'{"AEli":"","AElig":"","AM":"&","AMP":"&","Aacut":"","Aacute":"","Abreve":"","Acir":"","Acirc":"","Acy":"","Afr":"","Agrav":"","Agrave":"","Alpha":"","Amacr":"","And":"","Aogon":"","Aopf":"","ApplyFunction":"","Arin":"","Aring":"","Ascr":"","Assign":"","Atild":"","Atilde":"","Aum":"","Auml":"","Backslash":"","Barv":"","Barwed":"","Bcy":"","Because":"","Bernoullis":"","Beta":"","Bfr":"","Bopf":"","Breve":"","Bscr":"","Bumpeq":"","CHcy":"","COP":"","COPY":"","Cacute":"","Cap":"","CapitalDifferentialD":"","Cayleys":"","Ccaron":"","Ccedi":"","Ccedil":"","Ccirc":"","Cconint":"","Cdot":"","Cedilla":"","CenterDot":"","Cfr":"","Chi":"","CircleDot":"","CircleMinus":"","CirclePlus":"","CircleTimes":"","ClockwiseContourIntegral":"","CloseCurlyDoubleQuote":"","CloseCurlyQuote":"","Colon":"","Colone":"","Congruent":"","Conint":"","ContourIntegral":"","Copf":"","Coproduct":"","CounterClockwiseContourIntegral":"","Cross":"","Cscr":"","Cup":"","CupCap":"","DD":"","DDotrahd":"","DJcy":"","DScy":"","DZcy":"","Dagger":"","Darr":"","Dashv":"","Dcaron":"","Dcy":"","Del":"","Delta":"","Dfr":"","DiacriticalAcute":"","DiacriticalDot":"","DiacriticalDoubleAcute":"","DiacriticalGrave":"`","DiacriticalTilde":"","Diamond":"","DifferentialD":"","Dopf":"","Dot":"","DotDot":"","DotEqual":"","DoubleContourIntegral":"","DoubleDot":"","DoubleDownArrow":"","DoubleLeftArrow":"","DoubleLeftRightArrow":"","DoubleLeftTee":"","DoubleLongLeftArrow":"","DoubleLongLeftRightArrow":"","DoubleLongRightArrow":"","DoubleRightArrow":"","DoubleRightTee":"","DoubleUpArrow":"","DoubleUpDownArrow":"","DoubleVerticalBar":"","DownArrow":"","DownArrowBar":"","DownArrowUpArrow":"","DownBreve":"","DownLeftRightVector":"","DownLeftTeeVector":"","DownLeftVector":"","DownLeftVectorBar":"","DownRightTeeVector":"","DownRightVector":"","DownRightVectorBar":"","DownTee":"","DownTeeArrow":"","Downarrow":"","Dscr":"","Dstrok":"","ENG":"","ET":"","ETH":"","Eacut":"","Eacute":"","Ecaron":"","Ecir":"","Ecirc":"","Ecy":"","Edot":"","Efr":"","Egrav":"","Egrave":"","Element":"","Emacr":"","EmptySmallSquare":"","EmptyVerySmallSquare":"","Eogon":"","Eopf":"","Epsilon":"","Equal":"","EqualTilde":"","Equilibrium":"","Escr":"","Esim":"","Eta":"","Eum":"","Euml":"","Exists":"","ExponentialE":"","Fcy":"","Ffr":"","FilledSmallSquare":"","FilledVerySmallSquare":"","Fopf":"","ForAll":"","Fouriertrf":"","Fscr":"","GJcy":"","G":">","GT":">","Gamma":"","Gammad":"","Gbreve":"","Gcedil":"","Gcirc":"","Gcy":"","Gdot":"","Gfr":"","Gg":"","Gopf":"","GreaterEqual":"","GreaterEqualLess":"","GreaterFullEqual":"","GreaterGreater":"","GreaterLess":"","GreaterSlantEqual":"","GreaterTilde":"","Gscr":"","Gt":"","HARDcy":"","Hacek":"","Hat":"^","Hcirc":"","Hfr":"","HilbertSpace":"","Hopf":"","HorizontalLine":"","Hscr":"","Hstrok":"","HumpDownHump":"","HumpEqual":"","IEcy":"","IJlig":"","IOcy":"","Iacut":"","Iacute":"","Icir":"","Icirc":"","Icy":"","Idot":"","Ifr":"","Igrav":"","Igrave":"","Im":"","Imacr":"","ImaginaryI":"","Implies":"","Int":"","Integral":"","Intersection":"","InvisibleComma":"","InvisibleTimes":"","Iogon":"","Iopf":"","Iota":"","Iscr":"","Itilde":"","Iukcy":"","Ium":"","Iuml":"","Jcirc":"","Jcy":"","Jfr":"","Jopf":"","Jscr":"","Jsercy":"","Jukcy":"","KHcy":"","KJcy":"","Kappa":"","Kcedil":"","Kcy":"","Kfr":"","Kopf":"","Kscr":"","LJcy":"","L":"<","LT":"<","Lacute":"","Lambda":"","Lang":"","Laplacetrf":"","Larr":"","Lcaron":"","Lcedil":"","Lcy":"","LeftAngleBracket":"","LeftArrow":"","LeftArrowBar":"","LeftArrowRightArrow":"","LeftCeiling":"","LeftDoubleBracket":"","LeftDownTeeVector":"","LeftDownVector":"","LeftDownVectorBar":"","LeftFloor":"","LeftRightArrow":"","LeftRightVector":"","LeftTee":"","LeftTeeArrow":"","LeftTeeVector":"","LeftTriangle":"","LeftTriangleBar":"","LeftTriangleEqual":"","LeftUpDownVector":"","LeftUpTeeVector":"","LeftUpVector":"","LeftUpVectorBar":"","LeftVector":"","LeftVectorBar":"","Leftarrow":"","Leftrightarrow":"","LessEqualGreater":"","LessFullEqual":"","LessGreater":"","LessLess":"","LessSlantEqual":"","LessTilde":"","Lfr":"","Ll":"","Lleftarrow":"","Lmidot":"","LongLeftArrow":"","LongLeftRightArrow":"","LongRightArrow":"","Longleftarrow":"","Longleftrightarrow":"","Longrightarrow":"","Lopf":"","LowerLeftArrow":"","LowerRightArrow":"","Lscr":"","Lsh":"","Lstrok":"","Lt":"","Map":"","Mcy":"","MediumSpace":"","Mellintrf":"","Mfr":"","MinusPlus":"","Mopf":"","Mscr":"","Mu":"","NJcy":"","Nacute":"","Ncaron":"","Ncedil":"","Ncy":"","NegativeMediumSpace":"","NegativeThickSpace":"","NegativeThinSpace":"","NegativeVeryThinSpace":"","NestedGreaterGreater":"","NestedLessLess":"","NewLine":"\\n","Nfr":"","NoBreak":"","NonBreakingSpace":"","Nopf":"","Not":"","NotCongruent":"","NotCupCap":"","NotDoubleVerticalBar":"","NotElement":"","NotEqual":"","NotEqualTilde":"","NotExists":"","NotGreater":"","NotGreaterEqual":"","NotGreaterFullEqual":"","NotGreaterGreater":"","NotGreaterLess":"","NotGreaterSlantEqual":"","NotGreaterTilde":"","NotHumpDownHump":"","NotHumpEqual":"","NotLeftTriangle":"","NotLeftTriangleBar":"","NotLeftTriangleEqual":"","NotLess":"","NotLessEqual":"","NotLessGreater":"","NotLessLess":"","NotLessSlantEqual":"","NotLessTilde":"","NotNestedGreaterGreater":"","NotNestedLessLess":"","NotPrecedes":"","NotPrecedesEqual":"","NotPrecedesSlantEqual":"","NotReverseElement":"","NotRightTriangle":"","NotRightTriangleBar":"","NotRightTriangleEqual":"","NotSquareSubset":"","NotSquareSubsetEqual":"","NotSquareSuperset":"","NotSquareSupersetEqual":"","NotSubset":"","NotSubsetEqual":"","NotSucceeds":"","NotSucceedsEqual":"","NotSucceedsSlantEqual":"","NotSucceedsTilde":"","NotSuperset":"","NotSupersetEqual":"","NotTilde":"","NotTildeEqual":"","NotTildeFullEqual":"","NotTildeTilde":"","NotVerticalBar":"","Nscr":"","Ntild":"","Ntilde":"","Nu":"","OElig":"","Oacut":"","Oacute":"","Ocir":"","Ocirc":"","Ocy":"","Odblac":"","Ofr":"","Ograv":"","Ograve":"","Omacr":"","Omega":"","Omicron":"","Oopf":"","OpenCurlyDoubleQuote":"","OpenCurlyQuote":"","Or":"","Oscr":"","Oslas":"","Oslash":"","Otild":"","Otilde":"","Otimes":"","Oum":"","Ouml":"","OverBar":"","OverBrace":"","OverBracket":"","OverParenthesis":"","PartialD":"","Pcy":"","Pfr":"","Phi":"","Pi":"","PlusMinus":"","Poincareplane":"","Popf":"","Pr":"","Precedes":"","PrecedesEqual":"","PrecedesSlantEqual":"","PrecedesTilde":"","Prime":"","Product":"","Proportion":"","Proportional":"","Pscr":"","Psi":"","QUO":"\\"","QUOT":"\\"","Qfr":"","Qopf":"","Qscr":"","RBarr":"","RE":"","REG":"","Racute":"","Rang":"","Rarr":"","Rarrtl":"","Rcaron":"","Rcedil":"","Rcy":"","Re":"","ReverseElement":"","ReverseEquilibrium":"","ReverseUpEquilibrium":"","Rfr":"","Rho":"","RightAngleBracket":"","RightArrow":"","RightArrowBar":"","RightArrowLeftArrow":"","RightCeiling":"","RightDoubleBracket":"","RightDownTeeVector":"","RightDownVector":"","RightDownVectorBar":"","RightFloor":"","RightTee":"","RightTeeArrow":"","RightTeeVector":"","RightTriangle":"","RightTriangleBar":"","RightTriangleEqual":"","RightUpDownVector":"","RightUpTeeVector":"","RightUpVector":"","RightUpVectorBar":"","RightVector":"","RightVectorBar":"","Rightarrow":"","Ropf":"","RoundImplies":"","Rrightarrow":"","Rscr":"","Rsh":"","RuleDelayed":"","SHCHcy":"","SHcy":"","SOFTcy":"","Sacute":"","Sc":"","Scaron":"","Scedil":"","Scirc":"","Scy":"","Sfr":"","ShortDownArrow":"","ShortLeftArrow":"","ShortRightArrow":"","ShortUpArrow":"","Sigma":"","SmallCircle":"","Sopf":"","Sqrt":"","Square":"","SquareIntersection":"","SquareSubset":"","SquareSubsetEqual":"","SquareSuperset":"","SquareSupersetEqual":"","SquareUnion":"","Sscr":"","Star":"","Sub":"","Subset":"","SubsetEqual":"","Succeeds":"","SucceedsEqual":"","SucceedsSlantEqual":"","SucceedsTilde":"","SuchThat":"","Sum":"","Sup":"","Superset":"","SupersetEqual":"","Supset":"","THOR":"","THORN":"","TRADE":"","TSHcy":"","TScy":"","Tab":"\\t","Tau":"","Tcaron":"","Tcedil":"","Tcy":"","Tfr":"","Therefore":"","Theta":"","ThickSpace":"","ThinSpace":"","Tilde":"","TildeEqual":"","TildeFullEqual":"","TildeTilde":"","Topf":"","TripleDot":"","Tscr":"","Tstrok":"","Uacut":"","Uacute":"","Uarr":"","Uarrocir":"","Ubrcy":"","Ubreve":"","Ucir":"","Ucirc":"","Ucy":"","Udblac":"","Ufr":"","Ugrav":"","Ugrave":"","Umacr":"","UnderBar":"_","UnderBrace":"","UnderBracket":"","UnderParenthesis":"","Union":"","UnionPlus":"","Uogon":"","Uopf":"","UpArrow":"","UpArrowBar":"","UpArrowDownArrow":"","UpDownArrow":"","UpEquilibrium":"","UpTee":"","UpTeeArrow":"","Uparrow":"","Updownarrow":"","UpperLeftArrow":"","UpperRightArrow":"","Upsi":"","Upsilon":"","Uring":"","Uscr":"","Utilde":"","Uum":"","Uuml":"","VDash":"","Vbar":"","Vcy":"","Vdash":"","Vdashl":"","Vee":"","Verbar":"","Vert":"","VerticalBar":"","VerticalLine":"|","VerticalSeparator":"","VerticalTilde":"","VeryThinSpace":"","Vfr":"","Vopf":"","Vscr":"","Vvdash":"","Wcirc":"","Wedge":"","Wfr":"","Wopf":"","Wscr":"","Xfr":"","Xi":"","Xopf":"","Xscr":"","YAcy":"","YIcy":"","YUcy":"","Yacut":"","Yacute":"","Ycirc":"","Ycy":"","Yfr":"","Yopf":"","Yscr":"","Yuml":"","ZHcy":"","Zacute":"","Zcaron":"","Zcy":"","Zdot":"","ZeroWidthSpace":"","Zeta":"","Zfr":"","Zopf":"","Zscr":"","aacut":"","aacute":"","abreve":"","ac":"","acE":"","acd":"","acir":"","acirc":"","acut":"","acute":"","acy":"","aeli":"","aelig":"","af":"","afr":"","agrav":"","agrave":"","alefsym":"","aleph":"","alpha":"","amacr":"","amalg":"","am":"&","amp":"&","and":"","andand":"","andd":"","andslope":"","andv":"","ang":"","ange":"","angle":"","angmsd":"","angmsdaa":"","angmsdab":"","angmsdac":"","angmsdad":"","angmsdae":"","angmsdaf":"","angmsdag":"","angmsdah":"","angrt":"","angrtvb":"","angrtvbd":"","angsph":"","angst":"","angzarr":"","aogon":"","aopf":"","ap":"","apE":"","apacir":"","ape":"","apid":"","apos":"\'","approx":"","approxeq":"","arin":"","aring":"","ascr":"","ast":"*","asymp":"","asympeq":"","atild":"","atilde":"","aum":"","auml":"","awconint":"","awint":"","bNot":"","backcong":"","backepsilon":"","backprime":"","backsim":"","backsimeq":"","barvee":"","barwed":"","barwedge":"","bbrk":"","bbrktbrk":"","bcong":"","bcy":"","bdquo":"","becaus":"","because":"","bemptyv":"","bepsi":"","bernou":"","beta":"","beth":"","between":"","bfr":"","bigcap":"","bigcirc":"","bigcup":"","bigodot":"","bigoplus":"","bigotimes":"","bigsqcup":"","bigstar":"","bigtriangledown":"","bigtriangleup":"","biguplus":"","bigvee":"","bigwedge":"","bkarow":"","blacklozenge":"","blacksquare":"","blacktriangle":"","blacktriangledown":"","blacktriangleleft":"","blacktriangleright":"","blank":"","blk12":"","blk14":"","blk34":"","block":"","bne":"=","bnequiv":"","bnot":"","bopf":"","bot":"","bottom":"","bowtie":"","boxDL":"","boxDR":"","boxDl":"","boxDr":"","boxH":"","boxHD":"","boxHU":"","boxHd":"","boxHu":"","boxUL":"","boxUR":"","boxUl":"","boxUr":"","boxV":"","boxVH":"","boxVL":"","boxVR":"","boxVh":"","boxVl":"","boxVr":"","boxbox":"","boxdL":"","boxdR":"","boxdl":"","boxdr":"","boxh":"","boxhD":"","boxhU":"","boxhd":"","boxhu":"","boxminus":"","boxplus":"","boxtimes":"","boxuL":"","boxuR":"","boxul":"","boxur":"","boxv":"","boxvH":"","boxvL":"","boxvR":"","boxvh":"","boxvl":"","boxvr":"","bprime":"","breve":"","brvba":"","brvbar":"","bscr":"","bsemi":"","bsim":"","bsime":"","bsol":"\\\\","bsolb":"","bsolhsub":"","bull":"","bullet":"","bump":"","bumpE":"","bumpe":"","bumpeq":"","cacute":"","cap":"","capand":"","capbrcup":"","capcap":"","capcup":"","capdot":"","caps":"","caret":"","caron":"","ccaps":"","ccaron":"","ccedi":"","ccedil":"","ccirc":"","ccups":"","ccupssm":"","cdot":"","cedi":"","cedil":"","cemptyv":"","cen":"","cent":"","centerdot":"","cfr":"","chcy":"","check":"","checkmark":"","chi":"","cir":"","cirE":"","circ":"","circeq":"","circlearrowleft":"","circlearrowright":"","circledR":"","circledS":"","circledast":"","circledcirc":"","circleddash":"","cire":"","cirfnint":"","cirmid":"","cirscir":"","clubs":"","clubsuit":"","colon":":","colone":"","coloneq":"","comma":",","commat":"@","comp":"","compfn":"","complement":"","complexes":"","cong":"","congdot":"","conint":"","copf":"","coprod":"","cop":"","copy":"","copysr":"","crarr":"","cross":"","cscr":"","csub":"","csube":"","csup":"","csupe":"","ctdot":"","cudarrl":"","cudarrr":"","cuepr":"","cuesc":"","cularr":"","cularrp":"","cup":"","cupbrcap":"","cupcap":"","cupcup":"","cupdot":"","cupor":"","cups":"","curarr":"","curarrm":"","curlyeqprec":"","curlyeqsucc":"","curlyvee":"","curlywedge":"","curre":"","curren":"","curvearrowleft":"","curvearrowright":"","cuvee":"","cuwed":"","cwconint":"","cwint":"","cylcty":"","dArr":"","dHar":"","dagger":"","daleth":"","darr":"","dash":"","dashv":"","dbkarow":"","dblac":"","dcaron":"","dcy":"","dd":"","ddagger":"","ddarr":"","ddotseq":"","de":"","deg":"","delta":"","demptyv":"","dfisht":"","dfr":"","dharl":"","dharr":"","diam":"","diamond":"","diamondsuit":"","diams":"","die":"","digamma":"","disin":"","div":"","divid":"","divide":"","divideontimes":"","divonx":"","djcy":"","dlcorn":"","dlcrop":"","dollar":"$","dopf":"","dot":"","doteq":"","doteqdot":"","dotminus":"","dotplus":"","dotsquare":"","doublebarwedge":"","downarrow":"","downdownarrows":"","downharpoonleft":"","downharpoonright":"","drbkarow":"","drcorn":"","drcrop":"","dscr":"","dscy":"","dsol":"","dstrok":"","dtdot":"","dtri":"","dtrif":"","duarr":"","duhar":"","dwangle":"","dzcy":"","dzigrarr":"","eDDot":"","eDot":"","eacut":"","eacute":"","easter":"","ecaron":"","ecir":"","ecirc":"","ecolon":"","ecy":"","edot":"","ee":"","efDot":"","efr":"","eg":"","egrav":"","egrave":"","egs":"","egsdot":"","el":"","elinters":"","ell":"","els":"","elsdot":"","emacr":"","empty":"","emptyset":"","emptyv":"","emsp13":"","emsp14":"","emsp":"","eng":"","ensp":"","eogon":"","eopf":"","epar":"","eparsl":"","eplus":"","epsi":"","epsilon":"","epsiv":"","eqcirc":"","eqcolon":"","eqsim":"","eqslantgtr":"","eqslantless":"","equals":"=","equest":"","equiv":"","equivDD":"","eqvparsl":"","erDot":"","erarr":"","escr":"","esdot":"","esim":"","eta":"","et":"","eth":"","eum":"","euml":"","euro":"","excl":"!","exist":"","expectation":"","exponentiale":"","fallingdotseq":"","fcy":"","female":"","ffilig":"","fflig":"","ffllig":"","ffr":"","filig":"","fjlig":"fj","flat":"","fllig":"","fltns":"","fnof":"","fopf":"","forall":"","fork":"","forkv":"","fpartint":"","frac1":"","frac12":"","frac13":"","frac14":"","frac15":"","frac16":"","frac18":"","frac23":"","frac25":"","frac3":"","frac34":"","frac35":"","frac38":"","frac45":"","frac56":"","frac58":"","frac78":"","frasl":"","frown":"","fscr":"","gE":"","gEl":"","gacute":"","gamma":"","gammad":"","gap":"","gbreve":"","gcirc":"","gcy":"","gdot":"","ge":"","gel":"","geq":"","geqq":"","geqslant":"","ges":"","gescc":"","gesdot":"","gesdoto":"","gesdotol":"","gesl":"","gesles":"","gfr":"","gg":"","ggg":"","gimel":"","gjcy":"","gl":"","glE":"","gla":"","glj":"","gnE":"","gnap":"","gnapprox":"","gne":"","gneq":"","gneqq":"","gnsim":"","gopf":"","grave":"`","gscr":"","gsim":"","gsime":"","gsiml":"","g":">","gt":">","gtcc":"","gtcir":"","gtdot":"","gtlPar":"","gtquest":"","gtrapprox":"","gtrarr":"","gtrdot":"","gtreqless":"","gtreqqless":"","gtrless":"","gtrsim":"","gvertneqq":"","gvnE":"","hArr":"","hairsp":"","half":"","hamilt":"","hardcy":"","harr":"","harrcir":"","harrw":"","hbar":"","hcirc":"","hearts":"","heartsuit":"","hellip":"","hercon":"","hfr":"","hksearow":"","hkswarow":"","hoarr":"","homtht":"","hookleftarrow":"","hookrightarrow":"","hopf":"","horbar":"","hscr":"","hslash":"","hstrok":"","hybull":"","hyphen":"","iacut":"","iacute":"","ic":"","icir":"","icirc":"","icy":"","iecy":"","iexc":"","iexcl":"","iff":"","ifr":"","igrav":"","igrave":"","ii":"","iiiint":"","iiint":"","iinfin":"","iiota":"","ijlig":"","imacr":"","image":"","imagline":"","imagpart":"","imath":"","imof":"","imped":"","in":"","incare":"","infin":"","infintie":"","inodot":"","int":"","intcal":"","integers":"","intercal":"","intlarhk":"","intprod":"","iocy":"","iogon":"","iopf":"","iota":"","iprod":"","iques":"","iquest":"","iscr":"","isin":"","isinE":"","isindot":"","isins":"","isinsv":"","isinv":"","it":"","itilde":"","iukcy":"","ium":"","iuml":"","jcirc":"","jcy":"","jfr":"","jmath":"","jopf":"","jscr":"","jsercy":"","jukcy":"","kappa":"","kappav":"","kcedil":"","kcy":"","kfr":"","kgreen":"","khcy":"","kjcy":"","kopf":"","kscr":"","lAarr":"","lArr":"","lAtail":"","lBarr":"","lE":"","lEg":"","lHar":"","lacute":"","laemptyv":"","lagran":"","lambda":"","lang":"","langd":"","langle":"","lap":"","laqu":"","laquo":"","larr":"","larrb":"","larrbfs":"","larrfs":"","larrhk":"","larrlp":"","larrpl":"","larrsim":"","larrtl":"","lat":"","latail":"","late":"","lates":"","lbarr":"","lbbrk":"","lbrace":"{","lbrack":"[","lbrke":"","lbrksld":"","lbrkslu":"","lcaron":"","lcedil":"","lceil":"","lcub":"{","lcy":"","ldca":"","ldquo":"","ldquor":"","ldrdhar":"","ldrushar":"","ldsh":"","le":"","leftarrow":"","leftarrowtail":"","leftharpoondown":"","leftharpoonup":"","leftleftarrows":"","leftrightarrow":"","leftrightarrows":"","leftrightharpoons":"","leftrightsquigarrow":"","leftthreetimes":"","leg":"","leq":"","leqq":"","leqslant":"","les":"","lescc":"","lesdot":"","lesdoto":"","lesdotor":"","lesg":"","lesges":"","lessapprox":"","lessdot":"","lesseqgtr":"","lesseqqgtr":"","lessgtr":"","lesssim":"","lfisht":"","lfloor":"","lfr":"","lg":"","lgE":"","lhard":"","lharu":"","lharul":"","lhblk":"","ljcy":"","ll":"","llarr":"","llcorner":"","llhard":"","lltri":"","lmidot":"","lmoust":"","lmoustache":"","lnE":"","lnap":"","lnapprox":"","lne":"","lneq":"","lneqq":"","lnsim":"","loang":"","loarr":"","lobrk":"","longleftarrow":"","longleftrightarrow":"","longmapsto":"","longrightarrow":"","looparrowleft":"","looparrowright":"","lopar":"","lopf":"","loplus":"","lotimes":"","lowast":"","lowbar":"_","loz":"","lozenge":"","lozf":"","lpar":"(","lparlt":"","lrarr":"","lrcorner":"","lrhar":"","lrhard":"","lrm":"","lrtri":"","lsaquo":"","lscr":"","lsh":"","lsim":"","lsime":"","lsimg":"","lsqb":"[","lsquo":"","lsquor":"","lstrok":"","l":"<","lt":"<","ltcc":"","ltcir":"","ltdot":"","lthree":"","ltimes":"","ltlarr":"","ltquest":"","ltrPar":"","ltri":"","ltrie":"","ltrif":"","lurdshar":"","luruhar":"","lvertneqq":"","lvnE":"","mDDot":"","mac":"","macr":"","male":"","malt":"","maltese":"","map":"","mapsto":"","mapstodown":"","mapstoleft":"","mapstoup":"","marker":"","mcomma":"","mcy":"","mdash":"","measuredangle":"","mfr":"","mho":"","micr":"","micro":"","mid":"","midast":"*","midcir":"","middo":"","middot":"","minus":"","minusb":"","minusd":"","minusdu":"","mlcp":"","mldr":"","mnplus":"","models":"","mopf":"","mp":"","mscr":"","mstpos":"","mu":"","multimap":"","mumap":"","nGg":"","nGt":"","nGtv":"","nLeftarrow":"","nLeftrightarrow":"","nLl":"","nLt":"","nLtv":"","nRightarrow":"","nVDash":"","nVdash":"","nabla":"","nacute":"","nang":"","nap":"","napE":"","napid":"","napos":"","napprox":"","natur":"","natural":"","naturals":"","nbs":"","nbsp":"","nbump":"","nbumpe":"","ncap":"","ncaron":"","ncedil":"","ncong":"","ncongdot":"","ncup":"","ncy":"","ndash":"","ne":"","neArr":"","nearhk":"","nearr":"","nearrow":"","nedot":"","nequiv":"","nesear":"","nesim":"","nexist":"","nexists":"","nfr":"","ngE":"","nge":"","ngeq":"","ngeqq":"","ngeqslant":"","nges":"","ngsim":"","ngt":"","ngtr":"","nhArr":"","nharr":"","nhpar":"","ni":"","nis":"","nisd":"","niv":"","njcy":"","nlArr":"","nlE":"","nlarr":"","nldr":"","nle":"","nleftarrow":"","nleftrightarrow":"","nleq":"","nleqq":"","nleqslant":"","nles":"","nless":"","nlsim":"","nlt":"","nltri":"","nltrie":"","nmid":"","nopf":"","no":"","not":"","notin":"","notinE":"","notindot":"","notinva":"","notinvb":"","notinvc":"","notni":"","notniva":"","notnivb":"","notnivc":"","npar":"","nparallel":"","nparsl":"","npart":"","npolint":"","npr":"","nprcue":"","npre":"","nprec":"","npreceq":"","nrArr":"","nrarr":"","nrarrc":"","nrarrw":"","nrightarrow":"","nrtri":"","nrtrie":"","nsc":"","nsccue":"","nsce":"","nscr":"","nshortmid":"","nshortparallel":"","nsim":"","nsime":"","nsimeq":"","nsmid":"","nspar":"","nsqsube":"","nsqsupe":"","nsub":"","nsubE":"","nsube":"","nsubset":"","nsubseteq":"","nsubseteqq":"","nsucc":"","nsucceq":"","nsup":"","nsupE":"","nsupe":"","nsupset":"","nsupseteq":"","nsupseteqq":"","ntgl":"","ntild":"","ntilde":"","ntlg":"","ntriangleleft":"","ntrianglelefteq":"","ntriangleright":"","ntrianglerighteq":"","nu":"","num":"#","numero":"","numsp":"","nvDash":"","nvHarr":"","nvap":"","nvdash":"","nvge":"","nvgt":">","nvinfin":"","nvlArr":"","nvle":"","nvlt":"<","nvltrie":"","nvrArr":"","nvrtrie":"","nvsim":"","nwArr":"","nwarhk":"","nwarr":"","nwarrow":"","nwnear":"","oS":"","oacut":"","oacute":"","oast":"","ocir":"","ocirc":"","ocy":"","odash":"","odblac":"","odiv":"","odot":"","odsold":"","oelig":"","ofcir":"","ofr":"","ogon":"","ograv":"","ograve":"","ogt":"","ohbar":"","ohm":"","oint":"","olarr":"","olcir":"","olcross":"","oline":"","olt":"","omacr":"","omega":"","omicron":"","omid":"","ominus":"","oopf":"","opar":"","operp":"","oplus":"","or":"","orarr":"","ord":"","order":"","orderof":"","ordf":"","ordm":"","origof":"","oror":"","orslope":"","orv":"","oscr":"","oslas":"","oslash":"","osol":"","otild":"","otilde":"","otimes":"","otimesas":"","oum":"","ouml":"","ovbar":"","par":"","para":"","parallel":"","parsim":"","parsl":"","part":"","pcy":"","percnt":"%","period":".","permil":"","perp":"","pertenk":"","pfr":"","phi":"","phiv":"","phmmat":"","phone":"","pi":"","pitchfork":"","piv":"","planck":"","planckh":"","plankv":"","plus":"+","plusacir":"","plusb":"","pluscir":"","plusdo":"","plusdu":"","pluse":"","plusm":"","plusmn":"","plussim":"","plustwo":"","pm":"","pointint":"","popf":"","poun":"","pound":"","pr":"","prE":"","prap":"","prcue":"","pre":"","prec":"","precapprox":"","preccurlyeq":"","preceq":"","precnapprox":"","precneqq":"","precnsim":"","precsim":"","prime":"","primes":"","prnE":"","prnap":"","prnsim":"","prod":"","profalar":"","profline":"","profsurf":"","prop":"","propto":"","prsim":"","prurel":"","pscr":"","psi":"","puncsp":"","qfr":"","qint":"","qopf":"","qprime":"","qscr":"","quaternions":"","quatint":"","quest":"?","questeq":"","quo":"\\"","quot":"\\"","rAarr":"","rArr":"","rAtail":"","rBarr":"","rHar":"","race":"","racute":"","radic":"","raemptyv":"","rang":"","rangd":"","range":"","rangle":"","raqu":"","raquo":"","rarr":"","rarrap":"","rarrb":"","rarrbfs":"","rarrc":"","rarrfs":"","rarrhk":"","rarrlp":"","rarrpl":"","rarrsim":"","rarrtl":"","rarrw":"","ratail":"","ratio":"","rationals":"","rbarr":"","rbbrk":"","rbrace":"}","rbrack":"]","rbrke":"","rbrksld":"","rbrkslu":"","rcaron":"","rcedil":"","rceil":"","rcub":"}","rcy":"","rdca":"","rdldhar":"","rdquo":"","rdquor":"","rdsh":"","real":"","realine":"","realpart":"","reals":"","rect":"","re":"","reg":"","rfisht":"","rfloor":"","rfr":"","rhard":"","rharu":"","rharul":"","rho":"","rhov":"","rightarrow":"","rightarrowtail":"","rightharpoondown":"","rightharpoonup":"","rightleftarrows":"","rightleftharpoons":"","rightrightarrows":"","rightsquigarrow":"","rightthreetimes":"","ring":"","risingdotseq":"","rlarr":"","rlhar":"","rlm":"","rmoust":"","rmoustache":"","rnmid":"","roang":"","roarr":"","robrk":"","ropar":"","ropf":"","roplus":"","rotimes":"","rpar":")","rpargt":"","rppolint":"","rrarr":"","rsaquo":"","rscr":"","rsh":"","rsqb":"]","rsquo":"","rsquor":"","rthree":"","rtimes":"","rtri":"","rtrie":"","rtrif":"","rtriltri":"","ruluhar":"","rx":"","sacute":"","sbquo":"","sc":"","scE":"","scap":"","scaron":"","sccue":"","sce":"","scedil":"","scirc":"","scnE":"","scnap":"","scnsim":"","scpolint":"","scsim":"","scy":"","sdot":"","sdotb":"","sdote":"","seArr":"","searhk":"","searr":"","searrow":"","sec":"","sect":"","semi":";","seswar":"","setminus":"","setmn":"","sext":"","sfr":"","sfrown":"","sharp":"","shchcy":"","shcy":"","shortmid":"","shortparallel":"","sh":"","shy":"","sigma":"","sigmaf":"","sigmav":"","sim":"","simdot":"","sime":"","simeq":"","simg":"","simgE":"","siml":"","simlE":"","simne":"","simplus":"","simrarr":"","slarr":"","smallsetminus":"","smashp":"","smeparsl":"","smid":"","smile":"","smt":"","smte":"","smtes":"","softcy":"","sol":"/","solb":"","solbar":"","sopf":"","spades":"","spadesuit":"","spar":"","sqcap":"","sqcaps":"","sqcup":"","sqcups":"","sqsub":"","sqsube":"","sqsubset":"","sqsubseteq":"","sqsup":"","sqsupe":"","sqsupset":"","sqsupseteq":"","squ":"","square":"","squarf":"","squf":"","srarr":"","sscr":"","ssetmn":"","ssmile":"","sstarf":"","star":"","starf":"","straightepsilon":"","straightphi":"","strns":"","sub":"","subE":"","subdot":"","sube":"","subedot":"","submult":"","subnE":"","subne":"","subplus":"","subrarr":"","subset":"","subseteq":"","subseteqq":"","subsetneq":"","subsetneqq":"","subsim":"","subsub":"","subsup":"","succ":"","succapprox":"","succcurlyeq":"","succeq":"","succnapprox":"","succneqq":"","succnsim":"","succsim":"","sum":"","sung":"","sup":"","sup1":"","sup2":"","sup3":"","supE":"","supdot":"","supdsub":"","supe":"","supedot":"","suphsol":"","suphsub":"","suplarr":"","supmult":"","supnE":"","supne":"","supplus":"","supset":"","supseteq":"","supseteqq":"","supsetneq":"","supsetneqq":"","supsim":"","supsub":"","supsup":"","swArr":"","swarhk":"","swarr":"","swarrow":"","swnwar":"","szli":"","szlig":"","target":"","tau":"","tbrk":"","tcaron":"","tcedil":"","tcy":"","tdot":"","telrec":"","tfr":"","there4":"","therefore":"","theta":"","thetasym":"","thetav":"","thickapprox":"","thicksim":"","thinsp":"","thkap":"","thksim":"","thor":"","thorn":"","tilde":"","time":"","times":"","timesb":"","timesbar":"","timesd":"","tint":"","toea":"","top":"","topbot":"","topcir":"","topf":"","topfork":"","tosa":"","tprime":"","trade":"","triangle":"","triangledown":"","triangleleft":"","trianglelefteq":"","triangleq":"","triangleright":"","trianglerighteq":"","tridot":"","trie":"","triminus":"","triplus":"","trisb":"","tritime":"","trpezium":"","tscr":"","tscy":"","tshcy":"","tstrok":"","twixt":"","twoheadleftarrow":"","twoheadrightarrow":"","uArr":"","uHar":"","uacut":"","uacute":"","uarr":"","ubrcy":"","ubreve":"","ucir":"","ucirc":"","ucy":"","udarr":"","udblac":"","udhar":"","ufisht":"","ufr":"","ugrav":"","ugrave":"","uharl":"","uharr":"","uhblk":"","ulcorn":"","ulcorner":"","ulcrop":"","ultri":"","umacr":"","um":"","uml":"","uogon":"","uopf":"","uparrow":"","updownarrow":"","upharpoonleft":"","upharpoonright":"","uplus":"","upsi":"","upsih":"","upsilon":"","upuparrows":"","urcorn":"","urcorner":"","urcrop":"","uring":"","urtri":"","uscr":"","utdot":"","utilde":"","utri":"","utrif":"","uuarr":"","uum":"","uuml":"","uwangle":"","vArr":"","vBar":"","vBarv":"","vDash":"","vangrt":"","varepsilon":"","varkappa":"","varnothing":"","varphi":"","varpi":"","varpropto":"","varr":"","varrho":"","varsigma":"","varsubsetneq":"","varsubsetneqq":"","varsupsetneq":"","varsupsetneqq":"","vartheta":"","vartriangleleft":"","vartriangleright":"","vcy":"","vdash":"","vee":"","veebar":"","veeeq":"","vellip":"","verbar":"|","vert":"|","vfr":"","vltri":"","vnsub":"","vnsup":"","vopf":"","vprop":"","vrtri":"","vscr":"","vsubnE":"","vsubne":"","vsupnE":"","vsupne":"","vzigzag":"","wcirc":"","wedbar":"","wedge":"","wedgeq":"","weierp":"","wfr":"","wopf":"","wp":"","wr":"","wreath":"","wscr":"","xcap":"","xcirc":"","xcup":"","xdtri":"","xfr":"","xhArr":"","xharr":"","xi":"","xlArr":"","xlarr":"","xmap":"","xnis":"","xodot":"","xopf":"","xoplus":"","xotime":"","xrArr":"","xrarr":"","xscr":"","xsqcup":"","xuplus":"","xutri":"","xvee":"","xwedge":"","yacut":"","yacute":"","yacy":"","ycirc":"","ycy":"","ye":"","yen":"","yfr":"","yicy":"","yopf":"","yscr":"","yucy":"","yum":"","yuml":"","zacute":"","zcaron":"","zcy":"","zdot":"","zeetrf":"","zeta":"","zfr":"","zhcy":"","zigrarr":"","zopf":"","zscr":"","zwj":"","zwnj":""}',
			)

			/***/
		},

		/***/ 21257: /***/ (module) => {
			'use strict'
			module.exports = /*#__PURE__*/ JSON.parse(
				'{"0":"","128":"","130":"","131":"","132":"","133":"","134":"","135":"","136":"","137":"","138":"","139":"","140":"","142":"","145":"","146":"","147":"","148":"","149":"","150":"","151":"","152":"","153":"","154":"","155":"","156":"","158":"","159":""}',
			)

			/***/
		},

		/***/ 14652: /***/ (module) => {
			'use strict'
			module.exports = /*#__PURE__*/ JSON.parse(
				'{"builtin":{"Array":false,"ArrayBuffer":false,"Atomics":false,"BigInt":false,"BigInt64Array":false,"BigUint64Array":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"globalThis":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es5":{"Array":false,"Boolean":false,"constructor":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"propertyIsEnumerable":false,"RangeError":false,"ReferenceError":false,"RegExp":false,"String":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false},"es2015":{"Array":false,"ArrayBuffer":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es2017":{"Array":false,"ArrayBuffer":false,"Atomics":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"browser":{"AbortController":false,"AbortSignal":false,"addEventListener":false,"alert":false,"AnalyserNode":false,"Animation":false,"AnimationEffectReadOnly":false,"AnimationEffectTiming":false,"AnimationEffectTimingReadOnly":false,"AnimationEvent":false,"AnimationPlaybackEvent":false,"AnimationTimeline":false,"applicationCache":false,"ApplicationCache":false,"ApplicationCacheErrorEvent":false,"atob":false,"Attr":false,"Audio":false,"AudioBuffer":false,"AudioBufferSourceNode":false,"AudioContext":false,"AudioDestinationNode":false,"AudioListener":false,"AudioNode":false,"AudioParam":false,"AudioProcessingEvent":false,"AudioScheduledSourceNode":false,"AudioWorkletGlobalScope ":false,"AudioWorkletNode":false,"AudioWorkletProcessor":false,"BarProp":false,"BaseAudioContext":false,"BatteryManager":false,"BeforeUnloadEvent":false,"BiquadFilterNode":false,"Blob":false,"BlobEvent":false,"blur":false,"BroadcastChannel":false,"btoa":false,"BudgetService":false,"ByteLengthQueuingStrategy":false,"Cache":false,"caches":false,"CacheStorage":false,"cancelAnimationFrame":false,"cancelIdleCallback":false,"CanvasCaptureMediaStreamTrack":false,"CanvasGradient":false,"CanvasPattern":false,"CanvasRenderingContext2D":false,"ChannelMergerNode":false,"ChannelSplitterNode":false,"CharacterData":false,"clearInterval":false,"clearTimeout":false,"clientInformation":false,"ClipboardEvent":false,"close":false,"closed":false,"CloseEvent":false,"Comment":false,"CompositionEvent":false,"confirm":false,"console":false,"ConstantSourceNode":false,"ConvolverNode":false,"CountQueuingStrategy":false,"createImageBitmap":false,"Credential":false,"CredentialsContainer":false,"crypto":false,"Crypto":false,"CryptoKey":false,"CSS":false,"CSSConditionRule":false,"CSSFontFaceRule":false,"CSSGroupingRule":false,"CSSImportRule":false,"CSSKeyframeRule":false,"CSSKeyframesRule":false,"CSSMediaRule":false,"CSSNamespaceRule":false,"CSSPageRule":false,"CSSRule":false,"CSSRuleList":false,"CSSStyleDeclaration":false,"CSSStyleRule":false,"CSSStyleSheet":false,"CSSSupportsRule":false,"CustomElementRegistry":false,"customElements":false,"CustomEvent":false,"DataTransfer":false,"DataTransferItem":false,"DataTransferItemList":false,"defaultstatus":false,"defaultStatus":false,"DelayNode":false,"DeviceMotionEvent":false,"DeviceOrientationEvent":false,"devicePixelRatio":false,"dispatchEvent":false,"document":false,"Document":false,"DocumentFragment":false,"DocumentType":false,"DOMError":false,"DOMException":false,"DOMImplementation":false,"DOMMatrix":false,"DOMMatrixReadOnly":false,"DOMParser":false,"DOMPoint":false,"DOMPointReadOnly":false,"DOMQuad":false,"DOMRect":false,"DOMRectReadOnly":false,"DOMStringList":false,"DOMStringMap":false,"DOMTokenList":false,"DragEvent":false,"DynamicsCompressorNode":false,"Element":false,"ErrorEvent":false,"event":false,"Event":false,"EventSource":false,"EventTarget":false,"external":false,"fetch":false,"File":false,"FileList":false,"FileReader":false,"find":false,"focus":false,"FocusEvent":false,"FontFace":false,"FontFaceSetLoadEvent":false,"FormData":false,"frameElement":false,"frames":false,"GainNode":false,"Gamepad":false,"GamepadButton":false,"GamepadEvent":false,"getComputedStyle":false,"getSelection":false,"HashChangeEvent":false,"Headers":false,"history":false,"History":false,"HTMLAllCollection":false,"HTMLAnchorElement":false,"HTMLAreaElement":false,"HTMLAudioElement":false,"HTMLBaseElement":false,"HTMLBodyElement":false,"HTMLBRElement":false,"HTMLButtonElement":false,"HTMLCanvasElement":false,"HTMLCollection":false,"HTMLContentElement":false,"HTMLDataElement":false,"HTMLDataListElement":false,"HTMLDetailsElement":false,"HTMLDialogElement":false,"HTMLDirectoryElement":false,"HTMLDivElement":false,"HTMLDListElement":false,"HTMLDocument":false,"HTMLElement":false,"HTMLEmbedElement":false,"HTMLFieldSetElement":false,"HTMLFontElement":false,"HTMLFormControlsCollection":false,"HTMLFormElement":false,"HTMLFrameElement":false,"HTMLFrameSetElement":false,"HTMLHeadElement":false,"HTMLHeadingElement":false,"HTMLHRElement":false,"HTMLHtmlElement":false,"HTMLIFrameElement":false,"HTMLImageElement":false,"HTMLInputElement":false,"HTMLLabelElement":false,"HTMLLegendElement":false,"HTMLLIElement":false,"HTMLLinkElement":false,"HTMLMapElement":false,"HTMLMarqueeElement":false,"HTMLMediaElement":false,"HTMLMenuElement":false,"HTMLMetaElement":false,"HTMLMeterElement":false,"HTMLModElement":false,"HTMLObjectElement":false,"HTMLOListElement":false,"HTMLOptGroupElement":false,"HTMLOptionElement":false,"HTMLOptionsCollection":false,"HTMLOutputElement":false,"HTMLParagraphElement":false,"HTMLParamElement":false,"HTMLPictureElement":false,"HTMLPreElement":false,"HTMLProgressElement":false,"HTMLQuoteElement":false,"HTMLScriptElement":false,"HTMLSelectElement":false,"HTMLShadowElement":false,"HTMLSlotElement":false,"HTMLSourceElement":false,"HTMLSpanElement":false,"HTMLStyleElement":false,"HTMLTableCaptionElement":false,"HTMLTableCellElement":false,"HTMLTableColElement":false,"HTMLTableElement":false,"HTMLTableRowElement":false,"HTMLTableSectionElement":false,"HTMLTemplateElement":false,"HTMLTextAreaElement":false,"HTMLTimeElement":false,"HTMLTitleElement":false,"HTMLTrackElement":false,"HTMLUListElement":false,"HTMLUnknownElement":false,"HTMLVideoElement":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"IdleDeadline":false,"IIRFilterNode":false,"Image":false,"ImageBitmap":false,"ImageBitmapRenderingContext":false,"ImageCapture":false,"ImageData":false,"indexedDB":false,"innerHeight":false,"innerWidth":false,"InputEvent":false,"IntersectionObserver":false,"IntersectionObserverEntry":false,"Intl":false,"isSecureContext":false,"KeyboardEvent":false,"KeyframeEffect":false,"KeyframeEffectReadOnly":false,"length":false,"localStorage":false,"location":true,"Location":false,"locationbar":false,"matchMedia":false,"MediaDeviceInfo":false,"MediaDevices":false,"MediaElementAudioSourceNode":false,"MediaEncryptedEvent":false,"MediaError":false,"MediaKeyMessageEvent":false,"MediaKeySession":false,"MediaKeyStatusMap":false,"MediaKeySystemAccess":false,"MediaList":false,"MediaQueryList":false,"MediaQueryListEvent":false,"MediaRecorder":false,"MediaSettingsRange":false,"MediaSource":false,"MediaStream":false,"MediaStreamAudioDestinationNode":false,"MediaStreamAudioSourceNode":false,"MediaStreamEvent":false,"MediaStreamTrack":false,"MediaStreamTrackEvent":false,"menubar":false,"MessageChannel":false,"MessageEvent":false,"MessagePort":false,"MIDIAccess":false,"MIDIConnectionEvent":false,"MIDIInput":false,"MIDIInputMap":false,"MIDIMessageEvent":false,"MIDIOutput":false,"MIDIOutputMap":false,"MIDIPort":false,"MimeType":false,"MimeTypeArray":false,"MouseEvent":false,"moveBy":false,"moveTo":false,"MutationEvent":false,"MutationObserver":false,"MutationRecord":false,"name":false,"NamedNodeMap":false,"NavigationPreloadManager":false,"navigator":false,"Navigator":false,"NetworkInformation":false,"Node":false,"NodeFilter":false,"NodeIterator":false,"NodeList":false,"Notification":false,"OfflineAudioCompletionEvent":false,"OfflineAudioContext":false,"offscreenBuffering":false,"OffscreenCanvas":true,"onabort":true,"onafterprint":true,"onanimationend":true,"onanimationiteration":true,"onanimationstart":true,"onappinstalled":true,"onauxclick":true,"onbeforeinstallprompt":true,"onbeforeprint":true,"onbeforeunload":true,"onblur":true,"oncancel":true,"oncanplay":true,"oncanplaythrough":true,"onchange":true,"onclick":true,"onclose":true,"oncontextmenu":true,"oncuechange":true,"ondblclick":true,"ondevicemotion":true,"ondeviceorientation":true,"ondeviceorientationabsolute":true,"ondrag":true,"ondragend":true,"ondragenter":true,"ondragleave":true,"ondragover":true,"ondragstart":true,"ondrop":true,"ondurationchange":true,"onemptied":true,"onended":true,"onerror":true,"onfocus":true,"ongotpointercapture":true,"onhashchange":true,"oninput":true,"oninvalid":true,"onkeydown":true,"onkeypress":true,"onkeyup":true,"onlanguagechange":true,"onload":true,"onloadeddata":true,"onloadedmetadata":true,"onloadstart":true,"onlostpointercapture":true,"onmessage":true,"onmessageerror":true,"onmousedown":true,"onmouseenter":true,"onmouseleave":true,"onmousemove":true,"onmouseout":true,"onmouseover":true,"onmouseup":true,"onmousewheel":true,"onoffline":true,"ononline":true,"onpagehide":true,"onpageshow":true,"onpause":true,"onplay":true,"onplaying":true,"onpointercancel":true,"onpointerdown":true,"onpointerenter":true,"onpointerleave":true,"onpointermove":true,"onpointerout":true,"onpointerover":true,"onpointerup":true,"onpopstate":true,"onprogress":true,"onratechange":true,"onrejectionhandled":true,"onreset":true,"onresize":true,"onscroll":true,"onsearch":true,"onseeked":true,"onseeking":true,"onselect":true,"onstalled":true,"onstorage":true,"onsubmit":true,"onsuspend":true,"ontimeupdate":true,"ontoggle":true,"ontransitionend":true,"onunhandledrejection":true,"onunload":true,"onvolumechange":true,"onwaiting":true,"onwheel":true,"open":false,"openDatabase":false,"opener":false,"Option":false,"origin":false,"OscillatorNode":false,"outerHeight":false,"outerWidth":false,"PageTransitionEvent":false,"pageXOffset":false,"pageYOffset":false,"PannerNode":false,"parent":false,"Path2D":false,"PaymentAddress":false,"PaymentRequest":false,"PaymentRequestUpdateEvent":false,"PaymentResponse":false,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceLongTaskTiming":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceNavigationTiming":false,"PerformanceObserver":false,"PerformanceObserverEntryList":false,"PerformancePaintTiming":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"PeriodicWave":false,"Permissions":false,"PermissionStatus":false,"personalbar":false,"PhotoCapabilities":false,"Plugin":false,"PluginArray":false,"PointerEvent":false,"PopStateEvent":false,"postMessage":false,"Presentation":false,"PresentationAvailability":false,"PresentationConnection":false,"PresentationConnectionAvailableEvent":false,"PresentationConnectionCloseEvent":false,"PresentationConnectionList":false,"PresentationReceiver":false,"PresentationRequest":false,"print":false,"ProcessingInstruction":false,"ProgressEvent":false,"PromiseRejectionEvent":false,"prompt":false,"PushManager":false,"PushSubscription":false,"PushSubscriptionOptions":false,"queueMicrotask":false,"RadioNodeList":false,"Range":false,"ReadableStream":false,"registerProcessor":false,"RemotePlayback":false,"removeEventListener":false,"Request":false,"requestAnimationFrame":false,"requestIdleCallback":false,"resizeBy":false,"ResizeObserver":false,"ResizeObserverEntry":false,"resizeTo":false,"Response":false,"RTCCertificate":false,"RTCDataChannel":false,"RTCDataChannelEvent":false,"RTCDtlsTransport":false,"RTCIceCandidate":false,"RTCIceGatherer":false,"RTCIceTransport":false,"RTCPeerConnection":false,"RTCPeerConnectionIceEvent":false,"RTCRtpContributingSource":false,"RTCRtpReceiver":false,"RTCRtpSender":false,"RTCSctpTransport":false,"RTCSessionDescription":false,"RTCStatsReport":false,"RTCTrackEvent":false,"screen":false,"Screen":false,"screenLeft":false,"ScreenOrientation":false,"screenTop":false,"screenX":false,"screenY":false,"ScriptProcessorNode":false,"scroll":false,"scrollbars":false,"scrollBy":false,"scrollTo":false,"scrollX":false,"scrollY":false,"SecurityPolicyViolationEvent":false,"Selection":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerRegistration":false,"sessionStorage":false,"setInterval":false,"setTimeout":false,"ShadowRoot":false,"SharedWorker":false,"SourceBuffer":false,"SourceBufferList":false,"speechSynthesis":false,"SpeechSynthesisEvent":false,"SpeechSynthesisUtterance":false,"StaticRange":false,"status":false,"statusbar":false,"StereoPannerNode":false,"stop":false,"Storage":false,"StorageEvent":false,"StorageManager":false,"styleMedia":false,"StyleSheet":false,"StyleSheetList":false,"SubtleCrypto":false,"SVGAElement":false,"SVGAngle":false,"SVGAnimatedAngle":false,"SVGAnimatedBoolean":false,"SVGAnimatedEnumeration":false,"SVGAnimatedInteger":false,"SVGAnimatedLength":false,"SVGAnimatedLengthList":false,"SVGAnimatedNumber":false,"SVGAnimatedNumberList":false,"SVGAnimatedPreserveAspectRatio":false,"SVGAnimatedRect":false,"SVGAnimatedString":false,"SVGAnimatedTransformList":false,"SVGAnimateElement":false,"SVGAnimateMotionElement":false,"SVGAnimateTransformElement":false,"SVGAnimationElement":false,"SVGCircleElement":false,"SVGClipPathElement":false,"SVGComponentTransferFunctionElement":false,"SVGDefsElement":false,"SVGDescElement":false,"SVGDiscardElement":false,"SVGElement":false,"SVGEllipseElement":false,"SVGFEBlendElement":false,"SVGFEColorMatrixElement":false,"SVGFEComponentTransferElement":false,"SVGFECompositeElement":false,"SVGFEConvolveMatrixElement":false,"SVGFEDiffuseLightingElement":false,"SVGFEDisplacementMapElement":false,"SVGFEDistantLightElement":false,"SVGFEDropShadowElement":false,"SVGFEFloodElement":false,"SVGFEFuncAElement":false,"SVGFEFuncBElement":false,"SVGFEFuncGElement":false,"SVGFEFuncRElement":false,"SVGFEGaussianBlurElement":false,"SVGFEImageElement":false,"SVGFEMergeElement":false,"SVGFEMergeNodeElement":false,"SVGFEMorphologyElement":false,"SVGFEOffsetElement":false,"SVGFEPointLightElement":false,"SVGFESpecularLightingElement":false,"SVGFESpotLightElement":false,"SVGFETileElement":false,"SVGFETurbulenceElement":false,"SVGFilterElement":false,"SVGForeignObjectElement":false,"SVGGElement":false,"SVGGeometryElement":false,"SVGGradientElement":false,"SVGGraphicsElement":false,"SVGImageElement":false,"SVGLength":false,"SVGLengthList":false,"SVGLinearGradientElement":false,"SVGLineElement":false,"SVGMarkerElement":false,"SVGMaskElement":false,"SVGMatrix":false,"SVGMetadataElement":false,"SVGMPathElement":false,"SVGNumber":false,"SVGNumberList":false,"SVGPathElement":false,"SVGPatternElement":false,"SVGPoint":false,"SVGPointList":false,"SVGPolygonElement":false,"SVGPolylineElement":false,"SVGPreserveAspectRatio":false,"SVGRadialGradientElement":false,"SVGRect":false,"SVGRectElement":false,"SVGScriptElement":false,"SVGSetElement":false,"SVGStopElement":false,"SVGStringList":false,"SVGStyleElement":false,"SVGSVGElement":false,"SVGSwitchElement":false,"SVGSymbolElement":false,"SVGTextContentElement":false,"SVGTextElement":false,"SVGTextPathElement":false,"SVGTextPositioningElement":false,"SVGTitleElement":false,"SVGTransform":false,"SVGTransformList":false,"SVGTSpanElement":false,"SVGUnitTypes":false,"SVGUseElement":false,"SVGViewElement":false,"TaskAttributionTiming":false,"Text":false,"TextDecoder":false,"TextEncoder":false,"TextEvent":false,"TextMetrics":false,"TextTrack":false,"TextTrackCue":false,"TextTrackCueList":false,"TextTrackList":false,"TimeRanges":false,"toolbar":false,"top":false,"Touch":false,"TouchEvent":false,"TouchList":false,"TrackEvent":false,"TransitionEvent":false,"TreeWalker":false,"UIEvent":false,"URL":false,"URLSearchParams":false,"ValidityState":false,"visualViewport":false,"VisualViewport":false,"VTTCue":false,"WaveShaperNode":false,"WebAssembly":false,"WebGL2RenderingContext":false,"WebGLActiveInfo":false,"WebGLBuffer":false,"WebGLContextEvent":false,"WebGLFramebuffer":false,"WebGLProgram":false,"WebGLQuery":false,"WebGLRenderbuffer":false,"WebGLRenderingContext":false,"WebGLSampler":false,"WebGLShader":false,"WebGLShaderPrecisionFormat":false,"WebGLSync":false,"WebGLTexture":false,"WebGLTransformFeedback":false,"WebGLUniformLocation":false,"WebGLVertexArrayObject":false,"WebSocket":false,"WheelEvent":false,"window":false,"Window":false,"Worker":false,"WritableStream":false,"XMLDocument":false,"XMLHttpRequest":false,"XMLHttpRequestEventTarget":false,"XMLHttpRequestUpload":false,"XMLSerializer":false,"XPathEvaluator":false,"XPathExpression":false,"XPathResult":false,"XSLTProcessor":false},"worker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"clearInterval":false,"clearTimeout":false,"close":true,"console":false,"fetch":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":true,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onlanguagechange":true,"onmessage":true,"onoffline":true,"ononline":true,"onrejectionhandled":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"removeEventListener":false,"Request":false,"Response":false,"self":true,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"node":{"__dirname":false,"__filename":false,"Buffer":false,"clearImmediate":false,"clearInterval":false,"clearTimeout":false,"console":false,"exports":true,"global":false,"Intl":false,"module":false,"process":false,"queueMicrotask":false,"require":false,"setImmediate":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false},"commonjs":{"exports":true,"global":false,"module":false,"require":false},"amd":{"define":false,"require":false},"mocha":{"after":false,"afterEach":false,"before":false,"beforeEach":false,"context":false,"describe":false,"it":false,"mocha":false,"run":false,"setup":false,"specify":false,"suite":false,"suiteSetup":false,"suiteTeardown":false,"teardown":false,"test":false,"xcontext":false,"xdescribe":false,"xit":false,"xspecify":false},"jasmine":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fail":false,"fdescribe":false,"fit":false,"it":false,"jasmine":false,"pending":false,"runs":false,"spyOn":false,"spyOnProperty":false,"waits":false,"waitsFor":false,"xdescribe":false,"xit":false},"jest":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fdescribe":false,"fit":false,"it":false,"jest":false,"pit":false,"require":false,"test":false,"xdescribe":false,"xit":false,"xtest":false},"qunit":{"asyncTest":false,"deepEqual":false,"equal":false,"expect":false,"module":false,"notDeepEqual":false,"notEqual":false,"notOk":false,"notPropEqual":false,"notStrictEqual":false,"ok":false,"propEqual":false,"QUnit":false,"raises":false,"start":false,"stop":false,"strictEqual":false,"test":false,"throws":false},"phantomjs":{"console":true,"exports":true,"phantom":true,"require":true,"WebPage":true},"couch":{"emit":false,"exports":false,"getRow":false,"log":false,"module":false,"provides":false,"require":false,"respond":false,"send":false,"start":false,"sum":false},"rhino":{"defineClass":false,"deserialize":false,"gc":false,"help":false,"importClass":false,"importPackage":false,"java":false,"load":false,"loadClass":false,"Packages":false,"print":false,"quit":false,"readFile":false,"readUrl":false,"runCommand":false,"seal":false,"serialize":false,"spawn":false,"sync":false,"toint32":false,"version":false},"nashorn":{"__DIR__":false,"__FILE__":false,"__LINE__":false,"com":false,"edu":false,"exit":false,"java":false,"Java":false,"javafx":false,"JavaImporter":false,"javax":false,"JSAdapter":false,"load":false,"loadWithNewGlobal":false,"org":false,"Packages":false,"print":false,"quit":false},"wsh":{"ActiveXObject":true,"Enumerator":true,"GetObject":true,"ScriptEngine":true,"ScriptEngineBuildVersion":true,"ScriptEngineMajorVersion":true,"ScriptEngineMinorVersion":true,"VBArray":true,"WScript":true,"WSH":true,"XDomainRequest":true},"jquery":{"$":false,"jQuery":false},"yui":{"YAHOO":false,"YAHOO_config":false,"YUI":false,"YUI_config":false},"shelljs":{"cat":false,"cd":false,"chmod":false,"config":false,"cp":false,"dirs":false,"echo":false,"env":false,"error":false,"exec":false,"exit":false,"find":false,"grep":false,"ln":false,"ls":false,"mkdir":false,"mv":false,"popd":false,"pushd":false,"pwd":false,"rm":false,"sed":false,"set":false,"target":false,"tempdir":false,"test":false,"touch":false,"which":false},"prototypejs":{"$":false,"$$":false,"$A":false,"$break":false,"$continue":false,"$F":false,"$H":false,"$R":false,"$w":false,"Abstract":false,"Ajax":false,"Autocompleter":false,"Builder":false,"Class":false,"Control":false,"Draggable":false,"Draggables":false,"Droppables":false,"Effect":false,"Element":false,"Enumerable":false,"Event":false,"Field":false,"Form":false,"Hash":false,"Insertion":false,"ObjectRange":false,"PeriodicalExecuter":false,"Position":false,"Prototype":false,"Scriptaculous":false,"Selector":false,"Sortable":false,"SortableObserver":false,"Sound":false,"Template":false,"Toggle":false,"Try":false},"meteor":{"_":false,"$":false,"Accounts":false,"AccountsClient":false,"AccountsCommon":false,"AccountsServer":false,"App":false,"Assets":false,"Blaze":false,"check":false,"Cordova":false,"DDP":false,"DDPRateLimiter":false,"DDPServer":false,"Deps":false,"EJSON":false,"Email":false,"HTTP":false,"Log":false,"Match":false,"Meteor":false,"Mongo":false,"MongoInternals":false,"Npm":false,"Package":false,"Plugin":false,"process":false,"Random":false,"ReactiveDict":false,"ReactiveVar":false,"Router":false,"ServiceConfiguration":false,"Session":false,"share":false,"Spacebars":false,"Template":false,"Tinytest":false,"Tracker":false,"UI":false,"Utils":false,"WebApp":false,"WebAppInternals":false},"mongo":{"_isWindows":false,"_rand":false,"BulkWriteResult":false,"cat":false,"cd":false,"connect":false,"db":false,"getHostName":false,"getMemInfo":false,"hostname":false,"ISODate":false,"listFiles":false,"load":false,"ls":false,"md5sumFile":false,"mkdir":false,"Mongo":false,"NumberInt":false,"NumberLong":false,"ObjectId":false,"PlanCache":false,"print":false,"printjson":false,"pwd":false,"quit":false,"removeFile":false,"rs":false,"sh":false,"UUID":false,"version":false,"WriteResult":false},"applescript":{"$":false,"Application":false,"Automation":false,"console":false,"delay":false,"Library":false,"ObjC":false,"ObjectSpecifier":false,"Path":false,"Progress":false,"Ref":false},"serviceworker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"CacheStorage":false,"clearInterval":false,"clearTimeout":false,"Client":false,"clients":false,"Clients":false,"close":true,"console":false,"ExtendableEvent":false,"ExtendableMessageEvent":false,"fetch":false,"FetchEvent":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":false,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onfetch":true,"oninstall":true,"onlanguagechange":true,"onmessage":true,"onmessageerror":true,"onnotificationclick":true,"onnotificationclose":true,"onoffline":true,"ononline":true,"onpush":true,"onpushsubscriptionchange":true,"onrejectionhandled":true,"onsync":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"registration":false,"removeEventListener":false,"Request":false,"Response":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerGlobalScope":false,"ServiceWorkerMessageEvent":false,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"skipWaiting":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"WindowClient":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"atomtest":{"advanceClock":false,"fakeClearInterval":false,"fakeClearTimeout":false,"fakeSetInterval":false,"fakeSetTimeout":false,"resetTimeouts":false,"waitsForPromise":false},"embertest":{"andThen":false,"click":false,"currentPath":false,"currentRouteName":false,"currentURL":false,"fillIn":false,"find":false,"findAll":false,"findWithAssert":false,"keyEvent":false,"pauseTest":false,"resumeTest":false,"triggerEvent":false,"visit":false,"wait":false},"protractor":{"$":false,"$$":false,"browser":false,"by":false,"By":false,"DartObject":false,"element":false,"protractor":false},"shared-node-browser":{"clearInterval":false,"clearTimeout":false,"console":false,"setInterval":false,"setTimeout":false,"URL":false,"URLSearchParams":false},"webextensions":{"browser":false,"chrome":false,"opr":false},"greasemonkey":{"cloneInto":false,"createObjectIn":false,"exportFunction":false,"GM":false,"GM_addStyle":false,"GM_deleteValue":false,"GM_getResourceText":false,"GM_getResourceURL":false,"GM_getValue":false,"GM_info":false,"GM_listValues":false,"GM_log":false,"GM_openInTab":false,"GM_registerMenuCommand":false,"GM_setClipboard":false,"GM_setValue":false,"GM_xmlhttpRequest":false,"unsafeWindow":false},"devtools":{"$":false,"$_":false,"$$":false,"$0":false,"$1":false,"$2":false,"$3":false,"$4":false,"$x":false,"chrome":false,"clear":false,"copy":false,"debug":false,"dir":false,"dirxml":false,"getEventListeners":false,"inspect":false,"keys":false,"monitor":false,"monitorEvents":false,"profile":false,"profileEnd":false,"queryObjects":false,"table":false,"undebug":false,"unmonitor":false,"unmonitorEvents":false,"values":false}}',
			)

			/***/
		},

		/***/ 17324: /***/ (module) => {
			'use strict'
			module.exports = /*#__PURE__*/ JSON.parse(
				'{"assert":true,"node:assert":[">= 14.18 && < 15",">= 16"],"assert/strict":">= 15","node:assert/strict":">= 16","async_hooks":">= 8","node:async_hooks":[">= 14.18 && < 15",">= 16"],"buffer_ieee754":">= 0.5 && < 0.9.7","buffer":true,"node:buffer":[">= 14.18 && < 15",">= 16"],"child_process":true,"node:child_process":[">= 14.18 && < 15",">= 16"],"cluster":">= 0.5","node:cluster":[">= 14.18 && < 15",">= 16"],"console":true,"node:console":[">= 14.18 && < 15",">= 16"],"constants":true,"node:constants":[">= 14.18 && < 15",">= 16"],"crypto":true,"node:crypto":[">= 14.18 && < 15",">= 16"],"_debug_agent":">= 1 && < 8","_debugger":"< 8","dgram":true,"node:dgram":[">= 14.18 && < 15",">= 16"],"diagnostics_channel":[">= 14.17 && < 15",">= 15.1"],"node:diagnostics_channel":[">= 14.18 && < 15",">= 16"],"dns":true,"node:dns":[">= 14.18 && < 15",">= 16"],"dns/promises":">= 15","node:dns/promises":">= 16","domain":">= 0.7.12","node:domain":[">= 14.18 && < 15",">= 16"],"events":true,"node:events":[">= 14.18 && < 15",">= 16"],"freelist":"< 6","fs":true,"node:fs":[">= 14.18 && < 15",">= 16"],"fs/promises":[">= 10 && < 10.1",">= 14"],"node:fs/promises":[">= 14.18 && < 15",">= 16"],"_http_agent":">= 0.11.1","node:_http_agent":[">= 14.18 && < 15",">= 16"],"_http_client":">= 0.11.1","node:_http_client":[">= 14.18 && < 15",">= 16"],"_http_common":">= 0.11.1","node:_http_common":[">= 14.18 && < 15",">= 16"],"_http_incoming":">= 0.11.1","node:_http_incoming":[">= 14.18 && < 15",">= 16"],"_http_outgoing":">= 0.11.1","node:_http_outgoing":[">= 14.18 && < 15",">= 16"],"_http_server":">= 0.11.1","node:_http_server":[">= 14.18 && < 15",">= 16"],"http":true,"node:http":[">= 14.18 && < 15",">= 16"],"http2":">= 8.8","node:http2":[">= 14.18 && < 15",">= 16"],"https":true,"node:https":[">= 14.18 && < 15",">= 16"],"inspector":">= 8","node:inspector":[">= 14.18 && < 15",">= 16"],"inspector/promises":[">= 19"],"node:inspector/promises":[">= 19"],"_linklist":"< 8","module":true,"node:module":[">= 14.18 && < 15",">= 16"],"net":true,"node:net":[">= 14.18 && < 15",">= 16"],"node-inspect/lib/_inspect":">= 7.6 && < 12","node-inspect/lib/internal/inspect_client":">= 7.6 && < 12","node-inspect/lib/internal/inspect_repl":">= 7.6 && < 12","os":true,"node:os":[">= 14.18 && < 15",">= 16"],"path":true,"node:path":[">= 14.18 && < 15",">= 16"],"path/posix":">= 15.3","node:path/posix":">= 16","path/win32":">= 15.3","node:path/win32":">= 16","perf_hooks":">= 8.5","node:perf_hooks":[">= 14.18 && < 15",">= 16"],"process":">= 1","node:process":[">= 14.18 && < 15",">= 16"],"punycode":">= 0.5","node:punycode":[">= 14.18 && < 15",">= 16"],"querystring":true,"node:querystring":[">= 14.18 && < 15",">= 16"],"readline":true,"node:readline":[">= 14.18 && < 15",">= 16"],"readline/promises":">= 17","node:readline/promises":">= 17","repl":true,"node:repl":[">= 14.18 && < 15",">= 16"],"node:sea":[">= 20.12 && < 21",">= 21.7"],"smalloc":">= 0.11.5 && < 3","node:sqlite":[">= 22.13 && < 23",">= 23.4"],"_stream_duplex":">= 0.9.4","node:_stream_duplex":[">= 14.18 && < 15",">= 16"],"_stream_transform":">= 0.9.4","node:_stream_transform":[">= 14.18 && < 15",">= 16"],"_stream_wrap":">= 1.4.1","node:_stream_wrap":[">= 14.18 && < 15",">= 16"],"_stream_passthrough":">= 0.9.4","node:_stream_passthrough":[">= 14.18 && < 15",">= 16"],"_stream_readable":">= 0.9.4","node:_stream_readable":[">= 14.18 && < 15",">= 16"],"_stream_writable":">= 0.9.4","node:_stream_writable":[">= 14.18 && < 15",">= 16"],"stream":true,"node:stream":[">= 14.18 && < 15",">= 16"],"stream/consumers":">= 16.7","node:stream/consumers":">= 16.7","stream/promises":">= 15","node:stream/promises":">= 16","stream/web":">= 16.5","node:stream/web":">= 16.5","string_decoder":true,"node:string_decoder":[">= 14.18 && < 15",">= 16"],"sys":[">= 0.4 && < 0.7",">= 0.8"],"node:sys":[">= 14.18 && < 15",">= 16"],"test/reporters":">= 19.9 && < 20.2","node:test/reporters":[">= 18.17 && < 19",">= 19.9",">= 20"],"test/mock_loader":">= 22.3 && < 22.7","node:test/mock_loader":">= 22.3 && < 22.7","node:test":[">= 16.17 && < 17",">= 18"],"timers":true,"node:timers":[">= 14.18 && < 15",">= 16"],"timers/promises":">= 15","node:timers/promises":">= 16","_tls_common":">= 0.11.13","node:_tls_common":[">= 14.18 && < 15",">= 16"],"_tls_legacy":">= 0.11.3 && < 10","_tls_wrap":">= 0.11.3","node:_tls_wrap":[">= 14.18 && < 15",">= 16"],"tls":true,"node:tls":[">= 14.18 && < 15",">= 16"],"trace_events":">= 10","node:trace_events":[">= 14.18 && < 15",">= 16"],"tty":true,"node:tty":[">= 14.18 && < 15",">= 16"],"url":true,"node:url":[">= 14.18 && < 15",">= 16"],"util":true,"node:util":[">= 14.18 && < 15",">= 16"],"util/types":">= 15.3","node:util/types":">= 16","v8/tools/arguments":">= 10 && < 12","v8/tools/codemap":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/consarray":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/csvparser":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/logreader":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/profile_view":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/splaytree":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8":">= 1","node:v8":[">= 14.18 && < 15",">= 16"],"vm":true,"node:vm":[">= 14.18 && < 15",">= 16"],"wasi":[">= 13.4 && < 13.5",">= 18.17 && < 19",">= 20"],"node:wasi":[">= 18.17 && < 19",">= 20"],"worker_threads":">= 11.7","node:worker_threads":[">= 14.18 && < 15",">= 16"],"zlib":">= 0.5","node:zlib":[">= 14.18 && < 15",">= 16"]}',
			)

			/***/
		},

		/***/ 62035: /***/ (module) => {
			'use strict'
			module.exports = /*#__PURE__*/ JSON.parse(
				'{"assert":true,"node:assert":[">= 14.18 && < 15",">= 16"],"assert/strict":">= 15","node:assert/strict":">= 16","async_hooks":">= 8","node:async_hooks":[">= 14.18 && < 15",">= 16"],"buffer_ieee754":">= 0.5 && < 0.9.7","buffer":true,"node:buffer":[">= 14.18 && < 15",">= 16"],"child_process":true,"node:child_process":[">= 14.18 && < 15",">= 16"],"cluster":">= 0.5","node:cluster":[">= 14.18 && < 15",">= 16"],"console":true,"node:console":[">= 14.18 && < 15",">= 16"],"constants":true,"node:constants":[">= 14.18 && < 15",">= 16"],"crypto":true,"node:crypto":[">= 14.18 && < 15",">= 16"],"_debug_agent":">= 1 && < 8","_debugger":"< 8","dgram":true,"node:dgram":[">= 14.18 && < 15",">= 16"],"diagnostics_channel":[">= 14.17 && < 15",">= 15.1"],"node:diagnostics_channel":[">= 14.18 && < 15",">= 16"],"dns":true,"node:dns":[">= 14.18 && < 15",">= 16"],"dns/promises":">= 15","node:dns/promises":">= 16","domain":">= 0.7.12","node:domain":[">= 14.18 && < 15",">= 16"],"events":true,"node:events":[">= 14.18 && < 15",">= 16"],"freelist":"< 6","fs":true,"node:fs":[">= 14.18 && < 15",">= 16"],"fs/promises":[">= 10 && < 10.1",">= 14"],"node:fs/promises":[">= 14.18 && < 15",">= 16"],"_http_agent":">= 0.11.1","node:_http_agent":[">= 14.18 && < 15",">= 16"],"_http_client":">= 0.11.1","node:_http_client":[">= 14.18 && < 15",">= 16"],"_http_common":">= 0.11.1","node:_http_common":[">= 14.18 && < 15",">= 16"],"_http_incoming":">= 0.11.1","node:_http_incoming":[">= 14.18 && < 15",">= 16"],"_http_outgoing":">= 0.11.1","node:_http_outgoing":[">= 14.18 && < 15",">= 16"],"_http_server":">= 0.11.1","node:_http_server":[">= 14.18 && < 15",">= 16"],"http":true,"node:http":[">= 14.18 && < 15",">= 16"],"http2":">= 8.8","node:http2":[">= 14.18 && < 15",">= 16"],"https":true,"node:https":[">= 14.18 && < 15",">= 16"],"inspector":">= 8","node:inspector":[">= 14.18 && < 15",">= 16"],"inspector/promises":[">= 19"],"node:inspector/promises":[">= 19"],"_linklist":"< 8","module":true,"node:module":[">= 14.18 && < 15",">= 16"],"net":true,"node:net":[">= 14.18 && < 15",">= 16"],"node-inspect/lib/_inspect":">= 7.6 && < 12","node-inspect/lib/internal/inspect_client":">= 7.6 && < 12","node-inspect/lib/internal/inspect_repl":">= 7.6 && < 12","os":true,"node:os":[">= 14.18 && < 15",">= 16"],"path":true,"node:path":[">= 14.18 && < 15",">= 16"],"path/posix":">= 15.3","node:path/posix":">= 16","path/win32":">= 15.3","node:path/win32":">= 16","perf_hooks":">= 8.5","node:perf_hooks":[">= 14.18 && < 15",">= 16"],"process":">= 1","node:process":[">= 14.18 && < 15",">= 16"],"punycode":">= 0.5","node:punycode":[">= 14.18 && < 15",">= 16"],"querystring":true,"node:querystring":[">= 14.18 && < 15",">= 16"],"readline":true,"node:readline":[">= 14.18 && < 15",">= 16"],"readline/promises":">= 17","node:readline/promises":">= 17","repl":true,"node:repl":[">= 14.18 && < 15",">= 16"],"node:sea":[">= 20.12 && < 21",">= 21.7"],"smalloc":">= 0.11.5 && < 3","node:sqlite":">= 23.4","_stream_duplex":">= 0.9.4","node:_stream_duplex":[">= 14.18 && < 15",">= 16"],"_stream_transform":">= 0.9.4","node:_stream_transform":[">= 14.18 && < 15",">= 16"],"_stream_wrap":">= 1.4.1","node:_stream_wrap":[">= 14.18 && < 15",">= 16"],"_stream_passthrough":">= 0.9.4","node:_stream_passthrough":[">= 14.18 && < 15",">= 16"],"_stream_readable":">= 0.9.4","node:_stream_readable":[">= 14.18 && < 15",">= 16"],"_stream_writable":">= 0.9.4","node:_stream_writable":[">= 14.18 && < 15",">= 16"],"stream":true,"node:stream":[">= 14.18 && < 15",">= 16"],"stream/consumers":">= 16.7","node:stream/consumers":">= 16.7","stream/promises":">= 15","node:stream/promises":">= 16","stream/web":">= 16.5","node:stream/web":">= 16.5","string_decoder":true,"node:string_decoder":[">= 14.18 && < 15",">= 16"],"sys":[">= 0.4 && < 0.7",">= 0.8"],"node:sys":[">= 14.18 && < 15",">= 16"],"test/reporters":">= 19.9 && < 20.2","node:test/reporters":[">= 18.17 && < 19",">= 19.9",">= 20"],"test/mock_loader":">= 22.3 && < 22.7","node:test/mock_loader":">= 22.3 && < 22.7","node:test":[">= 16.17 && < 17",">= 18"],"timers":true,"node:timers":[">= 14.18 && < 15",">= 16"],"timers/promises":">= 15","node:timers/promises":">= 16","_tls_common":">= 0.11.13","node:_tls_common":[">= 14.18 && < 15",">= 16"],"_tls_legacy":">= 0.11.3 && < 10","_tls_wrap":">= 0.11.3","node:_tls_wrap":[">= 14.18 && < 15",">= 16"],"tls":true,"node:tls":[">= 14.18 && < 15",">= 16"],"trace_events":">= 10","node:trace_events":[">= 14.18 && < 15",">= 16"],"tty":true,"node:tty":[">= 14.18 && < 15",">= 16"],"url":true,"node:url":[">= 14.18 && < 15",">= 16"],"util":true,"node:util":[">= 14.18 && < 15",">= 16"],"util/types":">= 15.3","node:util/types":">= 16","v8/tools/arguments":">= 10 && < 12","v8/tools/codemap":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/consarray":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/csvparser":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/logreader":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/profile_view":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/splaytree":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8":">= 1","node:v8":[">= 14.18 && < 15",">= 16"],"vm":true,"node:vm":[">= 14.18 && < 15",">= 16"],"wasi":[">= 13.4 && < 13.5",">= 18.17 && < 19",">= 20"],"node:wasi":[">= 18.17 && < 19",">= 20"],"worker_threads":">= 11.7","node:worker_threads":[">= 14.18 && < 15",">= 16"],"zlib":">= 0.5","node:zlib":[">= 14.18 && < 15",">= 16"]}',
			)

			/***/
		},

		/***/ 50408: /***/ (module) => {
			'use strict'
			module.exports = /*#__PURE__*/ JSON.parse(
				'["cent","copy","divide","gt","lt","not","para","times"]',
			)

			/***/
		},

		/******/
	}
	/************************************************************************/
	/******/ // The module cache
	/******/ var __webpack_module_cache__ = {}
	/******/
	/******/ // The require function
	/******/ function __nccwpck_require__(moduleId) {
		/******/ // Check if module is in cache
		/******/ var cachedModule = __webpack_module_cache__[moduleId]
		/******/ if (cachedModule !== undefined) {
			/******/ return cachedModule.exports
			/******/
		}
		/******/ // Create a new module (and put it into the cache)
		/******/ var module = (__webpack_module_cache__[moduleId] = {
			/******/ id: moduleId,
			/******/ loaded: false,
			/******/ exports: {},
			/******/
		})
		/******/
		/******/ // Execute the module function
		/******/ var threw = true
		/******/ try {
			/******/ __webpack_modules__[moduleId].call(
				module.exports,
				module,
				module.exports,
				__nccwpck_require__,
			)
			/******/ threw = false
			/******/
		} finally {
			/******/ if (threw) delete __webpack_module_cache__[moduleId]
			/******/
		}
		/******/
		/******/ // Flag the module as loaded
		/******/ module.loaded = true
		/******/
		/******/ // Return the exports of the module
		/******/ return module.exports
		/******/
	}
	/******/
	/************************************************************************/
	/******/ /* webpack/runtime/compat get default export */
	/******/ ;(() => {
		/******/ // getDefaultExport function for compatibility with non-harmony modules
		/******/ __nccwpck_require__.n = (module) => {
			/******/ var getter =
				module && module.__esModule
					? /******/ () => module['default']
					: /******/ () => module
			/******/ __nccwpck_require__.d(getter, { a: getter })
			/******/ return getter
			/******/
		}
		/******/
	})()
	/******/
	/******/ /* webpack/runtime/define property getters */
	/******/ ;(() => {
		/******/ // define getter functions for harmony exports
		/******/ __nccwpck_require__.d = (exports, definition) => {
			/******/ for (var key in definition) {
				/******/ if (
					__nccwpck_require__.o(definition, key) &&
					!__nccwpck_require__.o(exports, key)
				) {
					/******/ Object.defineProperty(exports, key, {
						enumerable: true,
						get: definition[key],
					})
					/******/
				}
				/******/
			}
			/******/
		}
		/******/
	})()
	/******/
	/******/ /* webpack/runtime/hasOwnProperty shorthand */
	/******/ ;(() => {
		/******/ __nccwpck_require__.o = (obj, prop) =>
			Object.prototype.hasOwnProperty.call(obj, prop)
		/******/
	})()
	/******/
	/******/ /* webpack/runtime/node module decorator */
	/******/ ;(() => {
		/******/ __nccwpck_require__.nmd = (module) => {
			/******/ module.paths = []
			/******/ if (!module.children) module.children = []
			/******/ return module
			/******/
		}
		/******/
	})()
	/******/
	/******/ /* webpack/runtime/compat */
	/******/
	/******/ if (typeof __nccwpck_require__ !== 'undefined')
		__nccwpck_require__.ab = __dirname + '/'
	/******/
	/************************************************************************/
	var __webpack_exports__ = {}
	// This entry need to be wrapped in an IIFE because it need to be in strict mode.
	;(() => {
		'use strict'

		// EXTERNAL MODULE: ./node_modules/@actions/core/lib/core.js
		var core = __nccwpck_require__(37484)
		// EXTERNAL MODULE: external "fs"
		var external_fs_ = __nccwpck_require__(79896)
		// EXTERNAL MODULE: external "path"
		var external_path_ = __nccwpck_require__(16928)
		// EXTERNAL MODULE: ./node_modules/klaw-sync/klaw-sync.js
		var klaw_sync = __nccwpck_require__(71628)
		var klaw_sync_default = /*#__PURE__*/ __nccwpck_require__.n(klaw_sync)
		// EXTERNAL MODULE: ./node_modules/gray-matter/index.js
		var gray_matter = __nccwpck_require__(19599)
		var gray_matter_default = /*#__PURE__*/ __nccwpck_require__.n(gray_matter)
		// EXTERNAL MODULE: ./node_modules/remark/index.js
		var remark = __nccwpck_require__(11112)
		var remark_default = /*#__PURE__*/ __nccwpck_require__.n(remark)
		// EXTERNAL MODULE: ./node_modules/remark-mdx/index.js
		var remark_mdx = __nccwpck_require__(47926)
		var remark_mdx_default = /*#__PURE__*/ __nccwpck_require__.n(remark_mdx)
		// EXTERNAL MODULE: external "assert"
		var external_assert_ = __nccwpck_require__(42613) // CONCATENATED MODULE: ./node_modules/unist-util-is/lib/index.js
		/**
		 * @typedef {import('unist').Node} Node
		 * @typedef {import('unist').Parent} Parent
		 */

		/**
		 * @template Fn
		 * @template Fallback
		 * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate
		 */

		/**
		 * @callback Check
		 *   Check that an arbitrary value is a node.
		 * @param {unknown} this
		 *   The given context.
		 * @param {unknown} [node]
		 *   Anything (typically a node).
		 * @param {number | null | undefined} [index]
		 *   The nodes position in its parent.
		 * @param {Parent | null | undefined} [parent]
		 *   The nodes parent.
		 * @returns {boolean}
		 *   Whether this is a node and passes a test.
		 *
		 * @typedef {Record<string, unknown> | Node} Props
		 *   Object to check for equivalence.
		 *
		 *   Note: `Node` is included as it is common but is not indexable.
		 *
		 * @typedef {Array<Props | TestFunction | string> | Props | TestFunction | string | null | undefined} Test
		 *   Check for an arbitrary node.
		 *
		 * @callback TestFunction
		 *   Check if a node passes a test.
		 * @param {unknown} this
		 *   The given context.
		 * @param {Node} node
		 *   A node.
		 * @param {number | undefined} [index]
		 *   The nodes position in its parent.
		 * @param {Parent | undefined} [parent]
		 *   The nodes parent.
		 * @returns {boolean | undefined | void}
		 *   Whether this node passes the test.
		 *
		 *   Note: `void` is included until TS sees no return as `undefined`.
		 */

		/**
		 * Check if `node` is a `Node` and whether it passes the given test.
		 *
		 * @param {unknown} node
		 *   Thing to check, typically `Node`.
		 * @param {Test} test
		 *   A check for a specific node.
		 * @param {number | null | undefined} index
		 *   The nodes position in its parent.
		 * @param {Parent | null | undefined} parent
		 *   The nodes parent.
		 * @param {unknown} context
		 *   Context object (`this`) to pass to `test` functions.
		 * @returns {boolean}
		 *   Whether `node` is a node and passes a test.
		 */
		const is =
			// Note: overloads in JSDoc cant yet use different `@template`s.
			/**
			 * @type {(
			 *   (<Condition extends string>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
			 *   (<Condition extends Props>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
			 *   (<Condition extends TestFunction>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
			 *   ((node?: null | undefined) => false) &
			 *   ((node: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
			 *   ((node: unknown, test?: Test, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => boolean)
			 * )}
			 */
			(
				/**
				 * @param {unknown} [node]
				 * @param {Test} [test]
				 * @param {number | null | undefined} [index]
				 * @param {Parent | null | undefined} [parent]
				 * @param {unknown} [context]
				 * @returns {boolean}
				 */
				// eslint-disable-next-line max-params
				function (node, test, index, parent, context) {
					const check = convert(test)

					if (
						index !== undefined &&
						index !== null &&
						(typeof index !== 'number' ||
							index < 0 ||
							index === Number.POSITIVE_INFINITY)
					) {
						throw new Error('Expected positive finite index')
					}

					if (
						parent !== undefined &&
						parent !== null &&
						(!is(parent) || !parent.children)
					) {
						throw new Error('Expected parent node')
					}

					if (
						(parent === undefined || parent === null) !==
						(index === undefined || index === null)
					) {
						throw new Error('Expected both parent and index')
					}

					return looksLikeANode(node)
						? check.call(context, node, index, parent)
						: false
				}
			)

		/**
		 * Generate an assertion from a test.
		 *
		 * Useful if youre going to test many nodes, for example when creating a
		 * utility where something else passes a compatible test.
		 *
		 * The created function is a bit faster because it expects valid input only:
		 * a `node`, `index`, and `parent`.
		 *
		 * @param {Test} test
		 *   *   when nullish, checks if `node` is a `Node`.
		 *   *   when `string`, works like passing `(node) => node.type === test`.
		 *   *   when `function` checks if function passed the node is true.
		 *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.
		 *   *   when `array`, checks if any one of the subtests pass.
		 * @returns {Check}
		 *   An assertion.
		 */
		const convert =
			// Note: overloads in JSDoc cant yet use different `@template`s.
			/**
			 * @type {(
			 *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
			 *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
			 *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
			 *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
			 *   ((test?: Test) => Check)
			 * )}
			 */
			(
				/**
				 * @param {Test} [test]
				 * @returns {Check}
				 */
				function (test) {
					if (test === null || test === undefined) {
						return ok
					}

					if (typeof test === 'function') {
						return castFactory(test)
					}

					if (typeof test === 'object') {
						return Array.isArray(test) ? anyFactory(test) : propsFactory(test)
					}

					if (typeof test === 'string') {
						return typeFactory(test)
					}

					throw new Error('Expected function, string, or object as test')
				}
			)

		/**
		 * @param {Array<Props | TestFunction | string>} tests
		 * @returns {Check}
		 */
		function anyFactory(tests) {
			/** @type {Array<Check>} */
			const checks = []
			let index = -1

			while (++index < tests.length) {
				checks[index] = convert(tests[index])
			}

			return castFactory(any)

			/**
			 * @this {unknown}
			 * @type {TestFunction}
			 */
			function any(...parameters) {
				let index = -1

				while (++index < checks.length) {
					if (checks[index].apply(this, parameters)) return true
				}

				return false
			}
		}

		/**
		 * Turn an object into a test for a node with a certain fields.
		 *
		 * @param {Props} check
		 * @returns {Check}
		 */
		function propsFactory(check) {
			const checkAsRecord = /** @type {Record<string, unknown>} */ (check)

			return castFactory(all)

			/**
			 * @param {Node} node
			 * @returns {boolean}
			 */
			function all(node) {
				const nodeAsRecord = /** @type {Record<string, unknown>} */ (
					/** @type {unknown} */ (node)
				)

				/** @type {string} */
				let key

				for (key in check) {
					if (nodeAsRecord[key] !== checkAsRecord[key]) return false
				}

				return true
			}
		}

		/**
		 * Turn a string into a test for a node with a certain type.
		 *
		 * @param {string} check
		 * @returns {Check}
		 */
		function typeFactory(check) {
			return castFactory(type)

			/**
			 * @param {Node} node
			 */
			function type(node) {
				return node && node.type === check
			}
		}

		/**
		 * Turn a custom test into a test for a node that passes that test.
		 *
		 * @param {TestFunction} testFunction
		 * @returns {Check}
		 */
		function castFactory(testFunction) {
			return check

			/**
			 * @this {unknown}
			 * @type {Check}
			 */
			function check(value, index, parent) {
				return Boolean(
					looksLikeANode(value) &&
						testFunction.call(
							this,
							value,
							typeof index === 'number' ? index : undefined,
							parent || undefined,
						),
				)
			}
		}

		function ok() {
			return true
		}

		/**
		 * @param {unknown} value
		 * @returns {value is Node}
		 */
		function looksLikeANode(value) {
			return value !== null && typeof value === 'object' && 'type' in value
		} // CONCATENATED MODULE: ./node_modules/unist-util-visit-parents/lib/color.node.js

		/**
		 * @param {string} d
		 * @returns {string}
		 */
		function color(d) {
			return '\u001B[33m' + d + '\u001B[39m'
		} // CONCATENATED MODULE: ./node_modules/unist-util-visit-parents/lib/index.js

		/**
		 * @typedef {import('unist').Node} UnistNode
		 * @typedef {import('unist').Parent} UnistParent
		 */

		/**
		 * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test
		 *   Test from `unist-util-is`.
		 *
		 *   Note: we have remove and add `undefined`, because otherwise when generating
		 *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,
		 *   which doesnt work when publishing on npm.
		 */

		/**
		 * @typedef {(
		 *   Fn extends (value: any) => value is infer Thing
		 *   ? Thing
		 *   : Fallback
		 * )} Predicate
		 *   Get the value of a type guard `Fn`.
		 * @template Fn
		 *   Value; typically function that is a type guard (such as `(x): x is Y`).
		 * @template Fallback
		 *   Value to yield if `Fn` is not a type guard.
		 */

		/**
		 * @typedef {(
		 *   Check extends null | undefined // No test.
		 *   ? Value
		 *   : Value extends {type: Check} // String (type) test.
		 *   ? Value
		 *   : Value extends Check // Partial test.
		 *   ? Value
		 *   : Check extends Function // Function test.
		 *   ? Predicate<Check, Value> extends Value
		 *     ? Predicate<Check, Value>
		 *     : never
		 *   : never // Some other test?
		 * )} MatchesOne
		 *   Check whether a node matches a primitive check in the type system.
		 * @template Value
		 *   Value; typically unist `Node`.
		 * @template Check
		 *   Value; typically `unist-util-is`-compatible test, but not arrays.
		 */

		/**
		 * @typedef {(
		 *   Check extends Array<any>
		 *   ? MatchesOne<Value, Check[keyof Check]>
		 *   : MatchesOne<Value, Check>
		 * )} Matches
		 *   Check whether a node matches a check in the type system.
		 * @template Value
		 *   Value; typically unist `Node`.
		 * @template Check
		 *   Value; typically `unist-util-is`-compatible test.
		 */

		/**
		 * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint
		 *   Number; capped reasonably.
		 */

		/**
		 * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment
		 *   Increment a number in the type system.
		 * @template {Uint} [I=0]
		 *   Index.
		 */

		/**
		 * @typedef {(
		 *   Node extends UnistParent
		 *   ? Node extends {children: Array<infer Children>}
		 *     ? Child extends Children ? Node : never
		 *     : never
		 *   : never
		 * )} InternalParent
		 *   Collect nodes that can be parents of `Child`.
		 * @template {UnistNode} Node
		 *   All node types in a tree.
		 * @template {UnistNode} Child
		 *   Node to search for.
		 */

		/**
		 * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent
		 *   Collect nodes in `Tree` that can be parents of `Child`.
		 * @template {UnistNode} Tree
		 *   All node types in a tree.
		 * @template {UnistNode} Child
		 *   Node to search for.
		 */

		/**
		 * @typedef {(
		 *   Depth extends Max
		 *   ? never
		 *   :
		 *     | InternalParent<Node, Child>
		 *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>
		 * )} InternalAncestor
		 *   Collect nodes in `Tree` that can be ancestors of `Child`.
		 * @template {UnistNode} Node
		 *   All node types in a tree.
		 * @template {UnistNode} Child
		 *   Node to search for.
		 * @template {Uint} [Max=10]
		 *   Max; searches up to this depth.
		 * @template {Uint} [Depth=0]
		 *   Current depth.
		 */

		/**
		 * @typedef {InternalAncestor<InclusiveDescendant<Tree>, Child>} Ancestor
		 *   Collect nodes in `Tree` that can be ancestors of `Child`.
		 * @template {UnistNode} Tree
		 *   All node types in a tree.
		 * @template {UnistNode} Child
		 *   Node to search for.
		 */

		/**
		 * @typedef {(
		 *   Tree extends UnistParent
		 *     ? Depth extends Max
		 *       ? Tree
		 *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>
		 *     : Tree
		 * )} InclusiveDescendant
		 *   Collect all (inclusive) descendants of `Tree`.
		 *
		 *   >  **Note**: for performance reasons, this seems to be the fastest way to
		 *   > recurse without actually running into an infinite loop, which the
		 *   > previous version did.
		 *   >
		 *   > Practically, a max of `2` is typically enough assuming a `Root` is
		 *   > passed, but it doesnt improve performance.
		 *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.
		 *   > Using up to `10` doesnt hurt or help either.
		 * @template {UnistNode} Tree
		 *   Tree type.
		 * @template {Uint} [Max=10]
		 *   Max; searches up to this depth.
		 * @template {Uint} [Depth=0]
		 *   Current depth.
		 */

		/**
		 * @typedef {'skip' | boolean} Action
		 *   Union of the action types.
		 *
		 * @typedef {number} Index
		 *   Move to the sibling at `index` next (after node itself is completely
		 *   traversed).
		 *
		 *   Useful if mutating the tree, such as removing the node the visitor is
		 *   currently on, or any of its previous siblings.
		 *   Results less than 0 or greater than or equal to `children.length` stop
		 *   traversing the parent.
		 *
		 * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple
		 *   List with one or two values, the first an action, the second an index.
		 *
		 * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult
		 *   Any value that can be returned from a visitor.
		 */

		/**
		 * @callback Visitor
		 *   Handle a node (matching `test`, if given).
		 *
		 *   Visitors are free to transform `node`.
		 *   They can also transform the parent of node (the last of `ancestors`).
		 *
		 *   Replacing `node` itself, if `SKIP` is not returned, still causes its
		 *   descendants to be walked (which is a bug).
		 *
		 *   When adding or removing previous siblings of `node` (or next siblings, in
		 *   case of reverse), the `Visitor` should return a new `Index` to specify the
		 *   sibling to traverse after `node` is traversed.
		 *   Adding or removing next siblings of `node` (or previous siblings, in case
		 *   of reverse) is handled as expected without needing to return a new `Index`.
		 *
		 *   Removing the children property of an ancestor still results in them being
		 *   traversed.
		 * @param {Visited} node
		 *   Found node.
		 * @param {Array<VisitedParents>} ancestors
		 *   Ancestors of `node`.
		 * @returns {VisitorResult}
		 *   What to do next.
		 *
		 *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.
		 *   An `Action` is treated as a tuple of `[Action]`.
		 *
		 *   Passing a tuple back only makes sense if the `Action` is `SKIP`.
		 *   When the `Action` is `EXIT`, that action can be returned.
		 *   When the `Action` is `CONTINUE`, `Index` can be returned.
		 * @template {UnistNode} [Visited=UnistNode]
		 *   Visited node type.
		 * @template {UnistParent} [VisitedParents=UnistParent]
		 *   Ancestor type.
		 */

		/**
		 * @typedef {Visitor<Matches<InclusiveDescendant<Tree>, Check>, Ancestor<Tree, Matches<InclusiveDescendant<Tree>, Check>>>} BuildVisitor
		 *   Build a typed `Visitor` function from a tree and a test.
		 *
		 *   It will infer which values are passed as `node` and which as `parents`.
		 * @template {UnistNode} [Tree=UnistNode]
		 *   Tree type.
		 * @template {Test} [Check=Test]
		 *   Test type.
		 */

		/** @type {Readonly<ActionTuple>} */
		const empty = []

		/**
		 * Continue traversing as normal.
		 */
		const CONTINUE = true

		/**
		 * Stop traversing immediately.
		 */
		const EXIT = false

		/**
		 * Do not traverse this nodes children.
		 */
		const SKIP = 'skip'

		/**
		 * Visit nodes, with ancestral information.
		 *
		 * This algorithm performs *depth-first* *tree traversal* in *preorder*
		 * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).
		 *
		 * You can choose for which nodes `visitor` is called by passing a `test`.
		 * For complex tests, you should test yourself in `visitor`, as it will be
		 * faster and will have improved type information.
		 *
		 * Walking the tree is an intensive task.
		 * Make use of the return values of the visitor when possible.
		 * Instead of walking a tree multiple times, walk it once, use `unist-util-is`
		 * to check if a node matches, and then perform different operations.
		 *
		 * You can change the tree.
		 * See `Visitor` for more info.
		 *
		 * @overload
		 * @param {Tree} tree
		 * @param {Check} check
		 * @param {BuildVisitor<Tree, Check>} visitor
		 * @param {boolean | null | undefined} [reverse]
		 * @returns {undefined}
		 *
		 * @overload
		 * @param {Tree} tree
		 * @param {BuildVisitor<Tree>} visitor
		 * @param {boolean | null | undefined} [reverse]
		 * @returns {undefined}
		 *
		 * @param {UnistNode} tree
		 *   Tree to traverse.
		 * @param {Visitor | Test} test
		 *   `unist-util-is`-compatible test
		 * @param {Visitor | boolean | null | undefined} [visitor]
		 *   Handle each node.
		 * @param {boolean | null | undefined} [reverse]
		 *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).
		 * @returns {undefined}
		 *   Nothing.
		 *
		 * @template {UnistNode} Tree
		 *   Node type.
		 * @template {Test} Check
		 *   `unist-util-is`-compatible test.
		 */
		function visitParents(tree, test, visitor, reverse) {
			/** @type {Test} */
			let check

			if (typeof test === 'function' && typeof visitor !== 'function') {
				reverse = visitor
				// @ts-expect-error no visitor given, so `visitor` is test.
				visitor = test
			} else {
				// @ts-expect-error visitor given, so `test` isnt a visitor.
				check = test
			}

			const is = convert(check)
			const step = reverse ? -1 : 1

			factory(tree, undefined, [])()

			/**
			 * @param {UnistNode} node
			 * @param {number | undefined} index
			 * @param {Array<UnistParent>} parents
			 */
			function factory(node, index, parents) {
				const value = /** @type {Record<string, unknown>} */ (
					node && typeof node === 'object' ? node : {}
				)

				if (typeof value.type === 'string') {
					const name =
						// `hast`
						typeof value.tagName === 'string'
							? value.tagName
							: // `xast`
								typeof value.name === 'string'
								? value.name
								: undefined

					Object.defineProperty(visit, 'name', {
						value:
							'node (' +
							color(node.type + (name ? '<' + name + '>' : '')) +
							')',
					})
				}

				return visit

				function visit() {
					/** @type {Readonly<ActionTuple>} */
					let result = empty
					/** @type {Readonly<ActionTuple>} */
					let subresult
					/** @type {number} */
					let offset
					/** @type {Array<UnistParent>} */
					let grandparents

					if (
						!test ||
						is(node, index, parents[parents.length - 1] || undefined)
					) {
						// @ts-expect-error: `visitor` is now a visitor.
						result = toResult(visitor(node, parents))

						if (result[0] === EXIT) {
							return result
						}
					}

					if ('children' in node && node.children) {
						const nodeAsParent = /** @type {UnistParent} */ (node)

						if (nodeAsParent.children && result[0] !== SKIP) {
							offset = (reverse ? nodeAsParent.children.length : -1) + step
							grandparents = parents.concat(nodeAsParent)

							while (offset > -1 && offset < nodeAsParent.children.length) {
								const child = nodeAsParent.children[offset]

								subresult = factory(child, offset, grandparents)()

								if (subresult[0] === EXIT) {
									return subresult
								}

								offset =
									typeof subresult[1] === 'number'
										? subresult[1]
										: offset + step
							}
						}
					}

					return result
				}
			}
		}

		/**
		 * Turn a return value into a clean result.
		 *
		 * @param {VisitorResult} value
		 *   Valid return values from visitors.
		 * @returns {Readonly<ActionTuple>}
		 *   Clean result.
		 */
		function toResult(value) {
			if (Array.isArray(value)) {
				return value
			}

			if (typeof value === 'number') {
				return [CONTINUE, value]
			}

			return value === null || value === undefined ? empty : [value]
		} // CONCATENATED MODULE: ./node_modules/unist-util-visit/lib/index.js

		/**
		 * @typedef {import('unist').Node} UnistNode
		 * @typedef {import('unist').Parent} UnistParent
		 * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult
		 */

		/**
		 * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test
		 *   Test from `unist-util-is`.
		 *
		 *   Note: we have remove and add `undefined`, because otherwise when generating
		 *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,
		 *   which doesnt work when publishing on npm.
		 */

		// To do: use types from `unist-util-visit-parents` when its released.

		/**
		 * @typedef {(
		 *   Fn extends (value: any) => value is infer Thing
		 *   ? Thing
		 *   : Fallback
		 * )} Predicate
		 *   Get the value of a type guard `Fn`.
		 * @template Fn
		 *   Value; typically function that is a type guard (such as `(x): x is Y`).
		 * @template Fallback
		 *   Value to yield if `Fn` is not a type guard.
		 */

		/**
		 * @typedef {(
		 *   Check extends null | undefined // No test.
		 *   ? Value
		 *   : Value extends {type: Check} // String (type) test.
		 *   ? Value
		 *   : Value extends Check // Partial test.
		 *   ? Value
		 *   : Check extends Function // Function test.
		 *   ? Predicate<Check, Value> extends Value
		 *     ? Predicate<Check, Value>
		 *     : never
		 *   : never // Some other test?
		 * )} MatchesOne
		 *   Check whether a node matches a primitive check in the type system.
		 * @template Value
		 *   Value; typically unist `Node`.
		 * @template Check
		 *   Value; typically `unist-util-is`-compatible test, but not arrays.
		 */

		/**
		 * @typedef {(
		 *   Check extends Array<any>
		 *   ? MatchesOne<Value, Check[keyof Check]>
		 *   : MatchesOne<Value, Check>
		 * )} Matches
		 *   Check whether a node matches a check in the type system.
		 * @template Value
		 *   Value; typically unist `Node`.
		 * @template Check
		 *   Value; typically `unist-util-is`-compatible test.
		 */

		/**
		 * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint
		 *   Number; capped reasonably.
		 */

		/**
		 * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment
		 *   Increment a number in the type system.
		 * @template {Uint} [I=0]
		 *   Index.
		 */

		/**
		 * @typedef {(
		 *   Node extends UnistParent
		 *   ? Node extends {children: Array<infer Children>}
		 *     ? Child extends Children ? Node : never
		 *     : never
		 *   : never
		 * )} InternalParent
		 *   Collect nodes that can be parents of `Child`.
		 * @template {UnistNode} Node
		 *   All node types in a tree.
		 * @template {UnistNode} Child
		 *   Node to search for.
		 */

		/**
		 * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent
		 *   Collect nodes in `Tree` that can be parents of `Child`.
		 * @template {UnistNode} Tree
		 *   All node types in a tree.
		 * @template {UnistNode} Child
		 *   Node to search for.
		 */

		/**
		 * @typedef {(
		 *   Depth extends Max
		 *   ? never
		 *   :
		 *     | InternalParent<Node, Child>
		 *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>
		 * )} InternalAncestor
		 *   Collect nodes in `Tree` that can be ancestors of `Child`.
		 * @template {UnistNode} Node
		 *   All node types in a tree.
		 * @template {UnistNode} Child
		 *   Node to search for.
		 * @template {Uint} [Max=10]
		 *   Max; searches up to this depth.
		 * @template {Uint} [Depth=0]
		 *   Current depth.
		 */

		/**
		 * @typedef {(
		 *   Tree extends UnistParent
		 *     ? Depth extends Max
		 *       ? Tree
		 *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>
		 *     : Tree
		 * )} InclusiveDescendant
		 *   Collect all (inclusive) descendants of `Tree`.
		 *
		 *   >  **Note**: for performance reasons, this seems to be the fastest way to
		 *   > recurse without actually running into an infinite loop, which the
		 *   > previous version did.
		 *   >
		 *   > Practically, a max of `2` is typically enough assuming a `Root` is
		 *   > passed, but it doesnt improve performance.
		 *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.
		 *   > Using up to `10` doesnt hurt or help either.
		 * @template {UnistNode} Tree
		 *   Tree type.
		 * @template {Uint} [Max=10]
		 *   Max; searches up to this depth.
		 * @template {Uint} [Depth=0]
		 *   Current depth.
		 */

		/**
		 * @callback Visitor
		 *   Handle a node (matching `test`, if given).
		 *
		 *   Visitors are free to transform `node`.
		 *   They can also transform `parent`.
		 *
		 *   Replacing `node` itself, if `SKIP` is not returned, still causes its
		 *   descendants to be walked (which is a bug).
		 *
		 *   When adding or removing previous siblings of `node` (or next siblings, in
		 *   case of reverse), the `Visitor` should return a new `Index` to specify the
		 *   sibling to traverse after `node` is traversed.
		 *   Adding or removing next siblings of `node` (or previous siblings, in case
		 *   of reverse) is handled as expected without needing to return a new `Index`.
		 *
		 *   Removing the children property of `parent` still results in them being
		 *   traversed.
		 * @param {Visited} node
		 *   Found node.
		 * @param {Visited extends UnistNode ? number | undefined : never} index
		 *   Index of `node` in `parent`.
		 * @param {Ancestor extends UnistParent ? Ancestor | undefined : never} parent
		 *   Parent of `node`.
		 * @returns {VisitorResult}
		 *   What to do next.
		 *
		 *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.
		 *   An `Action` is treated as a tuple of `[Action]`.
		 *
		 *   Passing a tuple back only makes sense if the `Action` is `SKIP`.
		 *   When the `Action` is `EXIT`, that action can be returned.
		 *   When the `Action` is `CONTINUE`, `Index` can be returned.
		 * @template {UnistNode} [Visited=UnistNode]
		 *   Visited node type.
		 * @template {UnistParent} [Ancestor=UnistParent]
		 *   Ancestor type.
		 */

		/**
		 * @typedef {Visitor<Visited, Parent<Ancestor, Visited>>} BuildVisitorFromMatch
		 *   Build a typed `Visitor` function from a node and all possible parents.
		 *
		 *   It will infer which values are passed as `node` and which as `parent`.
		 * @template {UnistNode} Visited
		 *   Node type.
		 * @template {UnistParent} Ancestor
		 *   Parent type.
		 */

		/**
		 * @typedef {(
		 *   BuildVisitorFromMatch<
		 *     Matches<Descendant, Check>,
		 *     Extract<Descendant, UnistParent>
		 *   >
		 * )} BuildVisitorFromDescendants
		 *   Build a typed `Visitor` function from a list of descendants and a test.
		 *
		 *   It will infer which values are passed as `node` and which as `parent`.
		 * @template {UnistNode} Descendant
		 *   Node type.
		 * @template {Test} Check
		 *   Test type.
		 */

		/**
		 * @typedef {(
		 *   BuildVisitorFromDescendants<
		 *     InclusiveDescendant<Tree>,
		 *     Check
		 *   >
		 * )} BuildVisitor
		 *   Build a typed `Visitor` function from a tree and a test.
		 *
		 *   It will infer which values are passed as `node` and which as `parent`.
		 * @template {UnistNode} [Tree=UnistNode]
		 *   Node type.
		 * @template {Test} [Check=Test]
		 *   Test type.
		 */

		/**
		 * Visit nodes.
		 *
		 * This algorithm performs *depth-first* *tree traversal* in *preorder*
		 * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).
		 *
		 * You can choose for which nodes `visitor` is called by passing a `test`.
		 * For complex tests, you should test yourself in `visitor`, as it will be
		 * faster and will have improved type information.
		 *
		 * Walking the tree is an intensive task.
		 * Make use of the return values of the visitor when possible.
		 * Instead of walking a tree multiple times, walk it once, use `unist-util-is`
		 * to check if a node matches, and then perform different operations.
		 *
		 * You can change the tree.
		 * See `Visitor` for more info.
		 *
		 * @overload
		 * @param {Tree} tree
		 * @param {Check} check
		 * @param {BuildVisitor<Tree, Check>} visitor
		 * @param {boolean | null | undefined} [reverse]
		 * @returns {undefined}
		 *
		 * @overload
		 * @param {Tree} tree
		 * @param {BuildVisitor<Tree>} visitor
		 * @param {boolean | null | undefined} [reverse]
		 * @returns {undefined}
		 *
		 * @param {UnistNode} tree
		 *   Tree to traverse.
		 * @param {Visitor | Test} testOrVisitor
		 *   `unist-util-is`-compatible test (optional, omit to pass a visitor).
		 * @param {Visitor | boolean | null | undefined} [visitorOrReverse]
		 *   Handle each node (when test is omitted, pass `reverse`).
		 * @param {boolean | null | undefined} [maybeReverse=false]
		 *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).
		 * @returns {undefined}
		 *   Nothing.
		 *
		 * @template {UnistNode} Tree
		 *   Node type.
		 * @template {Test} Check
		 *   `unist-util-is`-compatible test.
		 */
		function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
			/** @type {boolean | null | undefined} */
			let reverse
			/** @type {Test} */
			let test
			/** @type {Visitor} */
			let visitor

			if (
				typeof testOrVisitor === 'function' &&
				typeof visitorOrReverse !== 'function'
			) {
				test = undefined
				visitor = testOrVisitor
				reverse = visitorOrReverse
			} else {
				// @ts-expect-error: assume the overload with test was given.
				test = testOrVisitor
				// @ts-expect-error: assume the overload with test was given.
				visitor = visitorOrReverse
				reverse = maybeReverse
			}

			visitParents(tree, test, overload, reverse)

			/**
			 * @param {UnistNode} node
			 * @param {Array<UnistParent>} parents
			 */
			function overload(node, parents) {
				const parent = parents[parents.length - 1]
				const index = parent ? parent.children.indexOf(node) : undefined
				return visitor(node, index, parent)
			}
		} // CONCATENATED MODULE: ./remark-get-images-plugin.ts

		/**
		 * Copyright (c) HashiCorp, Inc.
		 * SPDX-License-Identifier: BUSL-1.1
		 */
		/* eslint-disable */
		// @ts-nocheck
		// TODO: fix types
		// stdlib

		// for creating custom remark plugin
		// Use 4.1.0; 5+ is ESM

		const remarkGetImages = (HCPsourceDir, imageSrcSet) => {
			const test = (node) => {
				return is(node, 'image')
			}
			return function (tree) {
				visit(tree, test, (node) => {
					const src = external_path_.join(HCPsourceDir, node.url)
					external_assert_.ok(
						external_fs_.existsSync(src),
						'[getImagesPlugin] image not found: ' + src,
					)
					imageSrcSet.add(src)
				})
			}
		} // CONCATENATED MODULE: ./remark-transfrom-cloud-docs-links.ts

		/**
		 * Copyright (c) HashiCorp, Inc.
		 * SPDX-License-Identifier: BUSL-1.1
		 */
		/* eslint-disable */
		// @ts-nocheck
		// TODO: fix types
		// for creating custom remark plugin
		// Use 4.1.0; 5+ is ESM

		const remarkTransformCloudDocsLinks = () => {
			const test = (node) => {
				return is(node, 'link') || is(node, 'definition')
			}
			return function (tree) {
				visit(tree, test, (node) => {
					// early exit if any urls match any ignored patterns
					if (IGNORE_PATTERNS.some((e) => e.test(node.url))) {
						return
					}
					// Match urls beginning with `/cloud-docs` or `/terraform/cloud-docs`
					if (/^(\/terraform)?\/cloud-docs/i.test(node.url)) {
						node.url = node.url.replace('cloud-docs', 'enterprise')
					}
				})
			}
		} // CONCATENATED MODULE: ./main.ts

		/**
		 * Copyright (c) HashiCorp, Inc.
		 * SPDX-License-Identifier: BUSL-1.1
		 */

		const PR_TYPE = {
			NewVersion: 'NewVersion',
			Diff: 'Diff',
		}
		const imageSrcSet = new Set()
		// List of MDX files to exclude from being copied
		const IGNORE_LIST = ['cloud-docs/index.mdx']
		const IGNORE_PATTERNS = [
			/cloud-docs\/agents/i,
			/cloud-docs\/architectural-details/i,
		]
		const SUB_PATH_MAPPINGS = [
			{
				source: 'cloud-docs',
				target: 'enterprise',
			},
		]
		/**
		 * This is a helper to be passed to `walk` dry up repeated logic
		 * for ignore certain files.
		 */
		const filterFunc = (item) => {
			// if the item matches a IGNORE_PATTERNS expression, exclude it
			if (
				IGNORE_PATTERNS.some((pattern) => {
					return pattern.test(item.path)
				})
			) {
				return false
			}
			// Check files for `tfc_only` frontmatter property; Ignore them if true
			if (item.stats.isFile()) {
				const fullContent = external_fs_.readFileSync(item.path, 'utf8')
				const { data } = gray_matter_default()(fullContent)
				if (data.tfc_only == true) {
					return false
				}
			}
			return true
		}
		/**
		 * A helper that accepts a data object and an array of functions that
		 * receive the object as an arg and transform it.
		 */
		const transformObject = (data, plugins) => {
			let result = data
			plugins.forEach((fn) => {
				result = fn(result)
			})
			return result
		}
		/**
		 * This function will copy 3 things
		 * - MDX files
		 *   - these can be at varying levels of nesting
		 * - used images
		 *   - these are expected to all be at the same level
		 * - nav-data JSON files
		 *
		 * This function will also prune the target directory
		 * of any files that are not in the source directory.
		 *
		 * @param sourcePath {string} The directory content should be copied _from_
		 * @param targetPath {string} The directory content should be copied _to_
		 * @param {string} newTFEVersion An absolute path to a GitHub repository on disk
		 */
		async function main(sourcePath, targetPath, newTFEVersion) {
			const prType = newTFEVersion ? PR_TYPE.NewVersion : PR_TYPE.Diff
			//Read version metadata and get the latest version of terraform-enterprise
			const versionMetadataPath = external_path_.resolve(
				external_path_.join(sourcePath, 'app/api/versionMetadata.json'),
			)
			const versionMetadata = JSON.parse(
				external_fs_.readFileSync(versionMetadataPath, 'utf8'),
			)
			const tfeMetadata = versionMetadata['terraform-enterprise']
			if (!tfeMetadata || tfeMetadata.length === 0) {
				throw new Error('No terraform-enterprise found in versionMetadata.json')
			}
			const currentTfeRelease = tfeMetadata.find((release) => {
				return release.isLatest
			})?.version
			if (!currentTfeRelease) {
				throw new Error(
					'No latest terraform-enterprise found in versionMetadata.json',
				)
			}
			core.info(
				`Latest terraform-enterprise version found in versionMetadata.json: ${currentTfeRelease}`,
			)
			const HCPsourceDir = external_path_.join(
				sourcePath,
				'content/terraform-docs-common',
			)
			const HCPContentDir = external_path_.join(HCPsourceDir, 'docs')
			const newTFEVersionDir = external_path_.join(
				targetPath,
				'content/terraform-enterprise',
				prType === PR_TYPE.NewVersion ? newTFEVersion : currentTfeRelease,
			)
			const newTFEVersionContentDir = external_path_.join(
				newTFEVersionDir,
				'docs',
			)
			const newTFEVersionImageDir = external_path_.join(
				newTFEVersionDir,
				'img/docs',
			)
			// If this is a new version, we need to copy the current ptfe-release
			// files to the new version's directory.
			// This is to ensure that we have the all of the images and nav-data
			if (prType === PR_TYPE.NewVersion) {
				core.info(`Creating new version directory: ${newTFEVersionDir}`)
				external_fs_.mkdirSync(newTFEVersionDir, { recursive: true })
				const prevTFEVersionDir = external_path_.join(
					sourcePath,
					'content/terraform-enterprise',
					currentTfeRelease,
				)
				external_fs_.cpSync(prevTFEVersionDir, newTFEVersionDir, {
					recursive: true,
				})
			}
			// traverse source docs and accumulate mdx files for a given set of "subPaths"
			let items = []
			for (const { source: subPath } of SUB_PATH_MAPPINGS) {
				const src = external_path_.join(HCPContentDir, subPath)
				const docItems = klaw_sync_default()(src, {
					nodir: true,
					filter: filterFunc,
				})
				items = items.concat(docItems)
			}
			// Copy an entire directory
			// ---------------------------------------------
			//     /{source}/cloud-docs/dir/some-doc.mdx
			//                            
			//     /{target}/enterprise/dir/some-docs.mdx
			// ---------------------------------------------
			for (const { source, target } of SUB_PATH_MAPPINGS) {
				const src = external_path_.join(HCPContentDir, source)
				const dest = external_path_.join(newTFEVersionContentDir, target)
				const items = klaw_sync_default()(src, {
					nodir: true,
					filter: filterFunc,
				})
				for (const item of items) {
					// ignore some files
					if (
						IGNORE_LIST.some((ignore) => {
							return item.path.endsWith(ignore)
						})
					) {
						continue
					}
					// extract mdx content; ignore frontmatter
					const fullContent = external_fs_.readFileSync(item.path, 'utf8')
					// eslint-disable-next-line prefer-const
					let { content, data } = gray_matter_default()(fullContent)
					data = transformObject(data, [
						// inject `source` frontmatter property
						function injectSource(d) {
							d.source = external_path_.basename(HCPsourceDir)
							return d
						},
						// replace cloud instances with enterprise
						function replaceCloudWithEnterprise(d) {
							// Some docs do not have all frontmatter properties. Make sure
							// we do not assign `undefined` (which is invalid) in YAML
							if (d.page_title) {
								d.page_title = d.page_title.replace(
									'Terraform Cloud',
									'Terraform Enterprise',
								)
								d.page_title = d.page_title.replace(
									'HCP Terraform',
									'Terraform Enterprise',
								)
							}
							if (d.description) {
								d.description = d.description.replace(
									'Terraform Cloud',
									'Terraform Enterprise',
								)
								d.description = d.description.replace(
									'HCP Terraform',
									'Terraform Enterprise',
								)
							}
							return d
						},
					])
					const vfile = await remark_default()()
						.use(remark_mdx_default())
						// @ts-expect-error remark is being passed in through the pipeline
						.use(remarkGetImages, HCPsourceDir, imageSrcSet)
						// @ts-expect-error remark is being passed in through the pipeline
						.use(remarkTransformCloudDocsLinks)
						.process(content)
					// replace \-> with ->
					const stringOutput = vfile.toString().replaceAll('\\->', '->')
					// overwrite original file with transformed content
					const contents = gray_matter_default().stringify(
						'\n' + stringOutput,
						data,
					)
					// Get the relative path after "terraform-docs-common/docs/cloud-docs"
					const relPath = external_path_.relative(
						external_path_.join(HCPContentDir, 'cloud-docs'),
						item.path,
					)
					const destAbsolutePath = external_path_.join(dest, relPath)
					external_fs_.writeFileSync(destAbsolutePath, contents)
				}
			}
			// Copy images
			for (const src of Array.from(imageSrcSet)) {
				const basename = external_path_.basename(src)
				const target = external_path_.join(newTFEVersionImageDir, basename)
				external_fs_.mkdirSync(newTFEVersionImageDir, { recursive: true })
				external_fs_.copyFileSync(src, target)
			}
		} // CONCATENATED MODULE: ./index.ts

		/**
		 * Copyright (c) HashiCorp, Inc.
		 * SPDX-License-Identifier: BUSL-1.1
		 */

		async function action() {
			const sourcePath = core.getInput('source_path')
			const targetPath = core.getInput('target_path')
			const newTFEVersion = core.getInput('new_TFE_version')
			await main(sourcePath, targetPath, newTFEVersion)
		}
		action()
	})()

	module.exports = __webpack_exports__
	/******/
})()
